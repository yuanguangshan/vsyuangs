diff --git a/git_reviews.md b/git_reviews.md
index 031d930..d607fb1 100644
--- a/git_reviews.md
+++ b/git_reviews.md
@@ -142,3 +142,704 @@ private async performAIReview(diffText: string): Promise<ReviewResultV1>
 
 [↑ 返回顶部](#)
 
+
+---
+
+## 📋 Code Review - 2026/1/31 15:06:09
+
+**📊 评分:** 👍 82/100  
+**🔧 级别:** STANDARD  
+**🌿 分支:** `main`  
+**💾 提交:** `36d5cbe`  
+**📂 范围:** 未暂存 (3 个文件)  
+
+### 📝 总体评价
+
+本次变更整体方向明确，核心目标是提升 Diff 解析与应用的健壮性（自动修复、降级机制、模糊定位），在复杂和不规范 Diff 场景下显著提高成功率。但同时引入了状态可变性、副作用、日志/错误处理不一致等问题，部分 API 语义也变得模糊，存在长期维护和可预期性风险。
+
+### ⚠️ 发现的问题 (7)
+
+#### 1. [ERROR] src/core/diff.ts:448
+
+validateAndFixHunkLineCount 直接原地修改 hunk 对象，引入隐式副作用
+
+**💡 建议:** 建议返回一个新的 DiffHunk 副本（immutable 风格），或明确在函数命名和文档中声明该函数会 mutate 入参
+
+<details>
+<summary>代码片段</summary>
+
+```
+hunk.oldCount = actualOldCount;
+hunk.newCount = actualNewCount;
+```
+
+</details>
+
+#### 2. [WARNING] src/core/diff.ts:194
+
+validateAndFixHunkLineCount 的返回结构设计不清晰，ok / fixedHunk 语义重叠
+
+**💡 建议:** 建议使用明确的判别联合类型（如 { status: 'ok' | 'fixed' | 'error' }），避免 ok=true 但同时包含 error 字段
+
+<details>
+<summary>代码片段</summary>
+
+```
+return { ok: true, fixedHunk: hunk, error: "Auto-fixed line count mismatch" };
+```
+
+</details>
+
+#### 3. [WARNING] src/core/diff.ts:340
+
+在多个位置重复出现“校验 + push hunk + 统计”的逻辑，存在代码重复
+
+**💡 建议:** 建议抽取为 finalizeHunk(currentFile, currentHunk) 之类的私有方法，降低维护成本
+
+<details>
+<summary>代码片段</summary>
+
+```
+if (validateResult.fixedHunk) { currentFile.hunks.push(...) } else { ... }
+```
+
+</details>
+
+#### 4. [WARNING] src/core/diff.ts:964
+
+模糊匹配 locateHunkStart 的时间复杂度在大文件下可能退化为 O(n*m)
+
+**💡 建议:** 可考虑限制最大搜索窗口，或提前基于 oldStart 设定搜索范围，避免全文件扫描
+
+<details>
+<summary>代码片段</summary>
+
+```
+for (let i = 0; i < fileLines.length; i++) { ... }
+```
+
+</details>
+
+#### 5. [WARNING] src/core/diff.ts:784
+
+applyFullContent 中直接整文件替换存在较高风险，且未进行内容一致性校验
+
+**💡 建议:** 建议在覆盖前提示 diff 预览，或至少校验 newContent 非空、非明显异常
+
+<details>
+<summary>代码片段</summary>
+
+```
+edit.replace(fullPath, fullRange, newContent);
+```
+
+</details>
+
+#### 6. [WARNING] src/vscode/provider/ChatViewProvider.ts:600
+
+标准 DiffApplier 失败后静默回退到旧逻辑，可能掩盖真实错误
+
+**💡 建议:** 建议区分 parse 失败 / apply 失败 / 内部异常，并在日志或 UI 中明确告知回退原因
+
+<details>
+<summary>代码片段</summary>
+
+```
+catch (parseError) { ... await this.applyUnifiedDiff(file); }
+```
+
+</details>
+
+#### 7. [INFO] src/core/diff.ts:391
+
+normalizePath 重命名为 flexibleNormalizePath 后行为变宽，可能影响旧调用方假设
+
+**💡 建议:** 建议补充单元测试覆盖异常路径（引号、绝对路径、奇怪前缀）
+
+<details>
+<summary>代码片段</summary>
+
+```
+private static flexibleNormalizePath(pathStr: string): string
+```
+
+</details>
+
+### 👍 优点
+
+- ✅ 整体设计目标清晰：优先成功应用 Diff，其次自动修复，最后降级为全量覆盖
+- ✅ DiffParser / DiffApplier 职责边界相对清楚，没有明显的跨层污染
+- ✅ 对真实世界中 AI 生成 Diff 不规范问题有务实处理（行数修复、模糊定位）
+- ✅ 新增 Prompt 明确约束 Unified Diff 规则，有助于从源头降低错误率
+- ✅ 日志信息（warn / console.log）对调试复杂 Diff 场景较有帮助
+
+### 💡 建议
+
+- 为 DiffHunk、validateAndFixHunkLineCount 的返回值引入更强的类型约束（判别联合）
+- 增加针对异常 Diff 的单元测试（行数不匹配、无 context、错位 hunk）
+- 为 locateHunkStart / findBestMatchIndex 增加性能保护与最大搜索限制
+- 对 applyFullContent 引入显式用户确认与内容摘要，避免误覆盖
+- 统一错误处理和日志策略（warn vs error vs UI 提示），减少行为不确定性
+
+[↑ 返回顶部](#)
+
+
+---
+
+## 📋 Code Review - 2026/1/31 15:13:43
+
+**📊 评分:** 👍 82/100  
+**🔧 级别:** STANDARD  
+**🌿 分支:** `main`  
+**💾 提交:** `36d5cbe`  
+**📂 范围:** 未暂存 (4 个文件)  
+
+### 📝 总体评价
+
+本次变更围绕 Diff 解析与应用的健壮性进行了较大增强，引入了自动修复、模糊定位和降级机制，整体设计目标清晰且务实，能有效应对不规范 Diff 场景。但同时也带来了 API 语义复杂化、状态可变性风险、错误处理与日志策略不统一，以及部分性能与一致性隐患，后续维护成本有所上升。
+
+### ⚠️ 发现的问题 (7)
+
+#### 1. [ERROR] src/core/diff.ts:448
+
+validateAndFixHunkLineCount 在部分路径下仍存在对象语义混淆，调用方无法直观判断是否应使用 fixedHunk 还是原 hunk。
+
+**💡 建议:** 建议使用判别联合类型并强制在 status !== 'ok' 时只允许消费 fixedHunk，或统一返回新 hunk，避免混用。
+
+<details>
+<summary>代码片段</summary>
+
+```
+return { status: 'fixed', fixedHunk: fixedHunk, error: "Auto-fixed line count mismatch" };
+```
+
+</details>
+
+#### 2. [WARNING] src/core/diff.ts:472
+
+finalizeHunk 中统计信息始终基于原 hunk 计算，即使实际 push 的是 fixedHunk，可能导致统计与真实数据不一致。
+
+**💡 建议:** 应基于最终入库的 hunk（fixed 或原始）来更新 stats，确保统计一致性。
+
+<details>
+<summary>代码片段</summary>
+
+```
+file.stats.added += hunk.stats.added;
+```
+
+</details>
+
+#### 3. [WARNING] src/core/diff.ts:353
+
+flexibleNormalizePath 放宽了路径规范化规则，可能影响依赖旧行为的调用方假设。
+
+**💡 建议:** 补充单元测试覆盖异常路径（引号、绝对路径、多前缀），并在变更日志中明确行为变化。
+
+<details>
+<summary>代码片段</summary>
+
+```
+private static flexibleNormalizePath(pathStr: string): string
+```
+
+</details>
+
+#### 4. [WARNING] src/core/diff.ts:789
+
+applyFullContent 作为降级机制直接整文件覆盖，风险较高，且缺少与旧内容的差异校验或用户确认。
+
+**💡 建议:** 建议在 UI 层增加明确提示或确认步骤，并在逻辑层校验 newContent 与旧内容差异是否合理。
+
+<details>
+<summary>代码片段</summary>
+
+```
+edit.replace(fullPath, fullRange, newContent);
+```
+
+</details>
+
+#### 5. [WARNING] src/core/diff.ts:974
+
+模糊匹配逻辑在极端情况下仍可能带来性能压力，且锚点选择规则较为经验化。
+
+**💡 建议:** 考虑引入最大尝试次数、超时保护，或更明确的匹配评分策略。
+
+<details>
+<summary>代码片段</summary>
+
+```
+for (let i = expectedStart; i < expectedEnd && i < fileLines.length; i++) {
+```
+
+</details>
+
+#### 6. [WARNING] src/vscode/provider/ChatViewProvider.ts:600
+
+标准 DiffApplier 失败后静默回退到旧逻辑，可能掩盖真实错误来源。
+
+**💡 建议:** 区分 parse 失败、apply 失败和内部异常，并在日志或 UI 中明确告知回退原因。
+
+<details>
+<summary>代码片段</summary>
+
+```
+catch (parseError) { ... await this.applyUnifiedDiff(file); }
+```
+
+</details>
+
+#### 7. [INFO] src/engine/ai/prompt.ts:60
+
+新增 Prompt 构建函数但未体现与旧 Prompt 的差异约束或测试覆盖。
+
+**💡 建议:** 建议为 Prompt 变更增加快照测试，防止无意中破坏 Diff 生成约束。
+
+<details>
+<summary>代码片段</summary>
+
+```
+export function buildCodeModificationPrompt(
+```
+
+</details>
+
+### 👍 优点
+
+- ✅ 整体设计目标清晰：优先成功应用 Diff，其次自动修复，最后安全降级
+- ✅ 通过 finalizeHunk 抽取公共逻辑，明显降低了代码重复度
+- ✅ 对 AI 生成 Diff 的不规范场景有现实可行的工程化处理方案
+- ✅ DiffParser 与 DiffApplier 职责边界较为清晰
+- ✅ 日志信息对调试复杂 Diff 场景具有实际价值
+
+### 💡 建议
+
+- 为 DiffHunk 校验结果和 finalizeHunk 行为引入更强的类型约束（判别联合）
+- 补充针对异常 Diff 的单元测试（行数不匹配、无 context、错位 hunk）
+- 为模糊匹配和整文件覆盖机制增加性能与安全保护策略
+- 统一错误处理与日志级别（warn / error / UI 提示），减少行为不确定性
+- 在关键降级路径（applyFullContent）前增加显式用户感知或确认
+
+[↑ 返回顶部](#)
+
+
+---
+
+## 📋 Code Review - 2026/1/31 15:38:23
+
+**📊 评分:** 👍 82/100  
+**🔧 级别:** STANDARD  
+**🌿 分支:** `main`  
+**💾 提交:** `36d5cbe`  
+**📂 范围:** 未暂存 (4 个文件)  
+
+### 📝 总体评价
+
+本次变更在架构层面明确提升了 Diff 解析与应用的健壮性，通过引入自动修复、公共逻辑抽取和降级机制，显著增强了对不规范 Diff 的容错能力。但同时也引入了 API 语义复杂化、状态可变性风险、错误处理与日志策略不统一，以及部分性能与安全隐患，整体质量良好但仍有改进空间。
+
+### ⚠️ 发现的问题 (7)
+
+#### 1. [ERROR] src/core/diff.ts:448
+
+validateAndFixHunkLineCount 的返回结果与输入 hunk 的对象语义存在混淆风险，调用方可能误用原 hunk 或 fixedHunk。
+
+**💡 建议:** 使用严格的判别联合类型，并在 status !== 'ok' 时强制要求调用方仅使用 fixedHunk，或统一始终返回新的 hunk 实例。
+
+<details>
+<summary>代码片段</summary>
+
+```
+return { status: 'fixed', fixedHunk: fixedHunk, error: "Auto-fixed line count mismatch" };
+```
+
+</details>
+
+#### 2. [WARNING] src/core/diff.ts:472
+
+finalizeHunk 中统计逻辑可能在使用 fixedHunk 与原 hunk 不一致时产生错误统计。
+
+**💡 建议:** 确保所有统计数据严格基于最终入库的 hunkToUse 计算，并考虑通过类型系统避免误用。
+
+<details>
+<summary>代码片段</summary>
+
+```
+file.stats.added += hunkToUse.stats.added;
+```
+
+</details>
+
+#### 3. [WARNING] src/core/diff.ts:353
+
+flexibleNormalizePath 放宽路径规范化规则，可能破坏依赖旧 normalizePath 行为的调用方假设。
+
+**💡 建议:** 补充针对异常路径（引号、绝对路径、多前缀）的单元测试，并在变更日志中明确该行为变化。
+
+<details>
+<summary>代码片段</summary>
+
+```
+private static flexibleNormalizePath(pathStr: string): string
+```
+
+</details>
+
+#### 4. [WARNING] src/core/diff.ts:789
+
+applyFullContent 作为降级机制直接进行整文件覆盖，存在误覆盖和数据丢失风险。
+
+**💡 建议:** 在 UI 层增加显式用户确认，或在逻辑层引入更严格的新旧内容一致性与差异校验。
+
+<details>
+<summary>代码片段</summary>
+
+```
+edit.replace(fullPath, fullRange, newContent);
+```
+
+</details>
+
+#### 5. [WARNING] src/core/diff.ts:974
+
+模糊匹配逻辑在大文件或极端场景下可能退化为高时间复杂度，存在性能风险。
+
+**💡 建议:** 限制最大搜索窗口或尝试次数，并引入超时或评分阈值保护机制。
+
+<details>
+<summary>代码片段</summary>
+
+```
+for (let i = expectedStart; i < expectedEnd && i < fileLines.length; i++) {
+```
+
+</details>
+
+#### 6. [WARNING] src/vscode/provider/ChatViewProvider.ts:600
+
+标准 DiffApplier 失败后静默回退到旧逻辑，可能掩盖真实错误来源。
+
+**💡 建议:** 区分 parse 失败、apply 失败和内部异常，并在日志或 UI 中明确提示回退原因。
+
+<details>
+<summary>代码片段</summary>
+
+```
+catch (parseError) { ... await this.applyUnifiedDiff(file); }
+```
+
+</details>
+
+#### 7. [INFO] src/engine/ai/prompt.ts:60
+
+Prompt 构建逻辑发生变化，但缺少测试覆盖，可能引入不可预期的 Diff 生成行为。
+
+**💡 建议:** 为 Prompt 输出增加快照测试或对比测试，确保 Diff 约束不被无意破坏。
+
+<details>
+<summary>代码片段</summary>
+
+```
+export function buildCodeModificationPrompt(
+```
+
+</details>
+
+### 👍 优点
+
+- ✅ 成功抽取 finalizeHunk，显著减少重复代码，提高可维护性
+- ✅ DiffParser 与 DiffApplier 职责边界清晰，未出现明显跨层污染
+- ✅ 对 AI 生成 Diff 不规范场景（行数不匹配、错位 hunk）有务实可行的工程化处理
+- ✅ 引入自动修复与降级机制，整体设计目标清晰且符合真实使用场景
+- ✅ 日志信息对调试复杂 Diff 应用问题具有实际价值
+
+### 💡 建议
+
+- 为 DiffHunk 校验与修复流程引入更强的类型约束（判别联合类型）
+- 补充异常 Diff 场景的单元测试（行数不匹配、无 context、模糊定位失败）
+- 为模糊匹配和整文件覆盖机制增加性能与安全保护策略
+- 统一错误处理与日志分级策略（warn / error / UI 提示）
+- 在高风险降级路径（applyFullContent）前增加显式用户感知或确认机制
+
+[↑ 返回顶部](#)
+
+
+---
+
+## 📋 Code Review - 2026/1/31 15:41:56
+
+**📊 评分:** 👍 82/100  
+**🔧 级别:** STANDARD  
+**🌿 分支:** `main`  
+**💾 提交:** `36d5cbe`  
+**📂 范围:** 未暂存 (4 个文件)  
+
+### 📝 总体评价
+
+本次代码变更在语义层面显著提升了 Diff 解析与应用的健壮性，通过抽取公共逻辑、引入自动修复和降级机制，改善了对不规范 Diff 的容错能力。但同时也引入了 API 语义复杂化、状态可变性边界模糊、统计一致性和性能风险等问题，整体质量良好但仍有明确的改进空间。
+
+### ⚠️ 发现的问题 (7)
+
+#### 1. [ERROR] src/core/diff.ts:448
+
+validateAndFixHunkLineCount 返回的 finalHunk 与原 hunk 语义容易混淆，调用方可能误用未修复的对象。
+
+**💡 建议:** 统一始终返回新的 DiffHunk 实例，或通过更严格的判别联合类型强制调用方仅使用 finalHunk。
+
+<details>
+<summary>代码片段</summary>
+
+```
+return { status: 'fixed', finalHunk: fixedHunk, error: "Auto-fixed line count mismatch" };
+```
+
+</details>
+
+#### 2. [WARNING] src/core/diff.ts:472
+
+finalizeHunk 中的统计信息在 fixedHunk 与原 hunk 不一致时可能产生错误统计。
+
+**💡 建议:** 确保所有统计逻辑严格基于最终写入 file.hunks 的 hunkToUse 计算。
+
+<details>
+<summary>代码片段</summary>
+
+```
+file.stats.added += hunk.stats.added;
+```
+
+</details>
+
+#### 3. [WARNING] src/core/diff.ts:353
+
+flexibleNormalizePath 放宽路径规则，可能破坏依赖旧 normalizePath 行为的调用方假设。
+
+**💡 建议:** 补充异常路径的单元测试，并在变更日志中明确行为变化。
+
+<details>
+<summary>代码片段</summary>
+
+```
+private static flexibleNormalizePath(pathStr: string): string
+```
+
+</details>
+
+#### 4. [WARNING] src/core/diff.ts:789
+
+applyFullContent 作为降级机制直接整文件覆盖，存在误覆盖和数据丢失风险。
+
+**💡 建议:** 在 UI 层增加显式用户确认，或在逻辑层引入新旧内容一致性与差异校验。
+
+<details>
+<summary>代码片段</summary>
+
+```
+edit.replace(fullPath, fullRange, newContent);
+```
+
+</details>
+
+#### 5. [WARNING] src/core/diff.ts:974
+
+模糊匹配 locateHunkStart 在大文件或极端情况下可能退化为高时间复杂度。
+
+**💡 建议:** 限制最大搜索窗口或尝试次数，并引入超时或评分阈值保护。
+
+<details>
+<summary>代码片段</summary>
+
+```
+for (let i = expectedStart; i < expectedEnd && i < fileLines.length; i++) {
+```
+
+</details>
+
+#### 6. [WARNING] src/vscode/provider/ChatViewProvider.ts:600
+
+DiffApplier 失败后静默回退到旧逻辑，可能掩盖真实错误来源。
+
+**💡 建议:** 区分 parse 失败、apply 失败和内部异常，并在日志或 UI 中明确提示回退原因。
+
+<details>
+<summary>代码片段</summary>
+
+```
+catch (parseError) { ... await this.applyUnifiedDiff(file); }
+```
+
+</details>
+
+#### 7. [INFO] src/engine/ai/prompt.ts:60
+
+Prompt 构建逻辑发生变化但缺少测试覆盖，可能影响 Diff 生成约束。
+
+**💡 建议:** 为 Prompt 输出增加快照或对比测试，防止无意破坏约束。
+
+<details>
+<summary>代码片段</summary>
+
+```
+export function buildCodeModificationPrompt(
+```
+
+</details>
+
+### 👍 优点
+
+- ✅ 成功抽取 finalizeHunk，显著减少重复代码并提升可维护性
+- ✅ DiffParser 与 DiffApplier 职责边界清晰，架构层次合理
+- ✅ 针对 AI 生成 Diff 不规范问题提供了务实的工程化解决方案
+- ✅ 自动修复、模糊定位和降级机制整体设计目标明确
+- ✅ 日志信息对调试复杂 Diff 场景具有实际价值
+
+### 💡 建议
+
+- 为 DiffHunk 校验与修复流程引入更强的类型系统约束（判别联合类型）
+- 补充异常 Diff 场景的单元测试（行数不匹配、无 context、错位 hunk）
+- 为模糊匹配与整文件覆盖路径增加性能与安全保护策略
+- 统一错误处理与日志分级规范（warn / error / UI 提示）
+- 在高风险降级路径（applyFullContent）前增加显式用户感知或确认机制
+
+[↑ 返回顶部](#)
+
+
+---
+
+## 📋 Code Review - 2026/1/31 15:42:46
+
+**📊 评分:** 👍 82/100  
+**🔧 级别:** DEEP  
+**🌿 分支:** `main`  
+**💾 提交:** `36d5cbe`  
+**📂 范围:** 未暂存 (4 个文件)  
+
+### 📝 总体评价
+
+本次代码变更在架构和语义层面显著提升了 Diff 解析与应用的健壮性，尤其针对 AI 生成的不规范 Diff 场景提供了务实有效的工程化解决方案（自动修复、模糊定位、降级机制）。同时也引入了 API 语义复杂化、状态可变性、副作用、统计一致性、性能与安全风险等问题，整体质量良好但仍有清晰的改进空间。
+
+### ⚠️ 发现的问题 (7)
+
+#### 1. [ERROR] src/core/diff.ts:448
+
+validateAndFixHunkLineCount 返回结果与原 hunk 对象语义混淆，存在误用风险
+
+**💡 建议:** 建议使用判别联合类型（discriminated union），或统一始终返回新的 DiffHunk 实例，强制调用方仅使用最终 hunk
+
+<details>
+<summary>代码片段</summary>
+
+```
+return { status: 'fixed', finalHunk: fixedHunk, error: "Auto-fixed line count mismatch" };
+```
+
+</details>
+
+#### 2. [WARNING] src/core/diff.ts:472
+
+finalizeHunk 中统计逻辑可能基于原 hunk 而非最终写入的 hunk，导致统计不一致
+
+**💡 建议:** 确保所有统计信息严格基于最终入库的 hunkToUse 计算，并通过类型约束避免误用
+
+<details>
+<summary>代码片段</summary>
+
+```
+file.stats.added += hunk.stats.added;
+```
+
+</details>
+
+#### 3. [WARNING] src/core/diff.ts:353
+
+flexibleNormalizePath 放宽路径规范化规则，可能破坏依赖旧行为的调用方假设
+
+**💡 建议:** 补充单元测试覆盖异常路径（引号、绝对路径、多前缀），并在变更日志中明确行为变化
+
+<details>
+<summary>代码片段</summary>
+
+```
+private static flexibleNormalizePath(pathStr: string): string
+```
+
+</details>
+
+#### 4. [WARNING] src/core/diff.ts:789
+
+applyFullContent 作为降级机制直接整文件覆盖，存在误覆盖和数据丢失风险
+
+**💡 建议:** 建议在 UI 层增加显式用户确认，或在逻辑层引入新旧内容一致性与差异校验
+
+<details>
+<summary>代码片段</summary>
+
+```
+edit.replace(fullPath, fullRange, newContent);
+```
+
+</details>
+
+#### 5. [WARNING] src/core/diff.ts:974
+
+模糊匹配 locateHunkStart 在大文件或极端场景下可能退化为高时间复杂度
+
+**💡 建议:** 限制最大搜索窗口或尝试次数，并增加超时或评分阈值保护机制
+
+<details>
+<summary>代码片段</summary>
+
+```
+for (let i = expectedStart; i < expectedEnd && i < fileLines.length; i++) {
+```
+
+</details>
+
+#### 6. [WARNING] src/vscode/provider/ChatViewProvider.ts:600
+
+DiffApplier 失败后静默回退到旧逻辑，可能掩盖真实错误来源
+
+**💡 建议:** 区分 parse 失败、apply 失败和内部异常，并在日志或 UI 中明确提示回退原因
+
+<details>
+<summary>代码片段</summary>
+
+```
+catch (parseError) { ... await this.applyUnifiedDiff(file); }
+```
+
+</details>
+
+#### 7. [INFO] src/engine/ai/prompt.ts:60
+
+Prompt 构建逻辑发生变化但缺少测试覆盖，可能影响 Diff 生成约束
+
+**💡 建议:** 为 Prompt 输出增加快照测试或对比测试，确保约束不会被无意破坏
+
+<details>
+<summary>代码片段</summary>
+
+```
+export function buildCodeModificationPrompt(
+```
+
+</details>
+
+### 👍 优点
+
+- ✅ 成功抽取 finalizeHunk，显著减少重复代码并提升可维护性
+- ✅ DiffParser 与 DiffApplier 职责边界清晰，架构分层合理
+- ✅ 针对 AI 生成 Diff 不规范问题（行数不匹配、错位 hunk）提供了务实的工程化解决方案
+- ✅ 自动修复、模糊定位和降级机制的设计目标清晰，符合真实使用场景
+- ✅ 日志信息对调试复杂 Diff 场景具有实际价值
+
+### 💡 建议
+
+- 为 DiffHunk 校验与修复流程引入更强的类型系统约束（判别联合类型）
+- 补充异常 Diff 场景的单元测试（行数不匹配、无 context、模糊定位失败）
+- 为模糊匹配和整文件覆盖路径增加性能与安全保护策略
+- 统一错误处理与日志分级规范（warn / error / UI 提示）
+- 在高风险降级路径（applyFullContent）前增加显式用户感知或确认机制
+
+[↑ 返回顶部](#)
+
diff --git a/src/core/diff.ts b/src/core/diff.ts
index ae50a3a..8f0f103 100644
--- a/src/core/diff.ts
+++ b/src/core/diff.ts
@@ -194,21 +194,7 @@ export class DiffParser {
         if (currentFile) {
           // Finalize 前一个 hunk（如果存在）
           if (currentHunk) {
-            const validateResult = this.validateHunkLineCount(currentHunk);
-            if (!validateResult.ok) {
-              return this.error(
-                'LINE_COUNT_MISMATCH',
-                validateResult.error || 'Unknown validation error',
-                i,
-                currentFile.hunks.length - 1
-              );
-            }
-
-            currentFile.hunks.push(currentHunk);
-            currentFile.stats.hunkCount++;
-            currentFile.stats.added += currentHunk.stats.added;
-            currentFile.stats.removed += currentHunk.stats.removed;
-            currentFile.stats.context += currentHunk.stats.context;
+            this.finalizeHunk(currentFile, currentHunk);
             currentHunk = null;
           }
 
@@ -243,22 +229,7 @@ export class DiffParser {
 
         // 保存前一个 hunk（如果存在）
         if (currentHunk) {
-          // 校验行数统计
-          const validateResult = this.validateHunkLineCount(currentHunk);
-          if (!validateResult.ok) {
-            return this.error(
-              'LINE_COUNT_MISMATCH',
-              validateResult.error || 'Unknown validation error',
-              i,
-              currentFile.hunks.length - 1
-            );
-          }
-
-          currentFile.hunks.push(currentHunk);
-          currentFile.stats.hunkCount++;
-          currentFile.stats.added += currentHunk.stats.added;
-          currentFile.stats.removed += currentHunk.stats.removed;
-          currentFile.stats.context += currentHunk.stats.context;
+          this.finalizeHunk(currentFile, currentHunk);
         }
 
         // 解析 hunk 头
@@ -348,16 +319,7 @@ export class DiffParser {
 
     // 保存最后一个 hunk 和文件
     if (currentHunk && currentFile) {
-      const validateResult = this.validateHunkLineCount(currentHunk);
-      if (!validateResult.ok) {
-        return this.error('LINE_COUNT_MISMATCH', validateResult.error || 'Unknown validation error', lines.length - 1, currentFile.hunks.length);
-      }
-
-      currentFile.hunks.push(currentHunk);
-      currentFile.stats.hunkCount++;
-      currentFile.stats.added += currentHunk.stats.added;
-      currentFile.stats.removed += currentHunk.stats.removed;
-      currentFile.stats.context += currentHunk.stats.context;
+      this.finalizeHunk(currentFile, currentHunk);
     }
 
     if (currentFile) {
@@ -391,15 +353,33 @@ export class DiffParser {
 
   /**
    * 规范化文件路径
-   * 
+   *
    * @param path 原始路径
    * @returns 规范化后的路径（去除 a/ 或 b/ 前缀）
    */
   private static normalizePath(path: string): string {
-    if (path.startsWith('a/') || path.startsWith('b/')) {
-      return path.substring(2);
+    return this.flexibleNormalizePath(path);
+  }
+
+  /**
+   * 灵活的路径规范化函数，容忍各种格式错误
+   *
+   * @param pathStr 原始路径字符串
+   * @returns 规范化后的路径
+   */
+  private static flexibleNormalizePath(pathStr: string): string {
+    // 1. 去掉引号
+    let cleanPath = pathStr.replace(/^["']|["']$/g, '');
+
+    // 2. 移除常见的 git 前缀
+    if (cleanPath.startsWith('a/') || cleanPath.startsWith('b/')) {
+      cleanPath = cleanPath.substring(2);
     }
-    return path;
+
+    // 3. 移除开头的斜杠
+    cleanPath = cleanPath.replace(/^[/\\]+/, '');
+
+    return cleanPath.trim();
   }
 
   /**
@@ -437,31 +417,39 @@ export class DiffParser {
   }
 
   /**
-   * 校验 hunk 的行数统计（v2.1 修正：正确的 unified diff 语义）
-   * 
+   * 校验并修复 hunk 的行数统计（v2.1 修正：正确的 unified diff 语义）
+   *
    * unified diff 语义：
    * - oldCount = context + removed
    * - newCount = context + added
-   * 
+   *
    * @param hunk 要校验的 hunk
-   * @returns 校验结果
+   * @returns 校验结果 - 使用判别联合类型确保调用方正确处理返回值
    */
-  private static validateHunkLineCount(hunk: DiffHunk): { ok: boolean; error?: string } {
-    // 修正：正确的 unified diff 行数统计
-    const oldLines = hunk.stats.context + hunk.stats.removed;
-    const newLines = hunk.stats.context + hunk.stats.added;
-
-    if (oldLines !== hunk.oldCount) {
-      return {
-        ok: false,
-        error: `Hunk line count mismatch: expected ${hunk.oldCount} old lines (context+removed), found ${oldLines}`
+  private static validateAndFixHunkLineCount(hunk: DiffHunk):
+    | { status: 'ok'; finalHunk: DiffHunk }
+    | { status: 'fixed'; finalHunk: DiffHunk; error: string }
+    | { status: 'error'; error: string } {
+    // 计算实际解析到的旧代码行数 (context + remove)
+    const actualOldCount = hunk.stats.context + hunk.stats.removed;
+    // 计算实际解析到的新代码行数 (context + add)
+    const actualNewCount = hunk.stats.context + hunk.stats.added;
+
+    // 如果行数不一致，进行自动修复
+    if (actualOldCount !== hunk.oldCount || actualNewCount !== hunk.newCount) {
+      console.warn(`[Diff Fixer] 检测到行数不匹配: 声明(-${hunk.oldCount},+${hunk.newCount}) -> 实际(-${actualOldCount},+${actualNewCount})`);
+
+      // 创建新的 hunk 对象，避免修改原对象（副作用）
+      const fixedHunk = {
+        ...hunk,
+        oldCount: actualOldCount,
+        newCount: actualNewCount
       };
-    }
 
-    if (newLines !== hunk.newCount) {
       return {
-        ok: false,
-        error: `Hunk line count mismatch: expected ${hunk.newCount} new lines (context+added), found ${newLines}`
+        status: 'fixed', // 标记为已修复
+        finalHunk: fixedHunk,
+        error: "Auto-fixed line count mismatch"
       };
     }
 
@@ -472,12 +460,39 @@ export class DiffParser {
       console.warn(`[DiffParser] Hunk at ${hunk.filePath}:${hunk.oldStart} has no context lines`);
     }
 
-    return { ok: true };
+    return { status: 'ok', finalHunk: hunk };
+  }
+
+  /**
+   * 将 hunk 添加到文件并更新统计信息
+   *
+   * @param file 文件对象
+   * @param hunk 要添加的 hunk
+   */
+  private static finalizeHunk(file: DiffFile, hunk: DiffHunk) {
+    const validateResult = this.validateAndFixHunkLineCount(hunk);
+
+    if (validateResult.status === 'error') {
+      // 如果出现错误，可以选择跳过或抛出异常，这里我们使用原始hunk
+      console.error(`[DiffParser] Validation error: ${validateResult.error}`);
+      file.hunks.push(hunk);
+      file.stats.hunkCount++;
+      file.stats.added += hunk.stats.added;
+      file.stats.removed += hunk.stats.removed;
+      file.stats.context += hunk.stats.context;
+    } else {
+      // status 为 'ok' 或 'fixed'，两种情况下都有 finalHunk
+      file.hunks.push(validateResult.finalHunk);
+      file.stats.hunkCount++;
+      file.stats.added += validateResult.finalHunk.stats.added;
+      file.stats.removed += validateResult.finalHunk.stats.removed;
+      file.stats.context += validateResult.finalHunk.stats.context;
+    }
   }
 
   /**
    * 创建错误对象
-   * 
+   *
    * @param error 错误类型
    * @param message 错误消息
    * @param line 错误行号（可选）
@@ -784,6 +799,98 @@ export class DiffApplier {
     };
   }
 
+  /**
+   * 应用完整的文件内容（降级机制）
+   *
+   * @param filePath 文件路径
+   * @param newContent 新的文件内容
+   * @returns 应用结果
+   */
+  static async applyFullContent(filePath: string, newContent: string): Promise<ApplyResult> {
+    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
+    if (!workspaceFolder) {
+      return {
+        success: false,
+        error: 'INVALID_DIFF',
+        message: 'No workspace folder found'
+      };
+    }
+
+    // 基本内容校验，防止明显错误
+    if (!newContent || typeof newContent !== 'string') {
+      return {
+        success: false,
+        error: 'INVALID_DIFF',
+        message: 'Invalid content provided for replacement'
+      };
+    }
+
+    // 检查是否包含明显的异常内容（如过多的换行符或特殊字符）
+    if (newContent.length > 0 && newContent.length < 10 && !newContent.trim()) {
+      return {
+        success: false,
+        error: 'INVALID_DIFF',
+        message: 'Content appears to be empty or invalid'
+      };
+    }
+
+    const fullPath = vscode.Uri.joinPath(workspaceFolder.uri, filePath);
+
+    try {
+      // 获取当前文档
+      const document = await vscode.workspace.openTextDocument(fullPath);
+      const oldContent = document.getText();
+
+      // 检查新旧内容是否差异过大（可选的安全检查）
+      const oldLines = oldContent.split('\n').length;
+      const newLines = newContent.split('\n').length;
+      const lineDiffRatio = Math.abs(newLines - oldLines) / Math.max(oldLines, 1);
+
+      // 如果内容差异很大，可以考虑提示用户（这里暂时注释掉，可根据需要启用）
+      // if (lineDiffRatio > 2.0) { // 新内容是旧内容的2倍以上
+      //   console.warn(`[DiffApplier] Large content change detected: ${filePath}`);
+      // }
+
+      // 创建全文件范围
+      const fullRange = new vscode.Range(
+        document.lineAt(0).range.start,
+        document.lineAt(document.lineCount - 1).range.end
+      );
+
+      const edit = new vscode.WorkspaceEdit();
+      // 执行替换
+      edit.replace(fullPath, fullRange, newContent);
+
+      // 应用修改
+      const success = await vscode.workspace.applyEdit(edit);
+      if (success) {
+        await document.save();
+        return {
+          success: true,
+          changedFiles: [filePath],
+          stats: {
+            filesChanged: 1,
+            hunksApplied: 0,
+            linesAdded: newContent.split('\n').length,
+            linesRemoved: document.getText().split('\n').length
+          }
+        };
+      } else {
+        return {
+          success: false,
+          error: 'INVALID_DIFF',
+          message: 'VS Code rejected the file modification request'
+        };
+      }
+    } catch (error) {
+      return {
+        success: false,
+        error: 'FILE_NOT_FOUND',
+        message: `Failed to open or modify file: ${error instanceof Error ? error.message : String(error)}`
+      };
+    }
+  }
+
   /**
    * 应用单个 hunk（MVP 实现）
    * 
@@ -881,7 +988,7 @@ export class DiffApplier {
 
   /**
    * 定位 hunk 起始位置
-   * 
+   *
    * @param doc 文档对象
    * @param hunk 要定位的 hunk
    * @returns 起始行号（0-based），未找到返回 -1
@@ -889,13 +996,79 @@ export class DiffApplier {
   private static locateHunkStart(doc: vscode.TextDocument, hunk: DiffHunk): number {
     const targetLine = hunk.oldStart - 1; // 转换为 0-based
 
-    // 简单实现：直接使用 hunk.oldStart
-    // 未来可以添加模糊匹配、上下文搜索等
-
+    // 1. 首先尝试精确行号匹配
     if (targetLine >= 0 && targetLine < doc.lineCount) {
-      return targetLine;
+      // 检查上下文行是否匹配
+      const anchors = hunk.lines.filter(l => l.type === 'context' && l.content.trim().length > 0).map(l => l.content.trim());
+      if (anchors.length > 0 && this.isLinesMatch(doc.lineAt(targetLine).text, anchors[0])) {
+        // 如果第一个锚点匹配，检查后续锚点是否也匹配
+        let matchCount = 1;
+        for (let j = 1; j < Math.min(anchors.length, 3); j++) {
+          if (targetLine + j < doc.lineCount && this.isLinesMatch(doc.lineAt(targetLine + j).text, anchors[j])) {
+            matchCount++;
+          }
+        }
+        // 如果匹配超过 50% 的锚点，就认为找到了位置
+        if (matchCount / Math.min(anchors.length, 3) >= 0.5) {
+          return targetLine;
+        }
+      }
     }
 
+    // 2. 如果精确匹配失败，启动模糊搜索
+    console.log(`[Fuzzy] 行号 ${hunk.oldStart} 匹配失败，启动内容定位...`);
+    const bestMatchIndex = this.findBestMatchIndex(doc, hunk);
+
+    return bestMatchIndex;
+  }
+
+  /**
+   * 简单的模糊匹配工具函数
+   */
+  private static isLinesMatch(fileLine: string, diffLine: string): boolean {
+    if (!fileLine || !diffLine) return false;
+    // 忽略缩进和首尾空格进行对比
+    return fileLine.trim() === diffLine.trim();
+  }
+
+  /**
+   * 在文档中查找最佳匹配索引
+   */
+  private static findBestMatchIndex(doc: vscode.TextDocument, hunk: DiffHunk): number {
+    const fileLines = doc.getText().split('\n');
+
+    // 提取 context 类型且不为空的行作为搜索锚点
+    const anchors = hunk.lines
+      .filter(l => l.type === 'context' && l.content.trim().length > 5)
+      .map(l => l.content.trim());
+
+    if (anchors.length === 0) return -1;
+
+    // 限制搜索范围，避免全文件扫描导致性能问题
+    // 以期望位置为中心，前后各搜索50行，但不超过最大搜索范围
+    const searchRadius = 50;
+    const maxSearchAttempts = 200; // 限制最大尝试次数
+    let attempts = 0;
+
+    const expectedStart = Math.max(0, hunk.oldStart - 1 - searchRadius); // 转换为0-based并减去搜索半径
+    const expectedEnd = Math.min(fileLines.length, hunk.oldStart - 1 + searchRadius); // 加上搜索半径
+
+    // 搜索指定范围内的匹配
+    for (let i = expectedStart; i < expectedEnd && i < fileLines.length && attempts < maxSearchAttempts; i++, attempts++) {
+      if (this.isLinesMatch(fileLines[i], anchors[0])) {
+        // 如果第一个锚点匹配，检查后续锚点是否也匹配
+        let matchCount = 1;
+        for (let j = 1; j < Math.min(anchors.length, 3); j++) {
+          if (i + j < fileLines.length && this.isLinesMatch(fileLines[i + j], anchors[j])) {
+            matchCount++;
+          }
+        }
+        // 只要匹配超过 50% 的锚点，就认为找到了位置
+        if (matchCount / Math.min(anchors.length, 3) >= 0.5) {
+          return i;
+        }
+      }
+    }
     return -1;
   }
 }
diff --git a/src/engine/ai/prompt.ts b/src/engine/ai/prompt.ts
index 2a55d7e..0d5ca9c 100644
--- a/src/engine/ai/prompt.ts
+++ b/src/engine/ai/prompt.ts
@@ -60,6 +60,36 @@ ${userInput}
 `;
 }
 
+export function buildCodeModificationPrompt(
+    userInput: string,
+    context?: string
+): string {
+    return `
+你是一个专业的代码修改助手。
+
+【关于代码修改的强制指令】
+1. 必须使用标准的 Unified Diff 格式。
+2. 即使是微小的修改，也请至少提供 3 行上下文（Context lines）。
+3. 严禁使用 "..." 省略中间的代码，必须完整展示 Hunk 内的所有行。
+4. 如果无法确定行号，请确保上下文内容是唯一的。
+5. 保持 Diff 行数准确，如果不确定，请直接输出修改后的代码块，并带上前后 3 行作为锚点。
+
+【规则】
+- 严格按照 Unified Diff 格式输出
+- 提供足够的上下文行以便定位修改位置
+- 确保行数统计准确
+- 不要在 Diff 外添加额外解释
+
+【上下文信息】
+${context || '无'}
+
+【用户需求】
+${userInput}
+
+请直接输出符合标准 Unified Diff 格式的修改内容。
+`;
+}
+
 export function buildFixPrompt(
     originalCmd: string,
     stderr: string,
diff --git a/src/vscode/provider/ChatViewProvider.ts b/src/vscode/provider/ChatViewProvider.ts
index 71d1466..d61448a 100644
--- a/src/vscode/provider/ChatViewProvider.ts
+++ b/src/vscode/provider/ChatViewProvider.ts
@@ -6,6 +6,7 @@ import { GovernanceService } from '../../engine/agent/governance';
 import * as chatHistoryStorage from '../../engine/agent/chatHistoryStorage';
 import { createIgnoreFilter, IgnoreFilter } from '../utils/ignoreFilter';
 import { GitManager } from '../git/GitManager';
+import { DiffParser, DiffApplier } from '../core/diff';
 
 // 模型配置接口
 interface ModelConfig {
@@ -303,6 +304,9 @@ export class ChatViewProvider implements vscode.WebviewViewProvider {
                 case 'applyDiff':
                     await this.handleApplyDiff(data.value);
                     break;
+                case 'applyFullRewrite':
+                    await this.handleApplyFullRewrite(data.path, data.content);
+                    break;
                 case 'open':
                     if (data.path) {
                         try {
@@ -596,11 +600,83 @@ export class ChatViewProvider implements vscode.WebviewViewProvider {
 
         try {
             if (diffData.type === 'unified') {
-                for (const file of diffData.files) {
-                    await this.applyUnifiedDiff(file);
+                // 尝试使用新的DiffApplier
+                try {
+                    // 将diffData转换为DiffParser可以处理的格式
+                    const diffText = this.convertToUnifiedDiffFormat(diffData);
+                    const parseResult = DiffParser.parse(diffText);
+
+                    if (!parseResult.success) {
+                        console.warn('[ChatViewProvider] Diff parsing failed, falling back to legacy parser:', parseResult.message);
+                        // 如果解析失败，回退到原来的实现
+                        for (const file of diffData.files) {
+                            await this.applyUnifiedDiff(file);
+                        }
+                        this._view.webview.postMessage({ type: 'diffApplied' });
+                        vscode.window.showInformationMessage('✓ Diff applied successfully (using legacy parser)');
+                        return;
+                    }
+
+                    const applyResult = await DiffApplier.apply(parseResult);
+
+                    if (!applyResult.success) {
+                        console.warn('[ChatViewProvider] Diff application failed, offering full rewrite option:', applyResult.message);
+                        // 如果标准应用失败，询问用户是否尝试全量替换
+                        const result = await vscode.window.showErrorMessage(
+                            `补丁应用失败（${applyResult.message}）。是否尝试全量覆盖？`,
+                            "是的，覆盖全文件", "取消"
+                        );
+
+                        if (result === "是的，覆盖全文件") {
+                            // 这里可以触发一个特定的 Prompt 让 AI 重新发送完整代码，
+                            // 或者如果当前对话中已有完整代码，直接调用 applyFullContent
+                            await this.requestFullCodeFromAI();
+                            return;
+                        } else {
+                            throw new Error(applyResult.message);
+                        }
+                    }
+
+                    this._view.webview.postMessage({ type: 'diffApplied' });
+                    vscode.window.showInformationMessage('✓ Diff applied successfully!');
+                } catch (error) {
+                    // 区分不同类型的错误
+                    if (error instanceof Error) {
+                        if (error.message.includes('parsing failed') || error.message.includes('Invalid diff')) {
+                            console.warn('[ChatViewProvider] Diff parsing error, falling back to legacy parser:', error.message);
+                            // 解析错误：回退到旧解析器
+                            for (const file of diffData.files) {
+                                await this.applyUnifiedDiff(file);
+                            }
+                            this._view.webview.postMessage({ type: 'diffApplied' });
+                            vscode.window.showInformationMessage('✓ Diff applied successfully (using legacy parser)');
+                        } else if (error.message.includes('apply failed')) {
+                            console.warn('[ChatViewProvider] Diff application error, falling back to legacy implementation:', error.message);
+                            // 应用错误：回退到旧实现
+                            for (const file of diffData.files) {
+                                await this.applyUnifiedDiff(file);
+                            }
+                            this._view.webview.postMessage({ type: 'diffApplied' });
+                            vscode.window.showInformationMessage('✓ Diff applied successfully (using legacy implementation)');
+                        } else {
+                            console.error('[ChatViewProvider] Unexpected error during diff application:', error);
+                            // 其他错误：回退到旧实现
+                            for (const file of diffData.files) {
+                                await this.applyUnifiedDiff(file);
+                            }
+                            this._view.webview.postMessage({ type: 'diffApplied' });
+                            vscode.window.showInformationMessage('✓ Diff applied successfully (using legacy implementation)');
+                        }
+                    } else {
+                        console.error('[ChatViewProvider] Unknown error during diff application:', error);
+                        // 未知错误：回退到旧实现
+                        for (const file of diffData.files) {
+                            await this.applyUnifiedDiff(file);
+                        }
+                        this._view.webview.postMessage({ type: 'diffApplied' });
+                        vscode.window.showInformationMessage('✓ Diff applied successfully (using legacy implementation)');
+                    }
                 }
-                this._view.webview.postMessage({ type: 'diffApplied' });
-                vscode.window.showInformationMessage('✓ Diff applied successfully!');
             } else if (diffData.type === 'simple') {
                 await this.applySimpleDiff(diffData);
                 this._view.webview.postMessage({ type: 'diffApplied' });
@@ -614,6 +690,93 @@ export class ChatViewProvider implements vscode.WebviewViewProvider {
         }
     }
 
+    /**
+     * 将diffData转换为标准的unified diff格式
+     */
+    private convertToUnifiedDiffFormat(diffData: any): string {
+        let diffString = '';
+
+        for (const file of diffData.files) {
+            diffString += `--- a/${file.oldFile || 'original'}\n`;
+            diffString += `+++ b/${file.newFile || 'modified'}\n`;
+
+            for (const hunk of file.hunks) {
+                diffString += `@@ -${hunk.oldStart},${hunk.oldLines} +${hunk.newStart},${hunk.newLines} @@\n`;
+
+                for (const line of hunk.lines) {
+                    if (line.startsWith('+')) {
+                        diffString += line + '\n';
+                    } else if (line.startsWith('-')) {
+                        diffString += line + '\n';
+                    } else {
+                        diffString += ` ${line}\n`;
+                    }
+                }
+            }
+        }
+
+        return diffString;
+    }
+
+    /**
+     * 请求AI提供完整代码
+     */
+    private async requestFullCodeFromAI() {
+        // 这里可以实现向AI请求完整代码的逻辑
+        const editor = vscode.window.activeTextEditor;
+        if (!editor) {
+            vscode.window.showErrorMessage('请先打开一个文件');
+            return;
+        }
+
+        const document = editor.document;
+        const fileName = path.basename(document.fileName);
+
+        // 向AI发送请求，要求提供完整的文件内容
+        const prompt = `由于补丁应用失败，我需要您提供完整的 ${fileName} 文件内容。请直接输出完整的代码，不要包含任何解释。`;
+
+        // 发送消息到UI，触发AI请求
+        this._view?.webview.postMessage({
+            type: 'appendMessage',
+            value: { role: 'user', content: prompt }
+        });
+
+        await this.handleAgentTask(prompt);
+    }
+
+    /**
+     * 处理全量内容替换
+     */
+    private async handleApplyFullRewrite(filePath: string, content: string) {
+        try {
+            let actualFilePath = filePath;
+
+            // 如果没有提供路径，使用当前活动文件
+            if (!actualFilePath) {
+                const editor = vscode.window.activeTextEditor;
+                if (!editor) {
+                    throw new Error('没有打开的文件可供替换，请先打开一个文件');
+                }
+                actualFilePath = path.relative(
+                    vscode.workspace.workspaceFolders?.[0].uri.fsPath || '',
+                    editor.document.uri.fsPath
+                );
+            }
+
+            // 使用新的DiffApplier的全量替换功能
+            const result = await DiffApplier.applyFullContent(actualFilePath, content);
+
+            if (result.success) {
+                vscode.window.showInformationMessage(`已成功替换文件: ${actualFilePath}`);
+            } else {
+                throw new Error(result.message);
+            }
+        } catch (error) {
+            console.error('[ChatViewProvider] Full rewrite failed:', error);
+            vscode.window.showErrorMessage(`替换失败: ${error instanceof Error ? error.message : String(error)}`);
+        }
+    }
+
     private async applyUnifiedDiff(file: any) {
         const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
         if (!workspaceFolder) {
diff --git a/test/DiffImprovements.test.ts b/test/DiffImprovements.test.ts
new file mode 100644
index 0000000..0a912ec
--- /dev/null
+++ b/test/DiffImprovements.test.ts
@@ -0,0 +1,104 @@
+import { describe, it } from 'mocha';
+import { expect } from 'chai';
+import { DiffParser, DiffApplier } from '../src/core/diff';
+
+describe('Diff Parser and Applier Improvements', () => {
+  describe('Performance and Safety Improvements', () => {
+    it('should handle large files with limited search range', () => {
+      // 创建一个大文件内容
+      const largeFileContent = Array(1000).fill('line of code').join('\n');
+      const diffText = `--- a/large.ts
++++ b/large.ts
+@@ -499,5 +499,5 @@
+ line of code
+-line to be replaced
++new line of code
+ line of code
+ line of code
+`;
+      const result = DiffParser.parse(diffText);
+      expect(result.success).to.be.true;
+    });
+
+    it('should maintain accurate statistics after hunk fixes', () => {
+      const diffText = `--- a/test.ts
++++ b/test.ts
+@@ -1,10 +1,5 @@ // Intentionally wrong line counts
+ context_line
+-remove_line1
+-remove_line2
++add_line1
+ final_context
+`;
+      const result = DiffParser.parse(diffText);
+      expect(result.success).to.be.true;
+      if (result.success) {
+        expect(result.files).to.have.length(1);
+        const file = result.files[0];
+        expect(file.hunks).to.have.length(1);
+        const hunk = file.hunks[0];
+        
+        // 验证统计信息的一致性
+        const computedAdded = hunk.lines.filter(l => l.type === 'add').length;
+        const computedRemoved = hunk.lines.filter(l => l.type === 'remove').length;
+        const computedContext = hunk.lines.filter(l => l.type === 'context').length;
+        
+        expect(computedAdded).to.equal(hunk.stats.added);
+        expect(computedRemoved).to.equal(hunk.stats.removed);
+        expect(computedContext).to.equal(hunk.stats.context);
+      }
+    });
+
+    it('should validate content before full replacement', async () => {
+      // 这个测试验证applyFullContent的基本内容校验
+      const result = await DiffApplier.applyFullContent('dummy.ts', '');
+      expect(result.success).to.be.false;
+      expect(result.error).to.equal('INVALID_DIFF');
+    });
+
+    it('should handle edge cases in path normalization', () => {
+      const diffText = `--- "a/file with spaces.ts"
++++ "b/file with spaces.ts"
+@@ -1,1 +1,2 @@
+ old
++new
+`;
+      const result = DiffParser.parse(diffText);
+      expect(result.success).to.be.true;
+      if (result.success) {
+        expect(result.files[0].normalizedPath).to.equal('file with spaces.ts');
+      }
+    });
+
+    it('should properly handle mixed valid and invalid hunks', () => {
+      const diffText = `--- a/test.ts
++++ b/test.ts
+@@ -1,3 +1,3 @@ // Valid hunk
+ line1
+-line2
++line2_new
+ line3
+
+@@ -10,20 +10,5 @@ // Invalid hunk - wrong line count
+ context
+-old_long_line
++new_short
+ final
+`;
+      const result = DiffParser.parse(diffText);
+      expect(result.success).to.be.true;
+      if (result.success) {
+        expect(result.files).to.have.length(1);
+        expect(result.files[0].hunks).to.have.length(2);
+        
+        // 验证第一个hunk保持原计数
+        expect(result.files[0].hunks[0].oldCount).to.equal(3);
+        expect(result.files[0].hunks[0].newCount).to.equal(3);
+        
+        // 验证第二个hunk被修复
+        expect(result.files[0].hunks[1].oldCount).to.equal(3); // 修复后的值
+        expect(result.files[0].hunks[1].newCount).to.equal(3); // 修复后的值
+      }
+    });
+  });
+});
\ No newline at end of file
diff --git a/test/DiffPathNormalization.test.ts b/test/DiffPathNormalization.test.ts
new file mode 100644
index 0000000..af664f5
--- /dev/null
+++ b/test/DiffPathNormalization.test.ts
@@ -0,0 +1,83 @@
+import { describe, it, beforeEach } from 'mocha';
+import { expect } from 'chai';
+import { DiffParser } from '../src/core/diff';
+
+describe('Diff Path Normalization', () => {
+  describe('flexibleNormalizePath', () => {
+    // 由于flexibleNormalizePath是DiffParser的私有静态方法，
+    // 我们通过测试整个解析过程来验证路径处理功能
+    
+    it('should handle normal paths correctly', () => {
+      const diffText = `--- a/src/example.ts
++++ b/src/example.ts
+@@ -1,3 +1,4 @@
+ line1
+ line2
++new line
+ line3
+`;
+      const result = DiffParser.parse(diffText);
+      expect(result.success).to.be.true;
+      if (result.success) {
+        expect(result.files).to.have.length(1);
+        expect(result.files[0].normalizedPath).to.equal('src/example.ts');
+      }
+    });
+
+    it('should handle paths with a/ and b/ prefixes', () => {
+      const diffText = `--- a/path/to/file.js
++++ b/path/to/file.js
+@@ -1,2 +1,3 @@
+ old line
++new line
+`;
+      const result = DiffParser.parse(diffText);
+      expect(result.success).to.be.true;
+      if (result.success) {
+        expect(result.files[0].normalizedPath).to.equal('path/to/file.js');
+      }
+    });
+
+    it('should handle paths with leading slashes', () => {
+      const diffText = `--- /absolute/path/file.py
++++ /absolute/path/file.py
+@@ -1,1 +1,2 @@
+ old
++new
+`;
+      const result = DiffParser.parse(diffText);
+      expect(result.success).to.be.true;
+      if (result.success) {
+        expect(result.files[0].normalizedPath).to.equal('absolute/path/file.py');
+      }
+    });
+
+    it('should handle quoted paths', () => {
+      const diffText = `--- "a/spaced file.ts"
++++ "b/spaced file.ts"
+@@ -1,1 +1,2 @@
+ old
++new
+`;
+      const result = DiffParser.parse(diffText);
+      expect(result.success).to.be.true;
+      if (result.success) {
+        expect(result.files[0].normalizedPath).to.equal('spaced file.ts');
+      }
+    });
+
+    it('should handle mixed prefix and slash scenarios', () => {
+      const diffText = `--- a/subdir/file.txt
++++ b/subdir/file.txt
+@@ -1,1 +1,2 @@
+ content
++added
+`;
+      const result = DiffParser.parse(diffText);
+      expect(result.success).to.be.true;
+      if (result.success) {
+        expect(result.files[0].normalizedPath).to.equal('subdir/file.txt');
+      }
+    });
+  });
+});
\ No newline at end of file
diff --git a/test/DiffValidationFix.test.ts b/test/DiffValidationFix.test.ts
new file mode 100644
index 0000000..31dd564
--- /dev/null
+++ b/test/DiffValidationFix.test.ts
@@ -0,0 +1,94 @@
+import { describe, it, beforeEach } from 'mocha';
+import { expect } from 'chai';
+import { DiffParser } from '../src/core/diff';
+
+describe('Diff Validation and Fix', () => {
+  describe('validateAndFixHunkLineCount', () => {
+    // 由于validateAndFixHunkLineCount是DiffParser的私有静态方法，
+    // 我们通过测试整个解析过程来验证行数修复功能
+    
+    it('should auto-fix hunk line count mismatches', () => {
+      // 创建一个故意行数不匹配的diff
+      const diffText = `--- a/test.ts
++++ b/test.ts
+@@ -1,5 +1,3 @@ // 声明5行，但实际上只有3行（1 context + 1 remove + 1 add）
+ old line
+-new line 1
++new line 2
+ final line
+`;
+      const result = DiffParser.parse(diffText);
+      expect(result.success).to.be.true;
+      if (result.success) {
+        expect(result.files).to.have.length(1);
+        const file = result.files[0];
+        expect(file.hunks).to.have.length(1);
+        const hunk = file.hunks[0];
+        
+        // 验证行数已经被修复
+        // 实际应该是 oldCount=2 (1 context + 1 remove), newCount=2 (1 context + 1 add)
+        expect(hunk.oldCount).to.equal(2);
+        expect(hunk.newCount).to.equal(2);
+      }
+    });
+
+    it('should preserve correct hunk line counts', () => {
+      const diffText = `--- a/test.ts
++++ b/test.ts
+@@ -1,3 +1,3 @@
+ line1
+-line2
++NEW_LINE
+ line3
+`;
+      const result = DiffParser.parse(diffText);
+      expect(result.success).to.be.true;
+      if (result.success) {
+        expect(result.files).to.have.length(1);
+        const file = result.files[0];
+        expect(file.hunks).to.have.length(1);
+        const hunk = file.hunks[0];
+        
+        // 验证正确的行数没有被修改
+        // oldCount=3 (1 context + 1 remove + 1 context), newCount=3 (1 context + 1 add + 1 context)
+        expect(hunk.oldCount).to.equal(3);
+        expect(hunk.newCount).to.equal(3);
+      }
+    });
+
+    it('should handle multiple hunks with mixed validity', () => {
+      const diffText = `--- a/test.ts
++++ b/test.ts
+@@ -1,2 +1,2 @@ // 正确的hunk
+ line1
+-line2
++line2_modified
+
+@@ -5,10 +5,4 @@ // 错误的hunk，声明10行但实际只有4行
+ old_context
+-old_line1
+-old_line2
++new_line1
++new_line2
+ final_context
+`;
+      const result = DiffParser.parse(diffText);
+      expect(result.success).to.be.true;
+      if (result.success) {
+        expect(result.files).to.have.length(1);
+        const file = result.files[0];
+        expect(file.hunks).to.have.length(2);
+        
+        // 第一个hunk应该保持原有计数
+        const hunk1 = file.hunks[0];
+        expect(hunk1.oldCount).to.equal(2);
+        expect(hunk1.newCount).to.equal(2);
+        
+        // 第二个hunk应该被修复
+        const hunk2 = file.hunks[1];
+        expect(hunk2.oldCount).to.equal(4); // 修复后的值
+        expect(hunk2.newCount).to.equal(4); // 修复后的值
+      }
+    });
+  });
+});
\ No newline at end of file
diff --git a/test/PromptGeneration.test.ts b/test/PromptGeneration.test.ts
new file mode 100644
index 0000000..040fc5a
--- /dev/null
+++ b/test/PromptGeneration.test.ts
@@ -0,0 +1,42 @@
+import { describe, it } from 'mocha';
+import { expect } from 'chai';
+import { buildCodeModificationPrompt } from '../src/engine/ai/prompt';
+
+describe('Prompt Generation', () => {
+  describe('buildCodeModificationPrompt', () => {
+    it('should generate consistent code modification prompt', () => {
+      const userInput = 'Add a new function to calculate sum';
+      const context = 'Current file contains math utilities';
+      
+      const prompt = buildCodeModificationPrompt(userInput, context);
+      
+      // 验证prompt包含必要元素
+      expect(prompt).to.include('标准的 Unified Diff 格式');
+      expect(prompt).to.include('至少提供 3 行上下文');
+      expect(prompt).to.include('严禁使用 "..." 省略');
+      expect(prompt).to.include(userInput);
+      expect(prompt).to.include(context || '');
+      
+      // 验证prompt结构
+      expect(prompt).to.include('用户需求');
+      expect(prompt).to.include('请直接输出符合标准 Unified Diff 格式的修改内容');
+    });
+
+    it('should handle missing context', () => {
+      const userInput = 'Fix the bug in login function';
+      
+      const prompt = buildCodeModificationPrompt(userInput);
+      
+      expect(prompt).to.include(userInput);
+      expect(prompt).to.include('无'); // 因为context为空时会显示'无'
+    });
+
+    it('should enforce diff format rules', () => {
+      const prompt = buildCodeModificationPrompt('Modify the API endpoint');
+      
+      expect(prompt).to.include('必须使用标准的 Unified Diff 格式');
+      expect(prompt).to.include('保持 Diff 行数准确');
+      expect(prompt).to.include('提供足够的上下文行');
+    });
+  });
+});
\ No newline at end of file
