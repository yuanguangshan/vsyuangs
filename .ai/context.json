[
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/core/capabilities.ts",
    "content": "export enum AtomicCapability {\n  TEXT_GENERATION = 'text_generation',\n  CODE_GENERATION = 'code_generation',\n  TOOL_CALLING = 'tool_calling',\n  LONG_CONTEXT = 'long_context',\n  REASONING = 'reasoning',\n  STREAMING = 'streaming',\n}\n\nexport interface CompositeCapability {\n  name: string;\n  composedOf: AtomicCapability[];\n}\n\nexport const COMPOSITE_CAPABILITIES: CompositeCapability[] = [\n  {\n    name: 'interactive_agent',\n    composedOf: [AtomicCapability.TOOL_CALLING, AtomicCapability.REASONING],\n  },\n  {\n    name: 'large_repo_analysis',\n    composedOf: [AtomicCapability.LONG_CONTEXT, AtomicCapability.REASONING],\n  },\n  {\n    name: 'safe_code_editing',\n    composedOf: [AtomicCapability.CODE_GENERATION, AtomicCapability.REASONING],\n  },\n];\n\nexport enum ConstraintCapability {\n  PREFER_DETERMINISTIC = 'prefer_deterministic',\n  LOW_COST = 'low_cost',\n  FAST_RESPONSE = 'fast_response',\n}\n\nexport const CAPABILITY_VERSION = '1.0';\n\nexport function isAtomicCapability(value: string): value is AtomicCapability {\n  return Object.values(AtomicCapability).includes(value as AtomicCapability);\n}\n\nexport function isConstraintCapability(value: string): value is ConstraintCapability {\n  return Object.values(ConstraintCapability).includes(value as ConstraintCapability);\n}\n\nexport function resolveCompositeCapability(name: string): AtomicCapability[] {\n  const composite = COMPOSITE_CAPABILITIES.find(c => c.name === name);\n  if (!composite) {\n    throw new Error(`Unknown composite capability: ${name}`);\n  }\n  return composite.composedOf;\n}\n\nexport function expandCapabilities(\n  capabilities: Array<AtomicCapability | string>\n): Set<AtomicCapability> {\n  const result = new Set<AtomicCapability>();\n\n  for (const cap of capabilities) {\n    if (isAtomicCapability(cap)) {\n      result.add(cap);\n    } else {\n      const atomicCaps = resolveCompositeCapability(cap);\n      atomicCaps.forEach(c => result.add(c));\n    }\n  }\n\n  return result;\n}\n",
    "tokens": 486
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/core/completion/path.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\n\nexport type PathKind = 'file' | 'dir';\n\nexport function resolvePathSuggestions(\n  input: string,\n  kind: PathKind\n): string[] {\n  const cwd = process.cwd();\n  const normalized = input.replace(/^~(?=$|\\/)/, process.env.HOME || '');\n  const isDirInput = normalized.endsWith(path.sep);\n\n  const baseDir = isDirInput\n    ? path.resolve(cwd, normalized)\n    : path.resolve(cwd, path.dirname(normalized));\n\n  const prefix = isDirInput ? '' : path.basename(normalized);\n\n  try {\n    const entries = fs.readdirSync(baseDir, { withFileTypes: true });\n    return entries\n      .filter(e => !e.name.startsWith('.'))\n      .filter(e => {\n        if (kind === 'file') return e.isFile();\n        return e.isDirectory();\n      })\n      .filter(e => e.name.startsWith(prefix))\n      .map(e => {\n        const fullPath = path.join(baseDir, e.name);\n        const suggestion = e.isDirectory()\n          ? fullPath + path.sep\n          : fullPath;\n        return suggestion.replace(/^\\\\/g, '');\n      });\n  } catch {\n    return [];\n  }\n}\n",
    "tokens": 267
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/core/completion/builtin.ts",
    "content": "import type { CompletionItem } from './types';\n\nexport function getBuiltinCommands(): Array<{ name: string; description: string }> {\n  return [\n    { name: 'ai', description: 'å‘ AI æé—®' },\n    { name: 'list', description: 'åˆ—å‡ºæ‰€æœ‰åº”ç”¨' },\n    { name: 'history', description: 'æŸ¥çœ‹åŠæ‰§è¡Œå‘½ä»¤å†å²' },\n    { name: 'config', description: 'ç®¡ç†æœ¬åœ°é…ç½®' },\n    { name: 'macros', description: 'æŸ¥çœ‹æ‰€æœ‰å¿«æ·æŒ‡ä»¤' },\n    { name: 'save', description: 'ä¿å­˜å¿«æ·æŒ‡ä»¤' },\n    { name: 'run', description: 'æ‰§è¡Œå¿«æ·æŒ‡ä»¤' },\n    { name: 'help', description: 'æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯' },\n    { name: 'completion', description: 'å®‰è£… Shell è¡¥å…¨' },\n    { name: 'shici', description: 'æ‰“å¼€å¤è¯—è¯ PWA' },\n    { name: 'dict', description: 'æ‰“å¼€è‹±è¯­è¯å…¸' },\n    { name: 'pong', description: 'æ‰“å¼€ Pong æ¸¸æˆ' }\n  ];\n}\n",
    "tokens": 180
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/core/completion/resolver.ts",
    "content": "import { CompletionRequest, CompletionResponse, CompletionItem } from './types';\nimport { unique } from './utils';\nimport { getBuiltinCommands } from './builtin';\nimport { loadAppsConfig } from '../apps';\nimport { getMacros } from '../macros';\nimport { Command } from 'commander';\n\nlet programInstance: Command | null = null;\n\nexport function setProgramInstance(program: Command): void {\n  programInstance = program;\n}\n\nfunction getProgramInstance(): Command {\n  return programInstance || ({} as Command);\n}\n\nexport async function resolveCompletion(\n  req: CompletionRequest\n): Promise<CompletionResponse> {\n  const { words, currentIndex } = req;\n\n  const currentWord = words[currentIndex] ?? '';\n  const previousWord = words[currentIndex - 1] ?? '';\n\n  if (currentIndex === 1) {\n    return completeTopLevel(currentWord);\n  }\n\n  return completeSubcommand(words.slice(1, currentIndex), currentWord, previousWord);\n}\n\nfunction completeTopLevel(prefix: string): CompletionResponse {\n  const items: CompletionItem[] = [];\n\n  const commands = getBuiltinCommands();\n  commands.forEach(cmd => {\n    items.push({ label: cmd.name });\n  });\n\n  try {\n    const apps = loadAppsConfig();\n    Object.keys(apps).forEach(name => {\n      if (!items.find(i => i.label === name)) {\n        items.push({ label: name });\n      }\n    });\n  } catch {}\n\n  try {\n    const macros = getMacros();\n    Object.keys(macros).forEach(name => {\n      if (!items.find(i => i.label === name)) {\n        items.push({ label: name });\n      }\n    });\n  } catch {}\n\n  const filtered = items.filter(item => item.label.startsWith(prefix));\n\n  return {\n    items: unique(filtered),\n    isPartial: true\n  };\n}\n\nfunction completeSubcommand(\n  path: string[],\n  prefix: string,\n  prev: string\n): CompletionResponse {\n  const items: CompletionItem[] = [];\n\n  if (prev === '--model' || prev === '-m') {\n    items.push(\n      { label: 'gemini-2.5-flash-lite' },\n      { label: 'gemini-2.5-pro' },\n      { label: 'Assistant' },\n      { label: 'GPT-4o-mini' }\n    );\n  } else if (path.length > 0) {\n    const baseCommand = path[0];\n    const cmd = getProgramInstance().commands.find((c: any) => c.name() === baseCommand);\n\n    if (cmd) {\n      cmd.options.forEach((opt: any) => {\n        opt.flags.split(/[, ]+/).forEach((flag: string) => {\n          if (flag.startsWith('-') && !flag.startsWith('--')) {\n            items.push({ label: flag });\n          }\n        });\n      });\n\n      cmd.commands.forEach((subcmd: any) => {\n        items.push({ label: subcmd.name() });\n      });\n    }\n  }\n\n  const filtered = items.filter(item => item.label.startsWith(prefix));\n\n  return {\n    items: unique(filtered),\n    isPartial: true\n  };\n}\n",
    "tokens": 671
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/core/completion/utils.ts",
    "content": "import { CompletionItem } from './types';\n\nexport function unique(items: CompletionItem[]): CompletionItem[] {\n  const seen = new Set<string>();\n  return items.filter(i => {\n    if (seen.has(i.label)) return false;\n    seen.add(i.label);\n    return true;\n  });\n}\n",
    "tokens": 66
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/core/completion/types.ts",
    "content": "// core/completion/types.ts\n\n/**\n * yuangs Completion Protocol v1.1\n * ç»ˆæ€è¡¥å…¨åè®® - å”¯ä¸€ã€å¼ºçº¦æŸ\n */\n\nexport interface CompletionRequest {\n  /**\n   * å®Œæ•´ argvï¼Œä¸åŒ…å« node\n   * e.g. ['yuangs', 'ai', 'chat', '--m']\n   */\n  words: string[];\n\n  /**\n   * cursor æ‰€åœ¨ index\n   */\n  currentIndex: number;\n}\n\nexport interface CompletionItem {\n  label: string;\n  insertText?: string;\n  detail?: string;\n}\n\nexport interface CompletionResponse {\n  items: CompletionItem[];\n  isPartial: boolean;\n}\n",
    "tokens": 118
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/core/completion/cache.ts",
    "content": "import type { CompletionItem } from './types';\n\nexport class CompletionCache {\n  private static instance: CompletionCache;\n  private cache: Map<string, CompletionItem[]>;\n  private timestamp: number;\n  private readonly ttl: number = 5000;\n\n  private constructor() {\n    this.cache = new Map();\n    this.timestamp = Date.now();\n  }\n\n  static getInstance(): CompletionCache {\n    if (!CompletionCache.instance) {\n      CompletionCache.instance = new CompletionCache();\n    }\n    return CompletionCache.instance;\n  }\n\n  get(key: string): CompletionItem[] | null {\n    const now = Date.now();\n    if (now - this.timestamp > this.ttl) {\n      this.cache.clear();\n      this.timestamp = now;\n      return null;\n    }\n    return this.cache.get(key) || null;\n  }\n\n  set(key: string, items: CompletionItem[]): void {\n    this.cache.set(key, items);\n  }\n\n  invalidate(): void {\n    this.cache.clear();\n    this.timestamp = 0;\n  }\n\n  invalidatePattern(pattern: RegExp): void {\n    for (const key of this.cache.keys()) {\n      if (pattern.test(key)) {\n        this.cache.delete(key);\n      }\n    }\n  }\n}\n",
    "tokens": 273
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/core/completion/index.ts",
    "content": "import { CompletionRequest, CompletionResponse } from './types';\nimport { resolveCompletion } from './resolver';\n\nexport async function complete(\n  req: CompletionRequest\n): Promise<CompletionResponse> {\n  if (!Array.isArray(req.words)) {\n    return { items: [], isPartial: false };\n  }\n\n  if (\n    typeof req.currentIndex !== 'number' ||\n    req.currentIndex < 0 ||\n    req.currentIndex >= req.words.length\n  ) {\n    return { items: [], isPartial: false };\n  }\n\n  return resolveCompletion(req);\n}\n\nexport { setProgramInstance } from './resolver';\n\nexport {\n  getAllCommands,\n  getCommandSubcommands,\n  getCommandDescription,\n  installBashCompletion,\n  installZshCompletion\n} from '../completion.legacy';\n",
    "tokens": 177
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/core/capabilityInference.ts",
    "content": "import { AtomicCapability } from '../core/capabilities';\nimport type { CapabilityRequirement } from '../core/modelMatcher';\n\nexport function inferCapabilityRequirement(userInput: string): CapabilityRequirement {\n  const required: AtomicCapability[] = [];\n\n  const input = userInput.toLowerCase();\n\n  if (input.includes('ä»£ç ') || input.includes('script') || input.includes('æ–‡ä»¶') || input.includes('create') || input.includes('write')) {\n    required.push(AtomicCapability.CODE_GENERATION);\n  }\n\n  if (input.includes('åˆ†æ') || input.includes('ç†è§£') || input.includes('è§£é‡Š') || input.includes('æ¨ç†')) {\n    required.push(AtomicCapability.REASONING);\n  }\n\n  if (input.includes('é•¿') || input.includes('large') || input.includes('ä»“åº“') || input.includes('ç›®å½•') || input.includes('æ‰€æœ‰æ–‡ä»¶')) {\n    required.push(AtomicCapability.LONG_CONTEXT);\n  }\n\n  return {\n    required: Array.from(new Set(required)),\n    preferred: [],\n  };\n}\n",
    "tokens": 229
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/core/apps.ts",
    "content": "import { exec } from 'child_process';\nimport fs from 'fs';\nimport path from 'path';\nimport yaml from 'js-yaml';\nimport os from 'os';\nimport { DEFAULT_APPS, parseAppsConfig } from './validation';\n\nexport { DEFAULT_APPS };\n\nexport function loadAppsConfig(): Record<string, string> {\n    const configPaths = [\n        path.join(process.cwd(), 'yuangs.config.json'),\n        path.join(process.cwd(), 'yuangs.config.yaml'),\n        path.join(process.cwd(), 'yuangs.config.yml'),\n        path.join(process.cwd(), '.yuangs.json'),\n        path.join(process.cwd(), '.yuangs.yaml'),\n        path.join(process.cwd(), '.yuangs.yml'),\n        path.join(os.homedir(), '.yuangs.json'),\n        path.join(os.homedir(), '.yuangs.yaml'),\n        path.join(os.homedir(), '.yuangs.yml'),\n    ];\n\n    for (const configPath of configPaths) {\n        if (fs.existsSync(configPath)) {\n            try {\n                const configContent = fs.readFileSync(configPath, 'utf8');\n                let config: Record<string, string>;\n                if (configPath.endsWith('.yaml') || configPath.endsWith('.yml')) {\n                    config = yaml.load(configContent) as Record<string, string>;\n                } else {\n                    config = parseAppsConfig(configContent);\n                }\n                return config;\n            } catch (error) { }\n        }\n    }\n    return DEFAULT_APPS;\n}\n\n\nexport function openUrl(url: string) {\n    let command;\n    switch (process.platform) {\n        case 'darwin': command = `open \"${url}\"`; break;\n        case 'win32': command = `start \"${url}\"`; break;\n        default: command = `xdg-open \"${url}\"`; break;\n    }\n    exec(command);\n}\n",
    "tokens": 417
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/core/capabilitySystem.ts",
    "content": "import {\n  CapabilityRequirement,\n  matchModelWithFallback,\n  ModelCapabilities,\n  CapabilityMatchResult,\n} from './modelMatcher';\nimport {\n  mergeConfigs,\n  loadConfigAt,\n  dumpConfigSnapshot,\n  getConfigFilePaths,\n  MergedConfig,\n} from './configMerge';\nimport {\n  createExecutionRecord,\n  ExecutionRecord,\n} from './executionRecord';\nimport {\n  saveExecutionRecord,\n  loadExecutionRecord,\n  listExecutionRecords,\n} from './executionStore';\nimport { replayEngine, ReplayOptions, ReplayResult } from './replayEngine';\n\nexport class CapabilitySystem {\n  private primaryModels: ModelCapabilities[] = [];\n  private fallbackModels: ModelCapabilities[] = [];\n\n  constructor() {\n    this.initializeDefaultModels();\n  }\n\n  private initializeDefaultModels(): void {\n    // åˆå§‹åŒ–ä¸ºç©ºæ•°ç»„ï¼Œè®©é…ç½®æ–‡ä»¶æˆä¸ºä¸»è¦æ¥æº\n    this.primaryModels = [];\n    this.fallbackModels = [];\n  }\n\n  matchCapability(requirement: CapabilityRequirement): CapabilityMatchResult {\n    const allModels = this.getAllModels();\n    const primaryModels = [...this.primaryModels, ...this.loadCustomModels()];\n    return matchModelWithFallback(\n      primaryModels,\n      this.fallbackModels,\n      requirement\n    );\n  }\n\n  loadMergedConfig(): MergedConfig {\n    const builtin = {\n      aiProxyUrl: 'https://api.openai.com/v1/chat/completions',\n      defaultModel: 'gpt-4o-mini',\n      accountType: 'free',\n    };\n\n    const filePaths = getConfigFilePaths();\n    const projectConfig = filePaths.project ? loadConfigAt(filePaths.project) : null;\n    const userGlobal = loadConfigAt(filePaths.userGlobal);\n\n    return mergeConfigs(builtin, userGlobal, projectConfig, null);\n  }\n\n  loadCustomModels(): ModelCapabilities[] {\n    const filePaths = getConfigFilePaths();\n    const projectConfig = filePaths.project ? loadConfigAt(filePaths.project) : null;\n    const userGlobal = loadConfigAt(filePaths.userGlobal);\n\n    const customModelsArray = [];\n    if (userGlobal?.models && Array.isArray(userGlobal.models)) {\n      customModelsArray.push(...userGlobal.models as ModelCapabilities[]);\n    }\n    if (projectConfig?.models && Array.isArray(projectConfig.models)) {\n      customModelsArray.push(...projectConfig.models as ModelCapabilities[]);\n    }\n\n    return customModelsArray;\n  }\n\n  getAllModels(): ModelCapabilities[] {\n    const customModels = this.loadCustomModels();\n    return [...this.primaryModels, ...this.fallbackModels, ...customModels];\n  }\n\n  createAndSaveExecutionRecord(\n    commandName: string,\n    requirement: CapabilityRequirement,\n    matchResult: CapabilityMatchResult,\n    command?: string\n  ): string {\n    const config = this.loadMergedConfig();\n    const record = createExecutionRecord(\n      commandName,\n      requirement,\n      config,\n      matchResult,\n      { success: matchResult.selected !== null },\n      command\n    );\n\n    const filePath = saveExecutionRecord(record);\n    return record.id;\n  }\n\n  replayExecution(recordId: string, options: ReplayOptions): Promise<ReplayResult> {\n    return replayEngine.replay(recordId, options);\n  }\n\n  explainConfig(): string {\n    const config = this.loadMergedConfig();\n    return dumpConfigSnapshot(config);\n  }\n}\n\nexport const capabilitySystem = new CapabilitySystem();\n",
    "tokens": 798
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/core/configMerge.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport yaml from 'js-yaml';\n\nexport type ConfigSource = 'built-in' | 'user-global' | 'project' | 'command-override';\n\nexport interface ConfigFieldSource<T = unknown> {\n  value: T;\n  source: ConfigSource;\n  filePath?: string;\n}\n\nexport interface MergedConfig {\n  aiProxyUrl: ConfigFieldSource<string>;\n  defaultModel: ConfigFieldSource<string>;\n  accountType: ConfigFieldSource<'free' | 'pro'>;\n  [key: string]: ConfigFieldSource<unknown>;\n}\n\nexport function loadConfigAt(filePath: string): Record<string, unknown> | null {\n  if (!fs.existsSync(filePath)) {\n    return null;\n  }\n\n  try {\n    const content = fs.readFileSync(filePath, 'utf8');\n    if (filePath.endsWith('.yaml') || filePath.endsWith('.yml')) {\n      return yaml.load(content) as Record<string, unknown>;\n    }\n    return JSON.parse(content);\n  } catch (error) {\n    console.warn(`Failed to load config from ${filePath}:`, error);\n    return null;\n  }\n}\n\nexport function mergeConfigs(\n  builtin: Record<string, unknown>,\n  userGlobal: Record<string, unknown> | null,\n  project: Record<string, unknown> | null,\n  commandOverride: Record<string, unknown> | null\n): MergedConfig {\n  const merged: MergedConfig = {} as MergedConfig;\n\n  const addField = (key: string, value: unknown, source: ConfigSource, filePath?: string) => {\n    merged[key] = { value, source, filePath };\n  };\n\n  Object.entries(builtin).forEach(([key, value]) => {\n    addField(key, value, 'built-in');\n  });\n\n  if (userGlobal) {\n    Object.entries(userGlobal).forEach(([key, value]) => {\n      addField(key, value, 'user-global', path.join(os.homedir(), '.yuangs.json'));\n    });\n  }\n\n  if (project) {\n    Object.entries(project).forEach(([key, value]) => {\n      addField(key, value, 'project');\n    });\n  }\n\n  if (commandOverride) {\n    Object.entries(commandOverride).forEach(([key, value]) => {\n      addField(key, value, 'command-override');\n    });\n  }\n\n  return merged;\n}\n\nexport function dumpConfigSnapshot(config: MergedConfig): string {\n  const output: Record<string, any> = {};\n\n  Object.entries(config).forEach(([key, field]) => {\n    output[key] = {\n      value: field.value,\n      source: field.source,\n      filePath: field.filePath,\n    };\n  });\n\n  return JSON.stringify(output, null, 2);\n}\n\nfunction findProjectConfig(cwd = process.cwd()): string | null {\n  let dir = cwd;\n  const configFiles = ['.yuangs.json', '.yuangs.yaml', '.yuangs.yml', 'yuangs.config.json'];\n\n  while (dir && dir !== path.dirname(dir)) {\n    for (const filename of configFiles) {\n      const candidate = path.join(dir, filename);\n      if (fs.existsSync(candidate)) {\n        return candidate;\n      }\n    }\n    dir = path.dirname(dir);\n  }\n\n  const root = path.parse(cwd).root;\n  for (const filename of configFiles) {\n    const rootCandidate = path.join(root, filename);\n    if (fs.existsSync(rootCandidate)) {\n      return rootCandidate;\n    }\n  }\n\n  return null;\n}\n\nexport function getConfigFilePaths(): {\n  userGlobal: string;\n  project: string | null;\n} {\n  return {\n    userGlobal: path.join(os.homedir(), '.yuangs.json'),\n    project: findProjectConfig(),\n  };\n}\n",
    "tokens": 790
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/core/os.ts",
    "content": "export type OSProfile = {\n    name: string;\n    shell: string;\n    find: 'bsd' | 'gnu';\n    stat: 'bsd' | 'gnu';\n};\n\nexport function getOSProfile(): OSProfile {\n    switch (process.platform) {\n        case 'darwin':\n            return {\n                name: 'macOS',\n                shell: 'zsh',\n                find: 'bsd',\n                stat: 'bsd',\n            };\n        case 'linux':\n            return {\n                name: 'Linux',\n                shell: 'bash',\n                find: 'gnu',\n                stat: 'gnu',\n            };\n        case 'win32':\n            return {\n                name: 'Windows',\n                shell: 'cmd',\n                find: 'gnu', // Win32 find is different, but for AI context let's assume GNU style tools if they are there, or just label it.\n                stat: 'gnu',\n            };\n        default:\n            return {\n                name: process.platform,\n                shell: 'sh',\n                find: 'gnu',\n                stat: 'gnu',\n            };\n    }\n}\n",
    "tokens": 258
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/core/executionStore.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { ExecutionRecord, serializeExecutionRecord, deserializeExecutionRecord } from './executionRecord';\n\nconst RECORD_DIR = path.join(os.homedir(), '.yuangs', 'executions');\n\nexport function ensureRecordDir(): void {\n  if (!fs.existsSync(RECORD_DIR)) {\n    fs.mkdirSync(RECORD_DIR, { recursive: true });\n  }\n}\n\nexport function saveExecutionRecord(record: ExecutionRecord): string {\n  ensureRecordDir();\n\n  const filename = `${record.id}.json`;\n  const filepath = path.join(RECORD_DIR, filename);\n\n  fs.writeFileSync(filepath, serializeExecutionRecord(record), 'utf8');\n\n  return filepath;\n}\n\nexport function loadExecutionRecord(id: string): ExecutionRecord | null {\n  ensureRecordDir();\n\n  const filename = `${id}.json`;\n  const filepath = path.join(RECORD_DIR, filename);\n\n  if (!fs.existsSync(filepath)) {\n    return null;\n  }\n\n  try {\n    const content = fs.readFileSync(filepath, 'utf8');\n    return deserializeExecutionRecord(content);\n  } catch (error) {\n    console.error(`Failed to load execution record ${id}:`, error);\n    return null;\n  }\n}\n\nexport function listExecutionRecords(limit: number = 50): ExecutionRecord[] {\n  ensureRecordDir();\n\n  const files = fs.readdirSync(RECORD_DIR)\n    .filter(f => f.endsWith('.json'))\n    .sort((a, b) => {\n      const statA = fs.statSync(path.join(RECORD_DIR, a));\n      const statB = fs.statSync(path.join(RECORD_DIR, b));\n      return statB.mtimeMs - statA.mtimeMs;\n    })\n    .slice(0, limit);\n\n  const records: ExecutionRecord[] = [];\n\n  for (const file of files) {\n    const record = loadExecutionRecord(file.replace('.json', ''));\n    if (record) {\n      records.push(record);\n    }\n  }\n\n  return records;\n}\n\nexport function deleteExecutionRecord(id: string): boolean {\n  ensureRecordDir();\n\n  const filename = `${id}.json`;\n  const filepath = path.join(RECORD_DIR, filename);\n\n  if (!fs.existsSync(filepath)) {\n    return false;\n  }\n\n  try {\n    fs.unlinkSync(filepath);\n    return true;\n  } catch (error) {\n    console.error(`Failed to delete execution record ${id}:`, error);\n    return false;\n  }\n}\n\nexport function clearAllExecutionRecords(): void {\n  ensureRecordDir();\n\n  const files = fs.readdirSync(RECORD_DIR).filter(f => f.endsWith('.json'));\n\n  for (const file of files) {\n    const filepath = path.join(RECORD_DIR, file);\n    try {\n      fs.unlinkSync(filepath);\n    } catch (error) {\n      console.error(`Failed to delete ${filepath}:`, error);\n    }\n  }\n}\n",
    "tokens": 625
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/utils/history.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { parseCommandHistory, type HistoryEntry } from '../core/validation';\n\nconst HISTORY_FILE = path.join(os.homedir(), '.yuangs_cmd_history.json');\n\nexport type { HistoryEntry };\n\nexport function getCommandHistory(): HistoryEntry[] {\n    if (fs.existsSync(HISTORY_FILE)) {\n        try {\n            return parseCommandHistory(fs.readFileSync(HISTORY_FILE, 'utf8'));\n        } catch (e) { }\n    }\n    return [];\n}\n\nexport function saveHistory(entry: { question: string; command: string }) {\n    let history = getCommandHistory();\n    const newEntry: HistoryEntry = {\n        ...entry,\n        time: new Date().toLocaleString()\n    };\n    // Keep last 1000, unique commands\n    history = [newEntry, ...history.filter(item => item.command !== entry.command)].slice(0, 1000);\n    fs.writeFileSync(HISTORY_FILE, JSON.stringify(history, null, 2));\n}\n",
    "tokens": 229
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/utils/confirm.ts",
    "content": "import * as readline from 'node:readline/promises';\nimport chalk from 'chalk';\n\nexport async function confirm(message: string): Promise<boolean> {\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout,\n    });\n\n    try {\n        const answer = await rl.question(chalk.yellow(`\\nâš ï¸  ${message} (y/N) `));\n        return answer.toLowerCase() === 'y';\n    } finally {\n        rl.close();\n    }\n}\n\n",
    "tokens": 111
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/utils/renderer.ts",
    "content": "import chalk from 'chalk';\nimport { marked } from 'marked';\nimport TerminalRenderer from 'marked-terminal';\nimport ora, { Ora } from 'ora';\n\n// åˆå§‹åŒ– marked é…ç½®\nmarked.setOptions({\n    renderer: new TerminalRenderer({\n        tab: 2,\n        width: process.stdout.columns || 80,\n        showSectionPrefix: false\n    }) as any\n});\n\nexport class StreamMarkdownRenderer {\n    private fullResponse: string = '';\n    private prefix: string;\n    private isFirstOutput: boolean = true;\n    private spinner: Ora | null = null;\n    private startTime: number;\n\n    constructor(prefix: string = chalk.bold.blue('ğŸ¤– AIï¼š'), spinner?: Ora) {\n        this.prefix = prefix;\n        this.spinner = spinner || null;\n        this.startTime = Date.now();\n    }\n\n    /**\n     * å¤„ç†æµå¼æ•°æ®å—\n     */\n    public onChunk(chunk: string) {\n        if (this.spinner && this.spinner.isSpinning) {\n            this.spinner.stop();\n        }\n\n        if (this.isFirstOutput) {\n            process.stdout.write(this.prefix);\n            this.isFirstOutput = false;\n        }\n\n        this.fullResponse += chunk;\n        process.stdout.write(chunk);\n    }\n\n    /**\n     * æµç»“æŸï¼Œæ‰§è¡Œå›æ»šå¹¶æ¸²æŸ“ Markdown\n     */\n    public finish(): string {\n        // å¦‚æœ Spinner è¿˜åœ¨è½¬ï¼ˆè¯´æ˜æ²¡æœ‰ä»»ä½•è¾“å‡ºï¼‰ï¼Œå…ˆåœæ‰\n        if (this.spinner && this.spinner.isSpinning) {\n            this.spinner.stop();\n        }\n\n        const formatted = (marked.parse(this.fullResponse, { async: false }) as string).trim();\n\n        if (process.stdout.isTTY && this.fullResponse.trim()) {\n            const screenWidth = process.stdout.columns || 80;\n            const totalContent = this.prefix + this.fullResponse;\n\n            // è®¡ç®—åŸå§‹æ–‡æœ¬å ç”¨çš„å¯è§†è¡Œæ•°\n            const lineCount = this.getVisualLineCount(totalContent, screenWidth);\n\n            // 1. æ¸…é™¤å½“å‰è¡Œå‰©ä½™å†…å®¹\n            process.stdout.write('\\r\\x1b[K');\n            // 2. å‘ä¸Šå›æ»šå¹¶æ¸…é™¤ä¹‹å‰çš„è¡Œ\n            for (let i = 0; i < lineCount - 1; i++) {\n                process.stdout.write('\\x1b[A\\x1b[K');\n            }\n\n            // 3. è¾“å‡ºæ ¼å¼åŒ–åçš„ Markdown\n            process.stdout.write(this.prefix + formatted + '\\n');\n        } else {\n            // é TTY æ¨¡å¼æˆ–æ— å†…å®¹ï¼Œç›´æ¥è¡¥å……æ¢è¡Œï¼ˆå¦‚æœä¹‹å‰è¾“å‡ºäº†å†…å®¹ï¼‰\n            if (this.fullResponse.trim()) {\n                process.stdout.write('\\n');\n            }\n        }\n\n        // è¾“å‡ºè€—æ—¶ç»Ÿè®¡\n        const elapsed = (Date.now() - this.startTime) / 1000;\n        process.stdout.write('\\n' + chalk.gray(`â”€`.repeat(20) + ` (è€—æ—¶: ${elapsed.toFixed(2)}s) ` + `â”€`.repeat(20) + '\\n\\n'));\n\n        return this.fullResponse;\n    }\n\n    /**\n     * è®¡ç®—æ–‡æœ¬åœ¨ç»ˆç«¯çš„å¯è§†è¡Œæ•°\n     */\n    private getVisualLineCount(text: string, screenWidth: number): number {\n        const stripAnsi = (str: string) => str.replace(/[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');\n\n        const lines = text.split('\\n');\n        let totalLines = 0;\n\n        for (const line of lines) {\n            // Expand tabs\n            const expandedLine = line.replace(/\\t/g, '        ');\n            const cleanLine = stripAnsi(expandedLine);\n\n            let lineWidth = 0;\n            for (const char of cleanLine) {\n                const code = char.codePointAt(0) || 0;\n                // å¤§éƒ¨åˆ†å®½å­—ç¬¦ï¼ˆå¦‚ä¸­æ–‡ï¼‰å  2 æ ¼\n                lineWidth += code > 255 ? 2 : 1;\n            }\n\n            if (lineWidth === 0) {\n                totalLines += 1;\n            } else {\n                totalLines += Math.ceil(lineWidth / screenWidth);\n            }\n        }\n\n        return totalLines;\n    }\n}\n",
    "tokens": 859
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/utils/syntaxHandler.ts",
    "content": "import fs from 'fs';\nimport chalk from 'chalk';\nimport path from 'path';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport { buildPromptWithFileContent, readFilesContent } from '../core/fileReader';\nimport { ContextBuffer } from '../agent/contextBuffer';\nimport { loadContext, saveContext } from '../agent/contextStorage';\n\nconst execAsync = promisify(exec);\n\n/**\n * è§£æå¹¶å¤„ç†ç‰¹æ®Šè¯­æ³•ï¼ˆ@ã€#ã€:ls ç­‰ï¼‰\n */\nexport async function handleSpecialSyntax(input: string, stdinData?: string): Promise<{ processed: boolean; result?: string }> {\n    const trimmed = input.trim();\n\n    // å¤„ç† @ æ–‡ä»¶å¼•ç”¨è¯­æ³•\n    if (trimmed.startsWith('@')) {\n        // æ£€æŸ¥æ˜¯å¦æ˜¯ @! ç«‹å³æ‰§è¡Œè¯­æ³•\n        const immediateExecMatch = trimmed.match(/^@\\s*!\\s*(.+?)$/);\n        if (immediateExecMatch) {\n            const filePath = immediateExecMatch[1].trim();\n            return await handleImmediateExec(filePath);\n        }\n\n        // æ£€æŸ¥æ˜¯å¦æ˜¯å¸¦è¡Œå·çš„è¯­æ³• @file:start-end\n        const lineRangeMatch = trimmed.match(/^@\\s*(.+?)(?::(\\d+)(?:-(\\d+))?)?\\s*(?:\\n(.*))?$/s);\n        if (lineRangeMatch) {\n            const filePath = lineRangeMatch[1];\n            const startLine = lineRangeMatch[2] ? parseInt(lineRangeMatch[2]) : null;\n            const endLine = lineRangeMatch[3] ? parseInt(lineRangeMatch[3]) : null;\n            const question = lineRangeMatch[4] || (stdinData ? `åˆ†æä»¥ä¸‹æ–‡ä»¶å†…å®¹ï¼š\\n\\n${stdinData}` : 'è¯·åˆ†æè¿™ä¸ªæ–‡ä»¶');\n\n            return await handleFileReference(filePath.trim(), startLine, endLine, question);\n        }\n    }\n\n    // å¤„ç† # ç›®å½•å¼•ç”¨è¯­æ³•\n    if (trimmed.startsWith('#')) {\n        const dirMatch = trimmed.match(/^#\\s*(.+?)\\s*(?:\\n(.*))?$/s);\n        if (dirMatch) {\n            const dirPath = dirMatch[1].trim();\n            const question = dirMatch[2] || (stdinData ? `åˆ†æä»¥ä¸‹ç›®å½•å†…å®¹ï¼š\\n\\n${stdinData}` : 'è¯·åˆ†æè¿™ä¸ªç›®å½•');\n            return await handleDirectoryReference(dirPath, question);\n        }\n    }\n\n    // å¤„ç† :ls å‘½ä»¤\n    if (trimmed === ':ls') {\n        return await handleListContext();\n    }\n\n    // åœºæ™¯ 5.1: :exec åŸå­æ‰§è¡Œ\n    if (trimmed.startsWith(':exec ')) {\n        const command = trimmed.slice(6).trim();\n        return await handleAtomicExec(command);\n    }\n\n    // å¤„ç† :cat [index] å‘½ä»¤\n    if (trimmed === ':cat' || trimmed.startsWith(':cat ')) {\n        const parts = trimmed.split(' ');\n        const index = parts.length > 1 ? parseInt(parts[1]) : null;\n        return await handleCatContext(index);\n    }\n\n    // å¤„ç† :clear å‘½ä»¤\n    if (trimmed === ':clear') {\n        return await handleClearContext();\n    }\n\n    // å¦‚æœä¸æ˜¯ç‰¹æ®Šè¯­æ³•ï¼Œè¿”å›æœªå¤„ç†\n    return { processed: false };\n}\n\nasync function handleFileReference(filePath: string, startLine: number | null = null, endLine: number | null = null, question?: string): Promise<{ processed: boolean; result: string }> {\n    const fullPath = path.resolve(filePath);\n\n    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isFile()) {\n        return {\n            processed: true,\n            result: `é”™è¯¯: æ–‡ä»¶ \"${filePath}\" ä¸å­˜åœ¨æˆ–ä¸æ˜¯ä¸€ä¸ªæ–‡ä»¶`\n        };\n    }\n\n    try {\n        let content = fs.readFileSync(fullPath, 'utf-8');\n\n        // å¦‚æœæŒ‡å®šäº†è¡Œå·èŒƒå›´ï¼Œåˆ™æå–ç›¸åº”è¡Œ\n        if (startLine !== null) {\n            const lines = content.split('\\n');\n\n            // éªŒè¯è¡Œå·èŒƒå›´\n            if (startLine < 1 || startLine > lines.length) {\n                return {\n                    processed: true,\n                    result: `é”™è¯¯: èµ·å§‹è¡Œå· ${startLine} è¶…å‡ºæ–‡ä»¶èŒƒå›´ (æ–‡ä»¶å…±æœ‰ ${lines.length} è¡Œ)`\n                };\n            }\n\n            const startIdx = startLine - 1; // è½¬æ¢ä¸ºæ•°ç»„ç´¢å¼•ï¼ˆä»0å¼€å§‹ï¼‰\n            let endIdx = endLine ? Math.min(endLine, lines.length) : lines.length; // å¦‚æœæœªæŒ‡å®šç»“æŸè¡Œï¼Œåˆ™åˆ°æ–‡ä»¶æœ«å°¾\n\n            if (endLine && (endLine < startLine || endLine > lines.length)) {\n                return {\n                    processed: true,\n                    result: `é”™è¯¯: ç»“æŸè¡Œå· ${endLine} è¶…å‡ºæœ‰æ•ˆèŒƒå›´ (åº”åœ¨ ${startLine}-${lines.length} ä¹‹é—´)`\n                };\n            }\n\n            // æå–æŒ‡å®šèŒƒå›´çš„è¡Œ\n            content = lines.slice(startIdx, endIdx).join('\\n');\n        }\n\n        const contentMap = new Map<string, string>();\n        contentMap.set(filePath, content);\n\n        // æŒä¹…åŒ–åˆ°ä¸Šä¸‹æ–‡\n        const contextBuffer = new ContextBuffer();\n        const persisted = await loadContext();\n        contextBuffer.import(persisted);\n\n        contextBuffer.add({\n            type: 'file',\n            path: filePath + (startLine !== null ? `:${startLine}${endLine ? `-${endLine}` : ''}` : ''),\n            content: content\n        });\n\n        await saveContext(contextBuffer.export());\n\n        const prompt = buildPromptWithFileContent(\n            `æ–‡ä»¶: ${filePath}${startLine !== null ? `:${startLine}${endLine ? `-${endLine}` : ''}` : ''}`,\n            [filePath],\n            contentMap,\n            question || `è¯·åˆ†ææ–‡ä»¶: ${filePath}`\n        );\n\n        return { processed: true, result: prompt };\n    } catch (error) {\n        return {\n            processed: true,\n            result: `è¯»å–æ–‡ä»¶å¤±è´¥: ${error}`\n        };\n    }\n}\n\nasync function handleDirectoryReference(dirPath: string, question?: string): Promise<{ processed: boolean; result: string }> {\n    const fullPath = path.resolve(dirPath);\n\n    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isDirectory()) {\n        return {\n            processed: true,\n            result: `é”™è¯¯: ç›®å½• \"${dirPath}\" ä¸å­˜åœ¨æˆ–ä¸æ˜¯ä¸€ä¸ªç›®å½•`\n        };\n    }\n\n    try {\n        const findCommand = process.platform === 'darwin' || process.platform === 'linux'\n            ? `find \"${fullPath}\" -type f`\n            : `dir /s /b \"${fullPath}\"`;\n\n        const { stdout } = await execAsync(findCommand);\n        const filePaths = stdout.trim().split('\\n').filter(f => f);\n\n        if (filePaths.length === 0) {\n            return {\n                processed: true,\n                result: `ç›®å½• \"${dirPath}\" ä¸‹æ²¡æœ‰æ–‡ä»¶`\n            };\n        }\n\n        const contentMap = readFilesContent(filePaths);\n\n        // æŒä¹…åŒ–åˆ°ä¸Šä¸‹æ–‡\n        const contextBuffer = new ContextBuffer();\n        const persisted = await loadContext();\n        contextBuffer.import(persisted);\n\n        contextBuffer.add({\n            type: 'directory',\n            path: dirPath,\n            content: Array.from(contentMap.entries()).map(([p, c]) => `--- ${p} ---\\n${c}`).join('\\n\\n')\n        });\n\n        await saveContext(contextBuffer.export());\n\n        const prompt = buildPromptWithFileContent(\n            `ç›®å½•: ${dirPath}\\næ‰¾åˆ° ${filePaths.length} ä¸ªæ–‡ä»¶`,\n            filePaths.map(p => path.relative(process.cwd(), p)),\n            contentMap,\n            question\n        );\n\n        return { processed: true, result: prompt };\n    } catch (error) {\n        return {\n            processed: true,\n            result: `è¯»å–ç›®å½•å¤±è´¥: ${error}`\n        };\n    }\n}\n\nasync function handleImmediateExec(filePath: string): Promise<{ processed: boolean; result: string }> {\n    const fullPath = path.resolve(filePath);\n\n    if (!fs.existsSync(fullPath)) {\n        return {\n            processed: true,\n            result: `é”™è¯¯: æ–‡ä»¶ \"${filePath}\" ä¸å­˜åœ¨`\n        };\n    }\n\n    try {\n        // 1. è¯»å–è„šæœ¬å†…å®¹\n        const content = fs.readFileSync(fullPath, 'utf-8');\n\n        console.log(chalk.gray(`æ­£åœ¨æ‰§è¡Œ ${filePath} å¹¶æ•è·è¾“å‡º...`));\n\n        // 2. æ‰§è¡Œè„šæœ¬\n        // æ³¨æ„ï¼šè¿™é‡Œä½¿ç”¨ execAsync æ•è·è¾“å‡º\n        const { stdout, stderr } = await execAsync(`chmod +x \"${fullPath}\" && \"${fullPath}\"`, { cwd: process.cwd() });\n\n        // 3. æ„é€ ç»„åˆä¸Šä¸‹æ–‡ (å¥‘çº¦è¦æ±‚ï¼šå‘½ä»¤å†…å®¹ + å®é™…è¾“å‡º)\n        const combinedContext = `\n=== è„šæœ¬å†…å®¹ (${filePath}) ===\n\\`\\`\\`bash\n${content}\n\\`\\`\\`\n\n=== æ‰§è¡Œæ ‡å‡†è¾“å‡º (stdout) ===\n\\`\\`\\`\n${stdout}\n\\`\\`\\`\n\n=== æ‰§è¡Œæ ‡å‡†é”™è¯¯ (stderr) ===\n\\`\\`\\`\n${stderr}\n\\`\\`\\`\n`;\n\n        // æŒä¹…åŒ–åˆ°ä¸Šä¸‹æ–‡\n        const contextBuffer = new ContextBuffer();\n        const persisted = await loadContext();\n        contextBuffer.import(persisted);\n\n        contextBuffer.add({\n            type: 'file',\n            path: `${filePath} (Runtime Log)`,\n            content: combinedContext,\n            summary: 'åŒ…å«è„šæœ¬æºç å’Œæ‰§è¡Œåçš„è¾“å‡ºæ—¥å¿—'\n        });\n\n        await saveContext(contextBuffer.export());\n\n        // è¿”å›ç»™ AI çš„ Prompt\n        const result = `æˆ‘æ‰§è¡Œäº†è„šæœ¬ ${filePath}ã€‚\\nä»¥ä¸‹æ˜¯è„šæœ¬æºç å’Œæ‰§è¡Œè¾“å‡ºï¼š\\n${combinedContext}\\n\\nè¯·åˆ†æä¸ºä½•ä¼šå‡ºç°ä¸Šè¿°è¾“å‡ºï¼ˆç‰¹åˆ«æ˜¯é”™è¯¯ä¿¡æ¯ï¼‰ï¼Ÿ`;\n        return { processed: true, result };\n    } catch (error: any) {\n        const errorMsg = error.message || String(error);\n        const result = `æ‰§è¡Œè„šæœ¬ ${filePath} æ—¶å‘ç”Ÿé”™è¯¯ï¼š\\n${errorMsg}\\n\\nè¯·åˆ†æåŸå› ã€‚`;\n        return { processed: true, result };\n    }\n}\n\nasync function handleAtomicExec(command: string): Promise<{ processed: boolean; result: string }> {\n    console.log(chalk.cyan(`\\nâš¡ï¸ [Atomic Exec] æ‰§è¡Œå‘½ä»¤: ${command}\\n`));\n\n    try {\n        // å¯¹äºåŸå­æ‰§è¡Œï¼Œæˆ‘ä»¬å¸Œæœ›ç”¨æˆ·èƒ½å®æ—¶çœ‹åˆ°è¾“å‡ºï¼Œæ‰€ä»¥ç”¨ inherit\n        const { spawn } = require('child_process');\n        const child = spawn(command, {\n            shell: true,\n            stdio: 'inherit'\n        });\n\n        await new Promise<void>((resolve, reject) => {\n            child.on('close', (code: number) => {\n                if (code === 0) resolve();\n                else reject(new Error(`Exit code ${code}`));\n            });\n            child.on('error', reject);\n        });\n\n        // åŸå­æ‰§è¡Œä¸å°†ç»“æœä¼ ç»™ AIï¼Œç›´æ¥è¿”å›ç©ºç»“æœè¡¨ç¤ºå¤„ç†å®Œæˆ\n        return { processed: true, result: '' };\n    } catch (error) {\n        console.error(chalk.red(`æ‰§è¡Œå¤±è´¥: ${error}`));\n        return { processed: true, result: '' };\n    }\n}\n\nasync function handleListContext(): Promise<{ processed: boolean; result: string }> {\n    try {\n        const persisted = await loadContext();\n        const contextBuffer = new ContextBuffer();\n        contextBuffer.import(persisted);\n\n        if (contextBuffer.isEmpty()) {\n            return { processed: true, result: 'å½“å‰æ²¡æœ‰ä¸Šä¸‹æ–‡' };\n        }\n\n        const list = contextBuffer.list();\n        let result = 'å½“å‰ä¸Šä¸‹æ–‡åˆ—è¡¨ï¼š\\n';\n        list.forEach((item, index) => {\n            result += `${index + 1}. ${item.type}: ${item.path} (${item.tokens} tokens)\\n`;\n        });\n\n        return { processed: true, result };\n    } catch (error) {\n        return {\n            processed: true,\n            result: `è¯»å–ä¸Šä¸‹æ–‡å¤±è´¥: ${error}`\n        };\n    }\n}\n\nasync function handleCatContext(index: number | null): Promise<{ processed: boolean; result: string }> {\n    try {\n        const persisted = await loadContext();\n        const contextBuffer = new ContextBuffer();\n        contextBuffer.import(persisted);\n\n        if (contextBuffer.isEmpty()) {\n            return { processed: true, result: 'å½“å‰æ²¡æœ‰ä¸Šä¸‹æ–‡' };\n        }\n\n        const items = contextBuffer.export();\n\n        if (index !== null) {\n            // æŸ¥çœ‹æŒ‡å®šç´¢å¼•\n            if (index < 1 || index > items.length) {\n                return { processed: true, result: `é”™è¯¯: ç´¢å¼• ${index} è¶…å‡ºèŒƒå›´ (å…±æœ‰ ${items.length} ä¸ªé¡¹ç›®)` };\n            }\n            const item = items[index - 1];\n            return {\n                processed: true,\n                result: `--- [${index}] ${item.type}: ${item.path} ---\\n${item.content}\\n--- End ---`\n            };\n        } else {\n            // æŸ¥çœ‹å…¨éƒ¨\n            let result = '=== å½“å‰å®Œæ•´ä¸Šä¸‹æ–‡å†…å®¹ ===\\n\\n';\n            items.forEach((item, i) => {\n                result += `--- [${i + 1}] ${item.type}: ${item.path} ---\\n${item.content}\\n\\n`;\n            });\n            result += '==========================';\n            return { processed: true, result };\n        }\n    } catch (error) {\n        return {\n            processed: true,\n            result: `è¯»å–ä¸Šä¸‹æ–‡å¤±è´¥: ${error}`\n        };\n    }\n}\n\nasync function handleClearContext(): Promise<{ processed: boolean; result: string }> {\n    try {\n        // æ¸…é™¤æŒä¹…åŒ–å­˜å‚¨\n        await saveContext([]);\n\n        return { processed: true, result: 'ä¸Šä¸‹æ–‡å·²æ¸…ç©ºï¼ˆå«æŒä¹…åŒ–ï¼‰' };\n    } catch (error) {\n        return {\n            processed: true,\n            result: `æ¸…é™¤ä¸Šä¸‹æ–‡å¤±è´¥: ${error}`\n        };\n    }\n}\n",
    "tokens": 2887
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/governance.ts",
    "content": "import { ProposedAction, GovernanceDecision } from './state';\nimport { evaluateProposal, PolicyRule, RiskEntry } from './governance/core';\nimport { RiskLedger } from './governance/ledger';\nimport { WasmGovernanceBridge } from './governance/bridge';\nimport jsyaml from 'js-yaml';\nimport fs from 'fs';\nimport path from 'path';\n\nexport class GovernanceService {\n  private static rules: PolicyRule[] = [];\n  private static ledger = new RiskLedger();\n  private static initialized = false;\n\n  static async init(basePath?: string) {\n    if (this.initialized) return;\n    this.loadPolicy(basePath);\n    await WasmGovernanceBridge.init(basePath);\n    this.initialized = true;\n  }\n\n  private static loadPolicy(basePath?: string) {\n    try {\n      const root = basePath || process.cwd();\n      const policyPath = path.join(root, 'policy.yaml');\n      if (fs.existsSync(policyPath)) {\n        const content = fs.readFileSync(policyPath, 'utf8');\n        const config = jsyaml.load(content) as any;\n        this.rules = config.rules || [];\n      }\n    } catch (e) {\n      this.rules = [];\n    }\n  }\n\n  static getRules(): PolicyRule[] {\n    return this.rules;\n  }\n\n  static getLedgerSnapshot(): RiskEntry[] {\n    return this.ledger.getSnapshot();\n  }\n\n  static getPolicyManual(): string {\n    return this.rules.map(r => `- ${r.id}: ${r.reason} (${r.effect})`).join('\\n');\n  }\n\n  static async adjudicate(action: ProposedAction): Promise<GovernanceDecision> {\n    await this.init();\n\n    // 1. WASM ç‰©ç†å±‚æ ¸éªŒ\n    const wasmResult = WasmGovernanceBridge.evaluate(action, this.rules, this.ledger.getSnapshot());\n    if (wasmResult.effect === 'deny') {\n      return { status: 'rejected', by: 'policy', reason: wasmResult.reason || 'WASM Denied', timestamp: Date.now() };\n    }\n\n    // 2. é€»è¾‘å±‚æ ¸éªŒ\n    const logicResult = evaluateProposal(action, this.rules, this.ledger.getSnapshot());\n    if (logicResult.effect === 'deny') {\n      return { status: 'rejected', by: 'policy', reason: logicResult.reason || 'Policy Denied', timestamp: Date.now() };\n    }\n\n    if (logicResult.effect === 'allow') {\n      this.ledger.record(action.type);\n      return { status: 'approved', by: 'policy', timestamp: Date.now() };\n    }\n\n    // 3. äººå·¥å¹²é¢„å…œåº• (æ¨¡æ‹Ÿ)\n    return { status: 'approved', by: 'human', timestamp: Date.now() };\n  }\n}\n",
    "tokens": 573
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/state.ts",
    "content": "import { randomUUID } from 'crypto';\n\nexport type AgentState = \n  | 'IDLE' \n  | 'THINKING' \n  | 'PROPOSING' \n  | 'GOVERNING' \n  | 'EXECUTING' \n  | 'OBSERVING' \n  | 'EVALUATING' \n  | 'TERMINAL';\n\nexport type RiskLevel = 'low' | 'medium' | 'high';\n\nexport interface ProposedAction {\n  id: string;\n  type: 'tool_call' | 'code_diff' | 'shell_cmd' | 'answer';\n  payload: any;\n  riskLevel: RiskLevel;\n  reasoning: string;\n}\n\nexport type GovernanceDecision = \n  | { status: 'approved'; by: 'policy' | 'human'; timestamp: number }\n  | { status: 'rejected'; by: 'policy' | 'human'; reason: string; timestamp: number }\n  | { \n      status: 'modified'; \n      by: 'human'; \n      originalActionId: string;\n      modifiedAction: ProposedAction;\n      modificationReason: string;\n      timestamp: number;\n    };\n\nexport type EvaluationOutcome = \n  | { kind: 'continue'; reason: 'incomplete' | 'failure_retry' }\n  | { kind: 'terminate'; reason: 'goal_satisfied' | 'user_abort' | 'max_turns_exceeded' }\n  | { kind: 'pause'; reason: 'await_human_input' };\n\nexport interface AgentThought {\n  raw: string;\n  parsedPlan: any;\n  isDone: boolean;\n  type?: 'tool_call' | 'code_diff' | 'shell_cmd' | 'answer';\n  payload?: any;\n  reasoning?: string;\n}\n\nimport { ContextDiff } from './contextDiff';\n\nexport interface ExecutionTurn {\n  turnId: number;\n  startTime: number;\n  endTime?: number;\n  contextSnapshot: {\n    inputHash: string;\n    systemPromptVersion: string;\n    toolSetVersion: string;\n    recentMessages: Array<{ role: string; content: string; timestamp: number }>;\n  };\n  contextDiff?: ContextDiff;\n  thought?: AgentThought;\n  proposedAction?: ProposedAction;\n  governance?: GovernanceDecision;\n  executionResult?: {\n    success: boolean;\n    output: string;\n    error?: string;\n    artifacts?: string[];\n  };\n  observation?: {\n    summary: string;\n    artifacts: string[];\n    truncated?: boolean;\n  };\n  evaluation?: EvaluationOutcome;\n}\n\nexport interface GovernanceLoopConfig {\n  maxTurns: number;\n  autoApproveLowRisk: boolean;\n  verbose: boolean;\n}\n\nexport interface ToolExecutionResult {\n  success: boolean;\n  output: string;\n  error?: string;\n  artifacts?: string[];\n}\n\nexport interface GovernanceContext {\n  input: string;\n  mode: 'chat' | 'command' | 'command+exec';\n  history: AIRequestMessage[];\n  files?: Array<{ path: string; content: string }>;\n}\n\ninterface AIRequestMessage {\n  role: 'user' | 'assistant' | 'system' | 'tool';\n  content: string;\n}\n",
    "tokens": 613
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/executor.ts",
    "content": "import { ProposedAction, ToolExecutionResult } from './state';\nimport { VSCodeExecutor } from '../../runtime/vscode/VSCodeExecutor';\n\n/**\n * VS Code é€‚é…ç‰ˆçš„ ToolExecutor\n * å°†æ‰€æœ‰æ‰§è¡Œé€»è¾‘é‡å®šå‘åˆ° VS Code API\n */\nexport class ToolExecutor {\n  static async execute(action: ProposedAction): Promise<ToolExecutionResult> {\n    const { type, payload } = action;\n\n    try {\n      switch (type) {\n        case 'tool_call':\n          return await this.executeTool(payload);\n\n        case 'shell_cmd':\n          const shellResult = await VSCodeExecutor.runCommand(payload.command);\n          return { success: true, output: shellResult };\n\n        case 'code_diff':\n          const diffResult = await VSCodeExecutor.applyDiff(payload.diff);\n          return { success: true, output: diffResult };\n\n        case 'answer':\n          return {\n            success: true,\n            output: payload.content || payload.text || '',\n            artifacts: []\n          };\n\n        default:\n          return {\n            success: false,\n            error: `Unknown action type: ${type}`,\n            output: ''\n          };\n      }\n    } catch (error: any) {\n      return {\n        success: false,\n        error: error.message || String(error),\n        output: ''\n      };\n    }\n  }\n\n  private static async executeTool(payload: any): Promise<ToolExecutionResult> {\n    const toolName = payload.tool_name;\n    const params = payload.parameters || {};\n\n    switch (toolName) {\n      case 'read_file':\n        try {\n          const content = await VSCodeExecutor.readFile(params.path);\n          return { success: true, output: content };\n        } catch (e: any) {\n          return { success: false, error: e.message, output: \"\" };\n        }\n\n      case 'write_file':\n        const writeResult = await VSCodeExecutor.writeFile(params.path, params.content);\n        return { success: true, output: writeResult };\n\n      case 'list_files':\n        try {\n          const fileList = await VSCodeExecutor.listFiles(params.path || '.');\n          return { success: true, output: fileList };\n        } catch (e: any) {\n          return { success: false, error: e.message, output: \"\" };\n        }\n\n      default:\n        return {\n          success: false,\n          error: `Unknown tool: ${toolName}`,\n          output: ''\n        };\n    }\n  }\n}\n",
    "tokens": 577
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextDiff.ts",
    "content": "import { ContextItem } from './contextBuffer';\n\nexport interface ContextSnapshot {\n  items: Array<{\n    path: string;\n    hash: string; // å†…å®¹å“ˆå¸Œï¼Œç”¨äºæ£€æµ‹å˜åŒ–\n    tokens: number;\n  }>;\n}\n\nexport interface ContextDiff {\n  added: string[];\n  removed: string[];\n  changed: string[];\n}\n\n/**\n * è®¡ç®—ä¸¤ä¸ªä¸Šä¸‹æ–‡å¿«ç…§ä¹‹é—´çš„å·®å¼‚\n * @param prev ä¸Šä¸€ä¸ªå¿«ç…§ï¼Œå¦‚æœä¸ºnullè¡¨ç¤ºé¦–æ¬¡å¿«ç…§\n * @param curr å½“å‰å¿«ç…§\n * @returns ä¸Šä¸‹æ–‡å·®å¼‚å¯¹è±¡\n */\nexport function diffContext(\n  prev: ContextSnapshot | null,\n  curr: ContextSnapshot\n): ContextDiff {\n  if (!prev) {\n    return {\n      added: curr.items.map(i => i.path),\n      removed: [],\n      changed: []\n    };\n  }\n\n  const prevMap = new Map(prev.items.map(i => [i.path, i]));\n  const currMap = new Map(curr.items.map(i => [i.path, i]));\n\n  const added: string[] = [];\n  const removed: string[] = [];\n  const changed: string[] = [];\n\n  for (const [path, item] of currMap) {\n    const old = prevMap.get(path);\n    if (!old) {\n      added.push(path);\n    } else if (old.hash !== item.hash) {\n      changed.push(path);\n    }\n  }\n\n  for (const path of prevMap.keys()) {\n    if (!currMap.has(path)) {\n      removed.push(path);\n    }\n  }\n\n  return { added, removed, changed };\n}\n\nimport { ContextItem } from './contextBuffer';\n\n/**\n * ä»ContextBufferåˆ›å»ºå¿«ç…§\n * @param buffer ContextBufferå®ä¾‹\n * @returns ContextSnapshot\n */\nexport function snapshotFromBuffer(buffer: { items: ContextItem[] }): ContextSnapshot {\n  const items = buffer.items || [];\n  return {\n    items: items.map((item: ContextItem) => ({\n      path: item.path,\n      hash: calculateHash(item.content), // ç®€å•çš„å“ˆå¸Œè®¡ç®—\n      tokens: item.tokens\n    }))\n  };\n}\n\n/**\n * ç®€å•çš„å†…å®¹å“ˆå¸Œè®¡ç®—\n * @param content å†…å®¹å­—ç¬¦ä¸²\n * @returns å“ˆå¸Œå­—ç¬¦ä¸²\n */\nfunction calculateHash(content: string): string {\n  let hash = 0;\n  for (let i = 0; i < content.length; i++) {\n    const char = content.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash |= 0; // è½¬æ¢ä¸º32ä½æ•´æ•°\n  }\n  return hash.toString();\n}",
    "tokens": 477
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/AgentRuntime.ts",
    "content": "import chalk from \"chalk\";\nimport { randomUUID } from \"crypto\";\nimport { LLMAdapter } from \"./llmAdapter\";\nimport { GovernanceService } from \"./governance\";\nimport { ToolExecutor } from \"./executor\";\nimport { ContextManager } from \"./contextManager\";\nimport { evaluateProposal } from \"./governance/core\";\nimport { ProposedAction, ExecutionTurn } from \"./state\";\nimport { ContextBuffer } from \"./contextBuffer\";\nimport { snapshotFromBuffer, diffContext, ContextSnapshot } from \"./contextDiff\";\nimport { ExecutionRecorder } from \"./executionRecorder\";\n\nexport class AgentRuntime {\n  private context: ContextManager;\n  private lastContextSnapshot: ContextSnapshot | null = null;\n  private executionId: string;\n  private executionRecorder: ExecutionRecorder;\n\n  constructor(initialContext: any) {\n    this.context = new ContextManager(initialContext);\n    this.executionRecorder = new ExecutionRecorder();\n    this.executionId = randomUUID();\n  }\n\n  async run(\n    userInput: string,\n    mode: \"chat\" | \"command\" = \"chat\",\n    onChunk?: (chunk: string) => void,\n    model?: string,\n  ) {\n    let turnCount = 0;\n    const maxTurns = 10;\n\n    if (userInput) {\n      this.context.addMessage(\"user\", userInput);\n    }\n\n    while (turnCount < maxTurns) {\n      const currentTurn = ++turnCount;\n      if (currentTurn > 1) {\n        console.log(chalk.blue(`\\n--- Turn ${currentTurn} ---`));\n      }\n\n      const messages = this.context.getMessages().map((msg) => ({\n        role: (msg.role === \"tool\" ? \"system\" : msg.role) as\n          | \"system\"\n          | \"user\"\n          | \"assistant\",\n        content: msg.content,\n      }));\n\n      // === Context Diff ===\n      const currentSnapshot = snapshotFromBuffer(this.context.getContextBuffer());\n      const contextDiff = diffContext(this.lastContextSnapshot, currentSnapshot);\n\n      if (\n        contextDiff.added.length ||\n        contextDiff.removed.length ||\n        contextDiff.changed.length\n      ) {\n        console.log(chalk.cyan('\\n[Context Diff]'));\n        if (contextDiff.added.length)\n          console.log('  + added:', contextDiff.added);\n        if (contextDiff.removed.length)\n          console.log('  - removed:', contextDiff.removed);\n        if (contextDiff.changed.length)\n          console.log('  ~ changed:', contextDiff.changed);\n      }\n\n      this.lastContextSnapshot = currentSnapshot;\n\n      // è®°å½•æ‰§è¡Œå›åˆ\n      const executionTurn: Omit<ExecutionTurn, 'turnId'> = {\n        startTime: Date.now(),\n        contextSnapshot: {\n          inputHash: this.context.getHash(),\n          systemPromptVersion: 'v1.0.0',\n          toolSetVersion: 'v1.0.0',\n          recentMessages: this.context.getRecentMessages(5)\n        },\n        contextDiff: contextDiff.added.length || contextDiff.removed.length || contextDiff.changed.length\n          ? contextDiff\n          : undefined\n      };\n\n      const thought = await LLMAdapter.think(\n        messages,\n        mode as any,\n        onChunk,\n        model,\n        GovernanceService.getPolicyManual(),\n        this.context  // ä¼ é€’ContextManagerä»¥ä¾¿è®¿é—®ContextBuffer\n      );\n\n      const action: ProposedAction = {\n        id: randomUUID(),\n        type: (thought.type as any) || \"answer\",\n        payload: thought.payload || { text: thought.raw },\n        riskLevel: \"low\",\n        reasoning: thought.reasoning || \"\",\n      };\n\n      // æ›´æ–°executionTurn\n      executionTurn.proposedAction = action;\n\n      if (action.reasoning && !onChunk) {\n        console.log(chalk.gray(`\\nğŸ¤” Reasoning: ${action.reasoning}`));\n      }\n\n      // å¦‚æœ LLM è®¤ä¸ºå·²ç»å®Œæˆæˆ–è€…å½“å‰çš„åŠ¨ä½œå°±æ˜¯å›ç­”\n      if (thought.isDone || action.type === \"answer\") {\n        const result = await ToolExecutor.execute(action as any);\n        if (!onChunk) {\n          console.log(chalk.green(`\\nğŸ¤– AIï¼š${result.output}\\n`));\n        }\n        this.context.addMessage(\"assistant\", result.output);\n\n        // æ›´æ–°executionTurn\n        executionTurn.executionResult = result;\n        executionTurn.endTime = Date.now();\n\n        // è®°å½•æ‰§è¡Œå›åˆ\n        this.executionRecorder.recordTurn(executionTurn);\n\n        // ä»»åŠ¡æˆåŠŸå®Œæˆï¼Œåªæ›´æ–°è¢«ä½¿ç”¨è¿‡çš„ContextItemçš„é‡è¦æ€§\n        for (const item of this.context.getContextBuffer().export()) {\n          if (item.importance && item.importance.useCount > 0) {\n            // æˆåŠŸå®Œæˆä»»åŠ¡ï¼Œå¢åŠ æˆåŠŸè®¡æ•°\n            item.importance.successCount++;\n            item.importance.confidence = Math.min(1, item.importance.confidence + 0.05);\n            item.importance.lastUsed = Date.now();\n          }\n        }\n        break;\n      }\n\n      // === é¢„æ£€ (Pre-flight) ===\n      const preCheck = evaluateProposal(\n        action,\n        GovernanceService.getRules(),\n        GovernanceService.getLedgerSnapshot(),\n      );\n      if (preCheck.effect === \"deny\") {\n        console.log(\n          chalk.red(`[PRE-FLIGHT] ğŸ›¡ï¸ Policy Blocked: ${preCheck.reason}`),\n        );\n        this.context.addMessage(\n          \"system\",\n          `POLICY DENIED: ${preCheck.reason}. Find a different way.`,\n        );\n\n        // æ›´æ–°executionTurn\n        executionTurn.executionResult = {\n          success: false,\n          output: `POLICY DENIED: ${preCheck.reason}`,\n          error: preCheck.reason\n        };\n        executionTurn.endTime = Date.now();\n\n        // è®°å½•æ‰§è¡Œå›åˆ\n        this.executionRecorder.recordTurn(executionTurn);\n\n        continue;\n      }\n\n      // === æ­£å¼æ²»ç† (WASM + äººå·¥/è‡ªåŠ¨) ===\n      const decision = await GovernanceService.adjudicate(action);\n      if (decision.status === \"rejected\") {\n        console.log(chalk.red(`[GOVERNANCE] âŒ Rejected: ${decision.reason}`));\n        this.context.addMessage(\n          \"system\",\n          `Rejected by Governance: ${decision.reason}`,\n        );\n\n        // æ›´æ–°executionTurn\n        executionTurn.governance = decision;\n        executionTurn.executionResult = {\n          success: false,\n          output: `GOVERNANCE REJECTED: ${decision.reason}`,\n          error: decision.reason\n        };\n        executionTurn.endTime = Date.now();\n\n        // è®°å½•æ‰§è¡Œå›åˆ\n        this.executionRecorder.recordTurn(executionTurn);\n\n        // ä»»åŠ¡è¢«æ‹’ç»ï¼Œåªæ›´æ–°è¢«ä½¿ç”¨è¿‡çš„ContextItemçš„é‡è¦æ€§ï¼ˆå¤±è´¥æƒ©ç½šï¼‰\n        for (const item of this.context.getContextBuffer().export()) {\n          if (item.importance && item.importance.useCount > 0) {\n            // ä»»åŠ¡å¤±è´¥ï¼Œå¢åŠ å¤±è´¥è®¡æ•°\n            item.importance.failureCount++;\n            item.importance.confidence = Math.max(0, item.importance.confidence - 0.1);\n            item.importance.lastUsed = Date.now();\n          }\n        }\n\n        continue;\n      }\n\n      // æ›´æ–°executionTurn\n      executionTurn.governance = decision;\n\n      // === æ‰§è¡Œ ===\n      console.log(chalk.yellow(`[EXECUTING] âš™ï¸ ${action.type}...`));\n      const result = await ToolExecutor.execute(action as any);\n\n      // æ›´æ–°executionTurn\n      executionTurn.executionResult = result;\n      executionTurn.endTime = Date.now();\n\n      // è®°å½•æ‰§è¡Œå›åˆ\n      this.executionRecorder.recordTurn(executionTurn);\n\n      if (result.success) {\n        this.context.addToolResult(action.type, result.output);\n        const preview = result.output.length > 300\n          ? result.output.substring(0, 300) + '...'\n          : result.output;\n        console.log(chalk.green(`[SUCCESS] Result:\\n${preview}`));\n\n        // æ›´æ–°ContextBufferä¸­ç›¸å…³é¡¹çš„é‡è¦æ€§ï¼ˆæ ‡è®°ä¸ºè¢«ä½¿ç”¨ï¼‰\n        for (const item of this.context.getContextBuffer().export()) {\n          if (result.output.includes(item.path)) {\n            if (item.importance) {\n              item.importance.useCount++;\n              item.importance.lastUsed = Date.now();\n            }\n          }\n        }\n      } else {\n        this.context.addToolResult(action.type, `Error: ${result.error}`);\n        console.log(chalk.red(`[ERROR] ${result.error}`));\n      }\n    }\n\n    if (turnCount >= maxTurns) {\n      console.log(chalk.red(`\\nâš ï¸ Max turns (${maxTurns}) reached.`));\n    }\n  }\n\n  getContextManager(): ContextManager {\n    return this.context;\n  }\n\n  getExecutionRecorder(): ExecutionRecorder {\n    return this.executionRecorder;\n  }\n}\n",
    "tokens": 1978
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/prompt.ts",
    "content": "import {\n    AgentIntent,\n    AgentContext,\n    AgentMode,\n    AgentPrompt,\n} from './types';\nimport { buildCommandPrompt as buildCommandPromptString } from '../ai/prompt';\nimport { getOSProfile } from '../core/os';\nimport { getMacros } from '../core/macros';\nimport { aiCommandPlanSchema } from '../core/validation';\nimport { getRelevantSkills } from './skills';\n\nexport function buildPrompt(\n    intent: AgentIntent,\n    context: AgentContext,\n    mode: AgentMode,\n    input: string\n): AgentPrompt {\n    if (mode === 'chat') {\n        return buildChatPrompt(context, input);\n    }\n\n    return buildCommandPromptObject(input, context);\n}\n\nfunction buildChatPrompt(\n    context: AgentContext,\n    input: string\n): AgentPrompt {\n    const messages: any[] = [\n        ...(context.history ?? []),\n    ];\n\n    // Add context files if available\n    if (context.files && context.files.length > 0) {\n        const contextDesc = context.files.map(f =>\n            `File: ${f.path}\\n\\`\\`\\`\\n${f.content}\\n\\`\\`\\``\n        ).join('\\n\\n');\n\n        messages.push({\n            role: 'system',\n            content: `Context:\\n${contextDesc}`,\n        });\n    }\n\n    messages.push({\n        role: 'user',\n        content: input,\n    });\n\n    return {\n        system: 'You are a helpful AI assistant with expertise in software development, system administration, and problem-solving.',\n        messages,\n    };\n}\n\nfunction buildCommandPromptObject(\n    input: string,\n    context: AgentContext\n): AgentPrompt {\n    const os = getOSProfile();\n    const macros = getMacros();\n    const skills = getRelevantSkills(input);\n    let promptText = buildCommandPromptString(input, os, macros);\n\n    if (skills.length > 0) {\n        const skillList = skills.map(s => `- ${s.name}: å½“é‡åˆ° \"${s.whenToUse}\" æ—¶ï¼Œä½ å¯ä»¥å‚è€ƒè®¡åˆ’: ${s.planTemplate.goal}`).join('\\n');\n        promptText = `ã€å‚è€ƒæŠ€èƒ½åº“ã€‘\\n${skillList}\\n\\n${promptText}`;\n    }\n\n    return {\n        messages: [\n            {\n                role: 'user',\n                content: promptText,\n            },\n        ],\n        outputSchema: aiCommandPlanSchema,\n    };\n}\n",
    "tokens": 522
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextSkillBridge.ts",
    "content": "import { ContextItem } from './contextBuffer';\nimport { Skill } from './skills';\n\nexport interface ContextSkillHint {\n  source: 'context';\n  path: string;\n  suggestedSkillName: string;\n  confidence: number; // 0-1, how certain we are this should become a skill\n  usageCount: number; // how many times this context was used\n  lastUsed: number; // timestamp\n  description: string; // description of what this context enables\n}\n\n/**\n * åˆ†æContextItemsä»¥ç”ŸæˆSkillHints\n * å½“ContextItemè¢«é¢‘ç¹ä½¿ç”¨ä¸”ä¸æˆåŠŸä»»åŠ¡ç›¸å…³è”æ—¶ï¼Œå»ºè®®å°†å…¶è½¬æ¢ä¸ºSkill\n * \n * @param contextItems ContextItemæ•°ç»„\n * @returns ContextSkillHintæ•°ç»„\n */\nexport function generateSkillHintsFromContext(contextItems: ContextItem[]): ContextSkillHint[] {\n  const hints: ContextSkillHint[] = [];\n\n  for (const item of contextItems) {\n    // æ£€æŸ¥ContextItemæ˜¯å¦æ»¡è¶³æˆä¸ºSkillçš„æ¡ä»¶\n    if (item.importance) {\n      const { useCount, successCount, lastUsed } = item.importance;\n      \n      // å¦‚æœä½¿ç”¨æ¬¡æ•°è¶…è¿‡é˜ˆå€¼ï¼Œä¸”æœ‰ä¸€å®šæˆåŠŸç‡ï¼Œç”ŸæˆSkillå»ºè®®\n      if (useCount >= 3 && successCount > 0) {\n        const successRate = successCount / useCount;\n        const daysSinceLastUse = (Date.now() - lastUsed) / (1000 * 60 * 60 * 24);\n        \n        // è®¡ç®—å»ºè®®çš„ç½®ä¿¡åº¦\n        const confidence = Math.min(1, \n          (successRate * 0.6) +  // æˆåŠŸç‡æƒé‡\n          (Math.min(1, useCount / 10) * 0.3) +  // ä½¿ç”¨é¢‘ç‡æƒé‡\n          (Math.max(0, (7 - daysSinceLastUse) / 7) * 0.1)  // æ–°é²œåº¦æƒé‡\n        );\n        \n        if (confidence > 0.5) { // åªæœ‰ç½®ä¿¡åº¦è¶…è¿‡0.5æ‰ç”Ÿæˆå»ºè®®\n          hints.push({\n            source: 'context',\n            path: item.path,\n            suggestedSkillName: generateSkillNameFromPath(item.path),\n            confidence,\n            usageCount: useCount,\n            lastUsed,\n            description: `Frequently used context from ${item.path} that contributed to ${successCount} successful tasks`\n          });\n        }\n      }\n    }\n  }\n\n  return hints;\n}\n\n/**\n * ä»è·¯å¾„ç”ŸæˆSkillåç§°\n * @param path æ–‡ä»¶è·¯å¾„\n * @returns å»ºè®®çš„Skillåç§°\n */\nfunction generateSkillNameFromPath(path: string): string {\n  // ç§»é™¤æ–‡ä»¶æ‰©å±•åå¹¶ä½¿ç”¨é©¼å³°å‘½å\n  const basename = path.split('/').pop()?.split('.')[0] || path;\n  return basename\n    .split(/[^a-zA-Z0-9]/)  // æŒ‰éå­—æ¯æ•°å­—å­—ç¬¦åˆ†å‰²\n    .map((part, index) => \n      index === 0 \n        ? part.toLowerCase() \n        : part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()\n    )\n    .join('');\n}\n\n/**\n * å°†ContextSkillHintsè½¬æ¢ä¸ºå¯æ˜¾ç¤ºçš„æ–‡æœ¬\n * @param hints ContextSkillHintæ•°ç»„\n * @returns æ ¼å¼åŒ–çš„å­—ç¬¦ä¸²\n */\nexport function formatSkillHints(hints: ContextSkillHint[]): string {\n  if (hints.length === 0) {\n    return \"No skill suggestions generated from context.\";\n  }\n\n  const lines: string[] = [\"Skill Suggestions from Context:\", \"\"];\n\n  for (const hint of hints) {\n    lines.push(`- ${hint.suggestedSkillName} (confidence: ${(hint.confidence * 100).toFixed(1)}%)`);\n    lines.push(`  Path: ${hint.path}`);\n    lines.push(`  Usage: ${hint.usageCount}, Last used: ${new Date(hint.lastUsed).toLocaleDateString()}`);\n    lines.push(`  Description: ${hint.description}`);\n    lines.push(\"\");\n  }\n\n  return lines.join(\"\\n\");\n}",
    "tokens": 747
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/context.ts",
    "content": "import { AgentInput, AgentContext } from './types';\nimport { ContextBuffer } from './contextBuffer';\n\nexport function buildContext(input: AgentInput, contextBuffer: ContextBuffer): AgentContext {\n    const items = contextBuffer.export();\n\n    return {\n        files: items.map(item => ({\n            path: item.path,\n            content: item.content,\n        })),\n        gitDiff: undefined, // Will be enhanced later\n        history: [], // Will be populated from conversation history\n    };\n}\n",
    "tokens": 124
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/types.ts",
    "content": "import type { AIRequestMessage } from '../core/validation';\n// import { AgentPlan } from './plan';\n\nexport type AgentMode = 'chat' | 'command' | 'command+exec';\n\nexport interface AgentInput {\n    rawInput: string;\n    stdin?: string;\n    context?: AgentContext;\n    options?: {\n        model?: string;\n        stream?: boolean;\n        autoYes?: boolean;\n        verbose?: boolean;\n    };\n}\n\nexport interface AgentContext {\n    files?: Array<{ path: string; content: string }>;\n    gitDiff?: string;\n    history?: AIRequestMessage[];\n}\n\nexport interface AgentIntent {\n    type: 'chat' | 'shell' | 'analysis';\n    capabilities: {\n        reasoning?: boolean;\n        code?: boolean;\n        longContext?: boolean;\n        streaming?: boolean;\n    };\n}\n\nexport interface AgentPrompt {\n    system?: string;\n    messages: AIRequestMessage[];\n    outputSchema?: any;\n}\n\nexport interface LLMResult {\n    rawText: string;\n    parsed?: any;\n    plan?: any;\n    latencyMs: number;\n    tokens?: {\n        prompt: number;\n        completion: number;\n        total: number;\n    };\n    costUsd?: number;\n}\n\nexport type AgentAction =\n    | { type: 'print'; content: string }\n    | { type: 'confirm'; next: AgentAction }\n    | { type: 'execute'; command: string; risk: 'low' | 'medium' | 'high' };\n",
    "tokens": 321
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/llm.ts",
    "content": "import { AgentPrompt, LLMResult } from './types';\nimport { callAI_Stream } from '../ai/client';\nimport axios from 'axios';\nimport { DEFAULT_AI_PROXY_URL, DEFAULT_MODEL, DEFAULT_ACCOUNT_TYPE, type AIRequestMessage } from '../core/validation';\nimport fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { safeParseJSON } from '../core/validation';\n\nconst CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');\n\nfunction getUserConfig(): any {\n    if (fs.existsSync(CONFIG_FILE)) {\n        try {\n            const content = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(content);\n        } catch (e) { }\n    }\n    return {};\n}\n\nexport async function runLLM({\n    prompt,\n    model,\n    stream,\n    onChunk,\n}: {\n    prompt: AgentPrompt;\n    model: string;\n    stream: boolean;\n    onChunk?: (s: string) => void;\n}): Promise<LLMResult> {\n    const start = Date.now();\n\n    if (stream) {\n        let raw = '';\n        await callAI_Stream(prompt.messages, model, (chunk) => {\n            raw += chunk;\n            onChunk?.(chunk);\n        });\n        return {\n            rawText: raw,\n            latencyMs: Date.now() - start,\n        };\n    }\n\n    // Non-streaming mode with optional schema\n    const config = getUserConfig();\n    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;\n\n    const headers = {\n        'Content-Type': 'application/json',\n        'X-Client-ID': 'vscode',\n        'Origin': 'https://cli.want.biz',\n        'Referer': 'https://cli.want.biz/',\n        'account': config.accountType || DEFAULT_ACCOUNT_TYPE,\n        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',\n        'Accept': 'application/json'\n    };\n\n    const data = {\n        model: model || config.defaultModel || DEFAULT_MODEL,\n        messages: prompt.messages,\n        stream: false\n    };\n\n    try {\n        const response = await axios.post(url, data, { headers });\n        const rawText = response.data.choices[0]?.message?.content || '';\n\n        let parsed = undefined;\n        if (prompt.outputSchema) {\n            const parseResult = safeParseJSON(rawText, prompt.outputSchema, {});\n            if (parseResult.success) {\n                parsed = parseResult.data;\n            }\n        }\n\n        return {\n            rawText,\n            parsed,\n            latencyMs: Date.now() - start,\n        };\n    } catch (error: any) {\n        const errorMsg = error.response?.data?.error?.message || error.response?.data?.message || error.message || 'æœªçŸ¥é”™è¯¯';\n        throw new Error(`AI è¯·æ±‚å¤±è´¥: ${errorMsg}`);\n    }\n}\n",
    "tokens": 662
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/executionRecorder.ts",
    "content": "import { ExecutionTurn } from './state';\nimport { ContextDiff } from './contextDiff';\n\nexport class ExecutionRecorder {\n  private turns: ExecutionTurn[] = [];\n  private turnCounter = 0;\n\n  recordTurn(turn: Omit<ExecutionTurn, 'turnId'>): ExecutionTurn {\n    const executionTurn: ExecutionTurn = {\n      ...turn,\n      turnId: ++this.turnCounter\n    };\n    \n    this.turns.push(executionTurn);\n    return executionTurn;\n  }\n\n  getTurns(): ExecutionTurn[] {\n    return [...this.turns];\n  }\n\n  clear(): void {\n    this.turns = [];\n    this.turnCounter = 0;\n  }\n\n  getSummary(): {\n    totalTurns: number;\n    totalAddedContext: number;\n    totalRemovedContext: number;\n    totalChangedContext: number;\n  } {\n    return {\n      totalTurns: this.turns.length,\n      totalAddedContext: this.turns.reduce((sum, turn) => \n        sum + (turn.contextDiff?.added.length || 0), 0),\n      totalRemovedContext: this.turns.reduce((sum, turn) => \n        sum + (turn.contextDiff?.removed.length || 0), 0),\n      totalChangedContext: this.turns.reduce((sum, turn) => \n        sum + (turn.contextDiff?.changed.length || 0), 0)\n    };\n  }\n}",
    "tokens": 281
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextStorage.ts",
    "content": "import fs from 'fs/promises';\nimport path from 'path';\nimport { ContextItem } from './contextBuffer';\n\nconst CONTEXT_DIR = path.resolve(process.cwd(), '.ai');\nconst CONTEXT_FILE = path.join(CONTEXT_DIR, 'context.json');\n\nexport async function loadContext(): Promise<ContextItem[]> {\n    try {\n        const raw = await fs.readFile(CONTEXT_FILE, 'utf-8');\n        return JSON.parse(raw);\n    } catch {\n        return [];\n    }\n}\n\nexport async function saveContext(items: ContextItem[]) {\n    await fs.mkdir(CONTEXT_DIR, { recursive: true });\n    await fs.writeFile(CONTEXT_FILE, JSON.stringify(items, null, 2));\n}\n\nexport async function clearContextStorage() {\n    await fs.rm(CONTEXT_FILE, { force: true });\n}\n",
    "tokens": 178
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/actions.ts",
    "content": "import { AgentAction } from './types';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport chalk from 'chalk';\nimport readline from 'readline';\n\nconst execAsync = promisify(exec);\n\nexport async function executeAction(\n    action: AgentAction,\n    options?: { autoYes?: boolean }\n): Promise<void> {\n    if (action.type === 'print') {\n        console.log(action.content);\n        return;\n    }\n\n    if (action.type === 'confirm') {\n        const ok = options?.autoYes || await confirm('Execute this action?');\n        if (ok) {\n            await executeAction(action.next, options);\n        }\n        return;\n    }\n\n    if (action.type === 'execute') {\n        try {\n            console.log(chalk.cyan(`\\nExecuting: ${action.command}\\n`));\n            const { stdout, stderr } = await execAsync(action.command, {\n                shell: typeof process.env.SHELL === 'string' ? process.env.SHELL : undefined\n            });\n            if (stdout) console.log(stdout);\n            if (stderr) console.error(chalk.yellow(stderr));\n        } catch (error: any) {\n            console.error(chalk.red(`Execution failed: ${error.message}`));\n            throw error;\n        }\n    }\n}\n\nasync function confirm(message: string): Promise<boolean> {\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout,\n    });\n\n    return new Promise((resolve) => {\n        rl.question(chalk.cyan(`${message} (y/N): `), (answer) => {\n            rl.close();\n            resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');\n        });\n    });\n}\n",
    "tokens": 404
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextImportance.ts",
    "content": "import { randomUUID } from 'crypto';\n\nexport interface ContextImportance {\n  id: string;              // stable id\n  path: string;            // file / dir path\n  type: 'file' | 'directory';\n\n  // === Usage stats ===\n  useCount: number;\n  successCount: number;\n  failureCount: number;\n\n  // === Time ===\n  lastUsed: number;\n  createdAt: number;\n\n  // === Learned weight ===\n  confidence: number;      // 0 ~ 1, init 0.5\n}\n\n/**\n * è®¡ç®—ä¸Šä¸‹æ–‡é‡è¦æ€§åˆ†æ•°\n * è¯„åˆ†å…¬å¼ä¸Skillç³»ç»Ÿä¿æŒä¸€è‡´\n * @param ctx ContextImportanceå¯¹è±¡\n * @param now å½“å‰æ—¶é—´æˆ³\n * @returns é‡è¦æ€§åˆ†æ•° (0-1)\n */\nexport function computeContextImportance(\n  ctx: ContextImportance,\n  now = Date.now()\n): number {\n  const total = ctx.successCount + ctx.failureCount;\n  const successRate = total === 0 ? 0.5 : ctx.successCount / total;\n\n  const idleDays = (now - ctx.lastUsed) / (1000 * 60 * 60 * 24);\n  const freshness = Math.exp(-idleDays / 14); // 14 å¤©åŠè¡°\n\n  return (\n    0.45 * successRate +\n    0.35 * freshness +\n    0.20 * ctx.confidence\n  );\n}\n\n/**\n * åˆ›å»ºæ–°çš„ContextImportanceå¯¹è±¡\n * @param path æ–‡ä»¶æˆ–ç›®å½•è·¯å¾„\n * @param type ç±»å‹\n * @returns ContextImportanceå¯¹è±¡\n */\nexport function createContextImportance(path: string, type: 'file' | 'directory'): ContextImportance {\n  const now = Date.now();\n  return {\n    id: randomUUID(),\n    path,\n    type,\n    useCount: 0,\n    successCount: 0,\n    failureCount: 0,\n    confidence: 0.5,\n    createdAt: now,\n    lastUsed: now\n  };\n}\n\n/**\n * æ›´æ–°ContextImportanceçŠ¶æ€\n * @param ctx ContextImportanceå¯¹è±¡\n * @param success æ˜¯å¦æˆåŠŸ\n */\nexport function updateContextImportance(ctx: ContextImportance, success: boolean) {\n  ctx.useCount++;\n  ctx.lastUsed = Date.now();\n\n  if (success) {\n    ctx.successCount++;\n    ctx.confidence = Math.min(1, ctx.confidence + 0.05);\n  } else {\n    ctx.failureCount++;\n    ctx.confidence = Math.max(0, ctx.confidence - 0.1);\n  }\n}",
    "tokens": 453
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextSummary.ts",
    "content": "import { askAI } from '../ai/client';\n\nexport function buildContextSummaryPrompt(\n  type: 'file' | 'directory',\n  path: string,\n  content: string\n) {\n  return `\nä½ æ˜¯ä¸€ä¸ªä»£ç ä¸æ–‡æ¡£å‹ç¼©å™¨ã€‚\n\nç›®æ ‡ï¼š\n- æœ€å¤§é™åº¦ä¿ç•™\"ä¹‹åå›ç­”é—®é¢˜æ‰€éœ€çš„ä¿¡æ¯\"\n- åˆ é™¤å®ç°ç»†èŠ‚ã€é‡å¤å†…å®¹ã€å™ªå£°\n- ä¸è¦åŠ å…¥æ¨æµ‹\n\nè¯·å°†ä»¥ä¸‹ ${type} å†…å®¹å‹ç¼©ä¸º **ç»“æ„åŒ–æ‘˜è¦**ï¼š\n\nè·¯å¾„: ${path}\n\nè¦æ±‚æ ¼å¼ï¼š\n- ç”¨é¡¹ç›®ç¬¦å·\n- ä¿ç•™ï¼šèŒè´£ / æ¥å£ / å…³é”®æ•°æ®ç»“æ„ / å…³é”®è¡Œä¸º\n- ä»£ç åªä¿ç•™å‡½æ•°ç­¾åæˆ–æ ¸å¿ƒé€»è¾‘æè¿°\n- ä¸è¶…è¿‡åŸå†…å®¹çš„ 20%\n\nå†…å®¹ï¼š\n\\`\\`\\`\n${content}\n\\`\\`\\`\n`;\n}\n\nexport async function summarizeContext(\n  item: { type: 'file' | 'directory'; path: string; content: string }\n): Promise<string> {\n  const prompt = buildContextSummaryPrompt(\n    item.type,\n    item.path,\n    item.content\n  );\n\n  const summary = await askAI(prompt);\n  return summary.trim();\n}",
    "tokens": 170
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/chatHistoryStorage.ts",
    "content": "import fs from 'fs';\nimport { promisify } from 'util';\nimport path from 'path';\nimport os from 'os';\nimport { AIRequestMessage } from '../core/validation';\n\nconst CHAT_HISTORY_DIR = path.resolve(os.homedir(), '.yuangs_chat_history');\nconst CHAT_HISTORY_FILE = path.join(CHAT_HISTORY_DIR, 'chat_history.json');\n\nconst readFileAsync = promisify(fs.readFile);\nconst writeFileAsync = promisify(fs.writeFile);\nconst mkdirAsync = promisify(fs.mkdir);\nconst rmAsync = promisify(fs.rm);\n\nexport async function loadChatHistory(): Promise<AIRequestMessage[]> {\n    if (fs.existsSync(CHAT_HISTORY_FILE)) {\n        try {\n            const raw = await readFileAsync(CHAT_HISTORY_FILE, 'utf-8');\n            const data = JSON.parse(raw);\n\n            // éªŒè¯æ•°æ®ç»“æ„\n            if (Array.isArray(data) && data.every(msg =>\n                typeof msg === 'object' &&\n                ['user', 'assistant', 'system'].includes(msg.role) &&\n                typeof msg.content === 'string'\n            )) {\n                return data as AIRequestMessage[];\n            }\n        } catch (e) {\n            console.warn('è­¦å‘Š: åŠ è½½èŠå¤©å†å²è®°å½•å¤±è´¥ï¼Œä½¿ç”¨ç©ºå†å²è®°å½•');\n        }\n    }\n    return [];\n}\n\nexport async function saveChatHistory(history: AIRequestMessage[]) {\n    try {\n        await mkdirAsync(CHAT_HISTORY_DIR, { recursive: true });\n        await writeFileAsync(CHAT_HISTORY_FILE, JSON.stringify(history, null, 2));\n    } catch (e) {\n        console.error('é”™è¯¯: ä¿å­˜èŠå¤©å†å²è®°å½•å¤±è´¥:', e);\n    }\n}\n\nexport async function clearChatHistory() {\n    try {\n        await rmAsync(CHAT_HISTORY_FILE, { force: true });\n    } catch (e) {\n        console.error('é”™è¯¯: æ¸…é™¤èŠå¤©å†å²è®°å½•å¤±è´¥:', e);\n    }\n}\n",
    "tokens": 410
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/core.ts",
    "content": "import { ProposedAction } from '../state';\n\nexport interface PolicyRule {\n    id: string;\n    when: { type?: string; pattern?: string; max_per_minute?: number };\n    effect: 'allow' | 'deny' | 'require_approval';\n    reason?: string;\n}\n\nexport interface RiskEntry {\n    ts: number;\n    actionType: string;\n}\n\nexport function evaluateProposal(\n    action: ProposedAction,\n    rules: PolicyRule[],\n    ledger: RiskEntry[]\n): { effect: string; reason?: string } {\n    const now = Date.now();\n    for (const rule of rules) {\n        const typeMatch = !rule.when.type || rule.when.type === action.type;\n        const payloadStr = JSON.stringify(action.payload);\n        const patternMatch = !rule.when.pattern || new RegExp(rule.when.pattern, 'i').test(payloadStr);\n\n        if (typeMatch && patternMatch) {\n            if (rule.when.max_per_minute) {\n                const count = ledger.filter(e => e.ts > now - 60000 && e.actionType === action.type).length;\n                if (count >= rule.when.max_per_minute) return { effect: 'deny', reason: `Rate limit: ${rule.id}` };\n            }\n            return { effect: rule.effect, reason: rule.reason };\n        }\n    }\n    return { effect: 'require_approval', reason: 'Default human review required' };\n}\n",
    "tokens": 314
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/bridge.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\n\nexport class WasmGovernanceBridge {\n    private static instance: any = null;\n\n    static async init(basePath?: string): Promise<boolean> {\n        try {\n            const loader = require('@assemblyscript/loader');\n            const wasmPath = path.join(basePath || process.cwd(), 'build', 'release.wasm');\n\n            if (!fs.existsSync(wasmPath)) {\n                console.error(`WASM not found at: ${wasmPath}`);\n                return false;\n            }\n\n            const wasmModule = await loader.instantiate(fs.readFileSync(wasmPath));\n            this.instance = wasmModule.exports;\n            return true;\n        } catch (e) {\n            console.error(`WASM init error: ${e}`);\n            return false;\n        }\n    }\n\n    static evaluate(proposal: any, rules: any, ledger: any): any {\n        if (!this.instance) return { effect: 'error', reason: 'WASM not initialized' };\n\n        const { __newString, __getString, evaluate } = this.instance;\n\n        const pPtr = __newString(JSON.stringify(proposal));\n        const rPtr = __newString(JSON.stringify(rules));\n        const lPtr = __newString(JSON.stringify(ledger));\n\n        const resultPtr = evaluate(pPtr, rPtr, lPtr);\n        return JSON.parse(__getString(resultPtr));\n    }\n}\n",
    "tokens": 325
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/ledger.ts",
    "content": "import { RiskEntry } from './core';\n\nexport class RiskLedger {\n    private entries: RiskEntry[] = [];\n\n    record(actionType: string): void {\n        this.entries.push({\n            ts: Date.now(),\n            actionType\n        });\n        this.cleanup();\n    }\n\n    getSnapshot(): RiskEntry[] {\n        return [...this.entries];\n    }\n\n    private cleanup(): void {\n        const oneHourAgo = Date.now() - 3600000;\n        this.entries = this.entries.filter(e => e.ts > oneHourAgo);\n    }\n}\n",
    "tokens": 124
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/sandbox/core.as.ts",
    "content": "/**\n * yuangs Governance WASM Sandbox\n * è¿™é‡Œçš„ä»£ç åœ¨æ‰§è¡Œæ—¶ä¸ Node.js å†…å­˜å®Œå…¨éš”ç¦»\n */\n\n// ç®€å•çš„è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥å­—ç¬¦ä¸²åŒ…å«ï¼ˆWASM å†…éƒ¨å®ç°ï¼‰\nfunction includes(source: string, target: string): boolean {\n    return source.indexOf(target) != -1;\n}\n\n/**\n * æ ¸å¿ƒè£å†³å¯¼å‡ºå‡½æ•°\n * @param proposal ææ¡ˆå­—ç¬¦ä¸²\n * @param rules è§„åˆ™å­—ç¬¦ä¸²ï¼ˆYAML è½¬æ¢åçš„ JSONï¼‰\n * @param ledger è´¦æœ¬å­—ç¬¦ä¸²\n */\nexport function evaluate(proposal: string, rules: string, ledger: string): string {\n    // 1. æš´åŠ›é˜»æ–­ï¼šæœ€åº•å±‚çš„ç‰©ç†é˜²çº¿ï¼ˆå³ä¾¿å¤–éƒ¨é€»è¾‘è¢«æ±¡æŸ“ï¼Œè¿™é‡Œä¹Ÿæ˜¯æ­»çš„ï¼‰\n    if (proposal.includes(\"rm -rf /\") || proposal.includes(\"sudo rm\")) {\n        return '{\"effect\": \"deny\", \"reason\": \"WASM_SANDBOX: æ£€æµ‹åˆ°æ¯ç­æ€§å‘½ä»¤ï¼Œå¼ºåˆ¶é˜»æ–­\"}';\n    }\n\n    // 2. æ£€æŸ¥é€Ÿç‡ï¼ˆåŸºäºè´¦æœ¬é•¿åº¦ï¼‰\n    // å‡è®¾æˆ‘ä»¬ä¸æƒ³è®© AI åœ¨çŸ­æ—¶é—´å†…è¿ç»­æè®®è¶…è¿‡ 50 æ¬¡\n    if (ledger.length > 5000) { // ç®€å•é€šè¿‡å­—ç¬¦ä¸²é•¿åº¦æ¨¡æ‹Ÿå¼‚å¸¸è´¦æœ¬\n        return '{\"effect\": \"deny\", \"reason\": \"WASM_SANDBOX: è´¦æœ¬å¼‚å¸¸è†¨èƒ€ï¼Œå¯èƒ½é­å—æ‹’ç»æœåŠ¡æ”»å‡»\"}';\n    }\n\n    // 3. é€»è¾‘é€ä¼ \n    // åœ¨å®é™…ç”Ÿäº§ä¸­ï¼Œæˆ‘ä»¬ä¼šåœ¨è¿™é‡Œè§£æ JSON rulesã€‚\n    // ç›®å‰ç‰ˆæœ¬æˆ‘ä»¬å…ˆç¡®ä¿ç‰©ç†é“¾è·¯æ‰“é€šã€‚\n    return '{\"effect\": \"allow\", \"reason\": \"WASM_SANDBOX: ç‰©ç†éš”ç¦»å±‚éªŒè¯é€šè¿‡\"}';\n}\n",
    "tokens": 236
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/llmAdapter.ts",
    "content": "import { AgentThought } from './state';\nimport { runLLM } from './llm';\nimport { AgentPrompt } from './types';\nimport type { AIRequestMessage } from '../core/validation';\nimport { getUserConfig } from '../ai/client';\nimport { ContextManager } from './contextManager';\n\nexport class LLMAdapter {\n  static async think(\n    messages: AIRequestMessage[],\n    mode: 'chat' | 'command' | 'command+exec' = 'chat',\n    onChunk?: (chunk: string) => void,\n    model?: string,\n    customSystemPrompt?: string,\n    contextManager?: ContextManager\n  ): Promise<AgentThought> {\n    // æ„å»ºåŒ…å«ContextBufferå†…å®¹çš„å®Œæ•´ä¸Šä¸‹æ–‡\n    let fullMessages = [...messages];\n\n    if (contextManager) {\n      const contextBuffer = contextManager.getContextBuffer();\n      if (!contextBuffer.isEmpty()) {\n        // è·å–ContextBufferçš„å®Œæ•´æç¤ºï¼Œä½¿ç”¨æ’åç­–ç•¥\n        const contextPrompt = contextBuffer.buildPrompt('', {\n          strategy: 'ranked',  // ä½¿ç”¨æ’åç­–ç•¥\n          maxTokens: 16000     // è®¾ç½®æœ€å¤§tokené™åˆ¶\n        });\n\n        // å°†ContextBufferå†…å®¹ä½œä¸ºsystemæ¶ˆæ¯æ·»åŠ åˆ°æ¶ˆæ¯åˆ—è¡¨å¼€å¤´\n        fullMessages = [\n          { role: 'system', content: contextPrompt },\n          ...fullMessages\n        ];\n      }\n    }\n\n    const prompt: AgentPrompt = {\n      system: customSystemPrompt || `[SYSTEM PROTOCOL V2]\n- ROLE: AUTOMATED EXECUTION AGENT\n- OUTPUT: STRICT JSON ONLY\n- TALK: FORBIDDEN\n- MODE: REACT (THINK -> ACTION -> PERCEIVE)\n\nJSON SCHEMA:\n{\n  \"action_type\": \"tool_call\" | \"shell_cmd\" | \"code_diff\" | \"answer\",\n  \"reasoning\": \"thought process\",\n  \"tool_name\": \"list_files\" | \"read_file\",\n  \"diff\": \"unified diff string\",\n  \"parameters\": {},\n  \"command\": \"shell string\",\n  \"content\": \"final answer string\"\n}\n\nEXECUTION RULES:\n1. If data is unknown (e.g. file list), use 'shell_cmd' or 'tool_call'.\n2. NEVER explain how to do it. JUST EXECUTE.\n3. Your output MUST start with '{' and end with '}'.\n\nExample Task: \"count files\"\nYour Output: {\"action_type\":\"shell_cmd\",\"reasoning\":\"count files\",\"command\":\"ls | wc -l\"}`,\n      messages: fullMessages,\n    };\n\n    const config = getUserConfig();\n    const finalModel = model || config.defaultModel || 'Assistant';\n\n    const result = await runLLM({\n      prompt,\n      model: finalModel,\n      stream: !!onChunk,\n      onChunk\n    });\n\n    return this.parseThought(result.rawText);\n  }\n\n  private static parseThought(raw: string): AgentThought {\n    try {\n      // æå– JSONï¼šæ”¯æŒ Markdown å—æˆ–çº¯ JSON å­—ç¬¦ä¸²\n      const jsonMatch = raw.match(/```json\\n([\\s\\S]*?)\\n```/) || raw.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        const parsed = JSON.parse(jsonMatch[1] || jsonMatch[0]);\n\n        // å¦‚æœæ˜ç¡®æ ‡è®°ä¸º doneï¼Œæˆ–è€…åŠ¨ä½œä¸º answerï¼Œåˆ™è§†ä¸ºä»»åŠ¡ç»“æŸ\n        if (parsed.is_done === true || parsed.action_type === 'answer') {\n          return {\n            raw,\n            parsedPlan: parsed,\n            isDone: true,\n            type: 'answer',\n            payload: {\n              content: parsed.final_answer || parsed.content || parsed.text || raw\n            }\n          };\n        }\n\n        // æ™ºèƒ½æ¨æ–­åŠ¨ä½œç±»å‹ï¼šå¦‚æœ AI æ²¡ç»™ action_typeï¼Œæˆ‘ä»¬æ ¹æ®å­—æ®µçŒœæµ‹\n        let inferredType = parsed.action_type;\n        if (!inferredType) {\n          if (parsed.tool_name || parsed.tool) inferredType = 'tool_call';\n          else if (parsed.command || parsed.cmd) inferredType = 'shell_cmd';\n          else if (parsed.diff || parsed.patch) inferredType = 'code_diff';\n          else inferredType = 'answer';\n        }\n\n        return {\n          raw,\n          parsedPlan: parsed,\n          isDone: inferredType === 'answer' || parsed.is_done === true,\n          type: inferredType,\n          payload: {\n            tool_name: parsed.tool_name || parsed.tool || '',\n            parameters: parsed.parameters || parsed.params || {},\n            command: parsed.command || parsed.cmd || '',\n            diff: parsed.diff || parsed.patch || '',\n            content: parsed.content || parsed.text || ''\n          },\n          reasoning: parsed.reasoning || ''\n        };\n      }\n    } catch (e) {\n      // è§£æå¤±è´¥æ—¶ï¼Œå›é€€åˆ°å°†åŸå§‹å†…å®¹ä½œä¸ºå›ç­”\n    }\n\n    return {\n      raw,\n      parsedPlan: {},\n      isDone: true,\n      type: 'answer',\n      payload: { content: raw },\n      reasoning: ''\n    };\n  }\n}\n",
    "tokens": 1027
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/index.ts",
    "content": "export { AgentRuntime } from './AgentRuntime';\nexport * from './state';\nexport { LLMAdapter } from './llmAdapter';\nexport { GovernanceService } from './governance';\nexport { ToolExecutor } from './executor';\nexport { ContextManager } from './contextManager';\nexport { ContextBuffer } from './contextBuffer';\nexport { ContextImportance, computeContextImportance, createContextImportance, updateContextImportance } from './contextImportance';\nexport { buildContextSummaryPrompt, summarizeContext } from './contextSummary';\nexport { diffContext, snapshotFromBuffer, ContextDiff, ContextSnapshot } from './contextDiff';\nexport { ExecutionRecorder } from './executionRecorder';\nexport { explainExecution, replayExecution } from './replayExplain';\nexport { generateSkillHintsFromContext, formatSkillHints, ContextSkillHint } from './contextSkillBridge';\nexport * from './skills';\n",
    "tokens": 219
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/skills.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport chalk from 'chalk';\n\nexport interface Skill {\n    id: string;\n    name: string;\n    description: string;\n    whenToUse: string; // è§¦å‘åœºæ™¯æè¿°\n    planTemplate: any;\n\n    // è¯„ä»·æŒ‡æ ‡\n    successCount: number;\n    failureCount: number;\n    confidence: number; // 0 ~ 1, åˆå§‹ 0.5\n\n    // æ—¶é—´æˆ³\n    lastUsed: number;\n    createdAt: number;\n\n    // æ˜¯å¦å¯ç”¨\n    enabled: boolean;\n}\n\nconst SKILLS_FILE = path.join(os.homedir(), '.yuangs_skills.json');\nlet skillLibrary: Skill[] = [];\n\n// === Persistence Logic ===\n\nfunction loadSkills() {\n    if (fs.existsSync(SKILLS_FILE)) {\n        try {\n            const data = fs.readFileSync(SKILLS_FILE, 'utf-8');\n            skillLibrary = JSON.parse(data);\n        } catch (e) {\n            console.error(chalk.yellow(`Failed to load skills from ${SKILLS_FILE}, starting empty.`));\n            skillLibrary = [];\n        }\n    }\n}\n\nfunction saveSkills() {\n    try {\n        fs.writeFileSync(SKILLS_FILE, JSON.stringify(skillLibrary, null, 2));\n    } catch (e) {\n        console.error(chalk.red(`Failed to save skills to ${SKILLS_FILE}`));\n    }\n}\n\n// Initialize on load\nloadSkills();\n\n// === Existing Logic with Save Hooks ===\n\n/**\n * è®¡ç®—æŠ€èƒ½åˆ† (0 ~ 1)\n */\nexport function computeSkillScore(skill: Skill, now: number = Date.now()): number {\n    const totalUses = skill.successCount + skill.failureCount;\n    const successRate = totalUses === 0 ? 0.5 : skill.successCount / totalUses;\n\n    // æ—¶é—´è¡°å‡ (Freshness): åŠè¡°æœŸçº¦ 14 å¤©\n    const idleDays = (now - skill.lastUsed) / (1000 * 60 * 60 * 24);\n    const freshness = Math.exp(-idleDays / 14);\n\n    // ç»¼åˆå¾—åˆ†: 45% æˆåŠŸç‡ + 35% æ–°é²œåº¦ + 20% ç½®ä¿¡åº¦\n    return (0.45 * successRate) + (0.35 * freshness) + (0.20 * skill.confidence);\n}\n\n/**\n * æ›´æ–°æŠ€èƒ½çŠ¶æ€ (æ‰§è¡Œåè°ƒç”¨)\n */\nexport function updateSkillStatus(skillId: string, success: boolean) {\n    const skill = skillLibrary.find(s => s.id === skillId);\n    if (!skill) return;\n\n    skill.lastUsed = Date.now();\n    if (success) {\n        skill.successCount++;\n        // æˆåŠŸå¥–åŠ±: ç½®ä¿¡åº¦ç¼“æ…¢æå‡\n        skill.confidence = Math.min(1, skill.confidence + 0.05);\n    } else {\n        skill.failureCount++;\n        // å¤±è´¥æƒ©ç½š: æƒ©ç½šåŠ›åº¦å¤§äºå¥–åŠ±ï¼Œé˜²æ­¢ç³»ç»Ÿâ€œè‡ªå—¨â€\n        skill.confidence = Math.max(0, skill.confidence - 0.1);\n    }\n\n    saveSkills(); // Persist changes\n}\n\n/**\n * è‡ªåŠ¨å­¦ä¹ æ–°æŠ€èƒ½\n */\nexport function learnSkillFromRecord(record: any, success: boolean = true) {\n    if (record.mode === 'chat' || !record.llmResult.plan) return;\n\n    const existingSkill = skillLibrary.find(s => s.name === record.llmResult.plan?.goal);\n\n    if (existingSkill) {\n        updateSkillStatus(existingSkill.id, success);\n        return;\n    }\n\n    // åªæœ‰æˆåŠŸçš„è®°å½•æ‰è¢«å­¦ä¸ºæ–°æŠ€èƒ½\n    if (!success) return;\n\n    const now = Date.now();\n    skillLibrary.push({\n        id: record.id,\n        name: record.llmResult.plan.goal,\n        description: `è‡ªåŠ¨å­¦ä¹ çš„æŠ€èƒ½: ${record.llmResult.plan.goal}`,\n        whenToUse: record.input.rawInput,\n        planTemplate: record.llmResult.plan,\n        successCount: 1,\n        failureCount: 0,\n        confidence: 0.5,\n        lastUsed: now,\n        createdAt: now,\n        enabled: true\n    });\n\n    // æ¯å­¦ä¹ ä¸€æ¬¡ï¼Œå°è¯•æ¸…ç†ä¸€æ¬¡â€œå†·â€æŠ€èƒ½\n    reapColdSkills();\n\n    saveSkills(); // Persist changes\n}\n\n/**\n * ç­›é€‰å¹¶æ’åºæŠ€èƒ½ (ç”¨äºæ³¨å…¥ Prompt)\n */\nexport function getRelevantSkills(input: string, limit: number = 3): Skill[] {\n    const now = Date.now();\n\n    return skillLibrary\n        // 1. åŸºç¡€ç­›é€‰: å‰”é™¤è¯„åˆ†è¿‡ä½çš„æŠ€èƒ½ (ç¡¬æ·˜æ±°é˜ˆå€¼ 0.3)\n        .filter(s => computeSkillScore(s, now) >= 0.3)\n        // 2. è¿‡æ»¤å·²ç¦ç”¨çš„æŠ€èƒ½\n        .filter(s => s.enabled !== false)\n        // 3. æ’åº: æŒ‰ç»¼åˆåˆ†æ’åº\n        .sort((a, b) => computeSkillScore(b, now) - computeSkillScore(a, now))\n        // 4. å–ä¸Šé™\n        .slice(0, limit);\n}\n\n/**\n * æ¸…ç†è¿‡æœŸæˆ–ä½è´¨æŠ€èƒ½ (Reaper)\n */\nexport function reapColdSkills() {\n    const now = Date.now();\n    const initialCount = skillLibrary.length;\n\n    skillLibrary = skillLibrary.filter(skill => {\n        const score = computeSkillScore(skill, now);\n        const idleDays = (now - skill.lastUsed) / (1000 * 60 * 60 * 24);\n\n        // æ»¡è¶³ä»¥ä¸‹ä»»ä¸€æ¡ä»¶åˆ™æ·˜æ±°:\n        // 1. å¾—åˆ†æä½ä¸”é•¿æœŸä¸ç”¨\n        if (score < 0.25 && idleDays > 30) return false;\n        // 2. å¤±è´¥ç‡æé«˜ä¸”å°è¯•è¿‡ä¸€å®šæ¬¡æ•°\n        if (skill.failureCount > 5 && (skill.successCount / (skill.successCount + skill.failureCount)) < 0.2) return false;\n\n        return true;\n    });\n\n    // å¼ºåˆ¶ä¿æŒå®¹é‡\n    if (skillLibrary.length > 100) {\n        // å¦‚æœè¿˜è¶…æ ‡ï¼Œç§»é™¤å¾—åˆ†æœ€ä½çš„é‚£ä¸ª\n        skillLibrary.sort((a, b) => computeSkillScore(a, now) - computeSkillScore(b, now));\n        skillLibrary.shift();\n    }\n\n    if (skillLibrary.length !== initialCount) {\n        saveSkills(); // Persist if changes happened\n    }\n}\n\nexport function getAllSkills(): Skill[] {\n    return [...skillLibrary];\n}\n",
    "tokens": 1172
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/recorder.ts",
    "content": "import { RuntimeEvent, EventRecorder } from './events';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { randomUUID } from 'crypto';\n\nexport class FileEventRecorder implements EventRecorder {\n  private events: RuntimeEvent[] = [];\n  private logFile: string;\n  private flushInterval: number = 1000;\n\n  constructor(logDir: string = '.yuangs_events') {\n    this.logFile = path.join(logDir, `events_${Date.now()}.jsonl`);\n  }\n\n  async record(event: RuntimeEvent): Promise<void> {\n    this.events.push(event);\n\n    if (this.events.length >= this.flushInterval) {\n      await this.flush();\n    }\n  }\n\n  async flush(): Promise<void> {\n    if (this.events.length === 0) return;\n\n    const logDir = path.dirname(this.logFile);\n    await fs.mkdir(logDir, { recursive: true });\n\n    const content = this.events\n      .map(e => JSON.stringify(e))\n      .join('\\n') + '\\n';\n\n    await fs.appendFile(this.logFile, content, 'utf8');\n    this.events = [];\n  }\n\n  getEvents(executionId?: string): RuntimeEvent[] {\n    if (!executionId) {\n      return [...this.events];\n    }\n\n    return this.events.filter(e => e.executionId === executionId);\n  }\n}\n\nexport const createEvent = (\n  executionId: string,\n  type: RuntimeEvent['type'],\n  data: RuntimeEvent['data'],\n  metadata?: RuntimeEvent['metadata']\n): RuntimeEvent => ({\n  id: randomUUID(),\n  timestamp: Date.now(),\n  executionId,\n  type,\n  data,\n  metadata\n});\n",
    "tokens": 353
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/events.ts",
    "content": "export type EventType = \n  | 'state_transition'\n  | 'llm_call'\n  | 'tool_execution'\n  | 'governance_decision'\n  | 'observation_recorded'\n  | 'evaluation_result'\n  | 'error_occurred';\n\nexport interface RuntimeEvent {\n  id: string;\n  timestamp: number;\n  executionId: string;\n  type: EventType;\n  data: {\n    from?: string;\n    to?: string;\n    action?: any;\n    decision?: any;\n    result?: any;\n    error?: string;\n  };\n  metadata?: Record<string, any>;\n}\n\nexport interface EventRecorder {\n  record(event: RuntimeEvent): void;\n  flush(): Promise<void>;\n  getEvents(executionId?: string): RuntimeEvent[];\n}\n",
    "tokens": 152
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/index.ts",
    "content": "export * from './events';\nexport * from './recorder';\nexport * from './replayer';\n",
    "tokens": 21
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/replayer.ts",
    "content": "import { RuntimeEvent } from './events';\n\nexport interface ReplayerOptions {\n  speed?: number;\n  stopOnError?: boolean;\n  dryRun?: boolean;\n}\n\nexport class EventReplayer {\n  private events: RuntimeEvent[] = [];\n  private currentIndex: number = 0;\n  private options: Required<ReplayerOptions>;\n\n  constructor(events: RuntimeEvent[], options: ReplayerOptions = {}) {\n    this.events = events;\n    this.options = {\n      speed: options.speed || 1,\n      stopOnError: options.stopOnError !== undefined ? options.stopOnError : true,\n      dryRun: options.dryRun || false\n    };\n  }\n\n  hasNext(): boolean {\n    return this.currentIndex < this.events.length;\n  }\n\n  next(): RuntimeEvent | null {\n    if (!this.hasNext()) {\n      return null;\n    }\n\n    return this.events[this.currentIndex++];\n  }\n\n  reset(): void {\n    this.currentIndex = 0;\n  }\n\n  async replay(onEvent: (event: RuntimeEvent, options: Required<ReplayerOptions>) => Promise<void>): Promise<void> {\n    this.reset();\n    let hasError = false;\n\n    while (this.hasNext() && !hasError) {\n      const event = this.next();\n\n      if (!event) break;\n\n      try {\n        await onEvent(event, this.options);\n\n        if (event.type === 'error_occurred') {\n          hasError = true;\n          if (this.options.stopOnError) {\n            break;\n          }\n        }\n\n        if (this.options.speed > 1) {\n          const delay = 100 / this.options.speed;\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      } catch (error: any) {\n        console.error(`[Replay] Error at event ${event.id}:`, error.message);\n        hasError = true;\n      }\n    }\n\n    return;\n  }\n\n  getSummary(): {\n    total: number;\n    completed: number;\n    errors: number;\n  } {\n    const errors = this.events.filter(e => e.type === 'error_occurred').length;\n    \n    return {\n      total: this.events.length,\n      completed: this.currentIndex,\n      errors\n    };\n  }\n}\n",
    "tokens": 483
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextManager.ts",
    "content": "import crypto from 'crypto';\nimport { GovernanceContext } from './state';\nimport { ContextBuffer } from './contextBuffer';\n\nexport class ContextManager {\n  private messages: Array<{ role: string; content: string; timestamp: number }> = [];\n  private contextBuffer: ContextBuffer;\n  private maxHistorySize = 50;\n\n  constructor(initialContext?: GovernanceContext) {\n    this.contextBuffer = new ContextBuffer();\n\n    if (initialContext?.history) {\n      this.messages = initialContext.history.map(msg => ({\n        ...msg,\n        timestamp: Date.now()\n      }));\n    }\n\n    if (initialContext?.input) {\n      this.addMessage('user', initialContext.input);\n    }\n  }\n\n  addMessage(role: string, content: string): void {\n    this.messages.push({\n      role,\n      content,\n      timestamp: Date.now()\n    });\n\n    if (this.messages.length > this.maxHistorySize) {\n      this.messages = this.messages.slice(-this.maxHistorySize);\n    }\n  }\n\n  addToolResult(toolName: string, result: string): void {\n    const content = `Tool ${toolName} returned:\\n${result}`;\n    this.addMessage('tool', content);\n  }\n\n  addObservation(observation: string): void {\n    this.addMessage('system', observation);\n  }\n\n  getMessages(): Array<{ role: 'system' | 'user' | 'assistant' | 'tool'; content: string }> {\n    return this.messages.map(({ role, content }) => ({\n      role: role as 'system' | 'user' | 'assistant' | 'tool',\n      content\n    }));\n  }\n\n  getContextBuffer(): ContextBuffer {\n    return this.contextBuffer;\n  }\n\n  addContextItem(item: Omit<import('./contextBuffer').ContextItem, 'tokens'>) {\n    this.contextBuffer.add(item);\n  }\n\n  async addContextItemAsync(item: Omit<import('./contextBuffer').ContextItem, 'tokens'>) {\n    await this.contextBuffer.addAsync(item);\n  }\n\n  buildContextPrompt(userInput: string, options?: import('./contextBuffer').BuildPromptOptions) {\n    return this.contextBuffer.buildPrompt(userInput, options);\n  }\n\n  getRecentMessages(count: number): Array<{ role: string; content: string; timestamp: number }> {\n    return this.messages.slice(-count);\n  }\n\n  getHash(): string {\n    const content = JSON.stringify(this.messages);\n    return crypto.createHash('sha256').update(content).digest('hex');\n  }\n\n  getSnapshot() {\n    return {\n      inputHash: this.getHash(),\n      systemPromptVersion: 'v1.0.0',\n      toolSetVersion: 'v1.0.0',\n      recentMessages: this.getRecentMessages(10)\n    };\n  }\n\n  clear(): void {\n    this.messages = [];\n    this.contextBuffer.clear();\n  }\n}\n",
    "tokens": 625
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/selectModel.ts",
    "content": "import { AgentIntent } from './types';\nimport { getUserConfig } from '../ai/client';\n\nexport function selectModel(\n    intent: AgentIntent,\n    override?: string\n): string {\n    if (override) return override;\n\n    const config = getUserConfig();\n    const defaultModel = config.defaultModel || 'Assistant';\n\n    return defaultModel;\n}\n",
    "tokens": 84
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextBuffer.ts",
    "content": "import { randomUUID } from 'crypto';\nimport { ContextImportance, createContextImportance, computeContextImportance } from './contextImportance';\nimport { summarizeContext } from './contextSummary';\n\nexport type ContextItem = {\n    type: 'file' | 'directory';\n    path: string;\n    id?: string;\n    importance?: ContextImportance;\n    alias?: string;\n    content: string;\n    summary?: string;\n    summarized?: boolean;\n    tokens: number;\n};\n\nexport type InjectionStrategy = 'ranked' | 'recent' | 'all';\n\nexport interface BuildPromptOptions {\n  maxTokens?: number;\n  strategy?: InjectionStrategy;\n}\n\nconst estimateTokens = (text: string) => Math.ceil(text.length / 4);\n\nexport class ContextBuffer {\n    private items: ContextItem[] = [];\n    private maxTokens = 32000; // çº¦ 12.8 ä¸‡å­—ç¬¦\n\n    async addAsync(item: Omit<ContextItem, 'tokens'>, bypassTokenLimit: boolean = false) {\n        const tokens = estimateTokens(item.content);\n        this.items.push({\n            ...item,\n            id: item.id ?? randomUUID(),\n            importance: item.importance ?? createContextImportance(item.path, item.type),\n            tokens\n        });\n        if (!bypassTokenLimit) {\n            await this.trimIfNeeded();\n        }\n    }\n\n    add(item: Omit<ContextItem, 'tokens'>, bypassTokenLimit: boolean = false) {\n        const tokens = estimateTokens(item.content);\n        this.items.push({\n            ...item,\n            id: item.id ?? randomUUID(),\n            importance: item.importance ?? createContextImportance(item.path, item.type),\n            tokens\n        });\n        if (!bypassTokenLimit) {\n            // å¯¹äºåŒæ­¥æ–¹æ³•ï¼Œæˆ‘ä»¬åªåšåŸºæœ¬ä¿®å‰ªï¼ˆä¸è¿›è¡Œæ‘˜è¦ï¼‰\n            this.basicTrimIfNeeded();\n        }\n    }\n\n    private basicTrimIfNeeded() {\n        while (this.totalTokens() > this.maxTokens) {\n            // æŒ‰é‡è¦æ€§è¯„åˆ†æ’åºï¼Œä½é‡è¦æ€§çš„åœ¨å‰é¢\n            this.items.sort((a, b) =>\n                computeContextImportance(a.importance!) -\n                computeContextImportance(b.importance!)\n            );\n\n            const removed = this.items.shift();\n\n            if (removed) {\n                console.log(\n                    `[Context Trim] removed low-importance: ${removed.path}`\n                );\n            }\n        }\n    }\n\n    clear() {\n        this.items = [];\n    }\n\n    list() {\n        return this.items.map((item, i) => ({\n            index: i + 1,\n            type: item.type,\n            path: item.path,\n            alias: item.alias,\n            tokens: item.tokens,\n            summary: item.summary\n        }));\n    }\n\n    isEmpty() {\n        return this.items.length === 0;\n    }\n\n    export() {\n        return this.items;\n    }\n\n    import(items: ContextItem[]) {\n        this.items = items;\n    }\n\n    private totalTokens() {\n        return this.items.reduce((sum, i) => sum + i.tokens, 0);\n    }\n\n    private async trimIfNeeded() {\n        while (this.totalTokens() > this.maxTokens) {\n            // 1. æ‰¾ä¸€ä¸ªã€Œå°šæœª summaryã€ä¸”é‡è¦æ€§æœ€ä½çš„\n            const candidates = this.items\n                .filter(i => !i.summarized)\n                .sort((a, b) =>\n                    computeContextImportance(a.importance!) -\n                    computeContextImportance(b.importance!)\n                );\n\n            if (candidates.length > 0) {\n                const candidate = candidates[0];\n\n                // 2. æ‰§è¡Œ summary\n                try {\n                    const summary = await summarizeContext({\n                        type: candidate.type,\n                        path: candidate.path,\n                        content: candidate.content\n                    });\n\n                    candidate.summary = summary;\n                    candidate.summarized = true;\n\n                    // 3. ç”¨ summary é‡æ–°è®¡ç®— token\n                    candidate.tokens = estimateTokens(summary);\n\n                    // 4. é‡Šæ”¾åŸå§‹å†…å®¹ä»¥èŠ‚çœå†…å­˜ï¼ˆä¿ç•™åŸå§‹å†…å®¹çš„æ ‡è®°ï¼‰\n                    const originalContentSize = estimateTokens(candidate.content);\n                    candidate.content = `[ARCHIVED: Original content was ${originalContentSize} tokens, summarized to ${candidate.tokens} tokens]`;\n\n                    console.log(\n                        `[Context Summary] ${candidate.path} reduced from ${originalContentSize} to ${candidate.tokens} tokens`\n                    );\n\n                    continue; // é‡æ–°è¯„ä¼°tokenæ•°é‡\n                } catch (error) {\n                    console.warn(`[Context Summary] Failed to summarize ${candidate.path}:`, error);\n                }\n            }\n\n            // å¦‚æœæ²¡æœ‰å¯æ‘˜è¦çš„é¡¹æˆ–æ‘˜è¦å¤±è´¥ï¼Œåˆ™æŒ‰é‡è¦æ€§åˆ é™¤\n            this.items.sort((a, b) =>\n                computeContextImportance(a.importance!) -\n                computeContextImportance(b.importance!)\n            );\n\n            const removed = this.items.shift();\n\n            if (removed) {\n                console.log(\n                    `[Context Trim] removed low-importance: ${removed.path}`\n                );\n            }\n        }\n    }\n\n    /**\n     * è®¡ç®—ContextItemçš„ç»¼åˆè¯„åˆ†\n     * @param item ContextItem\n     * @returns è¯„åˆ†å€¼\n     */\n    private computeItemScore(item: ContextItem): number {\n        if (!item.importance) {\n            // å¦‚æœæ²¡æœ‰é‡è¦æ€§ä¿¡æ¯ï¼Œé»˜è®¤ä¸ºä¸­ç­‰è¯„åˆ†\n            return 0.5;\n        }\n\n        const baseScore = computeContextImportance(item.importance);\n\n        // ä½¿ç”¨æ¬¡æ•°çš„å½±å“ï¼ˆå¯¹æ•°å¢é•¿ï¼Œé¿å…è¿‡åº¦æ”¾å¤§ï¼‰\n        const useFactor = Math.log(1 + item.importance.useCount);\n\n        // æ–°é²œåº¦è¡°å‡ï¼ˆæœ€è¿‘ä½¿ç”¨çš„é¡¹ç›®è·å¾—æ›´é«˜è¯„åˆ†ï¼‰\n        const now = Date.now();\n        const daysSinceLastUse = (now - item.importance.lastUsed) / (1000 * 60 * 60 * 24);\n        const freshnessFactor = Math.exp(-daysSinceLastUse / 7); // 7å¤©åŠè¡°æœŸ\n\n        return baseScore * useFactor * freshnessFactor;\n    }\n\n    /**\n     * æ ¹æ®ç­–ç•¥å¯¹ContextItemsè¿›è¡Œæ’åº\n     * @param items ContextItemæ•°ç»„\n     * @param strategy æ’åºç­–ç•¥\n     * @returns æ’åºåçš„æ•°ç»„\n     */\n    private sortItemsByStrategy(items: ContextItem[], strategy: InjectionStrategy): ContextItem[] {\n        switch (strategy) {\n            case 'ranked':\n                // æŒ‰ç»¼åˆè¯„åˆ†é™åºæ’åˆ—\n                return [...items].sort((a, b) =>\n                    this.computeItemScore(b) - this.computeItemScore(a)\n                );\n            case 'recent':\n                // æŒ‰æœ€è¿‘ä½¿ç”¨æ—¶é—´é™åºæ’åˆ—\n                return [...items].sort((a, b) =>\n                    (b.importance?.lastUsed || 0) - (a.importance?.lastUsed || 0)\n                );\n            case 'all':\n            default:\n                // ä¿æŒåŸæœ‰é¡ºåº\n                return [...items];\n        }\n    }\n\n    buildPrompt(userInput: string, options: BuildPromptOptions = {}): string {\n        const { maxTokens, strategy = 'ranked' } = options;\n\n        if (this.isEmpty()) return userInput;\n\n        // æ ¹æ®ç­–ç•¥æ’åºitems\n        const sortedItems = this.sortItemsByStrategy([...this.items], strategy);\n\n        // å¦‚æœæŒ‡å®šäº†maxTokensï¼Œæˆ‘ä»¬éœ€è¦æˆªæ–­å†…å®¹ä»¥æ»¡è¶³é™åˆ¶\n        let filteredItems = sortedItems;\n        if (maxTokens) {\n            filteredItems = [];\n            let currentTokens = 0;\n\n            for (const item of sortedItems) {\n                if (currentTokens + item.tokens > maxTokens) {\n                    break;\n                }\n                filteredItems.push(item);\n                currentTokens += item.tokens;\n            }\n        }\n\n        // æŒ‰é‡è¦æ€§åˆ†ç»„\n        const highConfidenceItems = filteredItems.filter(item =>\n            item.importance && computeContextImportance(item.importance) > 0.7\n        );\n        const mediumConfidenceItems = filteredItems.filter(item =>\n            item.importance &&\n            computeContextImportance(item.importance) > 0.3 &&\n            computeContextImportance(item.importance) <= 0.7\n        );\n        const lowConfidenceItems = filteredItems.filter(item =>\n            !item.importance || computeContextImportance(item.importance) <= 0.3\n        );\n\n        // æ„å»ºä¸åŒéƒ¨åˆ†çš„ä¸Šä¸‹æ–‡\n        const sections = [];\n\n        if (highConfidenceItems.length > 0) {\n            const highConfidenceBlock = highConfidenceItems.map(item => {\n                const title = item.alias\n                    ? `[Reference] ${item.type}: ${item.alias} (${item.path})`\n                    : `[Reference] ${item.type}: ${item.path}`;\n\n                const body = item.summary ?? item.content;\n\n                return `${title}\\n---\\n${body}\\n---`;\n            }).join('\\n\\n');\n\n            sections.push(`# Background Knowledge (High Confidence)\\n${highConfidenceBlock}`);\n        }\n\n        if (mediumConfidenceItems.length > 0) {\n            const mediumConfidenceBlock = mediumConfidenceItems.map(item => {\n                const title = item.alias\n                    ? `[Reference] ${item.type}: ${item.alias} (${item.path})`\n                    : `[Reference] ${item.type}: ${item.path}`;\n\n                const body = item.summary ?? item.content;\n\n                return `${title}\\n---\\n${body}\\n---`;\n            }).join('\\n\\n');\n\n            sections.push(`# Supporting Information (Medium Confidence)\\n${mediumConfidenceBlock}`);\n        }\n\n        if (lowConfidenceItems.length > 0) {\n            const lowConfidenceBlock = lowConfidenceItems.map(item => {\n                const title = item.alias\n                    ? `[Reference] ${item.type}: ${item.alias} (${item.path})`\n                    : `[Reference] ${item.type}: ${item.path}`;\n\n                const body = item.summary ?? item.content;\n\n                return `${title}\\n---\\n${body}\\n---`;\n            }).join('\\n\\n');\n\n            sections.push(`# Archived References (Low Confidence)\\n${lowConfidenceBlock}`);\n        }\n\n        const contextBlock = sections.join('\\n\\n');\n\n        return `\n${contextBlock}\n\n# Task Instructions\nBased on the provided context (if any), answer the user's question. If the context contains source code, treat it as your \"source of truth.\"\n\nUser Question:\n${userInput}\n`;\n    }\n}\n// Test change for git diff\n// Another test change (unstaged)\n",
    "tokens": 2441
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/engine.ts",
    "content": "import { Policy, PolicyContext, PolicyResult } from './types';\nimport { RiskLevel } from '../state';\n\nexport class PolicyEngine {\n  private policies: Map<string, Policy> = new Map();\n\n  registerPolicy(policy: Policy): void {\n    this.policies.set(policy.name, policy);\n  }\n\n  unregisterPolicy(name: string): void {\n    this.policies.delete(name);\n  }\n\n  async evaluate(context: PolicyContext): Promise<PolicyResult> {\n    let finalResult: PolicyResult = {\n      allowed: true,\n      reason: 'All policies passed'\n    };\n\n    for (const [name, policy] of this.policies) {\n      const result = await policy.evaluate(context);\n      \n      if (!result.allowed) {\n        return {\n          allowed: false,\n          reason: `Policy \"${name}\" blocked: ${result.reason}`,\n          requiresEscalation: result.requiresEscalation || false,\n          suggestedActions: result.suggestedActions\n        };\n      }\n\n      if (result.requiresEscalation) {\n        finalResult.requiresEscalation = true;\n        finalResult.suggestedActions = result.suggestedActions;\n      }\n    }\n\n    return finalResult;\n  }\n\n  evaluateRisk(action: { type: string; payload: any }): RiskLevel {\n    const { type, payload } = action;\n\n    if (type === 'tool_call') {\n      const toolName = payload.tool_name;\n      \n      const lowRiskTools = ['read_file', 'list_files', 'web_search'];\n      if (lowRiskTools.includes(toolName)) {\n        return 'low';\n      }\n\n      const mediumRiskTools = ['write_file', 'shell'];\n      if (mediumRiskTools.includes(toolName)) {\n        const cmd = payload.parameters?.command || payload.command || '';\n        if (this.containsDangerousCommand(cmd)) {\n          return 'high';\n        }\n        return 'medium';\n      }\n\n      return 'medium';\n    }\n\n    if (type === 'shell_cmd') {\n      const cmd = payload.command || '';\n      if (this.containsDangerousCommand(cmd)) {\n        return 'high';\n      }\n      return 'medium';\n    }\n\n    return 'low';\n  }\n\n  private containsDangerousCommand(cmd: string): boolean {\n    const dangerousPatterns = [\n      /rm\\s+-rf\\s+\\//,\n      /rm\\s+-rf\\s+~/,\n      />\\s*\\/dev\\/null/,\n      /dd\\s+if=/,\n      /mkfs/,\n      /format/,\n      /sudo\\s+rm/\n    ];\n\n    return dangerousPatterns.some(pattern => pattern.test(cmd));\n  }\n}\n\nexport const policyEngine = new PolicyEngine();\n",
    "tokens": 580
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/policies/noDangerousShell.ts",
    "content": "import { Policy, PolicyContext, PolicyResult } from '../types';\nimport { RiskLevel } from '../../state';\n\nexport class NoDangerousShellPolicy implements Policy {\n  name = 'no-dangerous-shell';\n  description = 'Prevents execution of dangerous shell commands';\n\n  evaluate(context: PolicyContext): PolicyResult {\n    const { action } = context;\n\n    if (action.type === 'shell_cmd') {\n      const command = action.payload?.command || '';\n      \n      const dangerousPatterns = [\n        { pattern: /rm\\s+-rf\\s+\\//, name: 'rm -rf /', risk: 'high' },\n        { pattern: /rm\\s+-rf\\s+~/, name: 'rm -rf ~', risk: 'high' },\n        { pattern: />\\s*\\/dev\\/null/, name: 'Redirect to /dev/null', risk: 'medium' },\n        { pattern: /dd\\s+if=/, name: 'dd command', risk: 'high' },\n        { pattern: /mkfs/, name: 'mkfs (filesystem creation)', risk: 'high' },\n        { pattern: /format/, name: 'format command', risk: 'high' },\n        { pattern: /sudo\\s+rm/, name: 'sudo rm', risk: 'high' },\n        { pattern: /chmod\\s+777\\s+\\/(?!dev)/, name: 'chmod 777 on system', risk: 'high' },\n        { pattern: /:\\s*~\\(\\)/, name: 'fork bomb', risk: 'high' }\n      ];\n\n      for (const { pattern, name, risk } of dangerousPatterns) {\n        if (pattern.test(command)) {\n          return {\n            allowed: false,\n            reason: `Dangerous command detected: ${name} (${risk} risk)`,\n            requiresEscalation: risk === 'high',\n            suggestedActions: [\n              `Review the command: \"${command}\"`,\n              'Consider using safer alternatives',\n              'Break down the operation into smaller, safer steps'\n            ]\n          };\n        }\n      }\n    }\n\n    return {\n      allowed: true,\n      reason: 'No dangerous patterns detected'\n    };\n  }\n}\n\nexport const noDangerousShellPolicy = new NoDangerousShellPolicy();\n",
    "tokens": 460
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/types.ts",
    "content": "import { RiskLevel } from '../state';\n\nexport interface PolicyContext {\n  action: {\n    type: string;\n    payload: any;\n  };\n  user?: {\n    permissions: string[];\n  };\n  environment?: {\n    isProduction: boolean;\n  };\n}\n\nexport interface PolicyResult {\n  allowed: boolean;\n  reason?: string;\n  requiresEscalation?: boolean;\n  suggestedActions?: string[];\n}\n\nexport interface Policy {\n  name: string;\n  description: string;\n  evaluate(context: PolicyContext): PolicyResult | Promise<PolicyResult>;\n}\n",
    "tokens": 125
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/index.ts",
    "content": "export * from './types';\nexport * from './engine';\nexport * from './policies/noDangerousShell';\n",
    "tokens": 24
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/replayExplain.ts",
    "content": "import { ExecutionTurn } from './state';\nimport { ExecutionRecorder } from './executionRecorder';\nimport { generateSkillHintsFromContext, formatSkillHints, ContextSkillHint } from './contextSkillBridge';\nimport { ContextManager } from './contextManager';\n\nexport function explainExecution(recorder: ExecutionRecorder, contextManager?: ContextManager): string {\n  const turns = recorder.getTurns();\n  const summary = recorder.getSummary();\n\n  const lines: string[] = [];\n\n  lines.push('# Execution Explanation Report');\n  lines.push('');\n  lines.push('## Summary');\n  lines.push(`- Total Turns: ${summary.totalTurns}`);\n  lines.push(`- Added Context Items: ${summary.totalAddedContext}`);\n  lines.push(`- Removed Context Items: ${summary.totalRemovedContext}`);\n  lines.push(`- Changed Context Items: ${summary.totalChangedContext}`);\n  lines.push('');\n\n  // å¦‚æœæä¾›äº†ContextManagerï¼Œç”ŸæˆSkill Hints\n  if (contextManager) {\n    const contextItems = contextManager.getContextBuffer().export();\n    const skillHints = generateSkillHintsFromContext(contextItems);\n\n    if (skillHints.length > 0) {\n      lines.push('## Skill Suggestions from Context');\n      lines.push(formatSkillHints(skillHints));\n      lines.push('');\n    }\n  }\n\n  lines.push('## Detailed Turn-by-Turn Analysis');\n  lines.push('');\n\n  for (const turn of turns) {\n    lines.push(`### Turn ${turn.turnId}`);\n    lines.push('');\n\n    if (turn.startTime) {\n      lines.push(`- Start Time: ${new Date(turn.startTime).toISOString()}`);\n    }\n\n    if (turn.endTime) {\n      lines.push(`- End Time: ${new Date(turn.endTime).toISOString()}`);\n    }\n\n    if (turn.contextDiff) {\n      lines.push('');\n      lines.push('#### Context Changes:');\n\n      if (turn.contextDiff.added.length > 0) {\n        lines.push('- Added:');\n        for (const item of turn.contextDiff.added) {\n          lines.push(`  - ${item}`);\n        }\n      }\n\n      if (turn.contextDiff.removed.length > 0) {\n        lines.push('- Removed:');\n        for (const item of turn.contextDiff.removed) {\n          lines.push(`  - ${item}`);\n        }\n      }\n\n      if (turn.contextDiff.changed.length > 0) {\n        lines.push('- Changed:');\n        for (const item of turn.contextDiff.changed) {\n          lines.push(`  - ${item}`);\n        }\n      }\n    }\n\n    if (turn.proposedAction) {\n      lines.push('');\n      lines.push(`#### Action Type: ${turn.proposedAction.type}`);\n      lines.push(`- Reasoning: ${turn.proposedAction.reasoning}`);\n    }\n\n    if (turn.governance) {\n      lines.push('');\n      lines.push(`#### Governance Decision: ${turn.governance.status}`);\n      if (turn.governance.reason) {\n        lines.push(`- Reason: ${turn.governance.reason}`);\n      }\n      lines.push(`- Decided by: ${turn.governance.by}`);\n    }\n\n    if (turn.executionResult) {\n      lines.push('');\n      lines.push(`#### Execution Result: ${turn.executionResult.success ? 'SUCCESS' : 'FAILURE'}`);\n      if (turn.executionResult.error) {\n        lines.push(`- Error: ${turn.executionResult.error}`);\n      }\n    }\n\n    lines.push('');\n  }\n\n  return lines.join('\\n');\n}\n\nexport function replayExecution(recorder: ExecutionRecorder, options: { showContextDiff?: boolean } = {}): string {\n  const { showContextDiff = true } = options;\n  const turns = recorder.getTurns();\n  const lines: string[] = [];\n\n  lines.push('# Execution Replay');\n  lines.push('');\n\n  for (const turn of turns) {\n    lines.push(`## Turn ${turn.turnId}`);\n    \n    if (showContextDiff && turn.contextDiff) {\n      lines.push('');\n      lines.push('### Context Diff:');\n      \n      if (turn.contextDiff.added.length > 0) {\n        lines.push('Added:');\n        for (const item of turn.contextDiff.added) {\n          lines.push(`  + ${item}`);\n        }\n      }\n      \n      if (turn.contextDiff.removed.length > 0) {\n        lines.push('Removed:');\n        for (const item of turn.contextDiff.removed) {\n          lines.push(`  - ${item}`);\n        }\n      }\n      \n      if (turn.contextDiff.changed.length > 0) {\n        lines.push('Changed:');\n        for (const item of turn.contextDiff.changed) {\n          lines.push(`  ~ ${item}`);\n        }\n      }\n      \n      if (!turn.contextDiff.added.length && \n          !turn.contextDiff.removed.length && \n          !turn.contextDiff.changed.length) {\n        lines.push('(No context changes)');\n      }\n    }\n    \n    if (turn.proposedAction) {\n      lines.push('');\n      lines.push(`Action: ${turn.proposedAction.type}`);\n      lines.push(`Reasoning: ${turn.proposedAction.reasoning}`);\n    }\n    \n    if (turn.executionResult) {\n      lines.push('');\n      lines.push(`Result: ${turn.executionResult.success ? 'SUCCESS' : 'FAILURE'}`);\n    }\n    \n    lines.push('');\n  }\n\n  return lines.join('\\n');\n}",
    "tokens": 1186
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/ai/prompt.ts",
    "content": "import { OSProfile } from '../core/os';\nimport type { Macro } from '../core/validation';\n\nexport function buildCommandPrompt(\n    userInput: string,\n    os: OSProfile,\n    macros?: Record<string, Macro>,\n    context?: string\n): string {\n    const macroContext = macros && Object.keys(macros).length > 0\n        ? `\nã€å¯å¤ç”¨çš„å¿«æ·æŒ‡ä»¤ (Macros)ã€‘\nä»¥ä¸‹æ˜¯å¯ä»¥ç›´æ¥å¤ç”¨çš„å·²éªŒè¯å‘½ä»¤ã€‚ä¼˜å…ˆå¤ç”¨è¿™äº›æŒ‡ä»¤ï¼Œè€Œä¸æ˜¯ç”Ÿæˆæ–°å‘½ä»¤ï¼š\n\n${Object.entries(macros).map(([name, macro]) => `  - ${name}: ${macro.description || '(æ— æè¿°)'}`).join('\\n')}\n\nå½“ç”¨æˆ·çš„éœ€æ±‚ä¸æŸä¸ª Macro åŒ¹é…æˆ–ç›¸ä¼¼æ—¶ï¼š\n1. ä¼˜å…ˆä½¿ç”¨è¯¥ Macro\n2. åœ¨ JSON è¾“å‡ºä¸­ä½¿ç”¨ \"macro\" å­—æ®µæŒ‡å®š Macro åç§°ï¼Œè€Œä¸æ˜¯ \"command\" å­—æ®µ\n3. ä»…åœ¨æ²¡æœ‰åˆé€‚ Macro æ—¶æ‰ç”Ÿæˆæ–°å‘½ä»¤\n`\n        : '';\n\n    return `\nä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å‘½ä»¤è¡Œä¸“å®¶ã€‚\n\nã€ç³»ç»Ÿç¯å¢ƒã€‘\n- æ“ä½œç³»ç»Ÿ: ${os.name}\n- Shell: ${os.shell}\n- find å®ç°: ${os.find}\n- stat å®ç°: ${os.stat}\n\nã€è§„åˆ™ã€‘\n- å‘½ä»¤å¿…é¡»ä¸å½“å‰ç³»ç»Ÿå…¼å®¹ã€‚\n- å¦‚æœæ˜¯ macOS (BSD):\n  - ä¸å…è®¸ä½¿ç”¨ find -printf\n  - ä¼˜å…ˆä½¿ç”¨ stat -f\n- å¦‚æœæ˜¯ Linux (GNU):\n  - å¯ä½¿ç”¨ find -printf\n- é»˜è®¤ä¸ä½¿ç”¨ sudoã€‚\n- ç¡®ä¿è¾“å‡ºçš„å‘½ä»¤æ˜¯å•è¡Œæˆ–è€…ä½¿ç”¨ && è¿æ¥ã€‚\n- ä¸è¦è§£é‡Šï¼Œåªè¾“å‡ºç¬¦åˆä»¥ä¸‹ JSON ç»“æ„çš„æ–‡æœ¬ã€‚\n- ä¼˜å…ˆå¤ç”¨å·²éªŒè¯çš„å¿«æ·æŒ‡ä»¤ï¼ˆMacrosï¼‰ï¼Œæ¯ä¸ª Macro éƒ½æ˜¯ç»è¿‡äººå·¥éªŒè¯çš„å¯é å‘½ä»¤ã€‚åœ¨ç”Ÿæˆæ–°å‘½ä»¤å‰ï¼Œæ£€æŸ¥æ˜¯å¦å·²æœ‰ Macro å¯ä»¥å®Œæˆä»»åŠ¡ã€‚\n\n${macroContext}\n\nã€è¾“å‡º JSON ç»“æ„ã€‘\n{\n  \"plan\": \"ç®€è¦è¯´æ˜ä½ å‡†å¤‡æ‰§è¡Œçš„æ­¥éª¤\",\n  \"command\": \"å¯ç›´æ¥æ‰§è¡Œçš„ shell å‘½ä»¤ï¼ˆä»…å½“æ²¡æœ‰åˆé€‚ Macro æ—¶æä¾›ï¼‰\",\n  \"macro\": \"è¦å¤ç”¨çš„ Macro åç§°ï¼ˆä¼˜å…ˆä½¿ç”¨ï¼Œä¸ command äºŒé€‰ä¸€ï¼‰\",\n  \"risk\": \"low | medium | high\"\n}\n\nã€ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‘\n${context || 'æ— '}\n\nã€ç”¨æˆ·éœ€æ±‚ã€‘\n${userInput}\n`;\n}\n\nexport function buildFixPrompt(\n    originalCmd: string,\n    stderr: string,\n    os: OSProfile\n): string {\n    return `\nè¯¥å‘½ä»¤åœ¨ ${os.name} ä¸Šæ‰§è¡Œå¤±è´¥ï¼š\n\nå‘½ä»¤ï¼š\n${originalCmd}\n\né”™è¯¯ä¿¡æ¯ï¼š\n${stderr}\n\nè¯·ç”Ÿæˆä¸€ä¸ª **${os.name} å…¼å®¹** çš„ç­‰ä»·å‘½ä»¤ã€‚\nä¾ç„¶åªè¾“å‡º JSON æ ¼å¼ã€‚æ³¨æ„ï¼šè¿™æ˜¯ä¿®å¤å‘½ä»¤ï¼Œä¸éœ€è¦æ£€æŸ¥ Macroã€‚\n\n{\n  \"plan\": \"ä¿®å¤è¯´æ˜\",\n  \"command\": \"ä¿®å¤åçš„å‘½ä»¤\",\n  \"risk\": \"low | medium | high\"\n}\n`;\n}\n",
    "tokens": 393
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/ai/types.ts",
    "content": "export { AICommandPlan, type AICommandPlan as AICommandPlanType } from '../core/validation';\n",
    "tokens": 24
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/ai/client.ts",
    "content": "import axios from 'axios';\nimport fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { DEFAULT_AI_PROXY_URL, DEFAULT_MODEL, DEFAULT_ACCOUNT_TYPE, type UserConfig, type AIRequestMessage } from '../core/validation';\nimport { loadChatHistory, saveChatHistory } from '../agent/chatHistoryStorage';\n\nconst CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');\n\nlet conversationHistory: AIRequestMessage[] = [];\n\n// åˆå§‹åŒ–æ—¶åŠ è½½æŒä¹…åŒ–çš„èŠå¤©å†å²è®°å½•\nloadChatHistory().then(history => {\n    conversationHistory = history;\n});\n\nexport function addToConversationHistory(role: 'system' | 'user' | 'assistant', content: string) {\n    conversationHistory.push({ role, content });\n    if (conversationHistory.length > 20) {\n        conversationHistory = conversationHistory.slice(-20);\n    }\n    // åŒæ—¶ä¿å­˜åˆ°æŒä¹…åŒ–å­˜å‚¨\n    saveChatHistory(conversationHistory);\n}\n\nexport function clearConversationHistory() {\n    conversationHistory = [];\n    // åŒæ—¶æ¸…é™¤æŒä¹…åŒ–å­˜å‚¨\n    saveChatHistory(conversationHistory);\n}\n\nexport function getConversationHistory() {\n    return conversationHistory;\n}\n\nexport function getUserConfig(): UserConfig {\n    if (fs.existsSync(CONFIG_FILE)) {\n        try {\n            const content = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(content) as UserConfig;\n        } catch (e) { }\n    }\n    return {};\n}\n\nexport async function askAI(prompt: string, model?: string): Promise<string> {\n    const config = getUserConfig();\n    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;\n\n    const headers = {\n        'Content-Type': 'application/json',\n        'X-Client-ID': 'vscode',\n        'Origin': 'https://cli.want.biz',\n        'Referer': 'https://cli.want.biz/',\n        'account': config.accountType || DEFAULT_ACCOUNT_TYPE,\n        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',\n        'Accept': 'application/json'\n    };\n\n    const data = {\n        model: model || config.defaultModel || DEFAULT_MODEL,\n        messages: [{ role: 'user', content: prompt }],\n        stream: false\n    };\n\n    try {\n        const response = await axios.post(url, data, { headers });\n        const content = response.data?.choices?.[0]?.message?.content;\n        return content || '';\n    } catch (error: any) {\n        const errorMsg = error.response?.data?.error?.message || error.response?.data?.message || error.message || 'æœªçŸ¥é”™è¯¯';\n        throw new Error(`AI è¯·æ±‚å¤±è´¥: ${errorMsg}`);\n    }\n}\n\nexport async function callAI_Stream(messages: AIRequestMessage[], model: string | undefined, onChunk: (content: string) => void): Promise<void> {\n    const config = getUserConfig();\n    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;\n\n    const response = await axios({\n        method: 'post',\n        url: url,\n        data: {\n            model: model || config.defaultModel || DEFAULT_MODEL,\n            messages: messages,\n            stream: true\n        },\n        responseType: 'stream',\n        headers: {\n            'Content-Type': 'application/json',\n            'X-Client-ID': 'vscode',\n            'Origin': 'https://cli.want.biz',\n            'Referer': 'https://cli.want.biz/',\n            'account': config.accountType || DEFAULT_ACCOUNT_TYPE,\n            'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',\n            'Accept': 'application/json'\n        }\n    });\n\n    return new Promise((resolve, reject) => {\n        let buffer = '';\n        response.data.on('data', (chunk: Buffer) => {\n            buffer += chunk.toString();\n            let lines = buffer.split('\\n');\n            buffer = lines.pop() || '';\n\n            for (const line of lines) {\n                const trimmedLine = line.trim();\n                if (trimmedLine.startsWith('data: ')) {\n                    const data = trimmedLine.slice(6);\n                    if (data === '[DONE]') {\n                        resolve();\n                        return;\n                    }\n                    try {\n                        const parsed = JSON.parse(data);\n                        const content = parsed.choices[0]?.delta?.content || '';\n                        if (content) onChunk(content);\n                    } catch (e) { }\n                }\n            }\n        });\n        response.data.on('error', reject);\n        response.data.on('end', () => {\n            resolve();\n        });\n    });\n}\n",
    "tokens": 1127
  },
  {
    "type": "file",
    "path": "src/engine/ai/client.ts",
    "content": "import axios from 'axios';\nimport fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { DEFAULT_AI_PROXY_URL, DEFAULT_MODEL, DEFAULT_ACCOUNT_TYPE, type UserConfig, type AIRequestMessage } from '../core/validation';\nimport { loadChatHistory, saveChatHistory } from '../agent/chatHistoryStorage';\n\nconst CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');\n\nlet conversationHistory: AIRequestMessage[] = [];\n\n// åˆå§‹åŒ–æ—¶åŠ è½½æŒä¹…åŒ–çš„èŠå¤©å†å²è®°å½•\nloadChatHistory().then(history => {\n    conversationHistory = history;\n});\n\nexport function addToConversationHistory(role: 'system' | 'user' | 'assistant', content: string) {\n    conversationHistory.push({ role, content });\n    if (conversationHistory.length > 20) {\n        conversationHistory = conversationHistory.slice(-20);\n    }\n    // åŒæ—¶ä¿å­˜åˆ°æŒä¹…åŒ–å­˜å‚¨\n    saveChatHistory(conversationHistory);\n}\n\nexport function clearConversationHistory() {\n    conversationHistory = [];\n    // åŒæ—¶æ¸…é™¤æŒä¹…åŒ–å­˜å‚¨\n    saveChatHistory(conversationHistory);\n}\n\nexport function getConversationHistory() {\n    return conversationHistory;\n}\n\nexport function getUserConfig(): UserConfig {\n    if (fs.existsSync(CONFIG_FILE)) {\n        try {\n            const content = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(content) as UserConfig;\n        } catch (e) { }\n    }\n    return {};\n}\n\nexport async function askAI(prompt: string, model?: string): Promise<string> {\n    const config = getUserConfig();\n    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;\n\n    const headers = {\n        'Content-Type': 'application/json',\n        'X-Client-ID': 'vscode',\n        'Origin': 'https://cli.want.biz',\n        'Referer': 'https://cli.want.biz/',\n        'account': config.accountType || DEFAULT_ACCOUNT_TYPE,\n        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',\n        'Accept': 'application/json'\n    };\n\n    const data = {\n        model: model || config.defaultModel || DEFAULT_MODEL,\n        messages: [{ role: 'user', content: prompt }],\n        stream: false\n    };\n\n    try {\n        const response = await axios.post(url, data, { headers });\n        const content = response.data?.choices?.[0]?.message?.content;\n        return content || '';\n    } catch (error: any) {\n        const errorMsg = error.response?.data?.error?.message || error.response?.data?.message || error.message || 'æœªçŸ¥é”™è¯¯';\n        throw new Error(`AI è¯·æ±‚å¤±è´¥: ${errorMsg}`);\n    }\n}\n\nexport async function callAI_Stream(messages: AIRequestMessage[], model: string | undefined, onChunk: (content: string) => void): Promise<void> {\n    const config = getUserConfig();\n    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;\n\n    const response = await axios({\n        method: 'post',\n        url: url,\n        data: {\n            model: model || config.defaultModel || DEFAULT_MODEL,\n            messages: messages,\n            stream: true\n        },\n        responseType: 'stream',\n        headers: {\n            'Content-Type': 'application/json',\n            'X-Client-ID': 'vscode',\n            'Origin': 'https://cli.want.biz',\n            'Referer': 'https://cli.want.biz/',\n            'account': config.accountType || DEFAULT_ACCOUNT_TYPE,\n            'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',\n            'Accept': 'application/json'\n        }\n    });\n\n    return new Promise((resolve, reject) => {\n        let buffer = '';\n        response.data.on('data', (chunk: Buffer) => {\n            buffer += chunk.toString();\n            let lines = buffer.split('\\n');\n            buffer = lines.pop() || '';\n\n            for (const line of lines) {\n                const trimmedLine = line.trim();\n                if (trimmedLine.startsWith('data: ')) {\n                    const data = trimmedLine.slice(6);\n                    if (data === '[DONE]') {\n                        resolve();\n                        return;\n                    }\n                    try {\n                        const parsed = JSON.parse(data);\n                        const content = parsed.choices[0]?.delta?.content || '';\n                        if (content) onChunk(content);\n                    } catch (e) { }\n                }\n            }\n        });\n        response.data.on('error', reject);\n        response.data.on('end', () => {\n            resolve();\n        });\n    });\n}\n",
    "tokens": 1127
  }
]