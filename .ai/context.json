[
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/prompt.ts",
    "content": "import {\n    AgentIntent,\n    AgentContext,\n    AgentMode,\n    AgentPrompt,\n} from './types';\nimport { buildCommandPrompt as buildCommandPromptString } from '../ai/prompt';\nimport { getOSProfile } from '../core/os';\nimport { getMacros } from '../core/macros';\nimport { aiCommandPlanSchema } from '../core/validation';\nimport { getRelevantSkills } from './skills';\n\nexport function buildPrompt(\n    intent: AgentIntent,\n    context: AgentContext,\n    mode: AgentMode,\n    input: string\n): AgentPrompt {\n    if (mode === 'chat') {\n        return buildChatPrompt(context, input);\n    }\n\n    return buildCommandPromptObject(input, context);\n}\n\nfunction buildChatPrompt(\n    context: AgentContext,\n    input: string\n): AgentPrompt {\n    const messages: any[] = [\n        ...(context.history ?? []),\n    ];\n\n    // Add context files if available\n    if (context.files && context.files.length > 0) {\n        const contextDesc = context.files.map(f =>\n            `File: ${f.path}\\n\\`\\`\\`\\n${f.content}\\n\\`\\`\\``\n        ).join('\\n\\n');\n\n        messages.push({\n            role: 'system',\n            content: `Context:\\n${contextDesc}`,\n        });\n    }\n\n    messages.push({\n        role: 'user',\n        content: input,\n    });\n\n    return {\n        system: 'You are a helpful AI assistant with expertise in software development, system administration, and problem-solving.',\n        messages,\n    };\n}\n\nfunction buildCommandPromptObject(\n    input: string,\n    context: AgentContext\n): AgentPrompt {\n    const os = getOSProfile();\n    const macros = getMacros();\n    const skills = getRelevantSkills(input);\n    let promptText = buildCommandPromptString(input, os, macros);\n\n    if (skills.length > 0) {\n        const skillList = skills.map(s => `- ${s.name}: 当遇到 \"${s.whenToUse}\" 时，你可以参考计划: ${s.planTemplate.goal}`).join('\\n');\n        promptText = `【参考技能库】\\n${skillList}\\n\\n${promptText}`;\n    }\n\n    return {\n        messages: [\n            {\n                role: 'user',\n                content: promptText,\n            },\n        ],\n        outputSchema: aiCommandPlanSchema,\n    };\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/prompt.ts:1769134473140",
    "tokens": 522,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextSkillBridge.ts",
    "content": "import { ContextItem } from './contextBuffer';\nimport { Skill } from './skills';\nimport { ContextToSkillPromotionRules } from './contextSkillPromotion';\nimport { recordEdge } from './knowledgeGraph';\n\nexport interface ContextSkillHint {\n  source: 'context';\n  path: string;\n  suggestedSkillName: string;\n  confidence: number; // 0-1, how certain we are this should become a skill\n  usageCount: number; // how many times this context was used\n  lastUsed: number; // timestamp\n  description: string; // description of what this context enables\n}\n\n/**\n * 分析ContextItems以生成SkillHints\n * 当ContextItem被频繁使用且与成功任务相关联时，建议将其转换为Skill\n *\n * @param contextItems ContextItem数组\n * @returns ContextSkillHint数组\n */\nexport function generateSkillHintsFromContext(contextItems: ContextItem[]): ContextSkillHint[] {\n  const hints: ContextSkillHint[] = [];\n\n  for (const item of contextItems) {\n    // 使用新的晋升规则来评估是否应该晋升为技能\n    const promotedSkill = ContextToSkillPromotionRules.evaluatePromotion(item);\n\n    if (promotedSkill) {\n      // 如果符合晋升条件，生成提示\n      const { useCount, successCount, lastUsed } = item.importance || {\n        useCount: 0,\n        successCount: 0,\n        lastUsed: Date.now()\n      };\n\n      hints.push({\n        source: 'context',\n        path: item.path,\n        suggestedSkillName: promotedSkill.name,\n        confidence: promotedSkill.metadata?.promotionCriteria?.successRate ||\n                   promotedSkill.metadata?.promotionCriteria?.importanceScore ||\n                   0.8, // 默认高置信度\n        usageCount: useCount,\n        lastUsed,\n        description: promotedSkill.description\n      });\n\n      // === C5-B-1: Knowledge Graph Record (Context -> Skill Candidate) ===\n      if (item.id) {\n        recordEdge({\n            from: item.id,\n            to: `skill_candidate:${promotedSkill.name}`,\n            type: 'promoted_to',\n            timestamp: Date.now(),\n            meta: {\n                confidence: promotedSkill.confidence\n            }\n        });\n      }\n    } else {\n      // 使用旧的逻辑作为后备\n      if (item.importance) {\n        const { useCount, successCount, lastUsed } = item.importance;\n\n        // 如果使用次数超过阈值，且有一定成功率，生成Skill建议\n        if (useCount >= 3 && successCount > 0) {\n          const successRate = successCount / useCount;\n          const daysSinceLastUse = (Date.now() - lastUsed) / (1000 * 60 * 60 * 24);\n\n          // 计算建议的置信度\n          const confidence = Math.min(1,\n            (successRate * 0.6) +  // 成功率权重\n            (Math.min(1, useCount / 10) * 0.3) +  // 使用频率权重\n            (Math.max(0, (7 - daysSinceLastUse) / 7) * 0.1)  // 新鲜度权重\n          );\n\n          if (confidence > 0.5) { // 只有置信度超过0.5才生成建议\n            hints.push({\n              source: 'context',\n              path: item.path,\n              suggestedSkillName: generateSkillNameFromPath(item.path),\n              confidence,\n              usageCount: useCount,\n              lastUsed,\n              description: `Frequently used context from ${item.path} that contributed to ${successCount} successful tasks`\n            });\n          }\n        }\n      }\n    }\n  }\n\n  return hints;\n}\n\n/**\n * 从路径生成Skill名称\n * @param path 文件路径\n * @returns 建议的Skill名称\n */\nfunction generateSkillNameFromPath(path: string): string {\n  // 移除文件扩展名并使用驼峰命名\n  const basename = path.split('/').pop()?.split('.')[0] || path;\n  return basename\n    .split(/[^a-zA-Z0-9]/)  // 按非字母数字字符分割\n    .map((part, index) =>\n      index === 0\n        ? part.toLowerCase()\n        : part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()\n    )\n    .join('');\n}\n\n/**\n * 将ContextItem直接晋升为Skill\n * @param contextItem 要晋升的ContextItem\n * @returns 晋升后的Skill，如果不符合条件则返回null\n */\nexport function promoteContextToSkill(contextItem: ContextItem): Skill | null {\n  return ContextToSkillPromotionRules.evaluatePromotion(contextItem);\n}\n\n/**\n * 将ContextSkillHints转换为可显示的文本\n * @param hints ContextSkillHint数组\n * @returns 格式化的字符串\n */\nexport function formatSkillHints(hints: ContextSkillHint[]): string {\n  if (hints.length === 0) {\n    return \"No skill suggestions generated from context.\";\n  }\n\n  const lines: string[] = [\"Skill Suggestions from Context:\", \"\"];\n\n  for (const hint of hints) {\n    lines.push(`- ${hint.suggestedSkillName} (confidence: ${(hint.confidence * 100).toFixed(1)}%)`);\n    lines.push(`  Path: ${hint.path}`);\n    lines.push(`  Usage: ${hint.usageCount}, Last used: ${new Date(hint.lastUsed).toLocaleDateString()}`);\n    lines.push(`  Description: ${hint.description}`);\n    lines.push(\"\");\n  }\n\n  return lines.join(\"\\n\");\n}",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/contextSkillBridge.ts:1769134473140",
    "tokens": 1127,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/context.ts",
    "content": "import { AgentInput, AgentContext } from './types';\nimport { ContextBuffer } from './contextBuffer';\nimport { ExtendedContextProtocol } from './contextDSL';\nimport { computeContextImportance } from './contextImportance';\n\nexport function buildContext(input: AgentInput, contextBuffer: ContextBuffer): AgentContext {\n    // 同步获取所有上下文项\n    const items = contextBuffer.export();\n\n    return {\n        files: items.map(item => ({\n            path: item.path,\n            content: item.content,\n        })),\n        gitDiff: undefined, // Will be enhanced later\n        history: [], // Will be populated from conversation history\n        contextItems: items,\n        totalTokens: items.reduce((sum, item) => sum + item.tokens, 0),\n        highConfidenceItems: items.filter(item =>\n            item.importance && computeContextImportance(item.importance) > 0.7\n        ),\n        mediumConfidenceItems: items.filter(item =>\n            item.importance &&\n            computeContextImportance(item.importance) > 0.3 &&\n            computeContextImportance(item.importance) <= 0.7\n        ),\n        lowConfidenceItems: items.filter(item =>\n            !item.importance || computeContextImportance(item.importance) <= 0.3\n        )\n    };\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/context.ts:1769134473140",
    "tokens": 309,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextProtocol.ts",
    "content": "import { ContextBuffer, ContextItem } from './contextBuffer';\nimport { randomUUID } from 'crypto';\nimport { ExtendedContextProtocol } from './contextDSL';\n\n/**\n * Context引用协议v1实现\n * 定义了ContextItem如何被显式引用、管理和注入的协议\n */\n\nexport interface ContextReference {\n  path: string;\n  alias?: string;\n  lineRange?: { start: number; end?: number };\n  timestamp: number;\n  responseId?: string;\n}\n\nexport interface ContextProtocolResult {\n  referencedItems: ContextReference[];\n  extractedContent: string;\n  isValid: boolean;\n  errors: string[];\n}\n\n/**\n * 解析AI响应中的Context引用\n * @param response AI的响应内容\n * @returns 解析出的Context引用信息\n */\nexport function parseContextReferences(response: string): ContextProtocolResult {\n  const result: ContextProtocolResult = {\n    referencedItems: [],\n    extractedContent: response,\n    isValid: true,\n    errors: []\n  };\n\n  // 匹配显式引用格式，如 [Reference] file: path/to/file.ts (path/to/file.ts) 或类似格式\n  const referenceRegex = /\\[Reference\\]\\s+([^:\\s]+):\\s*([^(]+?)\\s*\\(([^)]+)\\)/g;\n  let match;\n\n  while ((match = referenceRegex.exec(response)) !== null) {\n    const [, type, description, path] = match;\n\n    const reference: ContextReference = {\n      path: path.trim(),\n      timestamp: Date.now()\n    };\n\n    result.referencedItems.push(reference);\n  }\n\n  // 匹配 DSL 查询语法 (例如: type:file importance:>0.5)\n  const dslRegex = /[@#][^{}`]+|\"[^\"]*\"|'[^']*'|[a-z_]+:[^\\\\s]+/gi;\n  let dslMatch;\n  while ((dslMatch = dslRegex.exec(response)) !== null) {\n    const dslPart = dslMatch[0];\n\n    // 检查是否是 DSL 查询语法 (包含冒号且不是文件路径)\n    if (dslPart.includes(':') && !dslPart.startsWith('/') && !dslPart.includes('.')) {\n      // 这可能是 DSL 查询的一部分，暂时跳过，因为我们需要完整的查询\n      continue;\n    }\n\n    // 检查是否是路径引用 (@file 或 #dir)\n    if (dslPart.startsWith('@') || dslPart.startsWith('#')) {\n      const path = dslPart.substring(1);\n      if (!result.referencedItems.some(ref => ref.path === path)) {\n        result.referencedItems.push({\n          path,\n          timestamp: Date.now()\n        });\n      }\n    }\n  }\n\n  // 也可以匹配JSON格式的引用（如果AI输出遵循特定格式）\n  try {\n    // 尝试查找JSON块中的引用信息\n    const jsonMatch = response.match(/```json\\n([\\s\\S]*?)\\n```/);\n    if (jsonMatch) {\n      const jsonData = JSON.parse(jsonMatch[1]);\n\n      // 如果JSON中包含used_context字段\n      if (jsonData.used_context && Array.isArray(jsonData.used_context)) {\n        for (const path of jsonData.used_context) {\n          if (!result.referencedItems.some(ref => ref.path === path)) {\n            result.referencedItems.push({\n              path,\n              timestamp: Date.now()\n            });\n          }\n        }\n      }\n    }\n  } catch (e) {\n    // 如果JSON解析失败，继续处理\n  }\n\n  return result;\n}\n\n/**\n * 验证Context引用的有效性\n * @param references Context引用列表\n * @param availableItems 可用的ContextItem列表\n * @returns 验证结果\n */\nexport function validateContextReferences(references: ContextReference[], availableItems: ContextItem[]): {\n  valid: ContextReference[];\n  invalid: ContextReference[];\n  warnings: string[];\n} {\n  const valid: ContextReference[] = [];\n  const invalid: ContextReference[] = [];\n  const warnings: string[] = [];\n\n  for (const ref of references) {\n    const foundItem = availableItems.find(item => \n      item.path === ref.path || \n      (item.alias && item.alias === ref.path)\n    );\n\n    if (foundItem) {\n      valid.push(ref);\n    } else {\n      invalid.push(ref);\n      warnings.push(`Context item not found: ${ref.path}`);\n    }\n  }\n\n  return { valid, invalid, warnings };\n}\n\n/**\n * 根据引用协议构建上下文提示\n * @param contextBuffer ContextBuffer实例\n * @param userInput 用户输入\n * @param referencedPaths 显式引用的路径列表\n * @returns 构建的提示字符串\n */\nexport async function buildContextPromptWithReferences(\n  contextBuffer: ContextBuffer,\n  userInput: string,\n  referencedPaths?: string[]\n): Promise<string> {\n  // 首先检查用户输入是否包含 DSL 查询\n  const dslContextItems = await contextBuffer.getDSLContextForInput(userInput);\n\n  let filteredItems: ContextItem[];\n\n  if (dslContextItems.length > 0) {\n    // 如果有 DSL 查询结果，使用 DSL 结果\n    filteredItems = dslContextItems;\n  } else if (referencedPaths && referencedPaths.length > 0) {\n    // 如果提供了显式引用路径，优先处理这些项\n    const allItems = contextBuffer.export();\n    filteredItems = allItems.filter(item =>\n      referencedPaths.includes(item.path) ||\n      (item.alias && referencedPaths.includes(item.alias))\n    );\n  } else {\n    // 否则使用所有可用项\n    filteredItems = contextBuffer.export();\n  }\n\n  // 按重要性分组\n  const highConfidenceItems = filteredItems.filter(item =>\n    item.importance && computeContextImportance(item.importance) > 0.7\n  );\n  const mediumConfidenceItems = filteredItems.filter(item =>\n    item.importance &&\n    computeContextImportance(item.importance) > 0.3 &&\n    computeContextImportance(item.importance) <= 0.7\n  );\n  const lowConfidenceItems = filteredItems.filter(item =>\n    !item.importance || computeContextImportance(item.importance) <= 0.3\n  );\n\n  // 构建不同部分的上下文\n  const sections = [];\n\n  if (highConfidenceItems.length > 0) {\n    // 按语义类型进一步细分高置信度项\n    const semanticGroups: Record<string, typeof highConfidenceItems> = {};\n    for (const item of highConfidenceItems) {\n      const semantic = item.semantic || 'other';\n      if (!semanticGroups[semantic]) {\n        semanticGroups[semantic] = [];\n      }\n      semanticGroups[semantic].push(item);\n    }\n\n    for (const [semantic, items] of Object.entries(semanticGroups)) {\n      const semanticBlock = items.map(item => {\n        const title = item.alias\n          ? `[Reference] ${item.type}: ${item.alias} (${item.path})`\n          : `[Reference] ${item.type}: ${item.path}`;\n\n        const body = item.summary ?? item.content;\n\n        return `${title}\\n---\\n${body}\\n---`;\n      }).join('\\n\\n');\n\n      sections.push(`# Background Knowledge (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - High Confidence)\\n${semanticBlock}`);\n    }\n  }\n\n  if (mediumConfidenceItems.length > 0) {\n    // 按语义类型进一步细分中置信度项\n    const semanticGroups: Record<string, typeof mediumConfidenceItems> = {};\n    for (const item of mediumConfidenceItems) {\n      const semantic = item.semantic || 'other';\n      if (!semanticGroups[semantic]) {\n        semanticGroups[semantic] = [];\n      }\n      semanticGroups[semantic].push(item);\n    }\n\n    for (const [semantic, items] of Object.entries(semanticGroups)) {\n      const semanticBlock = items.map(item => {\n        const title = item.alias\n          ? `[Reference] ${item.type}: ${item.alias} (${item.path})`\n          : `[Reference] ${item.type}: ${item.path}`;\n\n        const body = item.summary ?? item.content;\n\n        return `${title}\\n---\\n${body}\\n---`;\n      }).join('\\n\\n');\n\n      sections.push(`# Supporting Information (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - Medium Confidence)\\n${semanticBlock}`);\n    }\n  }\n\n  if (lowConfidenceItems.length > 0) {\n    // 按语义类型进一步细分低置信度项\n    const semanticGroups: Record<string, typeof lowConfidenceItems> = {};\n    for (const item of lowConfidenceItems) {\n      const semantic = item.semantic || 'other';\n      if (!semanticGroups[semantic]) {\n        semanticGroups[semantic] = [];\n      }\n      semanticGroups[semantic].push(item);\n    }\n\n    for (const [semantic, items] of Object.entries(semanticGroups)) {\n      const semanticBlock = items.map(item => {\n        const title = item.alias\n          ? `[Reference] ${item.type}: ${item.alias} (${item.path})`\n          : `[Reference] ${item.type}: ${item.path}`;\n\n        const body = item.summary ?? item.content;\n\n        return `${title}\\n---\\n${body}\\n---`;\n      }).join('\\n\\n');\n\n      sections.push(`# Archived References (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - Low Confidence)\\n${semanticBlock}`);\n    }\n  }\n\n  const contextBlock = sections.join('\\n\\n');\n\n  return `\n${contextBlock}\n\n# Task Instructions\nBased on the provided context (if any), answer the user's question. If the context contains source code, treat it as your \"source of truth.\"\n\nUser Question:\n${userInput}\n`;\n}\n\n/**\n * 验证Context引用的有效性\n * @param responseId 响应ID\n * @param expectedPaths 期望被引用的路径\n * @param actualReferences 实际引用的路径\n * @returns 验证结果\n */\nexport function validateResponseReferences(\n  responseId: string,\n  expectedPaths: string[],\n  actualReferences: ContextReference[]\n): {\n  success: boolean;\n  matched: string[];\n  missing: string[];\n  extra: string[];\n  accuracy: number; // 0-1, 引用准确率\n} {\n  const actualPaths = actualReferences.map(ref => ref.path);\n  const matched = expectedPaths.filter(path => actualPaths.includes(path));\n  const missing = expectedPaths.filter(path => !actualPaths.includes(path));\n  const extra = actualPaths.filter(path => !expectedPaths.includes(path));\n\n  const totalExpected = expectedPaths.length;\n  const totalActual = actualReferences.length;\n  const correctlyReferenced = matched.length;\n\n  // 计算准确率：考虑正确引用和额外引用的平衡\n  const accuracy = totalExpected > 0\n    ? correctlyReferenced / totalExpected  // 查全率\n    : (totalActual - extra.length) / Math.max(totalActual, 1); // 如果没有预期引用，则看有多少是相关的\n\n  return {\n    success: missing.length === 0 && extra.length <= Math.floor(expectedPaths.length * 0.2), // 允许最多20%的额外引用\n    matched,\n    missing,\n    extra,\n    accuracy\n  };\n}\n\n/**\n * 生成Context引用回溯报告\n * @param contextBuffer ContextBuffer实例\n * @param responseId 响应ID\n * @param userInput 用户输入\n * @param response AI响应\n * @returns 回溯报告\n */\nexport async function generateReferenceRetrospective(\n  contextBuffer: ContextBuffer,\n  responseId: string,\n  userInput: string,\n  response: string\n): Promise<string> {\n  const allItems = contextBuffer.export();\n  const references = parseContextReferences(response);\n\n  // 统计引用情况\n  const referencedItems = allItems.filter(item =>\n    references.referencedItems.some(ref => ref.path === item.path)\n  );\n\n  // 验证引用的有效性\n  const validation = validateContextReferences(\n    references.referencedItems,\n    allItems\n  );\n\n  // 计算引用统计\n  const stats = {\n    totalContextItems: allItems.length,\n    referencedItemsCount: referencedItems.length,\n    validReferences: validation.valid.length,\n    invalidReferences: validation.invalid.length,\n    referenceAccuracy: allItems.length > 0\n      ? validation.valid.length / (validation.valid.length + validation.invalid.length || 1)\n      : 0\n  };\n\n  // 生成报告\n  const reportLines = [\n    '# Context Reference Retrospective Report',\n    '',\n    '## Query',\n    userInput,\n    '',\n    '## Statistics',\n    `- Total Context Items: ${stats.totalContextItems}`,\n    `- Referenced Items: ${stats.referencedItemsCount}`,\n    `- Valid References: ${stats.validReferences}`,\n    `- Invalid References: ${stats.invalidReferences}`,\n    `- Reference Accuracy: ${(stats.referenceAccuracy * 100).toFixed(2)}%`,\n    '',\n    '## Referenced Context Items',\n    ...(referencedItems.length > 0\n      ? referencedItems.map(item => `- ${item.path} (${item.type})`)\n      : ['None']),\n    '',\n    '## Invalid References',\n    ...(validation.invalid.length > 0\n      ? validation.invalid.map(ref => `- ${ref.path}`)\n      : ['None']),\n    '',\n    '## Response Excerpt',\n    response.length > 200\n      ? response.substring(0, 200) + '...'\n      : response\n  ];\n\n  return reportLines.join('\\n');\n}\n\n/**\n * 分析ContextItem的生命周期和演变\n * @param contextBuffer ContextBuffer实例\n * @returns ContextItem生命周期分析\n */\nexport function analyzeContextLifecycle(\n  contextBuffer: ContextBuffer\n): Array<{\n  path: string;\n  usageTrend: number; // 使用趋势 (-1 to 1)\n  qualityScore: number; // 质量评分 (0 to 1)\n  relevanceScore: number; // 相关性评分 (0 to 1)\n  recommendation: 'keep' | 'archive' | 'remove' | 'enhance';\n}> {\n  const items = contextBuffer.export();\n\n  return items.map(item => {\n    // 计算使用趋势 (基于useCount和时间)\n    const now = Date.now();\n    const daysSinceCreated = (now - (item.importance?.createdAt || now)) / (1000 * 60 * 60 * 24);\n    const avgUsesPerDay = item.importance ? item.importance.useCount / (daysSinceCreated || 1) : 0;\n\n    // 使用趋势：正值表示使用频率增加，负值表示减少\n    const usageTrend = avgUsesPerDay > 0.5 ? 1 : (avgUsesPerDay > 0.1 ? 0.5 : 0);\n\n    // 质量评分：结合显式引用和验证结果\n    const qualityScore = item.usageStats\n      ? (item.usageStats.verifiedUseful + 1) /\n        (item.usageStats.verifiedUseful + item.usageStats.verifiedNotUseful + 2)\n      : 0.5; // 默认中等评分\n\n    // 相关性评分：结合重要性分数和显式引用次数\n    const relevanceScore = item.importance\n      ? (computeContextImportance(item.importance) +\n         (item.usageStats ? Math.min(1, item.usageStats.referencedCount / 10) : 0)) / 2\n      : 0.5;\n\n    // 生成推荐\n    let recommendation: 'keep' | 'archive' | 'remove' | 'enhance' = 'keep';\n    if (relevanceScore < 0.2 && qualityScore < 0.3) {\n      recommendation = 'remove';\n    } else if (relevanceScore < 0.4 && qualityScore < 0.5) {\n      recommendation = 'archive';\n    } else if (relevanceScore > 0.7 && qualityScore > 0.8) {\n      recommendation = 'enhance'; // 高价值，建议增强\n    }\n\n    return {\n      path: item.path,\n      usageTrend,\n      qualityScore,\n      relevanceScore,\n      recommendation\n    };\n  });\n}\n\n// 导入必要的函数\nimport { computeContextImportance } from './contextImportance';",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/contextProtocol.ts:1769134473140",
    "tokens": 3238,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/types.ts",
    "content": "import type { AIRequestMessage } from '../core/validation';\n// import { AgentPlan } from './plan';\n\nexport type AgentMode = 'chat' | 'command' | 'command+exec';\n\nexport interface AgentInput {\n    rawInput: string;\n    stdin?: string;\n    context?: AgentContext;\n    options?: {\n        model?: string;\n        stream?: boolean;\n        autoYes?: boolean;\n        verbose?: boolean;\n    };\n}\n\nexport interface AgentContext {\n    files?: Array<{ path: string; content: string }>;\n    gitDiff?: string;\n    history?: AIRequestMessage[];\n    contextItems?: import('./contextBuffer').ContextItem[];\n    totalTokens?: number;\n    highConfidenceItems?: import('./contextBuffer').ContextItem[];\n    mediumConfidenceItems?: import('./contextBuffer').ContextItem[];\n    lowConfidenceItems?: import('./contextBuffer').ContextItem[];\n}\n\nexport interface AgentIntent {\n    type: 'chat' | 'shell' | 'analysis';\n    capabilities: {\n        reasoning?: boolean;\n        code?: boolean;\n        longContext?: boolean;\n        streaming?: boolean;\n    };\n}\n\nexport interface AgentPrompt {\n    system?: string;\n    messages: AIRequestMessage[];\n    outputSchema?: any;\n}\n\nexport interface LLMResult {\n    rawText: string;\n    parsed?: any;\n    plan?: any;\n    latencyMs: number;\n    tokens?: {\n        prompt: number;\n        completion: number;\n        total: number;\n    };\n    costUsd?: number;\n}\n\nexport type AgentAction =\n    | { type: 'print'; content: string }\n    | { type: 'confirm'; next: AgentAction }\n    | { type: 'execute'; command: string; risk: 'low' | 'medium' | 'high' };\n\n/**\n * Observation 类型分级（v3.1）\n * 用于区分哪些 Observation 需要确认，哪些不需要\n */\nexport type ObservationKind = 'tool_result' | 'system_note' | 'error' | 'none';\n\n/**\n * 完整的 Observation 接口\n */\nexport interface Observation {\n    kind: ObservationKind;\n    content: string;\n    timestamp: number;\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/types.ts:1769134473140",
    "tokens": 464,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/knowledgeGraph.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\n\nexport type KGNodeType = 'context' | 'execution' | 'skill';\n\nexport type KGEdgeType =\n  | 'used_in'        // Context -> Execution\n  | 'validated_by'   // Execution -> Skill\n  | 'promoted_to'    // Context -> Skill\n  | 'derived_from';  // Skill -> Context (optional)\n\nexport interface KnowledgeGraphEdge {\n  from: string;\n  to: string;\n  type: KGEdgeType;\n  timestamp: number;\n  meta?: Record<string, any>;\n}\n\nconst KG_DIR = path.join(os.homedir(), '.yuangs', 'knowledge');\nconst KG_FILE = path.join(KG_DIR, 'graph.jsonl');\n\nfunction ensureDir() {\n  if (!fs.existsSync(KG_DIR)) {\n    fs.mkdirSync(KG_DIR, { recursive: true });\n  }\n}\n\n/**\n * 记录一条不可变的知识图谱边 (Append-only Fact)\n */\nexport function recordEdge(edge: KnowledgeGraphEdge) {\n  try {\n    ensureDir();\n    // 简单的 JSONL 格式：一行一个 JSON 对象\n    const line = JSON.stringify({\n        ...edge,\n        // 确保 timestamp 存在\n        timestamp: edge.timestamp || Date.now()\n    });\n    \n    fs.appendFileSync(KG_FILE, line + '\\n', 'utf8');\n  } catch (error) {\n    // 容错：KG 记录失败不应阻断主流程\n    console.warn('[KnowledgeGraph] Failed to record edge:', error);\n  }\n  // NOTE: sync write is acceptable at current scale (<100 edges / run)\n}",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/knowledgeGraph.ts:1769134473140",
    "tokens": 311,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/llm.ts",
    "content": "import { AgentPrompt, LLMResult } from './types';\nimport { callAI_Stream } from '../ai/client';\nimport axios from 'axios';\nimport { DEFAULT_AI_PROXY_URL, DEFAULT_MODEL, DEFAULT_ACCOUNT_TYPE, type AIRequestMessage } from '../core/validation';\nimport fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { safeParseJSON } from '../core/validation';\n\nconst CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');\n\nfunction getUserConfig(): any {\n    if (fs.existsSync(CONFIG_FILE)) {\n        try {\n            const content = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(content);\n        } catch (e) { }\n    }\n    return {};\n}\n\nexport async function runLLM({\n    prompt,\n    model,\n    stream,\n    onChunk,\n    abortSignal\n}: {\n    prompt: AgentPrompt;\n    model: string;\n    stream: boolean;\n    onChunk?: (s: string) => void;\n    abortSignal?: AbortSignal;\n}): Promise<LLMResult> {\n    const start = Date.now();\n\n    // ✅ 检查取消信号\n    if (abortSignal?.aborted) {\n        throw new Error('LLM request cancelled');\n    }\n\n    // ✅ 设置取消监听器\n    const cleanup = () => {};\n    if (abortSignal) {\n        abortSignal.addEventListener('abort', () => {\n            console.log('[runLLM] Request aborted');\n        });\n    }\n\n    if (stream) {\n        let raw = '';\n        let buffer = '';\n        let lastFlush = Date.now();\n\n        await callAI_Stream(prompt.messages, model, (chunk) => {\n            // ✅ 在每个chunk检查取消信号\n            if (abortSignal?.aborted) {\n                throw new Error('LLM streaming cancelled');\n            }\n\n            raw += chunk;\n            buffer += chunk;\n\n            // 节流：每50ms最多触发一次onChunk，约20FPS\n            if (Date.now() - lastFlush > 50) {\n                onChunk?.(buffer);\n                buffer = '';\n                lastFlush = Date.now();\n            }\n        });\n\n        // 确保最后的缓冲区内容也被发送\n        if (buffer) {\n            onChunk?.(buffer);\n        }\n\n        return {\n            rawText: raw,\n            latencyMs: Date.now() - start,\n        };\n    }\n\n    // Non-streaming mode with optional schema\n    const config = getUserConfig();\n    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;\n\n    const headers = {\n        'Content-Type': 'application/json',\n        'X-Client-ID': 'vscode',\n        'Origin': 'https://cli.want.biz',\n        'Referer': 'https://cli.want.biz/',\n        'account': config.accountType || DEFAULT_ACCOUNT_TYPE,\n        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',\n        'Accept': 'application/json'\n    };\n\n    const data = {\n        model: model || config.defaultModel || DEFAULT_MODEL,\n        messages: prompt.messages,\n        stream: false\n    };\n\n    try {\n        const response = await axios.post(url, data, { headers });\n        const rawText = response.data.choices[0]?.message?.content || '';\n\n        let parsed = undefined;\n        if (prompt.outputSchema) {\n            const parseResult = safeParseJSON(rawText, prompt.outputSchema, {});\n            if (parseResult.success) {\n                parsed = parseResult.data;\n            }\n        }\n\n        return {\n            rawText,\n            parsed,\n            latencyMs: Date.now() - start,\n        };\n    } catch (error: any) {\n        const errorMsg = error.response?.data?.error?.message || error.response?.data?.message || error.message || '未知错误';\n        throw new Error(`AI 请求失败: ${errorMsg}`);\n    }\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/llm.ts:1769134473140",
    "tokens": 877,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/executionRecorder.ts",
    "content": "import { ExecutionTurn } from './state';\nimport { ContextDiff } from './contextDiff';\n\nexport class ExecutionRecorder {\n  private turns: ExecutionTurn[] = [];\n  private turnCounter = 0;\n\n  recordTurn(turn: Omit<ExecutionTurn, 'turnId'>): ExecutionTurn {\n    const executionTurn: ExecutionTurn = {\n      ...turn,\n      turnId: ++this.turnCounter\n    };\n\n    this.turns.push(executionTurn);\n    return executionTurn;\n  }\n\n  getTurns(): ExecutionTurn[] {\n    return [...this.turns];\n  }\n\n  clear(): void {\n    this.turns = [];\n    this.turnCounter = 0;\n  }\n\n  getSummary(): {\n    totalTurns: number;\n    totalAddedContext: number;\n    totalRemovedContext: number;\n    totalChangedContext: number;\n  } {\n    return {\n      totalTurns: this.turns.length,\n      totalAddedContext: this.turns.reduce((sum, turn) => \n        sum + (turn.contextDiff?.added.length || 0), 0),\n      totalRemovedContext: this.turns.reduce((sum, turn) => \n        sum + (turn.contextDiff?.removed.length || 0), 0),\n      totalChangedContext: this.turns.reduce((sum, turn) => \n        sum + (turn.contextDiff?.changed.length || 0), 0)\n    };\n  }\n}",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/executionRecorder.ts:1769134473140",
    "tokens": 280,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextStorage.ts",
    "content": "import fs from 'fs/promises';\nimport path from 'path';\nimport { ContextItem } from './contextBuffer';\n\nconst CONTEXT_DIR = path.resolve(process.cwd(), '.ai');\nconst CONTEXT_FILE = path.join(CONTEXT_DIR, 'context.json');\n\nexport async function loadContext(): Promise<ContextItem[]> {\n    try {\n        const raw = await fs.readFile(CONTEXT_FILE, 'utf-8');\n        return JSON.parse(raw);\n    } catch {\n        return [];\n    }\n}\n\nexport async function saveContext(items: ContextItem[]) {\n    await fs.mkdir(CONTEXT_DIR, { recursive: true });\n    await fs.writeFile(CONTEXT_FILE, JSON.stringify(items, null, 2));\n}\n\nexport async function clearContextStorage() {\n    await fs.rm(CONTEXT_FILE, { force: true });\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/contextStorage.ts:1769134473140",
    "tokens": 178,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/actions.ts",
    "content": "import { AgentAction } from './types';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport chalk from 'chalk';\nimport readline from 'readline';\n\nconst execAsync = promisify(exec);\n\nexport async function executeAction(\n    action: AgentAction,\n    options?: { autoYes?: boolean }\n): Promise<void> {\n    if (action.type === 'print') {\n        console.log(action.content);\n        return;\n    }\n\n    if (action.type === 'confirm') {\n        const ok = options?.autoYes || await confirm('Execute this action?');\n        if (ok) {\n            await executeAction(action.next, options);\n        }\n        return;\n    }\n\n    if (action.type === 'execute') {\n        try {\n            console.log(chalk.cyan(`\\nExecuting: ${action.command}\\n`));\n            const { stdout, stderr } = await execAsync(action.command, {\n                shell: typeof process.env.SHELL === 'string' ? process.env.SHELL : undefined\n            });\n            if (stdout) console.log(stdout);\n            if (stderr) console.error(chalk.yellow(stderr));\n        } catch (error: any) {\n            console.error(chalk.red(`Execution failed: ${error.message}`));\n            throw error;\n        }\n    }\n}\n\nasync function confirm(message: string): Promise<boolean> {\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout,\n    });\n\n    return new Promise((resolve) => {\n        rl.question(chalk.cyan(`${message} (y/N): `), (answer) => {\n            rl.close();\n            resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');\n        });\n    });\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/actions.ts:1769134473140",
    "tokens": 404,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextImportance.ts",
    "content": "import { randomUUID } from 'crypto';\n\nexport interface ContextImportance {\n  id: string;              // stable id\n  path: string;            // file / dir path\n  type: 'file' | 'directory';\n\n  // === Usage stats ===\n  useCount: number;\n  successCount: number;\n  failureCount: number;\n\n  // === Time ===\n  lastUsed: number;\n  createdAt: number;\n\n  // === Learned weight ===\n  confidence: number;      // 0 ~ 1, init 0.5\n}\n\n/**\n * 计算上下文重要性分数\n * 评分公式与Skill系统保持一致\n * @param ctx ContextImportance对象\n * @param now 当前时间戳\n * @returns 重要性分数 (0-1)\n */\nexport function computeContextImportance(\n  ctx: ContextImportance,\n  now = Date.now()\n): number {\n  const total = ctx.successCount + ctx.failureCount;\n  const successRate = total === 0 ? 0.5 : ctx.successCount / total;\n\n  const idleDays = (now - ctx.lastUsed) / (1000 * 60 * 60 * 24);\n  const freshness = Math.exp(-idleDays / 14); // 14 天半衰\n\n  return (\n    0.45 * successRate +\n    0.35 * freshness +\n    0.20 * ctx.confidence\n  );\n}\n\n/**\n * 创建新的ContextImportance对象\n * @param path 文件或目录路径\n * @param type 类型\n * @returns ContextImportance对象\n */\nexport function createContextImportance(path: string, type: 'file' | 'directory'): ContextImportance {\n  const now = Date.now();\n  return {\n    id: randomUUID(),\n    path,\n    type,\n    useCount: 0,\n    successCount: 0,\n    failureCount: 0,\n    confidence: 0.5,\n    createdAt: now,\n    lastUsed: now\n  };\n}\n\n/**\n * 更新ContextImportance状态\n * @param ctx ContextImportance对象\n * @param success 是否成功\n */\nexport function updateContextImportance(ctx: ContextImportance, success: boolean) {\n  ctx.useCount++;\n  ctx.lastUsed = Date.now();\n\n  if (success) {\n    ctx.successCount++;\n    ctx.confidence = Math.min(1, ctx.confidence + 0.05);\n  } else {\n    ctx.failureCount++;\n    ctx.confidence = Math.max(0, ctx.confidence - 0.1);\n  }\n}",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/contextImportance.ts:1769134473140",
    "tokens": 453,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextSummary.ts",
    "content": "import { askAI } from '../ai/client';\n\nexport function buildContextSummaryPrompt(\n  type: 'file' | 'directory',\n  path: string,\n  content: string\n) {\n  return `\n你是一个代码与文档压缩器。\n\n目标：\n- 最大限度保留\"之后回答问题所需的信息\"\n- 删除实现细节、重复内容、噪声\n- 不要加入推测\n\n请将以下 ${type} 内容压缩为 **结构化摘要**：\n\n路径: ${path}\n\n要求格式：\n- 用项目符号\n- 保留：职责 / 接口 / 关键数据结构 / 关键行为\n- 代码只保留函数签名或核心逻辑描述\n- 不超过原内容的 20%\n\n内容：\n\\`\\`\\`\n${content}\n\\`\\`\\`\n`;\n}\n\nexport async function summarizeContext(\n  item: { type: 'file' | 'directory'; path: string; content: string }\n): Promise<string> {\n  const prompt = buildContextSummaryPrompt(\n    item.type,\n    item.path,\n    item.content\n  );\n\n  const summary = await askAI(prompt);\n  return summary.trim();\n}",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/contextSummary.ts:1769134473140",
    "tokens": 170,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/chatHistoryStorage.ts",
    "content": "import fs from 'fs';\nimport { promisify } from 'util';\nimport path from 'path';\nimport os from 'os';\nimport { AIRequestMessage } from '../core/validation';\n\nconst CHAT_HISTORY_DIR = path.resolve(os.homedir(), '.yuangs_chat_history');\nconst CHAT_HISTORY_FILE = path.join(CHAT_HISTORY_DIR, 'chat_history.json');\n\nconst readFileAsync = promisify(fs.readFile);\nconst writeFileAsync = promisify(fs.writeFile);\nconst mkdirAsync = promisify(fs.mkdir);\nconst rmAsync = promisify(fs.rm);\n\nexport async function loadChatHistory(): Promise<AIRequestMessage[]> {\n    if (fs.existsSync(CHAT_HISTORY_FILE)) {\n        try {\n            const raw = await readFileAsync(CHAT_HISTORY_FILE, 'utf-8');\n            const data = JSON.parse(raw);\n\n            // 验证数据结构\n            if (Array.isArray(data) && data.every(msg =>\n                typeof msg === 'object' &&\n                ['user', 'assistant', 'system'].includes(msg.role) &&\n                typeof msg.content === 'string'\n            )) {\n                return data as AIRequestMessage[];\n            }\n        } catch (e) {\n            console.warn('警告: 加载聊天历史记录失败，使用空历史记录');\n        }\n    }\n    return [];\n}\n\nexport async function saveChatHistory(history: AIRequestMessage[]) {\n    try {\n        await mkdirAsync(CHAT_HISTORY_DIR, { recursive: true });\n        await writeFileAsync(CHAT_HISTORY_FILE, JSON.stringify(history, null, 2));\n    } catch (e) {\n        console.error('错误: 保存聊天历史记录失败:', e);\n    }\n}\n\nexport async function clearChatHistory() {\n    try {\n        await rmAsync(CHAT_HISTORY_FILE, { force: true });\n    } catch (e) {\n        console.error('错误: 清除聊天历史记录失败:', e);\n    }\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/chatHistoryStorage.ts:1769134473140",
    "tokens": 410,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/core.ts",
    "content": "import { ProposedAction } from '../state';\n\nexport interface PolicyRule {\n    id: string;\n    when: { type?: string; pattern?: string; max_per_minute?: number };\n    effect: 'allow' | 'deny' | 'require_approval';\n    reason?: string;\n}\n\nexport interface RiskEntry {\n    ts: number;\n    actionType: string;\n}\n\nexport function evaluateProposal(\n    action: ProposedAction,\n    rules: PolicyRule[],\n    ledger: RiskEntry[]\n): { effect: string; reason?: string } {\n    const now = Date.now();\n    for (const rule of rules) {\n        const typeMatch = !rule.when.type || rule.when.type === action.type;\n        const payloadStr = JSON.stringify(action.payload);\n        const patternMatch = !rule.when.pattern || new RegExp(rule.when.pattern, 'i').test(payloadStr);\n\n        if (typeMatch && patternMatch) {\n            if (rule.when.max_per_minute) {\n                const count = ledger.filter(e => e.ts > now - 60000 && e.actionType === action.type).length;\n                if (count >= rule.when.max_per_minute) return { effect: 'deny', reason: `Rate limit: ${rule.id}` };\n            }\n            return { effect: rule.effect, reason: rule.reason };\n        }\n    }\n    return { effect: 'require_approval', reason: 'Default human review required' };\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/core.ts:1769134473140",
    "tokens": 314,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/bridge.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\n\nexport class WasmGovernanceBridge {\n    private static instance: any = null;\n\n    static async init(basePath?: string): Promise<boolean> {\n        try {\n            const loader = require('@assemblyscript/loader');\n            const wasmPath = path.join(basePath || process.cwd(), 'build', 'release.wasm');\n\n            if (!fs.existsSync(wasmPath)) {\n                console.error(`WASM not found at: ${wasmPath}`);\n                return false;\n            }\n\n            const wasmModule = await loader.instantiate(fs.readFileSync(wasmPath));\n            this.instance = wasmModule.exports;\n            return true;\n        } catch (e) {\n            console.error(`WASM init error: ${e}`);\n            return false;\n        }\n    }\n\n    static evaluate(proposal: any, rules: any, ledger: any): any {\n        if (!this.instance) return { effect: 'error', reason: 'WASM not initialized' };\n\n        const { __newString, __getString, evaluate } = this.instance;\n\n        const pPtr = __newString(JSON.stringify(proposal));\n        const rPtr = __newString(JSON.stringify(rules));\n        const lPtr = __newString(JSON.stringify(ledger));\n\n        const resultPtr = evaluate(pPtr, rPtr, lPtr);\n        return JSON.parse(__getString(resultPtr));\n    }\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/bridge.ts:1769134473140",
    "tokens": 325,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/ledger.ts",
    "content": "import { RiskEntry } from './core';\n\nexport class RiskLedger {\n    private entries: RiskEntry[] = [];\n\n    record(actionType: string): void {\n        this.entries.push({\n            ts: Date.now(),\n            actionType\n        });\n        this.cleanup();\n    }\n\n    getSnapshot(): RiskEntry[] {\n        return [...this.entries];\n    }\n\n    private cleanup(): void {\n        const oneHourAgo = Date.now() - 3600000;\n        this.entries = this.entries.filter(e => e.ts > oneHourAgo);\n    }\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/ledger.ts:1769134473140",
    "tokens": 124,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/sandbox/core.as.ts",
    "content": "/**\n * yuangs Governance WASM Sandbox\n * 这里的代码在执行时与 Node.js 内存完全隔离\n */\n\n// 简单的辅助函数：检查字符串包含（WASM 内部实现）\nfunction includes(source: string, target: string): boolean {\n    return source.indexOf(target) != -1;\n}\n\n/**\n * 核心裁决导出函数\n * @param proposal 提案字符串\n * @param rules 规则字符串（YAML 转换后的 JSON）\n * @param ledger 账本字符串\n */\nexport function evaluate(proposal: string, rules: string, ledger: string): string {\n    // 1. 暴力阻断：最底层的物理防线（即便外部逻辑被污染，这里也是死的）\n    if (proposal.includes(\"rm -rf /\") || proposal.includes(\"sudo rm\")) {\n        return '{\"effect\": \"deny\", \"reason\": \"WASM_SANDBOX: 检测到毁灭性命令，强制阻断\"}';\n    }\n\n    // 2. 检查速率（基于账本长度）\n    // 假设我们不想让 AI 在短时间内连续提议超过 50 次\n    if (ledger.length > 5000) { // 简单通过字符串长度模拟异常账本\n        return '{\"effect\": \"deny\", \"reason\": \"WASM_SANDBOX: 账本异常膨胀，可能遭受拒绝服务攻击\"}';\n    }\n\n    // 3. 逻辑透传\n    // 在实际生产中，我们会在这里解析 JSON rules。\n    // 目前版本我们先确保物理链路打通。\n    return '{\"effect\": \"allow\", \"reason\": \"WASM_SANDBOX: 物理隔离层验证通过\"}';\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/sandbox/core.as.ts:1769134473140",
    "tokens": 236,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/llmAdapter.ts",
    "content": "import { AgentThought } from './state';\nimport { runLLM } from './llm';\nimport { AgentPrompt } from './types';\nimport type { AIRequestMessage } from '../core/validation';\nimport { getUserConfig } from '../ai/client';\nimport { ContextManager } from './contextManager';\nimport { ExtendedContextProtocol } from './contextDSL';\nimport { parseContextReferences, validateContextReferences, buildContextPromptWithReferences } from './contextProtocol';\nimport { randomUUID } from 'crypto';\n\nexport class LLMAdapter {\n  static async think(\n    messages: AIRequestMessage[],\n    mode: 'chat' | 'command' | 'command+exec' = 'chat',\n    onChunk?: (chunk: string) => void,\n    model?: string,\n    customSystemPrompt?: string,\n    contextManager?: ContextManager,\n    abortSignal?: AbortSignal\n  ): Promise<AgentThought> {\n    // 生成唯一的响应ID用于引用跟踪\n    const responseId = randomUUID();\n\n    // 构建包含ContextBuffer内容的完整上下文\n    let fullMessages = [...messages];\n\n    if (contextManager) {\n      const contextBuffer = contextManager.getContextBuffer();\n      if (!contextBuffer.isEmpty()) {\n        // 检查用户消息中是否有 DSL 查询\n        const userInput = messages[messages.length - 1]?.content || '';\n        const dslContextItems = await contextBuffer.getDSLContextForInput(userInput);\n\n        let contextPrompt: string;\n\n        if (dslContextItems.length > 0) {\n          // 如果有 DSL 查询结果，使用 buildContextPromptWithReferences 来构建提示\n          contextPrompt = await buildContextPromptWithReferences(contextBuffer, userInput);\n        } else {\n          // 区分流式传输和非流式传输，流式传输时使用更简洁的策略以提高性能\n          if (onChunk) {\n            // 流式传输时使用最近的上下文，减少复杂度和渲染抖动\n            contextPrompt = contextBuffer.buildPrompt('', {\n              strategy: 'recent',  // 使用最近策略，更稳定\n              maxTokens: 4000      // 减少token数量，降低渲染负担\n            });\n          } else {\n            // 非流式传输时使用完整的排名策略\n            contextPrompt = contextBuffer.buildPrompt('', {\n              strategy: 'ranked',  // 使用排名策略\n              maxTokens: 16000     // 设置最大token限制\n            });\n          }\n        }\n\n        // 将ContextBuffer内容作为system消息添加到消息列表开头\n        fullMessages = [\n          { role: 'system', content: contextPrompt },\n          ...fullMessages\n        ];\n      }\n    }\n\n    const prompt: AgentPrompt = {\n      system: customSystemPrompt || `[SYSTEM PROTOCOL V3.1 - SAFE OBSERVATION ACK - CONTEXT REFERENCE ENABLED]\n- ROLE: AUTOMATED EXECUTION AGENT WITH CONTEXT REFERENCE\n- OUTPUT: STRICT JSON ONLY\n- TALK: FORBIDDEN\n- MODE: REACT (THINK -> ACTION -> PERCEIVE)\n- CONTEXT REFERENCE: When using information from the provided context, explicitly reference it in your response using [Reference] notation or in the JSON output\n\nOBSERVATION ACKNOWLEDGEMENT (MANDATORY, WITH EXCEPTIONS):\nBefore proposing any action, you MUST include the field \"acknowledged_observation\".\n\nRULES:\n1. If a valid Tool or System Observation exists, restate it VERBATIM.\n2. If NO such Observation exists, output: \"acknowledged_observation\": \"NONE\"\n3. DO NOT acknowledge:\n   - Runtime validation errors\n   - ACK-related errors\n   - System internal error messages\n4. If the user input is \"stop\" or \"halt\":\n   - Set action_type = \"answer\"\n   - Set acknowledged_observation = \"NONE\"\n   - Do NOT propose further actions\n\nJSON SCHEMA:\n{\n  \"acknowledged_observation\": \"string | 'NONE'\",\n  \"action_type\": \"tool_call\" | \"shell_cmd\" | \"code_diff\" | \"answer\" | \"halt\",\n  \"reasoning\": \"thought process\",\n  \"tool_name\": \"list_files\" | \"read_file\",\n  \"diff\": \"unified diff string\",\n  \"parameters\": {},\n  \"command\": \"shell string\",\n  \"content\": \"final answer string\",\n  \"used_context\": [\"path/to/file.ts\", \"path/to/dir\"] // OPTIONAL: List paths of context items used\n}\n\nEXECUTION RULES:\n1. If data is unknown (e.g. file list), use 'shell_cmd' or 'tool_call'.\n2. NEVER explain how to do it. JUST EXECUTE.\n3. Your output MUST start with '{' and end with '}'.\n4. When referencing information from provided context, include the path in \"used_context\" array or use [Reference] notation.\n5. TERMINATION RULE (HIGHEST PRIORITY): If user says \"stop\", \"exit\", or \"quit\", output action_type=\"answer\" with content=\"STOPPED\" and acknowledged_observation=\"NONE\".\n\nExample Task: \"count files\"\nYour Output: {\"action_type\":\"shell_cmd\",\"reasoning\":\"count files\",\"command\":\"ls | wc -l\",\"used_context\":[\"/path/to/config.json\"]}`,\n      messages: fullMessages,\n    };\n\n    const config = getUserConfig();\n    const finalModel = model || config.defaultModel || 'Assistant';\n\n    const result = await runLLM({\n      prompt,\n      model: finalModel,\n      stream: !!onChunk,\n      onChunk,\n      abortSignal // ✅ 传递取消信号到 runLLM\n    });\n\n    // 解析响应并处理Context引用\n    const thought = this.parseThought(result.rawText);\n\n    // 如果有ContextManager，解析并记录引用\n    if (contextManager) {\n      const contextBuffer = contextManager.getContextBuffer();\n      const references = parseContextReferences(result.rawText);\n\n      // 记录显式引用\n      for (const ref of references.referencedItems) {\n        contextBuffer.recordExplicitReference(ref.path, responseId);\n      }\n\n      // 验证引用的有效性\n      const validation = validateContextReferences(\n        references.referencedItems,\n        contextBuffer.export()\n      );\n\n      // 更新引用的有效性\n      for (const validRef of validation.valid) {\n        contextBuffer.validateReference(validRef.path, true);\n      }\n\n      for (const invalidRef of validation.invalid) {\n        contextBuffer.validateReference(invalidRef.path, false);\n      }\n    }\n\n    return thought;\n  }\n\n  private static parseThought(raw: string): AgentThought {\n    try {\n      // 提取 JSON：支持 Markdown 块或纯 JSON 字符串\n      const jsonMatch = raw.match(/```json\\n([\\s\\S]*?)\\n```/) || raw.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        const parsed = JSON.parse(jsonMatch[1] || jsonMatch[0]);\n\n        // 如果明确标记为 done，或者动作为 answer，则视为任务结束\n        if (parsed.is_done === true || parsed.action_type === 'answer') {\n          return {\n            raw,\n            parsedPlan: parsed,\n            isDone: true,\n            type: 'answer',\n            payload: {\n              content: parsed.final_answer || parsed.content || parsed.text || raw\n            }\n          };\n        }\n\n        // 智能推断动作类型：如果 AI 没给 action_type，我们根据字段猜测\n        let inferredType = parsed.action_type;\n        if (!inferredType) {\n          if (parsed.tool_name || parsed.tool) inferredType = 'tool_call';\n          else if (parsed.command || parsed.cmd) inferredType = 'shell_cmd';\n          else if (parsed.diff || parsed.patch) inferredType = 'code_diff';\n          else inferredType = 'answer';\n        }\n\n        return {\n          raw,\n          parsedPlan: parsed,\n          isDone: inferredType === 'answer' || parsed.is_done === true,\n          type: inferredType,\n          payload: {\n            tool_name: parsed.tool_name || parsed.tool || '',\n            parameters: parsed.parameters || parsed.params || {},\n            command: parsed.command || parsed.cmd || '',\n            diff: parsed.diff || parsed.patch || '',\n            content: parsed.content || parsed.text || ''\n          },\n          reasoning: parsed.reasoning || ''\n        };\n      }\n    } catch (e) {\n      // 解析失败时，回退到将原始内容作为回答\n    }\n\n    return {\n      raw,\n      parsedPlan: {},\n      isDone: true,\n      type: 'answer',\n      payload: { content: raw },\n      reasoning: ''\n    };\n  }\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/llmAdapter.ts:1769134473140",
    "tokens": 1832,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/index.ts",
    "content": "export { AgentRuntime } from './AgentRuntime';\nexport * from './state';\nexport { LLMAdapter } from './llmAdapter';\nexport { GovernanceService } from './governance';\nexport { ToolExecutor } from './executor';\nexport { ContextManager } from './contextManager';\nexport { ContextBuffer } from './contextBuffer';\nexport { ContextImportance, computeContextImportance, createContextImportance, updateContextImportance } from './contextImportance';\nexport { buildContextSummaryPrompt, summarizeContext } from './contextSummary';\nexport { diffContext, snapshotFromBuffer, ContextDiff, ContextSnapshot } from './contextDiff';\nexport { ExecutionRecorder } from './executionRecorder';\nexport { explainExecution, replayExecution } from './replayExplain';\nexport { generateSkillHintsFromContext, formatSkillHints, ContextSkillHint } from './contextSkillBridge';\nexport * from './skills';\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/index.ts:1769134473140",
    "tokens": 219,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/skills.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport chalk from 'chalk';\nimport { recordEdge } from './knowledgeGraph';\n\nexport interface Skill {\n    id: string;\n    name: string;\n    description: string;\n    whenToUse: string; // 触发场景描述\n    planTemplate: any;\n\n    // 评价指标\n    successCount: number;\n    failureCount: number;\n    confidence: number; // 0 ~ 1, 初始 0.5\n\n    // 时间戳\n    lastUsed: number;\n    createdAt: number;\n\n    // 是否启用\n    enabled: boolean;\n\n    // 可选属性\n    parameters?: any;\n    implementation?: string;\n    metadata?: {\n        source?: string;\n        originalContextId?: string;\n        originalContextPath?: string;\n        originalContextStableId?: string;\n        promotionCriteria?: any;\n        usageStats?: {\n            useCount: number;\n            successCount: number;\n            failureCount: number;\n            confidence: number;\n            lastUsed: number;\n        };\n        createdAt?: number;\n    };\n}\n\nconst SKILLS_FILE = path.join(os.homedir(), '.yuangs_skills.json');\nlet skillLibrary: Skill[] = [];\n\n// === Persistence Logic ===\n\nfunction loadSkills() {\n    if (fs.existsSync(SKILLS_FILE)) {\n        try {\n            const data = fs.readFileSync(SKILLS_FILE, 'utf-8');\n            skillLibrary = JSON.parse(data);\n        } catch (e) {\n            console.error(chalk.yellow(`Failed to load skills from ${SKILLS_FILE}, starting empty.`));\n            skillLibrary = [];\n        }\n    }\n}\n\nfunction saveSkills() {\n    try {\n        fs.writeFileSync(SKILLS_FILE, JSON.stringify(skillLibrary, null, 2));\n    } catch (e) {\n        console.error(chalk.red(`Failed to save skills to ${SKILLS_FILE}`));\n    }\n}\n\n// Initialize on load\nloadSkills();\n\n// === Existing Logic with Save Hooks ===\n\n/**\n * 计算技能分 (0 ~ 1)\n */\nexport function computeSkillScore(skill: Skill, now: number = Date.now()): number {\n    const totalUses = skill.successCount + skill.failureCount;\n    const successRate = totalUses === 0 ? 0.5 : skill.successCount / totalUses;\n\n    // 时间衰减 (Freshness): 半衰期约 14 天\n    const idleDays = (now - skill.lastUsed) / (1000 * 60 * 60 * 24);\n    const freshness = Math.exp(-idleDays / 14);\n\n    // 综合得分: 45% 成功率 + 35% 新鲜度 + 20% 置信度\n    return (0.45 * successRate) + (0.35 * freshness) + (0.20 * skill.confidence);\n}\n\n/**\n * 更新技能状态 (执行后调用)\n */\nexport function updateSkillStatus(skillId: string, success: boolean) {\n    const skill = skillLibrary.find(s => s.id === skillId);\n    if (!skill) return;\n\n    skill.lastUsed = Date.now();\n    if (success) {\n        skill.successCount++;\n        // 成功奖励: 置信度缓慢提升\n        skill.confidence = Math.min(1, skill.confidence + 0.05);\n    } else {\n        skill.failureCount++;\n        // 失败惩罚: 惩罚力度大于奖励，防止系统\"自嗨\"\n        skill.confidence = Math.max(0, skill.confidence - 0.1);\n    }\n\n    // === C5-B-1: Knowledge Graph Record (Execution -> Skill) ===\n    recordEdge({\n        from: 'current_execution', // TODO(KG): replace with real executionId (v2)\n        to: skill.id,\n        type: 'validated_by',\n        timestamp: Date.now(),\n        meta: { success, skillName: skill.name }\n    });\n\n    saveSkills(); // Persist changes\n}\n\n/**\n * 自动学习新技能\n */\nexport function learnSkillFromRecord(record: any, success: boolean = true) {\n    if (record.mode === 'chat' || !record.llmResult.plan) return;\n\n    const existingSkill = skillLibrary.find(s => s.name === record.llmResult.plan?.goal);\n\n    if (existingSkill) {\n        updateSkillStatus(existingSkill.id, success);\n        return;\n    }\n\n    // 只有成功的记录才被学为新技能\n    if (!success) return;\n\n    const now = Date.now();\n    skillLibrary.push({\n        id: record.id,\n        name: record.llmResult.plan.goal,\n        description: `自动学习的技能: ${record.llmResult.plan.goal}`,\n        whenToUse: record.input.rawInput,\n        planTemplate: record.llmResult.plan,\n        successCount: 1,\n        failureCount: 0,\n        confidence: 0.5,\n        lastUsed: now,\n        createdAt: now,\n        enabled: true\n    });\n\n    // 每学习一次，尝试清理一次“冷”技能\n    reapColdSkills();\n\n    saveSkills(); // Persist changes\n}\n\n/**\n * 筛选并排序技能 (用于注入 Prompt)\n */\nexport function getRelevantSkills(input: string, limit: number = 3): Skill[] {\n    const now = Date.now();\n\n    return skillLibrary\n        // 1. 基础筛选: 剔除评分过低的技能 (硬淘汰阈值 0.3)\n        .filter(s => computeSkillScore(s, now) >= 0.3)\n        // 2. 过滤已禁用的技能\n        .filter(s => s.enabled !== false)\n        // 3. 排序: 按综合分排序\n        .sort((a, b) => computeSkillScore(b, now) - computeSkillScore(a, now))\n        // 4. 取上限\n        .slice(0, limit);\n}\n\n/**\n * 清理过期或低质技能 (Reaper)\n */\nexport function reapColdSkills() {\n    const now = Date.now();\n    const initialCount = skillLibrary.length;\n\n    skillLibrary = skillLibrary.filter(skill => {\n        const score = computeSkillScore(skill, now);\n        const idleDays = (now - skill.lastUsed) / (1000 * 60 * 60 * 24);\n\n        // 满足以下任一条件则淘汰:\n        // 1. 得分极低且长期不用\n        if (score < 0.25 && idleDays > 30) return false;\n        // 2. 失败率极高且尝试过一定次数\n        if (skill.failureCount > 5 && (skill.successCount / (skill.successCount + skill.failureCount)) < 0.2) return false;\n\n        return true;\n    });\n\n    // 强制保持容量\n    if (skillLibrary.length > 100) {\n        // 如果还超标，移除得分最低的那个\n        skillLibrary.sort((a, b) => computeSkillScore(a, now) - computeSkillScore(b, now));\n        skillLibrary.shift();\n    }\n\n    if (skillLibrary.length !== initialCount) {\n        saveSkills(); // Persist if changes happened\n    }\n}\n\nexport function getAllSkills(): Skill[] {\n    return [...skillLibrary];\n}\n\n/**\n * 添加新技能\n */\nexport function addSkill(skill: Skill) {\n    // 检查是否已存在同名技能\n    const existingSkill = skillLibrary.find(s => s.name === skill.name);\n    if (existingSkill) {\n        console.log(`Skill with name \"${skill.name}\" already exists, skipping.`);\n        return false;\n    }\n\n    skillLibrary.push(skill);\n    saveSkills(); // 保存更改\n    return true;\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/skills.ts:1769134473140",
    "tokens": 1472,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/recorder.ts",
    "content": "import { RuntimeEvent, EventRecorder } from './events';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { randomUUID } from 'crypto';\n\nexport class FileEventRecorder implements EventRecorder {\n  private events: RuntimeEvent[] = [];\n  private logFile: string;\n  private flushInterval: number = 1000;\n\n  constructor(logDir: string = '.yuangs_events') {\n    this.logFile = path.join(logDir, `events_${Date.now()}.jsonl`);\n  }\n\n  async record(event: RuntimeEvent): Promise<void> {\n    this.events.push(event);\n\n    if (this.events.length >= this.flushInterval) {\n      await this.flush();\n    }\n  }\n\n  async flush(): Promise<void> {\n    if (this.events.length === 0) return;\n\n    const logDir = path.dirname(this.logFile);\n    await fs.mkdir(logDir, { recursive: true });\n\n    const content = this.events\n      .map(e => JSON.stringify(e))\n      .join('\\n') + '\\n';\n\n    await fs.appendFile(this.logFile, content, 'utf8');\n    this.events = [];\n  }\n\n  getEvents(executionId?: string): RuntimeEvent[] {\n    if (!executionId) {\n      return [...this.events];\n    }\n\n    return this.events.filter(e => e.executionId === executionId);\n  }\n}\n\nexport const createEvent = (\n  executionId: string,\n  type: RuntimeEvent['type'],\n  data: RuntimeEvent['data'],\n  metadata?: RuntimeEvent['metadata']\n): RuntimeEvent => ({\n  id: randomUUID(),\n  timestamp: Date.now(),\n  executionId,\n  type,\n  data,\n  metadata\n});\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/recorder.ts:1769134473140",
    "tokens": 353,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/events.ts",
    "content": "export type EventType = \n  | 'state_transition'\n  | 'llm_call'\n  | 'tool_execution'\n  | 'governance_decision'\n  | 'observation_recorded'\n  | 'evaluation_result'\n  | 'error_occurred';\n\nexport interface RuntimeEvent {\n  id: string;\n  timestamp: number;\n  executionId: string;\n  type: EventType;\n  data: {\n    from?: string;\n    to?: string;\n    action?: any;\n    decision?: any;\n    result?: any;\n    error?: string;\n  };\n  metadata?: Record<string, any>;\n}\n\nexport interface EventRecorder {\n  record(event: RuntimeEvent): void;\n  flush(): Promise<void>;\n  getEvents(executionId?: string): RuntimeEvent[];\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/events.ts:1769134473140",
    "tokens": 152,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/index.ts",
    "content": "export * from './events';\nexport * from './recorder';\nexport * from './replayer';\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/index.ts:1769134473140",
    "tokens": 21,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/replayer.ts",
    "content": "import { RuntimeEvent } from './events';\n\nexport interface ReplayerOptions {\n  speed?: number;\n  stopOnError?: boolean;\n  dryRun?: boolean;\n}\n\nexport class EventReplayer {\n  private events: RuntimeEvent[] = [];\n  private currentIndex: number = 0;\n  private options: Required<ReplayerOptions>;\n\n  constructor(events: RuntimeEvent[], options: ReplayerOptions = {}) {\n    this.events = events;\n    this.options = {\n      speed: options.speed || 1,\n      stopOnError: options.stopOnError !== undefined ? options.stopOnError : true,\n      dryRun: options.dryRun || false\n    };\n  }\n\n  hasNext(): boolean {\n    return this.currentIndex < this.events.length;\n  }\n\n  next(): RuntimeEvent | null {\n    if (!this.hasNext()) {\n      return null;\n    }\n\n    return this.events[this.currentIndex++];\n  }\n\n  reset(): void {\n    this.currentIndex = 0;\n  }\n\n  async replay(onEvent: (event: RuntimeEvent, options: Required<ReplayerOptions>) => Promise<void>): Promise<void> {\n    this.reset();\n    let hasError = false;\n\n    while (this.hasNext() && !hasError) {\n      const event = this.next();\n\n      if (!event) break;\n\n      try {\n        await onEvent(event, this.options);\n\n        if (event.type === 'error_occurred') {\n          hasError = true;\n          if (this.options.stopOnError) {\n            break;\n          }\n        }\n\n        if (this.options.speed > 1) {\n          const delay = 100 / this.options.speed;\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      } catch (error: any) {\n        console.error(`[Replay] Error at event ${event.id}:`, error.message);\n        hasError = true;\n      }\n    }\n\n    return;\n  }\n\n  getSummary(): {\n    total: number;\n    completed: number;\n    errors: number;\n  } {\n    const errors = this.events.filter(e => e.type === 'error_occurred').length;\n    \n    return {\n      total: this.events.length,\n      completed: this.currentIndex,\n      errors\n    };\n  }\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/replayer.ts:1769134473140",
    "tokens": 483,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextManager.ts",
    "content": "import crypto from 'crypto';\nimport { GovernanceContext } from './state';\nimport { ContextBuffer } from './contextBuffer';\nimport { ExtendedContextProtocol } from './contextDSL';\nimport { ContextBank } from './contextBank';\n\nexport class ContextManager {\n  private messages: Array<{ role: string; content: string; timestamp: number; metadata?: { kind?: import('./types').ObservationKind } }> = [];\n  private contextBuffer: ContextBuffer;\n  private contextBank: ContextBank;\n  private maxHistorySize = 50;\n\n  constructor(initialContext?: GovernanceContext) {\n    this.contextBuffer = new ContextBuffer();\n    this.contextBank = new ContextBank();\n\n    if (initialContext?.history) {\n      this.messages = initialContext.history.map(msg => ({\n        ...msg,\n        timestamp: Date.now()\n      }));\n    }\n\n    if (initialContext?.input) {\n      this.addMessage('user', initialContext.input);\n    }\n  }\n\n  addMessage(role: string, content: string): void {\n    this.messages.push({\n      role,\n      content,\n      timestamp: Date.now()\n    });\n\n    if (this.messages.length > this.maxHistorySize) {\n      this.messages = this.messages.slice(-this.maxHistorySize);\n    }\n  }\n\n  addToolResult(toolName: string, result: string): void {\n    const content = `Tool ${toolName} returned:\\n${result}`;\n    this.addMessage('tool', content);\n  }\n\n  /**\n   * 添加 Observation，支持类型分级（v3.1）\n   * @param observation 观察内容\n   * @param kind Observation 类型：tool_result, system_note, error\n   */\n  addObservation(observation: string, kind: import('./types').ObservationKind = 'system_note'): void {\n    this.addMessage('system', observation);\n    // 为最后一条消息添加 kind 元数据\n    if (this.messages.length > 0) {\n      this.messages[this.messages.length - 1].metadata = { kind };\n    }\n  }\n\n  /**\n   * 调试用：仅获取 Observation（Tool / System 注入）\n   * 不包含 user / assistant\n   */\n  getObservations(): Array<{ role: 'tool' | 'system'; content: string }> {\n    return this.messages\n      .filter(m => m.role === 'tool' || m.role === 'system')\n      .map(m => ({\n        role: m.role as 'tool' | 'system',\n        content: m.content\n      }));\n  }\n\n  /**\n   * 获取最新的 Observation（向后兼容）\n   */\n  getLastObservation(): { role: 'tool' | 'system'; content: string } | null {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n      const m = this.messages[i];\n      if (m.role === 'tool' || m.role === 'system') {\n        return { role: m.role as any, content: m.content };\n      }\n    }\n    return null;\n  }\n\n  /**\n   * 获取需要 ACK 的 Observation（排除 error 类型）\n   * 这是 v3.1 的核心修复：防止 ERROR 被当成需要确认的 Observation\n   */\n  getLastAckableObservation(): { role: 'tool' | 'system'; content: string } | null {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n      const m = this.messages[i];\n      if ((m.role === 'tool' || m.role === 'system') && m.metadata?.kind !== 'error') {\n        return { role: m.role as any, content: m.content };\n      }\n    }\n    return null;\n  }\n\n  getMessages(): Array<{ role: 'system' | 'user' | 'assistant' | 'tool'; content: string }> {\n    return this.messages.map(({ role, content }) => ({\n      role: role as 'system' | 'user' | 'assistant' | 'tool',\n      content\n    }));\n  }\n\n  getContextBuffer(): ContextBuffer {\n    return this.contextBuffer;\n  }\n\n  addContextItem(item: Omit<import('./contextBuffer').ContextItem, 'tokens'>) {\n    this.contextBuffer.add(item);\n  }\n\n  async addContextItemAsync(item: Omit<import('./contextBuffer').ContextItem, 'tokens'>) {\n    await this.contextBuffer.addAsync(item);\n  }\n\n  buildContextPrompt(userInput: string, options?: import('./contextBuffer').BuildPromptOptions) {\n    return this.contextBuffer.buildPrompt(userInput, options);\n  }\n\n  /**\n   * 使用 DSL 查询上下文\n   */\n  async queryDSL(dslQuery: string) {\n    return await this.contextBuffer.queryDSL(dslQuery, this.contextBank);\n  }\n\n  /**\n   * 解析包含 DSL 的用户输入并获取相关上下文\n   */\n  async getDSLContextForInput(input: string) {\n    return await this.contextBuffer.getDSLContextForInput(input, this.contextBank);\n  }\n\n  /**\n   * 初始化 Context Bank\n   */\n  async initializeContextBank(): Promise<void> {\n    await this.contextBank.initialize();\n  }\n\n  /**\n   * 从 ContextBuffer 导出高价值上下文到银行\n   */\n  async exportToContextBank(projectScope?: string): Promise<void> {\n    await this.contextBank.exportFromContextBuffer(this.contextBuffer, projectScope);\n  }\n\n  /**\n   * 从 Context Bank 查询上下文\n   */\n  async queryContextBank(options: import('./contextBank').BankQueryOptions): Promise<import('./contextBank').BankContextItem[]> {\n    return await this.contextBank.query(options);\n  }\n\n  /**\n   * 将 Context Bank 中的项目添加到当前上下文\n   */\n  async importFromContextBank(options: import('./contextBank').BankQueryOptions): Promise<void> {\n    const bankItems = await this.contextBank.query(options);\n\n    for (const item of bankItems) {\n      // 将 BankContextItem 转换为 ContextItem 并添加到缓冲区\n      this.contextBuffer.add({\n        type: item.type,\n        path: item.path,\n        stableId: item.stableId,\n        content: item.content,\n        summary: item.summary,\n        summarized: item.summarized,\n        semantic: item.semantic,\n        summaryQuality: item.summaryQuality,\n        referencedBy: item.referencedBy,\n        usageStats: item.usageStats,\n        importance: item.importance,\n        metadata: {\n          source: 'context_bank',\n          bankItemId: item.id\n        }\n      });\n    }\n  }\n\n  /**\n   * 记录 ContextBank 项目的使用情况\n   */\n  async recordBankUsage(success: boolean): Promise<void> {\n    const contextItems = this.contextBuffer.export();\n\n    for (const item of contextItems) {\n      // 检查项目是否来自银行（有 bankItemId）\n      const bankItemId = (item as any).metadata?.bankItemId;\n      if (bankItemId) {\n        try {\n          // 使用银行项目 ID 而不是路径进行记录\n          await this.contextBank.recordUsage(bankItemId, success);\n        } catch (error) {\n          console.warn(`[ContextManager] Could not record bank usage for ${bankItemId}:`, error);\n        }\n      }\n    }\n  }\n\n  getRecentMessages(count: number): Array<{ role: string; content: string; timestamp: number }> {\n    return this.messages.slice(-count);\n  }\n\n  getHash(): string {\n    const content = JSON.stringify(this.messages);\n    return crypto.createHash('sha256').update(content).digest('hex');\n  }\n\n  getSnapshot() {\n    return {\n      inputHash: this.getHash(),\n      systemPromptVersion: 'v1.0.0',\n      toolSetVersion: 'v1.0.0',\n      recentMessages: this.getRecentMessages(10)\n    };\n  }\n\n  clear(): void {\n    this.messages = [];\n    this.contextBuffer.clear();\n  }\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/contextManager.ts:1769134473140",
    "tokens": 1627,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/selectModel.ts",
    "content": "import { AgentIntent } from './types';\nimport { getUserConfig } from '../ai/client';\n\nexport function selectModel(\n    intent: AgentIntent,\n    override?: string\n): string {\n    if (override) return override;\n\n    const config = getUserConfig();\n    const defaultModel = config.defaultModel || 'Assistant';\n\n    return defaultModel;\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/selectModel.ts:1769134473140",
    "tokens": 84,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextBank.ts",
    "content": "/**\n * Context Bank v1 — 跨会话上下文银行\n * \n * 一个跨会话、跨执行周期的长期上下文存储系统，\n * 将短期 ContextBuffer 中被证明有价值的上下文沉淀为可复用资产。\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { ContextItem } from './contextBuffer';\nimport { ContextImportance, computeContextImportance } from './contextImportance';\nimport { randomUUID } from 'crypto';\n\nexport interface BankContextItem extends ContextItem {\n  id: string;\n  stableId: string;        // 稳定身份\n  source: 'project' | 'global' | 'external'; // 上下文来源\n  projectScope?: string;   // 项目作用域 (repo hash / path)\n  tags?: string[];         // 标签 (e.g. ['build', 'infra', 'ci'])\n  frozen?: boolean;        // 禁止自动修改\n  deprecated?: boolean;    // 已弃用\n  firstSeenAt: number;     // 首次出现时间\n  lastUsedAt: number;      // 最后使用时间\n}\n\nexport interface BankIndexEntry {\n  id: string;\n  path: string;\n  stableId: string;\n  type: 'file' | 'directory' | 'runtime';\n  confidence: number;      // 重要性评分\n  useCount: number;        // 使用次数\n  lastUsed: number;        // 最后使用时间戳\n  tags?: string[];         // 标签\n  projectScope?: string;   // 项目作用域\n  source?: 'project' | 'global' | 'external'; // 上下文来源\n}\n\nexport interface BankQueryOptions {\n  input?: string;          // 用户输入，用于相关性匹配\n  projectScope?: string;   // 项目作用域过滤\n  strategy?: 'ranked' | 'recent' | 'relevance'; // 查询策略\n  limit?: number;          // 限制返回数量\n  tags?: string[];         // 标签过滤\n}\n\nexport interface BankStats {\n  totalItems: number;\n  totalTokens: number;\n  lastUpdated: number;\n  usageLogSize: number;\n}\n\nexport class ContextBank {\n  private bankDir: string;\n  private indexPath: string;\n  private itemsDir: string;\n  private snapshotsDir: string;\n  private statsDir: string;\n\n  constructor(bankPath?: string) {\n    this.bankDir = bankPath || path.join(require('os').homedir(), '.yuangs', 'context-bank');\n    this.indexPath = path.join(this.bankDir, 'index.json');\n    this.itemsDir = path.join(this.bankDir, 'items');\n    this.snapshotsDir = path.join(this.bankDir, 'snapshots');\n    this.statsDir = path.join(this.bankDir, 'stats');\n  }\n\n  /**\n   * 初始化 Context Bank\n   */\n  async initialize(): Promise<void> {\n    await fs.mkdir(this.bankDir, { recursive: true });\n    await fs.mkdir(this.itemsDir, { recursive: true });\n    await fs.mkdir(this.snapshotsDir, { recursive: true });\n    await fs.mkdir(this.statsDir, { recursive: true });\n\n    // 初始化索引文件\n    try {\n      await fs.access(this.indexPath);\n    } catch {\n      // 如果索引文件不存在，创建一个空的\n      await this.saveIndex([]);\n    }\n  }\n\n  /**\n   * 从 ContextBuffer 导出高价值上下文到银行\n   */\n  async exportFromContextBuffer(contextBuffer: { export(): ContextItem[] }, projectScope?: string): Promise<void> {\n    const items = contextBuffer.export();\n    const highValueItems = this.filterHighValueItems(items);\n\n    for (const item of highValueItems) {\n      // 添加项目作用域信息\n      const bankItem: BankContextItem = {\n        ...item,\n        id: `bank_${randomUUID()}`,\n        stableId: item.stableId || item.path, // 确保 stableId 存在\n        source: projectScope ? 'project' : 'global',\n        projectScope,\n        firstSeenAt: Date.now(),\n        lastUsedAt: Date.now()\n      };\n\n      await this.upsertItem(bankItem);\n    }\n  }\n\n  /**\n   * 过滤高价值 ContextItem\n   */\n  private filterHighValueItems(items: ContextItem[]): ContextItem[] {\n    return items.filter(item => {\n      if (!item.importance) return false;\n\n      const { useCount, successCount } = item.importance;\n      const totalInteractions = useCount + item.importance.failureCount;\n      const successRate = totalInteractions > 0 ? successCount / totalInteractions : 0;\n\n      // 触发条件：使用次数≥3 且 成功率≥0.6\n      return useCount >= 3 && successRate >= 0.6;\n    });\n  }\n\n  /**\n   * 插入或更新银行中的项目\n   */\n  async upsertItem(item: BankContextItem): Promise<void> {\n    // 检查是否已存在相同 stableId 的项目\n    const existingItems = await this.loadIndex();\n    const existingIndex = existingItems.findIndex(idx => idx.stableId === item.stableId);\n\n    if (existingIndex !== -1) {\n      // 更新现有项目\n      const existingItemPath = path.join(this.itemsDir, `${existingItems[existingIndex].id}.json`);\n      const existingItem: BankContextItem = JSON.parse(await fs.readFile(existingItemPath, 'utf-8'));\n\n      // 合并重要性统计\n      if (item.importance && existingItem.importance) {\n        existingItem.importance.useCount += item.importance.useCount;\n        existingItem.importance.successCount += item.importance.successCount;\n        existingItem.importance.failureCount += item.importance.failureCount;\n        existingItem.importance.confidence = Math.max(\n          existingItem.importance.confidence,\n          item.importance.confidence\n        );\n      }\n\n      // 更新最后使用时间\n      existingItem.lastUsedAt = Math.max(existingItem.lastUsedAt, item.lastUsedAt);\n      \n      // 更新内容（如果内容不同）\n      if (item.content !== existingItem.content) {\n        existingItem.content = item.content;\n        existingItem.tokens = item.tokens;\n        existingItem.summary = item.summary;\n        existingItem.summarized = item.summarized;\n      }\n\n      // 保存更新后的项目\n      await fs.writeFile(existingItemPath, JSON.stringify(existingItem, null, 2));\n      \n      // 更新索引\n      existingItems[existingIndex] = {\n        id: existingItem.id,\n        path: existingItem.path,\n        stableId: existingItem.stableId,\n        type: existingItem.type,\n        confidence: computeContextImportance(existingItem.importance!),\n        useCount: existingItem.importance?.useCount || 0,\n        lastUsed: existingItem.lastUsedAt,\n        tags: existingItem.tags,\n        projectScope: existingItem.projectScope\n      };\n    } else {\n      // 添加新项目\n      const itemId = item.id || `bank_${randomUUID()}`;\n      const itemPath = path.join(this.itemsDir, `${itemId}.json`);\n\n      await fs.writeFile(itemPath, JSON.stringify(item, null, 2));\n\n      // 添加到索引\n      const indexEntry: BankIndexEntry = {\n        id: itemId,\n        path: item.path,\n        stableId: item.stableId,\n        type: item.type,\n        confidence: computeContextImportance(item.importance!),\n        useCount: item.importance?.useCount || 0,\n        lastUsed: item.lastUsedAt,\n        tags: item.tags,\n        projectScope: item.projectScope\n      };\n\n      existingItems.push(indexEntry);\n    }\n\n    await this.saveIndex(existingItems);\n  }\n\n  /**\n   * 根据查询选项从银行检索上下文\n   */\n  async query(options: BankQueryOptions): Promise<BankContextItem[]> {\n    const index = await this.loadIndex();\n    let filteredIndex = [...index];\n\n    // 过滤项目作用域\n    if (options.projectScope) {\n      filteredIndex = filteredIndex.filter(item => \n        item.projectScope === options.projectScope || item.source === 'global'\n      );\n    }\n\n    // 过滤标签\n    if (options.tags && options.tags.length > 0) {\n      filteredIndex = filteredIndex.filter(item => \n        item.tags && options.tags?.every(tag => item.tags?.includes(tag))\n      );\n    }\n\n    // 根据策略排序\n    switch (options.strategy || 'ranked') {\n      case 'ranked':\n        filteredIndex.sort((a, b) => b.confidence - a.confidence);\n        break;\n      case 'recent':\n        filteredIndex.sort((a, b) => b.lastUsed - a.lastUsed);\n        break;\n      case 'relevance':\n        // 简单的相关性计算：基于路径匹配\n        if (options.input) {\n          filteredIndex.sort((a, b) => {\n            const aRelevance = this.calculateRelevance(a.path, options.input!);\n            const bRelevance = this.calculateRelevance(b.path, options.input!);\n            return bRelevance - aRelevance;\n          });\n        }\n        break;\n    }\n\n    // 限制返回数量\n    if (options.limit) {\n      filteredIndex = filteredIndex.slice(0, options.limit);\n    }\n\n    // 加载匹配的项目\n    const results: BankContextItem[] = [];\n    for (const entry of filteredIndex) {\n      try {\n        const itemPath = path.join(this.itemsDir, `${entry.id}.json`);\n        const item: BankContextItem = JSON.parse(await fs.readFile(itemPath, 'utf-8'));\n        results.push(item);\n      } catch (error) {\n        console.warn(`[ContextBank] Failed to load item ${entry.id}:`, error);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * 计算路径与输入的相关性\n   */\n  private calculateRelevance(itemPath: string, input: string): number {\n    const pathLower = itemPath.toLowerCase();\n    const inputLower = input.toLowerCase();\n    \n    // 计算关键词匹配度\n    const inputWords = inputLower.split(/\\W+/).filter(Boolean);\n    const matches = inputWords.filter(word => pathLower.includes(word)).length;\n    \n    return matches / inputWords.length; // 返回匹配比例\n  }\n\n  /**\n   * 加载索引\n   */\n  private async loadIndex(): Promise<BankIndexEntry[]> {\n    try {\n      const content = await fs.readFile(this.indexPath, 'utf-8');\n      const data = JSON.parse(content);\n\n      if (!data || data.version !== '1.0' || !Array.isArray(data.items)) {\n        throw new Error('Invalid ContextBank index format');\n      }\n\n      return data.items;\n    } catch (error) {\n      console.warn(`[ContextBank] Failed to load index:`, error);\n      return [];\n    }\n  }\n\n  /**\n   * 保存索引\n   */\n  private async saveIndex(index: BankIndexEntry[]): Promise<void> {\n    const data = {\n      version: '1.0',\n      updatedAt: Date.now(),\n      items: index\n    };\n    await fs.writeFile(this.indexPath, JSON.stringify(data, null, 2));\n  }\n\n  /**\n   * 获取银行统计信息\n   */\n  async getStats(): Promise<BankStats> {\n    const index = await this.loadIndex();\n    let totalTokens = 0;\n\n    for (const entry of index) {\n      try {\n        const itemPath = path.join(this.itemsDir, `${entry.id}.json`);\n        const item: BankContextItem = JSON.parse(await fs.readFile(itemPath, 'utf-8'));\n        totalTokens += item.tokens;\n      } catch (error) {\n        console.warn(`[ContextBank] Failed to load item for stats ${entry.id}:`, error);\n      }\n    }\n\n    // 获取使用日志大小\n    let usageLogSize = 0;\n    try {\n      const usageLogPath = path.join(this.statsDir, 'usage.log');\n      const stat = await fs.stat(usageLogPath);\n      usageLogSize = stat.size;\n    } catch {\n      // 如果日志文件不存在，大小为0\n    }\n\n    return {\n      totalItems: index.length,\n      totalTokens,\n      lastUpdated: Date.now(), // 实际上应该是索引文件的修改时间\n      usageLogSize\n    };\n  }\n\n  /**\n   * 创建银行快照\n   */\n  async createSnapshot(name?: string): Promise<string> {\n    const snapshotName = name || `snapshot_${Date.now()}`;\n    const snapshotPath = path.join(this.snapshotsDir, `${snapshotName}.json`);\n    \n    const index = await this.loadIndex();\n    const snapshot = {\n      name: snapshotName,\n      createdAt: Date.now(),\n      items: [] as BankContextItem[]\n    };\n\n    for (const entry of index) {\n      try {\n        const itemPath = path.join(this.itemsDir, `${entry.id}.json`);\n        const item: BankContextItem = JSON.parse(await fs.readFile(itemPath, 'utf-8'));\n        snapshot.items.push(item);\n      } catch (error) {\n        console.warn(`[ContextBank] Failed to load item for snapshot ${entry.id}:`, error);\n      }\n    }\n\n    await fs.writeFile(snapshotPath, JSON.stringify(snapshot, null, 2));\n    return snapshotPath;\n  }\n\n  /**\n   * 从快照恢复银行\n   */\n  async restoreFromSnapshot(snapshotName: string): Promise<void> {\n    const snapshotPath = path.join(this.snapshotsDir, `${snapshotName}.json`);\n    const snapshotContent = await fs.readFile(snapshotPath, 'utf-8');\n    const snapshot = JSON.parse(snapshotContent);\n\n    // 清空当前项目\n    const files = await fs.readdir(this.itemsDir);\n    for (const file of files) {\n      if (file.endsWith('.json')) {\n        await fs.unlink(path.join(this.itemsDir, file));\n      }\n    }\n\n    // 恢复项目\n    for (const item of snapshot.items) {\n      const itemPath = path.join(this.itemsDir, `${item.id}.json`);\n      await fs.writeFile(itemPath, JSON.stringify(item, null, 2));\n    }\n\n    // 重建索引\n    const newIndex: BankIndexEntry[] = snapshot.items.map((item: BankContextItem) => ({\n      id: item.id,\n      path: item.path,\n      type: item.type,\n      confidence: computeContextImportance(item.importance!),\n      useCount: item.importance?.useCount || 0,\n      lastUsed: item.lastUsedAt,\n      tags: item.tags,\n      projectScope: item.projectScope\n    }));\n\n    await this.saveIndex(newIndex);\n  }\n\n  /**\n   * 记录使用情况\n   */\n  async recordUsage(identifier: string, success: boolean): Promise<void> {\n    // 首先尝试按 ID 查找项目\n    let itemPath = path.join(this.itemsDir, `${identifier}.json`);\n    let itemExists = false;\n    let actualId = identifier;\n\n    try {\n      await fs.access(itemPath);\n      itemExists = true;\n    } catch {\n      // ID 不存在，尝试按路径查找\n      const index = await this.loadIndex();\n      let indexEntry = index.find(entry => entry.path === identifier);\n\n      // 如果还是找不到，尝试按 stableId 查找\n      if (!indexEntry) {\n        indexEntry = index.find(entry => entry.stableId === identifier);\n      }\n\n      if (indexEntry) {\n        itemPath = path.join(this.itemsDir, `${indexEntry.id}.json`);\n        actualId = indexEntry.id; // 使用实际的 ID\n        itemExists = true;\n      }\n    }\n\n    if (!itemExists) {\n      console.warn(`[ContextBank] Item with identifier \"${identifier}\" not found`);\n      return;\n    }\n\n    try {\n      const item: BankContextItem = JSON.parse(await fs.readFile(itemPath, 'utf-8'));\n\n      if (item.importance) {\n        item.importance.useCount++;\n        if (success) {\n          item.importance.successCount++;\n          item.importance.confidence = Math.min(1, item.importance.confidence + 0.05);\n        } else {\n          item.importance.failureCount++;\n          item.importance.confidence = Math.max(0, item.importance.confidence - 0.1);\n        }\n        item.lastUsedAt = Date.now();\n      }\n\n      await fs.writeFile(itemPath, JSON.stringify(item, null, 2));\n\n      // 更新索引\n      const index = await this.loadIndex();\n      const indexEntry = index.find(entry => entry.id === actualId);\n      if (indexEntry) {\n        indexEntry.useCount = item.importance?.useCount || 0;\n        indexEntry.lastUsed = item.lastUsedAt;\n        indexEntry.confidence = computeContextImportance(item.importance!);\n        await this.saveIndex(index);\n      }\n    } catch (error) {\n      console.warn(`[ContextBank] Failed to update usage for item ${identifier}:`, error);\n    }\n\n    // 记录到使用日志\n    const logPath = path.join(this.statsDir, 'usage.log');\n    const logEntry = {\n      timestamp: Date.now(),\n      itemId: actualId,\n      success,\n      userAgent: 'ContextBank/v1'\n    };\n\n    try {\n      await fs.appendFile(logPath, JSON.stringify(logEntry) + '\\n');\n    } catch (error) {\n      console.warn('[ContextBank] Failed to write to usage log:', error);\n    }\n  }\n\n  /**\n   * 清理过期或低价值项目\n   */\n  async cleanup(options: {\n    minConfidence?: number;\n    maxAgeDays?: number;\n    dryRun?: boolean\n  } = {}): Promise<number> {\n    const {\n      minConfidence = 0.3,\n      maxAgeDays = 180,\n      dryRun = false\n    } = options;\n\n    const index = await this.loadIndex();\n    const cutoffTime = Date.now() - (maxAgeDays * 24 * 60 * 60 * 1000);\n    let cleanedCount = 0;\n\n    const remainingIndex: BankIndexEntry[] = [];\n\n    for (const entry of index) {\n      try {\n        const itemPath = path.join(this.itemsDir, `${entry.id}.json`);\n        const item: BankContextItem = JSON.parse(await fs.readFile(itemPath, 'utf-8'));\n\n        // 检查是否应该保留该项目\n        const isHighConfidence = entry.confidence >= minConfidence;\n        const isRecentlyUsed = entry.lastUsed >= cutoffTime;\n        const isFrozen = item.frozen === true;\n        const isDeprecated = item.deprecated === true;\n\n        const shouldKeep = isHighConfidence || isRecentlyUsed || isFrozen || isDeprecated;\n\n        if (!shouldKeep && !dryRun) {\n          // 删除项目文件\n          await fs.unlink(itemPath);\n          cleanedCount++;\n        } else {\n          // 保留项目\n          remainingIndex.push(entry);\n        }\n      } catch (error) {\n        console.warn(`[ContextBank] Failed to evaluate item for cleanup ${entry.id}:`, error);\n        // 如果无法读取项目，保留它以防万一\n        remainingIndex.push(entry);\n      }\n    }\n\n    if (!dryRun) {\n      await this.saveIndex(remainingIndex);\n    }\n\n    return cleanedCount;\n  }\n}",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/contextBank.ts:1769134473140",
    "tokens": 3986,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextBuffer.ts",
    "content": "import { randomUUID } from 'crypto';\nimport { ContextImportance, createContextImportance, computeContextImportance } from './contextImportance';\nimport { summarizeContext } from './contextSummary';\nimport { ExtendedContextProtocol, DSLQueryEngine, DSLParser } from './contextDSL';\nimport { recordEdge } from './knowledgeGraph';\nimport crypto from 'crypto';\n\nfunction computeStableId(item: {\n  path: string;\n  semantic?: string;\n  content: string;\n}) {\n  const sig = `${item.path}::${item.semantic ?? ''}::${item.content.slice(0, 512)}`;\n  return crypto.createHash('sha256').update(sig).digest('hex');\n}\n\nexport type ContextItem = {\n    schemaVersion?: 1; // Schema 版本\n    type: 'file' | 'directory';\n    path: string;\n    id?: string;\n    stableId?: string;   // 稳定身份（跨 session）\n    importance?: ContextImportance;\n    alias?: string;\n    content: string;\n    summary?: string;\n    summarized?: boolean;\n    tokens: number;\n    // 引用协议相关字段\n    semantic?: 'source_code' | 'log' | 'config' | 'decision' | 'evidence' | 'documentation' | 'test' | 'requirement';\n    summaryQuality?: number; // 摘要质量评分 (0-1)\n    summarySourceHash?: string; // 摘要来源内容的哈希值\n    referencedBy?: string[]; // 引用此ContextItem的AI响应ID列表\n    usageStats?: {\n        referencedCount: number; // 被显式引用的次数\n        verifiedUseful: number; // 经验证有用的引用次数\n        verifiedNotUseful: number; // 经验证无用的引用次数\n    };\n    tags?: string[]; // 标签\n    projectScope?: string; // 项目作用域\n    metadata?: {\n        promotedToSkill?: boolean;\n        bankItemId?: string;\n        source?: string;\n    }; // 元数据\n};\n\nexport type InjectionStrategy = 'ranked' | 'recent' | 'all';\n\nexport interface BuildPromptOptions {\n  maxTokens?: number;\n  strategy?: InjectionStrategy;\n}\n\nconst estimateTokens = (text: string) => Math.ceil(text.length / 4);\n\nexport class ContextBuffer {\n    private items: ContextItem[] = [];\n    private maxTokens = 32000; // 约 12.8 万字符\n\n    async addAsync(item: Omit<ContextItem, 'tokens'>, bypassTokenLimit: boolean = false) {\n        const tokens = estimateTokens(item.content);\n        this.items.push({\n            ...item,\n            schemaVersion: item.schemaVersion ?? 1,\n            stableId: item.stableId ?? computeStableId(item),\n            id: item.id ?? randomUUID(),\n            importance: item.importance ?? createContextImportance(item.path, item.type),\n            tokens,\n            usageStats: item.usageStats ?? {\n                referencedCount: 0,\n                verifiedUseful: 0,\n                verifiedNotUseful: 0\n            }\n        });\n        if (!bypassTokenLimit) {\n            await this.trimIfNeeded();\n        }\n    }\n\n    add(item: Omit<ContextItem, 'tokens'>, bypassTokenLimit: boolean = false) {\n        const tokens = estimateTokens(item.content);\n        this.items.push({\n            ...item,\n            schemaVersion: item.schemaVersion ?? 1,\n            stableId: item.stableId ?? computeStableId(item),\n            id: item.id ?? randomUUID(),\n            importance: item.importance ?? createContextImportance(item.path, item.type),\n            tokens,\n            usageStats: item.usageStats ?? {\n                referencedCount: 0,\n                verifiedUseful: 0,\n                verifiedNotUseful: 0\n            }\n        });\n        if (!bypassTokenLimit) {\n            // 对于同步方法，我们只做基本修剪（不进行摘要）\n            this.basicTrimIfNeeded();\n        }\n    }\n\n    private basicTrimIfNeeded() {\n        while (this.totalTokens() > this.maxTokens) {\n            // 按重要性评分排序，低重要性的在前面\n            this.items.sort((a, b) =>\n                computeContextImportance(a.importance!) -\n                computeContextImportance(b.importance!)\n            );\n\n            const removed = this.items.shift();\n\n            if (removed) {\n                console.log(\n                    `[Context Trim] removed low-importance: ${removed.path}`\n                );\n            }\n        }\n    }\n\n    clear() {\n        this.items = [];\n    }\n\n    list() {\n        return this.items.map((item, i) => ({\n            index: i + 1,\n            type: item.type,\n            path: item.path,\n            alias: item.alias,\n            tokens: item.tokens,\n            summary: item.summary\n        }));\n    }\n\n    isEmpty() {\n        return this.items.length === 0;\n    }\n\n    export() {\n        return this.items;\n    }\n\n    import(items: ContextItem[]) {\n        this.items = items;\n    }\n\n    private totalTokens() {\n        return this.items.reduce((sum, i) => sum + i.tokens, 0);\n    }\n\n    private async trimIfNeeded() {\n        while (this.totalTokens() > this.maxTokens) {\n            // 1. 找一个「尚未 summary」且重要性最低的\n            const candidates = this.items\n                .filter(i => !i.summarized)\n                .sort((a, b) =>\n                    computeContextImportance(a.importance!) -\n                    computeContextImportance(b.importance!)\n                );\n\n            if (candidates.length > 0) {\n                const candidate = candidates[0];\n\n                // 2. 执行 summary\n                try {\n                    const summary = await summarizeContext({\n                        type: candidate.type,\n                        path: candidate.path,\n                        content: candidate.content\n                    });\n\n                    candidate.summary = summary;\n                    candidate.summarized = true;\n\n                    // 3. 用 summary 重新计算 token\n                    candidate.tokens = estimateTokens(summary);\n\n                    // 4. 释放原始内容以节省内存（保留原始内容的标记）\n                    const originalContentSize = estimateTokens(candidate.content);\n                    candidate.content = `[ARCHIVED: Original content was ${originalContentSize} tokens, summarized to ${candidate.tokens} tokens]`;\n\n                    console.log(\n                        `[Context Summary] ${candidate.path} reduced from ${originalContentSize} to ${candidate.tokens} tokens`\n                    );\n\n                    continue; // 重新评估token数量\n                } catch (error) {\n                    console.warn(`[Context Summary] Failed to summarize ${candidate.path}:`, error);\n                }\n            }\n\n            // 如果没有可摘要的项或摘要失败，则按重要性删除\n            this.items.sort((a, b) =>\n                computeContextImportance(a.importance!) -\n                computeContextImportance(b.importance!)\n            );\n\n            const removed = this.items.shift();\n\n            if (removed) {\n                console.log(\n                    `[Context Trim] removed low-importance: ${removed.path}`\n                );\n            }\n        }\n    }\n\n    /**\n     * 记录ContextItem被显式引用\n     * @param path ContextItem的路径\n     * @param responseId 引用该ContextItem的AI响应ID\n     */\n    recordExplicitReference(path: string, responseId?: string) {\n        const item = this.items.find(i => i.path === path);\n        if (item) {\n            if (!item.usageStats) {\n                item.usageStats = {\n                    referencedCount: 0,\n                    verifiedUseful: 0,\n                    verifiedNotUseful: 0\n                };\n            }\n            item.usageStats.referencedCount++;\n\n            if (responseId) {\n                if (!item.referencedBy) {\n                    item.referencedBy = [];\n                }\n                if (!item.referencedBy.includes(responseId)) {\n                    item.referencedBy.push(responseId);\n                }\n\n                // === C5-B-1: Knowledge Graph Record (Context -> Execution) ===\n                if (item.id) {\n                    recordEdge({\n                        from: item.id,\n                        to: responseId, // 使用 AI 响应 ID 作为执行节点的代理 ID\n                        type: 'used_in',\n                        timestamp: Date.now(),\n                        meta: { path: item.path, type: item.type }\n                    });\n                }\n            }\n\n            // 同时更新importance中的useCount\n            if (item.importance) {\n                item.importance.useCount++;\n                item.importance.lastUsed = Date.now();\n            }\n        }\n    }\n\n    /**\n     * 验证ContextItem引用的有效性\n     * @param path ContextItem的路径\n     * @param wasUseful 引用是否被证明有用\n     */\n    validateReference(path: string, wasUseful: boolean) {\n        const item = this.items.find(i => i.path === path);\n        if (item && item.usageStats) {\n            if (wasUseful) {\n                item.usageStats.verifiedUseful++;\n            } else {\n                item.usageStats.verifiedNotUseful++;\n            }\n        }\n    }\n\n    /**\n     * 计算ContextItem的综合评分\n     * @param item ContextItem\n     * @returns 评分值\n     */\n    private computeItemScore(item: ContextItem): number {\n        if (!item.importance) {\n            // 如果没有重要性信息，默认为中等评分\n            return 0.5;\n        }\n\n        const baseScore = computeContextImportance(item.importance);\n\n        // 使用次数的影响（对数增长，避免过度放大）\n        const useFactor = Math.log(1 + item.importance.useCount);\n\n        // 新鲜度衰减（最近使用的项目获得更高评分）\n        const now = Date.now();\n        const daysSinceLastUse = (now - item.importance.lastUsed) / (1000 * 60 * 60 * 24);\n        const freshnessFactor = Math.exp(-daysSinceLastUse / 7); // 7天半衰期\n\n        // 显式引用的影响\n        const explicitReferenceFactor = item.usageStats ?\n            Math.log(1 + item.usageStats.referencedCount) : 0;\n\n        return baseScore * useFactor * freshnessFactor * (1 + explicitReferenceFactor * 0.1);\n    }\n\n    /**\n     * 根据策略对ContextItems进行排序\n     * @param items ContextItem数组\n     * @param strategy 排序策略\n     * @returns 排序后的数组\n     */\n    private sortItemsByStrategy(items: ContextItem[], strategy: InjectionStrategy): ContextItem[] {\n        switch (strategy) {\n            case 'ranked':\n                // 按综合评分降序排列\n                return [...items].sort((a, b) =>\n                    this.computeItemScore(b) - this.computeItemScore(a)\n                );\n            case 'recent':\n                // 按最近使用时间降序排列\n                return [...items].sort((a, b) =>\n                    (b.importance?.lastUsed || 0) - (a.importance?.lastUsed || 0)\n                );\n            case 'all':\n            default:\n                // 保持原有顺序\n                return [...items];\n        }\n    }\n\n    buildPrompt(userInput: string, options: BuildPromptOptions = {}): string {\n        const { maxTokens, strategy = 'ranked' } = options;\n\n        if (this.isEmpty()) return userInput;\n\n        // 根据策略排序items\n        const sortedItems = this.sortItemsByStrategy([...this.items], strategy);\n\n        // 如果指定了maxTokens，我们需要截断内容以满足限制\n        let filteredItems = sortedItems;\n        if (maxTokens) {\n            filteredItems = [];\n            let currentTokens = 0;\n\n            for (const item of sortedItems) {\n                if (currentTokens + item.tokens > maxTokens) {\n                    break;\n                }\n                filteredItems.push(item);\n                currentTokens += item.tokens;\n            }\n        }\n\n        // 按重要性和语义类型分组\n        const highConfidenceItems = filteredItems.filter(item =>\n            item.importance && computeContextImportance(item.importance) > 0.7\n        );\n        const mediumConfidenceItems = filteredItems.filter(item =>\n            item.importance &&\n            computeContextImportance(item.importance) > 0.3 &&\n            computeContextImportance(item.importance) <= 0.7\n        );\n        const lowConfidenceItems = filteredItems.filter(item =>\n            !item.importance || computeContextImportance(item.importance) <= 0.3\n        );\n\n        // 构建不同部分的上下文\n        const sections = [];\n\n        if (highConfidenceItems.length > 0) {\n            // 按语义类型进一步细分高置信度项\n            const semanticGroups: Record<string, typeof highConfidenceItems> = {};\n            for (const item of highConfidenceItems) {\n                const semantic = item.semantic || 'other';\n                if (!semanticGroups[semantic]) {\n                    semanticGroups[semantic] = [];\n                }\n                semanticGroups[semantic].push(item);\n            }\n\n            for (const [semantic, items] of Object.entries(semanticGroups)) {\n                const semanticBlock = items.map(item => {\n                    const title = item.alias\n                        ? `[Reference] ${item.type}: ${item.alias} (${item.path})`\n                        : `[Reference] ${item.type}: ${item.path}`;\n\n                    const body = item.summary ?? item.content;\n\n                    return `${title}\\n---\\n${body}\\n---`;\n                }).join('\\n\\n');\n\n                sections.push(`# Background Knowledge (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - High Confidence)\\n${semanticBlock}`);\n            }\n        }\n\n        if (mediumConfidenceItems.length > 0) {\n            // 按语义类型进一步细分中置信度项\n            const semanticGroups: Record<string, typeof mediumConfidenceItems> = {};\n            for (const item of mediumConfidenceItems) {\n                const semantic = item.semantic || 'other';\n                if (!semanticGroups[semantic]) {\n                    semanticGroups[semantic] = [];\n                }\n                semanticGroups[semantic].push(item);\n            }\n\n            for (const [semantic, items] of Object.entries(semanticGroups)) {\n                const semanticBlock = items.map(item => {\n                    const title = item.alias\n                        ? `[Reference] ${item.type}: ${item.alias} (${item.path})`\n                        : `[Reference] ${item.type}: ${item.path}`;\n\n                    const body = item.summary ?? item.content;\n\n                    return `${title}\\n---\\n${body}\\n---`;\n                }).join('\\n\\n');\n\n                sections.push(`# Supporting Information (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - Medium Confidence)\\n${semanticBlock}`);\n            }\n        }\n\n        if (lowConfidenceItems.length > 0) {\n            // 按语义类型进一步细分低置信度项\n            const semanticGroups: Record<string, typeof lowConfidenceItems> = {};\n            for (const item of lowConfidenceItems) {\n                const semantic = item.semantic || 'other';\n                if (!semanticGroups[semantic]) {\n                    semanticGroups[semantic] = [];\n                }\n                semanticGroups[semantic].push(item);\n            }\n\n            for (const [semantic, items] of Object.entries(semanticGroups)) {\n                const semanticBlock = items.map(item => {\n                    const title = item.alias\n                        ? `[Reference] ${item.type}: ${item.alias} (${item.path})`\n                        : `[Reference] ${item.type}: ${item.path}`;\n\n                    const body = item.summary ?? item.content;\n\n                    return `${title}\\n---\\n${body}\\n---`;\n                }).join('\\n\\n');\n\n                sections.push(`# Archived References (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - Low Confidence)\\n${semanticBlock}`);\n            }\n        }\n\n        const contextBlock = sections.join('\\n\\n');\n\n        return `\n${contextBlock}\n\n# Task Instructions\nBased on the provided context (if any), answer the user's question. If the context contains source code, treat it as your \"source of truth.\"\n\nUser Question:\n${userInput}\n`;\n    }\n\n    /**\n     * 使用 DSL 查询上下文\n     */\n    async queryDSL(dslQuery: string, contextBank?: import('./contextBank').ContextBank): Promise<ContextItem[]> {\n        const parsedQuery = DSLParser.parse(dslQuery);\n        const engine = new DSLQueryEngine(this.items);\n        const result = engine.execute(parsedQuery);\n\n        let matchingItems = result.items;\n\n        // 如果提供了 ContextBank，也查询银行中的项目\n        if (contextBank) {\n            try {\n                // 将 DSL 查询转换为 ContextBank 查询选项\n                const bankQueryOptions: import('./contextBank').BankQueryOptions = {\n                    input: dslQuery,\n                    strategy: 'relevance',\n                    limit: 10 // 限制从银行返回的数量\n                };\n\n                // 执行银行查询\n                const bankResults = await contextBank.query(bankQueryOptions);\n                matchingItems = [...matchingItems, ...bankResults];\n            } catch (error) {\n                console.warn(`[ContextBuffer] Could not query ContextBank: ${error}`);\n            }\n        }\n\n        return matchingItems;\n    }\n\n    /**\n     * 解析包含 DSL 的用户输入并获取相关上下文\n     */\n    async getDSLContextForInput(input: string, contextBank?: import('./contextBank').ContextBank): Promise<ContextItem[]> {\n        const { dslQueries } = ExtendedContextProtocol.parseUserInput(input);\n        let allMatchingItems: ContextItem[] = [];\n\n        for (const query of dslQueries) {\n            const matchingItems = await this.queryDSL(query, contextBank);\n            allMatchingItems = [...allMatchingItems, ...matchingItems];\n        }\n\n        // 去重\n        const uniqueItems = allMatchingItems.filter((item, index, self) =>\n            index === self.findIndex(i => i.path === item.path)\n        );\n\n        return uniqueItems;\n    }\n}\n// Test change for git diff\n// Another test change (unstaged)\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/contextBuffer.ts:1769134473140",
    "tokens": 4259,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/engine.ts",
    "content": "import { Policy, PolicyContext, PolicyResult } from './types';\nimport { RiskLevel } from '../state';\n\nexport class PolicyEngine {\n  private policies: Map<string, Policy> = new Map();\n\n  registerPolicy(policy: Policy): void {\n    this.policies.set(policy.name, policy);\n  }\n\n  unregisterPolicy(name: string): void {\n    this.policies.delete(name);\n  }\n\n  async evaluate(context: PolicyContext): Promise<PolicyResult> {\n    let finalResult: PolicyResult = {\n      allowed: true,\n      reason: 'All policies passed'\n    };\n\n    for (const [name, policy] of this.policies) {\n      const result = await policy.evaluate(context);\n      \n      if (!result.allowed) {\n        return {\n          allowed: false,\n          reason: `Policy \"${name}\" blocked: ${result.reason}`,\n          requiresEscalation: result.requiresEscalation || false,\n          suggestedActions: result.suggestedActions\n        };\n      }\n\n      if (result.requiresEscalation) {\n        finalResult.requiresEscalation = true;\n        finalResult.suggestedActions = result.suggestedActions;\n      }\n    }\n\n    return finalResult;\n  }\n\n  evaluateRisk(action: { type: string; payload: any }): RiskLevel {\n    const { type, payload } = action;\n\n    if (type === 'tool_call') {\n      const toolName = payload.tool_name;\n      \n      const lowRiskTools = ['read_file', 'list_files', 'web_search'];\n      if (lowRiskTools.includes(toolName)) {\n        return 'low';\n      }\n\n      const mediumRiskTools = ['write_file', 'shell'];\n      if (mediumRiskTools.includes(toolName)) {\n        const cmd = payload.parameters?.command || payload.command || '';\n        if (this.containsDangerousCommand(cmd)) {\n          return 'high';\n        }\n        return 'medium';\n      }\n\n      return 'medium';\n    }\n\n    if (type === 'shell_cmd') {\n      const cmd = payload.command || '';\n      if (this.containsDangerousCommand(cmd)) {\n        return 'high';\n      }\n      return 'medium';\n    }\n\n    return 'low';\n  }\n\n  private containsDangerousCommand(cmd: string): boolean {\n    const dangerousPatterns = [\n      /rm\\s+-rf\\s+\\//,\n      /rm\\s+-rf\\s+~/,\n      />\\s*\\/dev\\/null/,\n      /dd\\s+if=/,\n      /mkfs/,\n      /format/,\n      /sudo\\s+rm/\n    ];\n\n    return dangerousPatterns.some(pattern => pattern.test(cmd));\n  }\n}\n\nexport const policyEngine = new PolicyEngine();\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/engine.ts:1769134473140",
    "tokens": 580,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/policies/noDangerousShell.ts",
    "content": "import { Policy, PolicyContext, PolicyResult } from '../types';\nimport { RiskLevel } from '../../state';\n\nexport class NoDangerousShellPolicy implements Policy {\n  name = 'no-dangerous-shell';\n  description = 'Prevents execution of dangerous shell commands';\n\n  evaluate(context: PolicyContext): PolicyResult {\n    const { action } = context;\n\n    if (action.type === 'shell_cmd') {\n      const command = action.payload?.command || '';\n      \n      const dangerousPatterns = [\n        { pattern: /rm\\s+-rf\\s+\\//, name: 'rm -rf /', risk: 'high' },\n        { pattern: /rm\\s+-rf\\s+~/, name: 'rm -rf ~', risk: 'high' },\n        { pattern: />\\s*\\/dev\\/null/, name: 'Redirect to /dev/null', risk: 'medium' },\n        { pattern: /dd\\s+if=/, name: 'dd command', risk: 'high' },\n        { pattern: /mkfs/, name: 'mkfs (filesystem creation)', risk: 'high' },\n        { pattern: /format/, name: 'format command', risk: 'high' },\n        { pattern: /sudo\\s+rm/, name: 'sudo rm', risk: 'high' },\n        { pattern: /chmod\\s+777\\s+\\/(?!dev)/, name: 'chmod 777 on system', risk: 'high' },\n        { pattern: /:\\s*~\\(\\)/, name: 'fork bomb', risk: 'high' }\n      ];\n\n      for (const { pattern, name, risk } of dangerousPatterns) {\n        if (pattern.test(command)) {\n          return {\n            allowed: false,\n            reason: `Dangerous command detected: ${name} (${risk} risk)`,\n            requiresEscalation: risk === 'high',\n            suggestedActions: [\n              `Review the command: \"${command}\"`,\n              'Consider using safer alternatives',\n              'Break down the operation into smaller, safer steps'\n            ]\n          };\n        }\n      }\n    }\n\n    return {\n      allowed: true,\n      reason: 'No dangerous patterns detected'\n    };\n  }\n}\n\nexport const noDangerousShellPolicy = new NoDangerousShellPolicy();\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/policies/noDangerousShell.ts:1769134473140",
    "tokens": 460,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/types.ts",
    "content": "import { RiskLevel } from '../state';\n\nexport interface PolicyContext {\n  action: {\n    type: string;\n    payload: any;\n  };\n  user?: {\n    permissions: string[];\n  };\n  environment?: {\n    isProduction: boolean;\n  };\n}\n\nexport interface PolicyResult {\n  allowed: boolean;\n  reason?: string;\n  requiresEscalation?: boolean;\n  suggestedActions?: string[];\n}\n\nexport interface Policy {\n  name: string;\n  description: string;\n  evaluate(context: PolicyContext): PolicyResult | Promise<PolicyResult>;\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/types.ts:1769134473140",
    "tokens": 125,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/index.ts",
    "content": "export * from './types';\nexport * from './engine';\nexport * from './policies/noDangerousShell';\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/index.ts:1769134473140",
    "tokens": 24,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/replayExplain.ts",
    "content": "import { ExecutionTurn } from './state';\nimport { ExecutionRecorder } from './executionRecorder';\nimport { generateSkillHintsFromContext, formatSkillHints, ContextSkillHint, promoteContextToSkill } from './contextSkillBridge';\nimport { ContextManager } from './contextManager';\nimport { ContextToSkillPromotionRules } from './contextSkillPromotion';\n\nexport function explainExecution(recorder: ExecutionRecorder, contextManager?: ContextManager): string {\n  const turns = recorder.getTurns();\n  const summary = recorder.getSummary();\n\n  const lines: string[] = [];\n\n  lines.push('# Execution Explanation Report');\n  lines.push('');\n  lines.push('## Summary');\n  lines.push(`- Total Turns: ${summary.totalTurns}`);\n  lines.push(`- Added Context Items: ${summary.totalAddedContext}`);\n  lines.push(`- Removed Context Items: ${summary.totalRemovedContext}`);\n  lines.push(`- Changed Context Items: ${summary.totalChangedContext}`);\n  lines.push('');\n\n  // 如果提供了ContextManager，生成Skill Hints\n  if (contextManager) {\n    const contextItems = contextManager.getContextBuffer().export();\n    const skillHints = generateSkillHintsFromContext(contextItems);\n\n    if (skillHints.length > 0) {\n      lines.push('## Skill Suggestions from Context');\n      lines.push(formatSkillHints(skillHints));\n      lines.push('');\n    }\n  }\n\n  lines.push('## Detailed Turn-by-Turn Analysis');\n  lines.push('');\n\n  for (const turn of turns) {\n    lines.push(`### Turn ${turn.turnId}`);\n    lines.push('');\n\n    if (turn.startTime) {\n      lines.push(`- Start Time: ${new Date(turn.startTime).toISOString()}`);\n    }\n\n    if (turn.endTime) {\n      lines.push(`- End Time: ${new Date(turn.endTime).toISOString()}`);\n    }\n\n    if (turn.contextDiff) {\n      lines.push('');\n      lines.push('#### Context Changes:');\n\n      if (turn.contextDiff.added.length > 0) {\n        lines.push('- Added:');\n        for (const item of turn.contextDiff.added) {\n          lines.push(`  - ${item}`);\n        }\n      }\n\n      if (turn.contextDiff.removed.length > 0) {\n        lines.push('- Removed:');\n        for (const item of turn.contextDiff.removed) {\n          lines.push(`  - ${item}`);\n        }\n      }\n\n      if (turn.contextDiff.changed.length > 0) {\n        lines.push('- Changed:');\n        for (const item of turn.contextDiff.changed) {\n          lines.push(`  - ${item}`);\n        }\n      }\n    }\n\n    if (turn.proposedAction) {\n      lines.push('');\n      lines.push(`#### Action Type: ${turn.proposedAction.type}`);\n      lines.push(`- Reasoning: ${turn.proposedAction.reasoning}`);\n    }\n\n    if (turn.governance) {\n      lines.push('');\n      lines.push(`#### Governance Decision: ${turn.governance.status}`);\n      if ('reason' in turn.governance) {\n        lines.push(`- Reason: ${turn.governance.reason}`);\n      }\n      lines.push(`- Decided by: ${turn.governance.by}`);\n    }\n\n    if (turn.executionResult) {\n      lines.push('');\n      lines.push(`#### Execution Result: ${turn.executionResult.success ? 'SUCCESS' : 'FAILURE'}`);\n      if (turn.executionResult.error) {\n        lines.push(`- Error: ${turn.executionResult.error}`);\n      }\n    }\n\n    lines.push('');\n  }\n\n  return lines.join('\\n');\n}\n\nexport function replayExecution(recorder: ExecutionRecorder, options: { showContextDiff?: boolean } = {}): string {\n  const { showContextDiff = true } = options;\n  const turns = recorder.getTurns();\n  const lines: string[] = [];\n\n  lines.push('# Execution Replay');\n  lines.push('');\n\n  for (const turn of turns) {\n    lines.push(`## Turn ${turn.turnId}`);\n    \n    if (showContextDiff && turn.contextDiff) {\n      lines.push('');\n      lines.push('### Context Diff:');\n      \n      if (turn.contextDiff.added.length > 0) {\n        lines.push('Added:');\n        for (const item of turn.contextDiff.added) {\n          lines.push(`  + ${item}`);\n        }\n      }\n      \n      if (turn.contextDiff.removed.length > 0) {\n        lines.push('Removed:');\n        for (const item of turn.contextDiff.removed) {\n          lines.push(`  - ${item}`);\n        }\n      }\n      \n      if (turn.contextDiff.changed.length > 0) {\n        lines.push('Changed:');\n        for (const item of turn.contextDiff.changed) {\n          lines.push(`  ~ ${item}`);\n        }\n      }\n      \n      if (!turn.contextDiff.added.length && \n          !turn.contextDiff.removed.length && \n          !turn.contextDiff.changed.length) {\n        lines.push('(No context changes)');\n      }\n    }\n    \n    if (turn.proposedAction) {\n      lines.push('');\n      lines.push(`Action: ${turn.proposedAction.type}`);\n      lines.push(`Reasoning: ${turn.proposedAction.reasoning}`);\n    }\n    \n    if (turn.executionResult) {\n      lines.push('');\n      lines.push(`Result: ${turn.executionResult.success ? 'SUCCESS' : 'FAILURE'}`);\n    }\n    \n    lines.push('');\n  }\n\n  return lines.join('\\n');\n}",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/replayExplain.ts:1769134473140",
    "tokens": 1211,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/ai/prompt.ts",
    "content": "import { OSProfile } from '../core/os';\nimport type { Macro } from '../core/validation';\n\nexport function buildCommandPrompt(\n    userInput: string,\n    os: OSProfile,\n    macros?: Record<string, Macro>,\n    context?: string\n): string {\n    const macroContext = macros && Object.keys(macros).length > 0\n        ? `\n【可复用的快捷指令 (Macros)】\n以下是可以直接复用的已验证命令。优先复用这些指令，而不是生成新命令：\n\n${Object.entries(macros).map(([name, macro]) => `  - ${name}: ${macro.description || '(无描述)'}`).join('\\n')}\n\n当用户的需求与某个 Macro 匹配或相似时：\n1. 优先使用该 Macro\n2. 在 JSON 输出中使用 \"macro\" 字段指定 Macro 名称，而不是 \"command\" 字段\n3. 仅在没有合适 Macro 时才生成新命令\n`\n        : '';\n\n    return `\n你是一个专业的命令行专家。\n\n【系统环境】\n- 操作系统: ${os.name}\n- Shell: ${os.shell}\n- find 实现: ${os.find}\n- stat 实现: ${os.stat}\n\n【规则】\n- 命令必须与当前系统兼容。\n- 如果是 macOS (BSD):\n  - 不允许使用 find -printf\n  - 优先使用 stat -f\n- 如果是 Linux (GNU):\n  - 可使用 find -printf\n- 默认不使用 sudo。\n- 确保输出的命令是单行或者使用 && 连接。\n- 不要解释，只输出符合以下 JSON 结构的文本。\n- 优先复用已验证的快捷指令（Macros），每个 Macro 都是经过人工验证的可靠命令。在生成新命令前，检查是否已有 Macro 可以完成任务。\n\n${macroContext}\n\n【输出 JSON 结构】\n{\n  \"plan\": \"简要说明你准备执行的步骤\",\n  \"command\": \"可直接执行的 shell 命令（仅当没有合适 Macro 时提供）\",\n  \"macro\": \"要复用的 Macro 名称（优先使用，与 command 二选一）\",\n  \"risk\": \"low | medium | high\"\n}\n\n【上下文信息】\n${context || '无'}\n\n【用户需求】\n${userInput}\n`;\n}\n\nexport function buildFixPrompt(\n    originalCmd: string,\n    stderr: string,\n    os: OSProfile\n): string {\n    return `\n该命令在 ${os.name} 上执行失败：\n\n命令：\n${originalCmd}\n\n错误信息：\n${stderr}\n\n请生成一个 **${os.name} 兼容** 的等价命令。\n依然只输出 JSON 格式。注意：这是修复命令，不需要检查 Macro。\n\n{\n  \"plan\": \"修复说明\",\n  \"command\": \"修复后的命令\",\n  \"risk\": \"low | medium | high\"\n}\n`;\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/ai/prompt.ts:1769134473140",
    "tokens": 393,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/ai/types.ts",
    "content": "export { AICommandPlan, type AICommandPlan as AICommandPlanType } from '../core/validation';\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/ai/types.ts:1769134473140",
    "tokens": 24,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/ai/client.ts",
    "content": "import axios from 'axios';\nimport fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { DEFAULT_AI_PROXY_URL, DEFAULT_MODEL, DEFAULT_ACCOUNT_TYPE, type UserConfig, type AIRequestMessage } from '../core/validation';\nimport { loadChatHistory, saveChatHistory } from '../agent/chatHistoryStorage';\n\nconst CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');\n\nlet conversationHistory: AIRequestMessage[] = [];\n\n// 初始化时加载持久化的聊天历史记录\nloadChatHistory().then(history => {\n    conversationHistory = history;\n});\n\nexport function addToConversationHistory(role: 'system' | 'user' | 'assistant', content: string) {\n    conversationHistory.push({ role, content });\n    if (conversationHistory.length > 20) {\n        conversationHistory = conversationHistory.slice(-20);\n    }\n    // 同时保存到持久化存储\n    saveChatHistory(conversationHistory);\n}\n\nexport function clearConversationHistory() {\n    conversationHistory = [];\n    // 同时清除持久化存储\n    saveChatHistory(conversationHistory);\n}\n\nexport function getConversationHistory() {\n    return conversationHistory;\n}\n\nexport function getUserConfig(): UserConfig {\n    if (fs.existsSync(CONFIG_FILE)) {\n        try {\n            const content = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(content) as UserConfig;\n        } catch (e) { }\n    }\n    return {};\n}\n\nexport async function askAI(prompt: string, model?: string): Promise<string> {\n    const config = getUserConfig();\n    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;\n\n    const headers = {\n        'Content-Type': 'application/json',\n        'X-Client-ID': 'vscode',\n        'Origin': 'https://cli.want.biz',\n        'Referer': 'https://cli.want.biz/',\n        'account': config.accountType || DEFAULT_ACCOUNT_TYPE,\n        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',\n        'Accept': 'application/json'\n    };\n\n    const data = {\n        model: model || config.defaultModel || DEFAULT_MODEL,\n        messages: [{ role: 'user', content: prompt }],\n        stream: false\n    };\n\n    try {\n        const response = await axios.post(url, data, { headers });\n        const content = response.data?.choices?.[0]?.message?.content;\n        return content || '';\n    } catch (error: any) {\n        const errorMsg = error.response?.data?.error?.message || error.response?.data?.message || error.message || '未知错误';\n        throw new Error(`AI 请求失败: ${errorMsg}`);\n    }\n}\n\nexport async function callAI_Stream(messages: AIRequestMessage[], model: string | undefined, onChunk: (content: string) => void, abortSignal?: AbortSignal): Promise<void> {\n    const config = getUserConfig();\n    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;\n\n    // ✅ 使用传入的 AbortSignal，或创建新的\n    const controller = abortSignal ? { signal: abortSignal, abort: () => {} } : new AbortController();\n\n    const response = await axios({\n        method: 'post',\n        url: url,\n        data: {\n            model: model || config.defaultModel || DEFAULT_MODEL,\n            messages: messages,\n            stream: true\n        },\n        responseType: 'stream',\n        signal: controller.signal,\n        headers: {\n            'Content-Type': 'application/json',\n            'X-Client-ID': 'vscode',\n        }\n    });\n\n    return new Promise((resolve, reject) => {\n        let buffer = '';\n        \n        const handleChunk = (chunk: Buffer) => {\n            // ✅ 检查取消信号\n            if (controller.signal.aborted) {\n                reject(new Error('Stream request aborted'));\n                return;\n            }\n\n            buffer += chunk.toString();\n            let lines = buffer.split('\\n');\n            buffer = lines.pop() || '';\n\n            for (const line of lines) {\n                const trimmedLine = line.trim();\n                if (trimmedLine.startsWith('data: ')) {\n                    const data = trimmedLine.slice(6);\n                    if (data === '[DONE]') {\n                        resolve();\n                        return;\n                    }\n                    try {\n                        const parsed = JSON.parse(data);\n                        const content = parsed.choices[0]?.delta?.content || '';\n                        if (content) onChunk(content);\n                    } catch (e) { }\n                }\n            }\n        };\n\n        response.data.on('data', handleChunk);\n        \n        response.data.on('error', (error: any) => {\n            reject(error);\n        });\n        \n        response.data.on('end', () => {\n            resolve();\n        });\n    });\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/ai/client.ts:1769134473140",
    "tokens": 1156,
    "importance": 0.5,
    "lastUsedAt": 1769134473140
  }
]