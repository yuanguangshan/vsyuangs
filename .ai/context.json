[
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/executor.ts",
    "content": "import { spawn } from 'child_process';\n\nexport type ExecResult = {\n    stdout: string;\n    stderr: string;\n    code: number | null;\n};\n\nexport async function exec(command: string): Promise<ExecResult> {\n    return new Promise((resolve) => {\n        let stdout = '';\n        let stderr = '';\n\n        // Use user's preferred shell back with full support for their environment\n        const shell = process.env.SHELL || true;\n        const child = spawn(command, [], { shell });\n\n        child.stdout.on('data', (data) => {\n            stdout += data.toString();\n            process.stdout.write(data);\n        });\n\n        child.stderr.on('data', (data) => {\n            stderr += data.toString();\n            process.stderr.write(data);\n        });\n\n        child.on('close', (code) => {\n            resolve({ stdout, stderr, code });\n        });\n\n        child.on('error', (err) => {\n            stderr += err.message;\n            resolve({ stdout, stderr, code: 1 });\n        });\n    });\n}\n",
    "tokens": 248
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/replayEngine.ts",
    "content": "import chalk from 'chalk';\nimport { ExecutionRecord } from './executionRecord';\nimport { loadExecutionRecord } from './executionStore';\nimport { explainExecution } from './explain';\n\nexport type ReplayMode = 'strict' | 'compatible' | 're-evaluate';\n\nexport interface ReplayOptions {\n  mode: ReplayMode;\n  skipAI?: boolean;\n  verbose?: boolean;\n  dry?: boolean;\n  explain?: boolean;\n  diff?: boolean;\n}\n\nexport interface ReplayResult {\n  success: boolean;\n  message: string;\n  executedModel?: string;\n  deviationReason?: string;\n}\n\nexport class ReplayEngine {\n  async replay(recordId: string, options: ReplayOptions = { mode: 'strict' }): Promise<ReplayResult> {\n    const record = loadExecutionRecord(recordId);\n\n    if (!record) {\n      return {\n        success: false,\n        message: `Execution record ${recordId} not found`,\n      };\n    }\n\n    // NOTE: --diff implicitly enables --explain\n    if (options.diff) {\n      options.explain = true;\n    }\n\n    if (options.explain) {\n      console.log(explainExecution(record));\n      console.log('');\n\n      if (options.dry) {\n        return {\n          success: true,\n          message: '[Explain + Dry] Explanation shown, no execution',\n        };\n      }\n    }\n\n    if (options.mode === 'strict') {\n      return this.strictReplay(record, options);\n    }\n\n    if (options.mode === 'compatible') {\n      return this.compatibleReplay(record, options);\n    }\n\n    return this.reEvaluate(record, options);\n  }\n\n  private async strictReplay(\n    record: ExecutionRecord,\n    options: ReplayOptions\n  ): Promise<ReplayResult> {\n    const selectedModel = record.decision.selectedModel;\n\n    if (options.verbose || options.dry) {\n      console.log(chalk.cyan('[Strict Replay]'));\n      console.log(chalk.gray(`  Original Model: ${selectedModel?.name || 'N/A'}`));\n      console.log(chalk.gray(`  Original Provider: ${selectedModel?.provider || 'N/A'}`));\n      console.log(chalk.gray(`  Original Timestamp: ${record.meta.timestamp}`));\n      console.log(chalk.gray(`  Original Command: ${record.meta.commandName}`));\n    }\n\n    if (options.dry) {\n      return {\n        success: true,\n        message: '[Dry Replay] Command not executed',\n        executedModel: selectedModel?.name ?? undefined,\n      };\n    }\n\n    if (options.skipAI) {\n      return {\n        success: true,\n        message: 'Strict replay prepared (AI execution skipped)',\n        executedModel: selectedModel?.name ?? undefined,\n      };\n    }\n\n    if (!record.command) {\n      return {\n        success: false,\n        message: 'Strict replay: No command to execute (command not stored in record)',\n        executedModel: selectedModel?.name ?? undefined,\n      };\n    }\n\n    const { exec } = require('./executor');\n\n    try {\n      console.log(chalk.gray('[Strict Replay] Executing with original parameters...'));\n      const result = await exec(record.command);\n\n      return {\n        success: result.code === 0 || result.code === null,\n        message: result.code === 0 || result.code === null\n          ? 'Strict replay completed successfully'\n          : `Strict replay failed with code ${result.code}`,\n        executedModel: selectedModel?.name ?? undefined,\n      };\n    } catch (error: unknown) {\n      const message = error instanceof Error ? error.message : String(error);\n      return {\n        success: false,\n        message: `Strict replay error: ${message}`,\n        executedModel: selectedModel?.name ?? undefined,\n      };\n    }\n  }\n\n  private async compatibleReplay(\n    record: ExecutionRecord,\n    options: ReplayOptions\n  ): Promise<ReplayResult> {\n    const originalModel = record.decision.selectedModel;\n\n    if (options.verbose) {\n      console.log(chalk.cyan('[Compatible Replay]'));\n      console.log(chalk.gray(`  Original Model: ${originalModel?.name || 'N/A'}`));\n      console.log(chalk.gray(`  Will attempt fallback if original unavailable`));\n    }\n\n    return {\n      success: false,\n      message: 'Compatible replay not yet implemented in Phase 1',\n      executedModel: originalModel?.name,\n      deviationReason: 'Phase 1 only supports strict replay',\n    };\n  }\n\n  private async reEvaluate(\n    record: ExecutionRecord,\n    options: ReplayOptions\n  ): Promise<ReplayResult> {\n    if (options.verbose) {\n      console.log(chalk.cyan('[Re-evaluate]'));\n      console.log(chalk.gray(`  Will re-run capability matching with current config`));\n      console.log(chalk.gray(`  Original Intent: ${record.intent.required.join(', ')}`));\n    }\n\n    return {\n      success: false,\n      message: 'Re-evaluate not yet implemented in Phase 1',\n    };\n  }\n}\n\nexport const replayEngine = new ReplayEngine();\n",
    "tokens": 1162
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/explain.ts",
    "content": "import { ExecutionRecord } from './executionRecord';\nimport { computeSkillScore, Skill } from '../agent/skills';\n\n/**\n * Explain Output Spec v1\n * - Stable, human-readable, diff-friendly\n * - No side effects\n * - Do NOT change without bumping spec version\n */\nexport function explainExecution(record: ExecutionRecord): string {\n  const lines: string[] = [];\n\n  lines.push('=== Execution Explanation ===');\n\n  /* =========================\n   * [1] Command\n   * ========================= */\n  lines.push('[1] Command');\n  lines.push(`- Name: ${record.meta.commandName ?? 'N/A'}`);\n\n  if (record.command) {\n    lines.push(`- Args: ${record.command}`);\n  }\n\n  if (record.meta.rawInput) {\n    lines.push(`- Raw: ${record.meta.rawInput}`);\n  }\n  lines.push('');\n\n  /* =========================\n   * [2] Decision\n   * ========================= */\n  const decision = record.decision ?? {};\n\n  lines.push('[2] Decision');\n  lines.push(`- Strategy: ${decision.strategy ?? 'capability-match'}`);\n  lines.push(\n    `- Selected Model: ${decision.selectedModel?.name ?? 'N/A'}`\n  );\n  lines.push(\n    `- Reason: ${decision.reason ?? 'Capability-based selection with fallback support'}`\n  );\n  lines.push('');\n\n  /* =========================\n   * [3] Model\n   * ========================= */\n  const model = decision.selectedModel;\n\n  lines.push('[3] Model');\n  lines.push(`- Name: ${model?.name ?? 'N/A'}`);\n  lines.push(`- Provider: ${model?.provider ?? 'N/A'}`);\n  lines.push(`- Context Window: ${model?.contextWindow ?? 'default'}`);\n  lines.push(`- Cost Profile: ${model?.costProfile ?? 'default'}`);\n  lines.push('');\n\n  /* =========================\n   * [4] Skills\n   * ========================= */\n  lines.push('[4] Skills');\n\n  const skills: Skill[] = decision.skills ?? [];\n  const now = Date.now();\n\n  if (skills.length === 0) {\n    lines.push('- (none)');\n  } else {\n    const scored = skills\n      .map(skill => ({\n        skill,\n        score: computeSkillScore(skill, now),\n      }))\n      .sort((a, b) => b.score - a.score);\n\n    for (const { skill, score } of scored) {\n      const totalUses = skill.successCount + skill.failureCount;\n      const successRate =\n        totalUses === 0 ? 0.5 : skill.successCount / totalUses;\n\n      lines.push(`- ${skill.name}`);\n      lines.push(`    score: ${score.toFixed(3)}`);\n      lines.push(`    confidence: ${skill.confidence.toFixed(3)}`);\n      lines.push(`    successRate: ${successRate.toFixed(3)}`);\n      lines.push(`    enabled: ${skill.enabled}`);\n      lines.push(\n        `    lastUsed: ${new Date(skill.lastUsed).toISOString()}`\n      );\n    }\n  }\n  lines.push('');\n\n  /* =========================\n   * [5] Meta\n   * ========================= */\n  lines.push('[5] Meta');\n  lines.push(`- Execution ID: ${record.id}`);\n  lines.push(\n    `- Timestamp: ${new Date(record.meta.timestamp).toISOString()}`\n  );\n  lines.push(`- Replayable: ${record.meta.replayable ?? true}`);\n  lines.push(`- Version: ${record.meta.version ?? 'unknown'}`);\n\n  lines.push('=============================');\n\n  return lines.join('\\n');\n}\n",
    "tokens": 767
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/modelMatcher.ts",
    "content": "import { AtomicCapability, ConstraintCapability, expandCapabilities } from './capabilities';\n\nexport interface ModelCapabilities {\n  name: string;\n  provider: string;\n  atomicCapabilities: AtomicCapability[];\n  contextWindow?: number;\n  costProfile?: 'low' | 'medium' | 'high';\n}\n\nexport interface CapabilityRequirement {\n  required: AtomicCapability[];\n  preferred: AtomicCapability[];\n  constraints?: ConstraintCapability[];\n}\n\nexport interface CapabilityMatchExplanation {\n  modelName: string;\n  provider: string;\n  hasRequired: boolean;\n  hasPreferred: AtomicCapability[];\n  missingRequired: AtomicCapability[];\n  reason: string;\n}\n\nexport interface CapabilityMatchResult {\n  selected: ModelCapabilities | null;\n  candidates: CapabilityMatchExplanation[];\n  fallbackOccurred: boolean;\n}\n\nexport function matchModel(\n  models: ModelCapabilities[],\n  requirement: CapabilityRequirement\n): CapabilityMatchResult {\n  const explanations: CapabilityMatchExplanation[] = [];\n\n  for (const model of models) {\n    const hasRequired = requirement.required.every(cap =>\n      model.atomicCapabilities.includes(cap)\n    );\n\n    const missingRequired = requirement.required.filter(cap =>\n      !model.atomicCapabilities.includes(cap)\n    );\n\n    const hasPreferred = requirement.preferred.filter(cap =>\n      model.atomicCapabilities.includes(cap)\n    );\n\n    const explanation: CapabilityMatchExplanation = {\n      modelName: model.name,\n      provider: model.provider,\n      hasRequired,\n      hasPreferred,\n      missingRequired,\n      reason: hasRequired\n        ? `Has all required capabilities. Matches ${hasPreferred.length}/${requirement.preferred.length} preferred.`\n        : `Missing required capabilities: ${missingRequired.map(c => String(c)).join(', ')}`,\n    };\n\n    explanations.push(explanation);\n  }\n\n  const matchingModels = explanations.filter(e => e.hasRequired);\n\n  if (matchingModels.length === 0) {\n    return {\n      selected: null,\n      candidates: explanations,\n      fallbackOccurred: false,\n    };\n  }\n\n  const bestMatch = matchingModels[0];\n  const selectedModel = models.find(m => m.name === bestMatch.modelName);\n\n  return {\n    selected: selectedModel || null,\n    candidates: explanations,\n    fallbackOccurred: false,\n  };\n}\n\nexport function matchModelWithFallback(\n  models: ModelCapabilities[],\n  fallbackModels: ModelCapabilities[],\n  requirement: CapabilityRequirement\n): CapabilityMatchResult {\n  const primaryResult = matchModel(models, requirement);\n\n  if (primaryResult.selected) {\n    return primaryResult;\n  }\n\n  const fallbackResult = matchModel(fallbackModels, requirement);\n\n  return {\n    ...fallbackResult,\n    fallbackOccurred: fallbackResult.selected !== null,\n  };\n}\n",
    "tokens": 678
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/fileReader.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\n\nexport function parseFilePathsFromLsOutput(output: string): string[] {\n    const lines = output.trim().split('\\n');\n    const filePaths: string[] = [];\n\n    for (const line of lines) {\n        const parts = line.trim().split(/\\s+/);\n        const lastPart = parts[parts.length - 1];\n        \n        if (lastPart && !lastPart.startsWith('-') && lastPart !== '.' && lastPart !== '..') {\n            filePaths.push(lastPart);\n        }\n    }\n\n    return filePaths;\n}\n\nexport function readFilesContent(filePaths: string[]): Map<string, string> {\n    const contentMap = new Map<string, string>();\n\n    for (const filePath of filePaths) {\n        try {\n            const fullPath = path.resolve(filePath);\n            if (fs.existsSync(fullPath) && fs.statSync(fullPath).isFile()) {\n                const content = fs.readFileSync(fullPath, 'utf-8');\n                contentMap.set(filePath, content);\n            }\n        } catch (error) {\n            console.error(`无法读取文件: ${filePath}`);\n        }\n    }\n\n    return contentMap;\n}\n\nexport function buildPromptWithFileContent(\n    originalOutput: string,\n    filePaths: string[],\n    contentMap: Map<string, string>,\n    question?: string\n): string {\n    let prompt = '';\n\n    prompt += '## 文件列表\\n';\n    prompt += '```\\n';\n    prompt += originalOutput;\n    prompt += '```\\n\\n';\n\n    if (contentMap.size > 0) {\n        prompt += '## 文件内容\\n\\n';\n        for (const [filePath, content] of contentMap) {\n            prompt += `### ${filePath}\\n`;\n            prompt += '```\\n';\n            const maxChars = 5000;\n            const truncated = content.length > maxChars \n                ? content.substring(0, maxChars) + '\\n... (内容过长已截断)'\n                : content;\n            prompt += truncated;\n            prompt += '\\n```\\n\\n';\n        }\n    }\n\n    if (question) {\n        prompt += `\\n## 我的问题\\n${question}`;\n    } else {\n        prompt += '\\n## 我的问题\\n请分析以上文件列表和文件内容';\n    }\n\n    return prompt;\n}\n",
    "tokens": 498
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/risk.ts",
    "content": "export function assessRisk(command: string, aiRisk: 'low' | 'medium' | 'high'): 'low' | 'medium' | 'high' {\n    const HIGH_RISK_PATTERNS = [\n        /\\brm\\b/i,\n        /\\bsudo\\b/i,\n        /\\bmv\\b/i,\n        /\\bdd\\b/i,\n        /\\bchmod\\b/i,\n        /\\bchown\\b/i,\n        />\\s*\\/dev\\//,\n        /:\\(\\)\\s*\\{.*\\}/, // Fork bomb\n        /\\bmkfs\\b/i,\n    ];\n\n    const hasHighRisk = HIGH_RISK_PATTERNS.some(pattern => pattern.test(command));\n\n    if (hasHighRisk) return 'high';\n    return aiRisk;\n}\n",
    "tokens": 124
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/executionRecord.ts",
    "content": "import { MergedConfig } from './configMerge';\nimport { ModelCapabilities, CapabilityMatchExplanation } from './modelMatcher';\nimport { CapabilityRequirement } from './modelMatcher';\nimport { Skill } from '../agent/skills';\n\nexport interface ExecutionMeta {\n  commandName: string;\n  timestamp: string;\n  toolVersion: string;\n  projectPath: string;\n  args?: any;\n  rawInput?: string;\n  replayable?: boolean;\n  version?: string;\n}\n\nexport interface CapabilityIntent {\n  required: string[];\n  preferred: string[];\n  capabilityVersion: string;\n}\n\nexport interface ModelDecision {\n  candidateModels: CapabilityMatchExplanation[];\n  selectedModel: ModelCapabilities | null;\n  usedFallback: boolean;\n  fallbackReason?: string;\n  strategy?: string;\n  reason?: string;\n  skills?: Skill[];\n}\n\nexport interface ExecutionOutcome {\n  success: boolean;\n  failureReason?: 'capability-mismatch' | 'provider-error' | 'user-abort' | 'timeout' | 'other';\n  tokenCount?: number;\n  latencyMs?: number;\n}\n\nexport interface ExecutionRecord {\n  id: string;\n  meta: ExecutionMeta;\n  intent: CapabilityIntent;\n  configSnapshot: MergedConfig;\n  decision: ModelDecision;\n  outcome: ExecutionOutcome;\n  command?: string;\n}\n\nexport function createExecutionId(): string {\n  return `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\nexport function createExecutionRecord(\n  commandName: string,\n  requirement: CapabilityRequirement,\n  config: MergedConfig,\n  matchResult: any,\n  outcome: Partial<ExecutionOutcome> = {},\n  command?: string\n): ExecutionRecord {\n  const version = require('../../package.json').version;\n\n  return {\n    id: createExecutionId(),\n    meta: {\n      commandName,\n      timestamp: new Date().toISOString(),\n      toolVersion: version,\n      projectPath: process.cwd(),\n      version,\n      replayable: true,\n    },\n    intent: {\n      required: requirement.required.map(String),\n      preferred: requirement.preferred.map(String),\n      capabilityVersion: require('./capabilities').CAPABILITY_VERSION,\n    },\n    configSnapshot: config,\n    decision: {\n      candidateModels: matchResult.candidates || [],\n      selectedModel: matchResult.selected,\n      usedFallback: matchResult.fallbackOccurred,\n    },\n    outcome: {\n      success: outcome.success ?? false,\n      ...outcome,\n    },\n    command,\n  };\n}\n\nexport function serializeExecutionRecord(record: ExecutionRecord): string {\n  return JSON.stringify(record, null, 2);\n}\n\nexport function deserializeExecutionRecord(json: string): ExecutionRecord {\n  return JSON.parse(json) as ExecutionRecord;\n}\n",
    "tokens": 641
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/macros.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { parseMacros, type Macro } from './validation';\n\nconst USER_MACROS_FILE = path.join(os.homedir(), '.yuangs_macros.json');\n\nexport type { Macro };\n\nfunction loadMacrosFromFile(filePath: string): Record<string, Macro> {\n    if (fs.existsSync(filePath)) {\n        try {\n            return parseMacros(fs.readFileSync(filePath, 'utf8'));\n        } catch (e) { }\n    }\n    return {};\n}\n\nfunction findProjectMacros(cwd = process.cwd()): string | null {\n    let dir = cwd;\n    while (dir && dir !== path.dirname(dir)) {\n        const candidate = path.join(dir, 'yuangs_macros.json');\n        if (fs.existsSync(candidate)) {\n            return candidate;\n        }\n        dir = path.dirname(dir);\n    }\n    // Check root one last time\n    const rootCandidate = path.join(targetRoot(dir), 'yuangs_macros.json');\n    if (fs.existsSync(rootCandidate)) return rootCandidate;\n    \n    return null;\n}\n\n// Helper to reliably stop at root (dirname('/') is '/')\nfunction targetRoot(dir: string) {\n    return path.parse(dir).root;\n}\n\nexport function getMacros(): Record<string, Macro> {\n    const userMacros = loadMacrosFromFile(USER_MACROS_FILE);\n    \n    const projectMacrosPath = findProjectMacros();\n    const projectMacros = projectMacrosPath ? loadMacrosFromFile(projectMacrosPath) : {};\n\n    return {\n        ...userMacros,\n        ...projectMacros // Project overrides User\n    };\n}\n\nexport function saveMacro(name: string, commands: string, description: string = '') {\n    // Only load USER macros for saving\n    const macros = loadMacrosFromFile(USER_MACROS_FILE);\n    macros[name] = {\n        commands,\n        description,\n        createdAt: new Date().toISOString()\n    };\n    fs.writeFileSync(USER_MACROS_FILE, JSON.stringify(macros, null, 2));\n    return true;\n}\n\nexport function deleteMacro(name: string) {\n    // Only delete from USER macros\n    const macros = loadMacrosFromFile(USER_MACROS_FILE);\n    if (macros[name]) {\n        delete macros[name];\n        fs.writeFileSync(USER_MACROS_FILE, JSON.stringify(macros, null, 2));\n        return true;\n    }\n    return false;\n}\n\nexport function runMacro(name: string) {\n    const macros = getMacros();\n    const macro = macros[name];\n    if (!macro) return false;\n\n    const { spawn } = require('child_process');\n    spawn(macro.commands, [], { shell: true, stdio: 'inherit' });\n    return true;\n}\n",
    "tokens": 606
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/replayDiff.ts",
    "content": "import { ExecutionRecord } from './executionRecord';\nimport { computeSkillScore } from '../agent/skills';\n\nexport interface ReplayDiffResult {\n  decisionDiff: DecisionDiff;\n  modelDiff: ModelDiff;\n  skillsDiff: SkillsDiff;\n}\n\ninterface DecisionDiff {\n  changed: boolean;\n  strategyChanged: boolean;\n  modelChanged: boolean;\n  reasonChanged: boolean;\n  before?: {\n    strategy: string;\n    selectedModel: string;\n    reason: string;\n  };\n  after?: {\n    strategy: string;\n    selectedModel: string;\n    reason: string;\n  };\n}\n\ninterface ModelDiff {\n  changed: boolean;\n  nameChanged: boolean;\n  providerChanged: boolean;\n  before?: {\n    name: string;\n    provider: string;\n    contextWindow: number | string;\n    costProfile: string;\n  };\n  after?: {\n    name: string;\n    provider: string;\n    contextWindow: number | string;\n    costProfile: string;\n  };\n}\n\ninterface SkillsDiff {\n  added: SkillChange[];\n  removed: SkillChange[];\n  changed: SkillChange[];\n}\n\ninterface SkillChange {\n  name: string;\n  score?: number;\n  enabled?: boolean;\n  confidence?: number;\n  successRate?: number;\n  lastUsed?: string;\n}\n\nexport function diffExecution(\n  original: ExecutionRecord,\n  current: ExecutionRecord\n): ReplayDiffResult {\n  return {\n    decisionDiff: diffDecision(original, current),\n    modelDiff: diffModel(original, current),\n    skillsDiff: diffSkills(original, current),\n  };\n}\n\nfunction diffDecision(original: ExecutionRecord, current: ExecutionRecord): DecisionDiff {\n  const origDecision = original.decision;\n  const currDecision = current.decision;\n\n  const strategyChanged = origDecision?.strategy !== currDecision?.strategy;\n  const modelChanged = origDecision?.selectedModel?.name !== currDecision?.selectedModel?.name;\n  const reasonChanged = origDecision?.reason !== currDecision?.reason;\n\n  return {\n    changed: strategyChanged || modelChanged || reasonChanged,\n    strategyChanged,\n    modelChanged,\n    reasonChanged,\n    before: {\n      strategy: origDecision?.strategy ?? 'N/A',\n      selectedModel: origDecision?.selectedModel?.name ?? 'N/A',\n      reason: origDecision?.reason ?? 'N/A',\n    },\n    after: {\n      strategy: currDecision?.strategy ?? 'N/A',\n      selectedModel: currDecision?.selectedModel?.name ?? 'N/A',\n      reason: currDecision?.reason ?? 'N/A',\n    },\n  };\n}\n\nfunction diffModel(original: ExecutionRecord, current: ExecutionRecord): ModelDiff {\n  const origModel = original.decision.selectedModel;\n  const currModel = current.decision.selectedModel;\n\n  if (!origModel || !currModel) {\n    return {\n      changed: true,\n      nameChanged: true,\n      providerChanged: true,\n      before: origModel ? {\n        name: origModel.name,\n        provider: origModel.provider,\n        contextWindow: origModel.contextWindow ?? 'default',\n        costProfile: origModel.costProfile ?? 'default',\n      } : undefined,\n      after: currModel ? {\n        name: currModel.name,\n        provider: currModel.provider,\n        contextWindow: currModel.contextWindow ?? 'default',\n        costProfile: currModel.costProfile ?? 'default',\n      } : undefined,\n    };\n  }\n\n  const nameChanged = origModel.name !== currModel.name;\n  const providerChanged = origModel.provider !== currModel.provider;\n\n  return {\n    changed: nameChanged || providerChanged,\n    nameChanged,\n    providerChanged,\n    before: {\n      name: origModel.name,\n      provider: origModel.provider,\n      contextWindow: origModel.contextWindow ?? 'default',\n      costProfile: origModel.costProfile ?? 'default',\n    },\n    after: {\n      name: currModel.name,\n      provider: currModel.provider,\n      contextWindow: currModel.contextWindow ?? 'default',\n      costProfile: currModel.costProfile ?? 'default',\n    },\n  };\n}\n\nfunction diffSkills(original: ExecutionRecord, current: ExecutionRecord): SkillsDiff {\n  const origSkills = original.decision.skills ?? [];\n  const currSkills = current.decision.skills ?? [];\n\n  const origSkillMap = new Map(origSkills.map(s => [s.name, s]));\n  const currSkillMap = new Map(currSkills.map(s => [s.name, s]));\n\n  const added: SkillChange[] = [];\n  const removed: SkillChange[] = [];\n  const changed: SkillChange[] = [];\n\n  const now = Date.now();\n\n  // Find added and changed skills\n  for (const skill of currSkills) {\n    const origSkill = origSkillMap.get(skill.name);\n\n    if (!origSkill) {\n      // Added\n      const score = computeSkillScore(skill, now);\n      const totalUses = skill.successCount + skill.failureCount;\n      const successRate = totalUses === 0 ? 0.5 : skill.successCount / totalUses;\n\n      added.push({\n        name: skill.name,\n        score,\n        enabled: skill.enabled,\n        confidence: skill.confidence,\n        successRate,\n        lastUsed: new Date(skill.lastUsed).toISOString(),\n      });\n    } else {\n      // Check if changed\n      const origScore = computeSkillScore(origSkill, now);\n      const currScore = computeSkillScore(skill, now);\n      const origTotalUses = origSkill.successCount + origSkill.failureCount;\n      const currTotalUses = skill.successCount + skill.failureCount;\n      const origSuccessRate = origTotalUses === 0 ? 0.5 : origSkill.successCount / origTotalUses;\n      const currSuccessRate = currTotalUses === 0 ? 0.5 : skill.successCount / currTotalUses;\n\n      if (\n        Math.abs(origScore - currScore) > 0.001 ||\n        origSkill.enabled !== skill.enabled ||\n        Math.abs(origSuccessRate - currSuccessRate) > 0.001\n      ) {\n        changed.push({\n          name: skill.name,\n          score: currScore,\n          enabled: skill.enabled,\n          confidence: skill.confidence,\n          successRate: currSuccessRate,\n          lastUsed: new Date(skill.lastUsed).toISOString(),\n        });\n      }\n    }\n  }\n\n  // Find removed skills\n  for (const skill of origSkills) {\n    if (!currSkillMap.has(skill.name)) {\n      const score = computeSkillScore(skill, now);\n      const totalUses = skill.successCount + skill.failureCount;\n      const successRate = totalUses === 0 ? 0.5 : skill.successCount / totalUses;\n\n      removed.push({\n        name: skill.name,\n        score,\n        enabled: skill.enabled,\n        confidence: skill.confidence,\n        successRate,\n        lastUsed: new Date(skill.lastUsed).toISOString(),\n      });\n    }\n  }\n\n  return {\n    added,\n    removed,\n    changed,\n  };\n}\n\nexport function formatReplayDiff(diff: ReplayDiffResult): string {\n  const lines: string[] = [];\n\n  lines.push('=== Replay Diff ===');\n\n  // [Decision]\n  lines.push('[Decision]');\n  if (!diff.decisionDiff.changed) {\n    lines.push('- no change');\n  } else {\n    if (diff.decisionDiff.strategyChanged) {\n      lines.push(`- strategy: ${diff.decisionDiff.before?.strategy} → ${diff.decisionDiff.after?.strategy}`);\n    }\n    if (diff.decisionDiff.modelChanged) {\n      lines.push(`- selectedModel: ${diff.decisionDiff.before?.selectedModel} → ${diff.decisionDiff.after?.selectedModel}`);\n    }\n    if (diff.decisionDiff.reasonChanged) {\n      lines.push(`- reason:`);\n      lines.push(`    before: \"${diff.decisionDiff.before?.reason}\"`);\n      lines.push(`    after: \"${diff.decisionDiff.after?.reason}\"`);\n    }\n  }\n  lines.push('');\n\n  // [Model]\n  lines.push('[Model]');\n  if (!diff.modelDiff.changed) {\n    lines.push('- no change');\n  } else {\n    if (diff.modelDiff.nameChanged) {\n      lines.push(`- name: ${diff.modelDiff.before?.name} → ${diff.modelDiff.after?.name}`);\n    }\n    if (diff.modelDiff.providerChanged) {\n      lines.push(`- provider: ${diff.modelDiff.before?.provider} → ${diff.modelDiff.after?.provider}`);\n    }\n  }\n  lines.push('');\n\n  // [Skills]\n  lines.push('[Skills]');\n  if (diff.skillsDiff.added.length === 0 &&\n      diff.skillsDiff.removed.length === 0 &&\n      diff.skillsDiff.changed.length === 0) {\n    lines.push('- no change');\n  } else {\n    for (const skill of diff.skillsDiff.added) {\n      lines.push(`+ added: ${skill.name} (score=${skill.score?.toFixed(3)})`);\n    }\n    for (const skill of diff.skillsDiff.removed) {\n      lines.push(`- removed: ${skill.name}`);\n    }\n    for (const skill of diff.skillsDiff.changed) {\n      lines.push(`~ changed: ${skill.name} (score=${skill.score?.toFixed(3)}, enabled=${skill.enabled})`);\n    }\n  }\n\n  lines.push('===================');\n\n  return lines.join('\\n');\n}\n",
    "tokens": 2065
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/completion.legacy.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport { Command } from 'commander';\nimport { loadAppsConfig } from './apps';\nimport { getMacros } from './macros';\nexport function getAllCommands(program: Command): string[] {\n    const commands: string[] = [];\n\n    program.commands.forEach(cmd => {\n        if (cmd.name()) {\n            commands.push(cmd.name());\n        }\n        if (cmd.aliases()) {\n            commands.push(...cmd.aliases());\n        }\n    });\n\n    try {\n        const apps = loadAppsConfig();\n        Object.keys(apps).forEach(app => {\n            if (!commands.includes(app)) {\n                commands.push(app);\n            }\n        });\n    } catch {\n    }\n\n    try {\n        const macros = getMacros();\n        Object.keys(macros).forEach(macro => {\n            if (!commands.includes(macro)) {\n                commands.push(macro);\n            }\n        });\n    } catch {\n    }\n\n    return [...new Set(commands)].sort();\n}\n\n/**\n * 获取命令的子命令或参数\n */\nexport function getCommandSubcommands(program: Command, commandName: string): string[] {\n    const command = program.commands.find(cmd => cmd.name() === commandName);\n    if (!command) return [];\n\n    const subcommands: string[] = [];\n\n    command.commands.forEach(cmd => {\n        if (cmd.name()) {\n            subcommands.push(cmd.name());\n        }\n    });\n\n    command.options.forEach(opt => {\n        opt.flags.split(/[, ]+/).forEach(flag => {\n            if (flag.startsWith('--')) {\n                subcommands.push(flag);\n            } else if (flag.startsWith('-')) {\n                subcommands.push(flag);\n            }\n        });\n    });\n\n    return [...new Set(subcommands)].sort();\n}\n\n/**\n * 生成 Bash 补全脚本\n */\nexport function generateBashCompletion(program: Command): string {\n    const commands = getAllCommands(program);\n\n    return `#!/bin/bash\n# yuangs bash completion\n\n_yuangs_completion() {\n    local cur prev words cword\n    _init_completion || return\n\n    # 补全命令名\n    if [[ \\${COMP_CWORD} -eq 1 ]]; then\n        COMPREPLY=($(compgen -W '${commands.join(' ')}' -- \"\\${cur}\"))\n        return\n    fi\n\n    # 补全子命令和参数\n    local cmd=\"\\${words[1]}\"\n    case \"\\${cmd}\" in\n        ${commands.map(cmd => `\n        ${cmd})\n            case \"\\${prev}\" in\n                -m|--model)\n                    COMPREPLY=($(compgen -W \"gemini-2.5-flash-lite gemini-2.5-pro\" -- \"\\${cur}\"))\n                    ;;\n                *)\n                    COMPREPLY=($(compgen -W \"$(yuangs _complete_subcommand ${cmd})\" -- \"\\${cur}\"))\n                    ;;\n            esac\n            ;;\n        `).join('\\n')}\n\n        *)\n            ;;\n    esac\n}\n\ncomplete -F _yuangs_completion yuangs\n`;\n}\n\n/**\n * 生成 Zsh 补全脚本\n */\nexport function generateZshCompletion(program: Command): string {\n    const commands = getAllCommands(program);\n\n    return `#compdef yuangs\n# yuangs zsh completion\n\n_yuangs() {\n    local -a commands\n    commands=(\n${commands.map(cmd => `        '${cmd}:$(yuangs _describe ${cmd})'`).join('\\n')}\n    )\n\n    if (( CURRENT == 2 )); then\n        _describe 'command' commands\n    else\n        local cmd=\"\\${words[2]}\"\n        case \"\\${cmd}\" in\n${commands.map(cmd => `\n            ${cmd})\n                _values 'options' $(yuangs _complete_subcommand ${cmd})\n                ;;\n`).join('\\n')}\n            *)\n                ;;\n        esac\n    fi\n}\n\n_yuangs\n`;\n}\n\nexport async function installBashCompletion(program: Command): Promise<boolean> {\n    const bashrcPath = path.join(process.env.HOME || '', '.bashrc');\n    const bashCompletionDir = path.join(process.env.HOME || '', '.bash_completion.d');\n\n    try {\n        if (!fs.existsSync(bashCompletionDir)) {\n            fs.mkdirSync(bashCompletionDir, { recursive: true });\n        }\n\n        const completionPath = path.join(bashCompletionDir, 'yuangs-completion.bash');\n        const completionScript = generateBashCompletion(program);\n\n        fs.writeFileSync(completionPath, completionScript, { mode: 0o644 });\n        const sourceLine = `# yuangs completion\nif [ -f ~/.bash_completion.d/yuangs-completion.bash ]; then\n    source ~/.bash_completion.d/yuangs-completion.bash\nfi\n`;\n\n        let bashrc = '';\n        if (fs.existsSync(bashrcPath)) {\n            bashrc = fs.readFileSync(bashrcPath, 'utf-8');\n        }\n\n        if (!bashrc.includes('yuangs-completion.bash')) {\n            fs.appendFileSync(bashrcPath, `\\n${sourceLine}`);\n        }\n\n        return true;\n    } catch (error) {\n        console.error('安装 Bash 补全失败:', error);\n        return false;\n    }\n}\n\nexport async function installZshCompletion(program: Command): Promise<boolean> {\n    const zshrcPath = path.join(process.env.HOME || '', '.zshrc');\n    const zfuncDir = path.join(process.env.HOME || '', '.zfunctions');\n\n    try {\n        if (!fs.existsSync(zfuncDir)) {\n            fs.mkdirSync(zfuncDir, { recursive: true });\n        }\n\n        const completionPath = path.join(zfuncDir, '_yuangs');\n        const completionScript = generateZshCompletion(program);\n\n        fs.writeFileSync(completionPath, completionScript, { mode: 0o644 });\n        let zshrc = '';\n        if (fs.existsSync(zshrcPath)) {\n            zshrc = fs.readFileSync(zshrcPath, 'utf-8');\n        }\n\n        const fpathLine = 'fpath=(~/.zfunctions $fpath)';\n        const autoloadLine = 'autoload -U compinit && compinit';\n\n        if (!zshrc.includes('fpath=')) {\n            fs.appendFileSync(zshrcPath, `\\n${fpathLine}`);\n        }\n\n        if (!zshrc.includes('autoload -U compinit')) {\n            fs.appendFileSync(zshrcPath, `\\n${autoloadLine}`);\n        }\n\n        return true;\n    } catch (error) {\n        console.error('安装 Zsh 补全失败:', error);\n        return false;\n    }\n}\n\n/**\n * 获取命令描述（用于补全提示）\n */\nexport function getCommandDescription(program: Command, commandName: string): string {\n    const command = program.commands.find(cmd => cmd.name() === commandName);\n    return command?.description() || '';\n}\n",
    "tokens": 1478
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/capabilities.ts",
    "content": "export enum AtomicCapability {\n  TEXT_GENERATION = 'text_generation',\n  CODE_GENERATION = 'code_generation',\n  TOOL_CALLING = 'tool_calling',\n  LONG_CONTEXT = 'long_context',\n  REASONING = 'reasoning',\n  STREAMING = 'streaming',\n}\n\nexport interface CompositeCapability {\n  name: string;\n  composedOf: AtomicCapability[];\n}\n\nexport const COMPOSITE_CAPABILITIES: CompositeCapability[] = [\n  {\n    name: 'interactive_agent',\n    composedOf: [AtomicCapability.TOOL_CALLING, AtomicCapability.REASONING],\n  },\n  {\n    name: 'large_repo_analysis',\n    composedOf: [AtomicCapability.LONG_CONTEXT, AtomicCapability.REASONING],\n  },\n  {\n    name: 'safe_code_editing',\n    composedOf: [AtomicCapability.CODE_GENERATION, AtomicCapability.REASONING],\n  },\n];\n\nexport enum ConstraintCapability {\n  PREFER_DETERMINISTIC = 'prefer_deterministic',\n  LOW_COST = 'low_cost',\n  FAST_RESPONSE = 'fast_response',\n}\n\nexport const CAPABILITY_VERSION = '1.0';\n\nexport function isAtomicCapability(value: string): value is AtomicCapability {\n  return Object.values(AtomicCapability).includes(value as AtomicCapability);\n}\n\nexport function isConstraintCapability(value: string): value is ConstraintCapability {\n  return Object.values(ConstraintCapability).includes(value as ConstraintCapability);\n}\n\nexport function resolveCompositeCapability(name: string): AtomicCapability[] {\n  const composite = COMPOSITE_CAPABILITIES.find(c => c.name === name);\n  if (!composite) {\n    throw new Error(`Unknown composite capability: ${name}`);\n  }\n  return composite.composedOf;\n}\n\nexport function expandCapabilities(\n  capabilities: Array<AtomicCapability | string>\n): Set<AtomicCapability> {\n  const result = new Set<AtomicCapability>();\n\n  for (const cap of capabilities) {\n    if (isAtomicCapability(cap)) {\n      result.add(cap);\n    } else {\n      const atomicCaps = resolveCompositeCapability(cap);\n      atomicCaps.forEach(c => result.add(c));\n    }\n  }\n\n  return result;\n}\n",
    "tokens": 486
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/completion/path.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\n\nexport type PathKind = 'file' | 'dir';\n\nexport function resolvePathSuggestions(\n  input: string,\n  kind: PathKind\n): string[] {\n  const cwd = process.cwd();\n  const normalized = input.replace(/^~(?=$|\\/)/, process.env.HOME || '');\n  const isDirInput = normalized.endsWith(path.sep);\n\n  const baseDir = isDirInput\n    ? path.resolve(cwd, normalized)\n    : path.resolve(cwd, path.dirname(normalized));\n\n  const prefix = isDirInput ? '' : path.basename(normalized);\n\n  try {\n    const entries = fs.readdirSync(baseDir, { withFileTypes: true });\n    return entries\n      .filter(e => !e.name.startsWith('.'))\n      .filter(e => {\n        if (kind === 'file') return e.isFile();\n        return e.isDirectory();\n      })\n      .filter(e => e.name.startsWith(prefix))\n      .map(e => {\n        const fullPath = path.join(baseDir, e.name);\n        const suggestion = e.isDirectory()\n          ? fullPath + path.sep\n          : fullPath;\n        return suggestion.replace(/^\\\\/g, '');\n      });\n  } catch {\n    return [];\n  }\n}\n",
    "tokens": 267
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/completion/builtin.ts",
    "content": "import type { CompletionItem } from './types';\n\nexport function getBuiltinCommands(): Array<{ name: string; description: string }> {\n  return [\n    { name: 'ai', description: '向 AI 提问' },\n    { name: 'list', description: '列出所有应用' },\n    { name: 'history', description: '查看及执行命令历史' },\n    { name: 'config', description: '管理本地配置' },\n    { name: 'macros', description: '查看所有快捷指令' },\n    { name: 'save', description: '保存快捷指令' },\n    { name: 'run', description: '执行快捷指令' },\n    { name: 'help', description: '显示帮助信息' },\n    { name: 'completion', description: '安装 Shell 补全' },\n    { name: 'shici', description: '打开古诗词 PWA' },\n    { name: 'dict', description: '打开英语词典' },\n    { name: 'pong', description: '打开 Pong 游戏' }\n  ];\n}\n",
    "tokens": 180
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/completion/resolver.ts",
    "content": "import { CompletionRequest, CompletionResponse, CompletionItem } from './types';\nimport { unique } from './utils';\nimport { getBuiltinCommands } from './builtin';\nimport { loadAppsConfig } from '../apps';\nimport { getMacros } from '../macros';\nimport { Command } from 'commander';\n\nlet programInstance: Command | null = null;\n\nexport function setProgramInstance(program: Command): void {\n  programInstance = program;\n}\n\nfunction getProgramInstance(): Command {\n  return programInstance || ({} as Command);\n}\n\nexport async function resolveCompletion(\n  req: CompletionRequest\n): Promise<CompletionResponse> {\n  const { words, currentIndex } = req;\n\n  const currentWord = words[currentIndex] ?? '';\n  const previousWord = words[currentIndex - 1] ?? '';\n\n  if (currentIndex === 1) {\n    return completeTopLevel(currentWord);\n  }\n\n  return completeSubcommand(words.slice(1, currentIndex), currentWord, previousWord);\n}\n\nfunction completeTopLevel(prefix: string): CompletionResponse {\n  const items: CompletionItem[] = [];\n\n  const commands = getBuiltinCommands();\n  commands.forEach(cmd => {\n    items.push({ label: cmd.name });\n  });\n\n  try {\n    const apps = loadAppsConfig();\n    Object.keys(apps).forEach(name => {\n      if (!items.find(i => i.label === name)) {\n        items.push({ label: name });\n      }\n    });\n  } catch {}\n\n  try {\n    const macros = getMacros();\n    Object.keys(macros).forEach(name => {\n      if (!items.find(i => i.label === name)) {\n        items.push({ label: name });\n      }\n    });\n  } catch {}\n\n  const filtered = items.filter(item => item.label.startsWith(prefix));\n\n  return {\n    items: unique(filtered),\n    isPartial: true\n  };\n}\n\nfunction completeSubcommand(\n  path: string[],\n  prefix: string,\n  prev: string\n): CompletionResponse {\n  const items: CompletionItem[] = [];\n\n  if (prev === '--model' || prev === '-m') {\n    items.push(\n      { label: 'gemini-2.5-flash-lite' },\n      { label: 'gemini-2.5-pro' },\n      { label: 'Assistant' },\n      { label: 'GPT-4o-mini' }\n    );\n  } else if (path.length > 0) {\n    const baseCommand = path[0];\n    const cmd = getProgramInstance().commands.find((c: any) => c.name() === baseCommand);\n\n    if (cmd) {\n      cmd.options.forEach((opt: any) => {\n        opt.flags.split(/[, ]+/).forEach((flag: string) => {\n          if (flag.startsWith('-') && !flag.startsWith('--')) {\n            items.push({ label: flag });\n          }\n        });\n      });\n\n      cmd.commands.forEach((subcmd: any) => {\n        items.push({ label: subcmd.name() });\n      });\n    }\n  }\n\n  const filtered = items.filter(item => item.label.startsWith(prefix));\n\n  return {\n    items: unique(filtered),\n    isPartial: true\n  };\n}\n",
    "tokens": 671
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/completion/utils.ts",
    "content": "import { CompletionItem } from './types';\n\nexport function unique(items: CompletionItem[]): CompletionItem[] {\n  const seen = new Set<string>();\n  return items.filter(i => {\n    if (seen.has(i.label)) return false;\n    seen.add(i.label);\n    return true;\n  });\n}\n",
    "tokens": 66
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/completion/types.ts",
    "content": "// core/completion/types.ts\n\n/**\n * yuangs Completion Protocol v1.1\n * 终态补全协议 - 唯一、强约束\n */\n\nexport interface CompletionRequest {\n  /**\n   * 完整 argv，不包含 node\n   * e.g. ['yuangs', 'ai', 'chat', '--m']\n   */\n  words: string[];\n\n  /**\n   * cursor 所在 index\n   */\n  currentIndex: number;\n}\n\nexport interface CompletionItem {\n  label: string;\n  insertText?: string;\n  detail?: string;\n}\n\nexport interface CompletionResponse {\n  items: CompletionItem[];\n  isPartial: boolean;\n}\n",
    "tokens": 118
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/completion/cache.ts",
    "content": "import type { CompletionItem } from './types';\n\nexport class CompletionCache {\n  private static instance: CompletionCache;\n  private cache: Map<string, CompletionItem[]>;\n  private timestamp: number;\n  private readonly ttl: number = 5000;\n\n  private constructor() {\n    this.cache = new Map();\n    this.timestamp = Date.now();\n  }\n\n  static getInstance(): CompletionCache {\n    if (!CompletionCache.instance) {\n      CompletionCache.instance = new CompletionCache();\n    }\n    return CompletionCache.instance;\n  }\n\n  get(key: string): CompletionItem[] | null {\n    const now = Date.now();\n    if (now - this.timestamp > this.ttl) {\n      this.cache.clear();\n      this.timestamp = now;\n      return null;\n    }\n    return this.cache.get(key) || null;\n  }\n\n  set(key: string, items: CompletionItem[]): void {\n    this.cache.set(key, items);\n  }\n\n  invalidate(): void {\n    this.cache.clear();\n    this.timestamp = 0;\n  }\n\n  invalidatePattern(pattern: RegExp): void {\n    for (const key of this.cache.keys()) {\n      if (pattern.test(key)) {\n        this.cache.delete(key);\n      }\n    }\n  }\n}\n",
    "tokens": 273
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/completion/index.ts",
    "content": "import { CompletionRequest, CompletionResponse } from './types';\nimport { resolveCompletion } from './resolver';\n\nexport async function complete(\n  req: CompletionRequest\n): Promise<CompletionResponse> {\n  if (!Array.isArray(req.words)) {\n    return { items: [], isPartial: false };\n  }\n\n  if (\n    typeof req.currentIndex !== 'number' ||\n    req.currentIndex < 0 ||\n    req.currentIndex >= req.words.length\n  ) {\n    return { items: [], isPartial: false };\n  }\n\n  return resolveCompletion(req);\n}\n\nexport { setProgramInstance } from './resolver';\n\nexport {\n  getAllCommands,\n  getCommandSubcommands,\n  getCommandDescription,\n  installBashCompletion,\n  installZshCompletion\n} from '../completion.legacy';\n",
    "tokens": 177
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/capabilityInference.ts",
    "content": "import { AtomicCapability } from '../core/capabilities';\nimport type { CapabilityRequirement } from '../core/modelMatcher';\n\nexport function inferCapabilityRequirement(userInput: string): CapabilityRequirement {\n  const required: AtomicCapability[] = [];\n\n  const input = userInput.toLowerCase();\n\n  if (input.includes('代码') || input.includes('script') || input.includes('文件') || input.includes('create') || input.includes('write')) {\n    required.push(AtomicCapability.CODE_GENERATION);\n  }\n\n  if (input.includes('分析') || input.includes('理解') || input.includes('解释') || input.includes('推理')) {\n    required.push(AtomicCapability.REASONING);\n  }\n\n  if (input.includes('长') || input.includes('large') || input.includes('仓库') || input.includes('目录') || input.includes('所有文件')) {\n    required.push(AtomicCapability.LONG_CONTEXT);\n  }\n\n  return {\n    required: Array.from(new Set(required)),\n    preferred: [],\n  };\n}\n",
    "tokens": 229
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/apps.ts",
    "content": "import { exec } from 'child_process';\nimport fs from 'fs';\nimport path from 'path';\nimport yaml from 'js-yaml';\nimport os from 'os';\nimport { DEFAULT_APPS, parseAppsConfig } from './validation';\n\nexport { DEFAULT_APPS };\n\nexport function loadAppsConfig(): Record<string, string> {\n    const configPaths = [\n        path.join(process.cwd(), 'yuangs.config.json'),\n        path.join(process.cwd(), 'yuangs.config.yaml'),\n        path.join(process.cwd(), 'yuangs.config.yml'),\n        path.join(process.cwd(), '.yuangs.json'),\n        path.join(process.cwd(), '.yuangs.yaml'),\n        path.join(process.cwd(), '.yuangs.yml'),\n        path.join(os.homedir(), '.yuangs.json'),\n        path.join(os.homedir(), '.yuangs.yaml'),\n        path.join(os.homedir(), '.yuangs.yml'),\n    ];\n\n    for (const configPath of configPaths) {\n        if (fs.existsSync(configPath)) {\n            try {\n                const configContent = fs.readFileSync(configPath, 'utf8');\n                let config: Record<string, string>;\n                if (configPath.endsWith('.yaml') || configPath.endsWith('.yml')) {\n                    config = yaml.load(configContent) as Record<string, string>;\n                } else {\n                    config = parseAppsConfig(configContent);\n                }\n                return config;\n            } catch (error) { }\n        }\n    }\n    return DEFAULT_APPS;\n}\n\n\nexport function openUrl(url: string) {\n    let command;\n    switch (process.platform) {\n        case 'darwin': command = `open \"${url}\"`; break;\n        case 'win32': command = `start \"${url}\"`; break;\n        default: command = `xdg-open \"${url}\"`; break;\n    }\n    exec(command);\n}\n",
    "tokens": 417
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/capabilitySystem.ts",
    "content": "import {\n  CapabilityRequirement,\n  matchModelWithFallback,\n  ModelCapabilities,\n  CapabilityMatchResult,\n} from './modelMatcher';\nimport {\n  mergeConfigs,\n  loadConfigAt,\n  dumpConfigSnapshot,\n  getConfigFilePaths,\n  MergedConfig,\n} from './configMerge';\nimport {\n  createExecutionRecord,\n  ExecutionRecord,\n} from './executionRecord';\nimport {\n  saveExecutionRecord,\n  loadExecutionRecord,\n  listExecutionRecords,\n} from './executionStore';\nimport { replayEngine, ReplayOptions, ReplayResult } from './replayEngine';\n\nexport class CapabilitySystem {\n  private primaryModels: ModelCapabilities[] = [];\n  private fallbackModels: ModelCapabilities[] = [];\n\n  constructor() {\n    this.initializeDefaultModels();\n  }\n\n  private initializeDefaultModels(): void {\n    // 初始化为空数组，让配置文件成为主要来源\n    this.primaryModels = [];\n    this.fallbackModels = [];\n  }\n\n  matchCapability(requirement: CapabilityRequirement): CapabilityMatchResult {\n    const allModels = this.getAllModels();\n    const primaryModels = [...this.primaryModels, ...this.loadCustomModels()];\n    return matchModelWithFallback(\n      primaryModels,\n      this.fallbackModels,\n      requirement\n    );\n  }\n\n  loadMergedConfig(): MergedConfig {\n    const builtin = {\n      aiProxyUrl: 'https://aiproxy.want.biz/v1/chat/completions',\n      defaultModel: 'Assistant',\n      accountType: 'paid',\n    };\n\n    const filePaths = getConfigFilePaths();\n    const projectConfig = filePaths.project ? loadConfigAt(filePaths.project) : null;\n    const userGlobal = loadConfigAt(filePaths.userGlobal);\n\n    return mergeConfigs(builtin, userGlobal, projectConfig, null);\n  }\n\n  loadCustomModels(): ModelCapabilities[] {\n    const filePaths = getConfigFilePaths();\n    const projectConfig = filePaths.project ? loadConfigAt(filePaths.project) : null;\n    const userGlobal = loadConfigAt(filePaths.userGlobal);\n\n    const customModelsArray = [];\n    if (userGlobal?.models && Array.isArray(userGlobal.models)) {\n      customModelsArray.push(...userGlobal.models as ModelCapabilities[]);\n    }\n    if (projectConfig?.models && Array.isArray(projectConfig.models)) {\n      customModelsArray.push(...projectConfig.models as ModelCapabilities[]);\n    }\n\n    return customModelsArray;\n  }\n\n  getAllModels(): ModelCapabilities[] {\n    const customModels = this.loadCustomModels();\n    return [...this.primaryModels, ...this.fallbackModels, ...customModels];\n  }\n\n  createAndSaveExecutionRecord(\n    commandName: string,\n    requirement: CapabilityRequirement,\n    matchResult: CapabilityMatchResult,\n    command?: string\n  ): string {\n    const config = this.loadMergedConfig();\n    const record = createExecutionRecord(\n      commandName,\n      requirement,\n      config,\n      matchResult,\n      { success: matchResult.selected !== null },\n      command\n    );\n\n    const filePath = saveExecutionRecord(record);\n    return record.id;\n  }\n\n  replayExecution(recordId: string, options: ReplayOptions): Promise<ReplayResult> {\n    return replayEngine.replay(recordId, options);\n  }\n\n  explainConfig(): string {\n    const config = this.loadMergedConfig();\n    return dumpConfigSnapshot(config);\n  }\n}\n\nexport const capabilitySystem = new CapabilitySystem();\n",
    "tokens": 798
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/configMerge.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport yaml from 'js-yaml';\n\nexport type ConfigSource = 'built-in' | 'user-global' | 'project' | 'command-override';\n\nexport interface ConfigFieldSource<T = unknown> {\n  value: T;\n  source: ConfigSource;\n  filePath?: string;\n}\n\nexport interface MergedConfig {\n  aiProxyUrl: ConfigFieldSource<string>;\n  defaultModel: ConfigFieldSource<string>;\n  accountType: ConfigFieldSource<'free' | 'pro'>;\n  [key: string]: ConfigFieldSource<unknown>;\n}\n\nexport function loadConfigAt(filePath: string): Record<string, unknown> | null {\n  if (!fs.existsSync(filePath)) {\n    return null;\n  }\n\n  try {\n    const content = fs.readFileSync(filePath, 'utf8');\n    if (filePath.endsWith('.yaml') || filePath.endsWith('.yml')) {\n      return yaml.load(content) as Record<string, unknown>;\n    }\n    return JSON.parse(content);\n  } catch (error) {\n    console.warn(`Failed to load config from ${filePath}:`, error);\n    return null;\n  }\n}\n\nexport function mergeConfigs(\n  builtin: Record<string, unknown>,\n  userGlobal: Record<string, unknown> | null,\n  project: Record<string, unknown> | null,\n  commandOverride: Record<string, unknown> | null\n): MergedConfig {\n  const merged: MergedConfig = {} as MergedConfig;\n\n  const addField = (key: string, value: unknown, source: ConfigSource, filePath?: string) => {\n    merged[key] = { value, source, filePath };\n  };\n\n  Object.entries(builtin).forEach(([key, value]) => {\n    addField(key, value, 'built-in');\n  });\n\n  if (userGlobal) {\n    Object.entries(userGlobal).forEach(([key, value]) => {\n      addField(key, value, 'user-global', path.join(os.homedir(), '.yuangs.json'));\n    });\n  }\n\n  if (project) {\n    Object.entries(project).forEach(([key, value]) => {\n      addField(key, value, 'project');\n    });\n  }\n\n  if (commandOverride) {\n    Object.entries(commandOverride).forEach(([key, value]) => {\n      addField(key, value, 'command-override');\n    });\n  }\n\n  return merged;\n}\n\nexport function dumpConfigSnapshot(config: MergedConfig): string {\n  const output: Record<string, any> = {};\n\n  Object.entries(config).forEach(([key, field]) => {\n    output[key] = {\n      value: field.value,\n      source: field.source,\n      filePath: field.filePath,\n    };\n  });\n\n  return JSON.stringify(output, null, 2);\n}\n\nfunction findProjectConfig(cwd = process.cwd()): string | null {\n  let dir = cwd;\n  const configFiles = ['.yuangs.json', '.yuangs.yaml', '.yuangs.yml', 'yuangs.config.json'];\n\n  while (dir && dir !== path.dirname(dir)) {\n    for (const filename of configFiles) {\n      const candidate = path.join(dir, filename);\n      if (fs.existsSync(candidate)) {\n        return candidate;\n      }\n    }\n    dir = path.dirname(dir);\n  }\n\n  const root = path.parse(cwd).root;\n  for (const filename of configFiles) {\n    const rootCandidate = path.join(root, filename);\n    if (fs.existsSync(rootCandidate)) {\n      return rootCandidate;\n    }\n  }\n\n  return null;\n}\n\nexport function getConfigFilePaths(): {\n  userGlobal: string;\n  project: string | null;\n} {\n  return {\n    userGlobal: path.join(os.homedir(), '.yuangs.json'),\n    project: findProjectConfig(),\n  };\n}\n",
    "tokens": 790
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/os.ts",
    "content": "export type OSProfile = {\n    name: string;\n    shell: string;\n    find: 'bsd' | 'gnu';\n    stat: 'bsd' | 'gnu';\n};\n\nexport function getOSProfile(): OSProfile {\n    switch (process.platform) {\n        case 'darwin':\n            return {\n                name: 'macOS',\n                shell: 'zsh',\n                find: 'bsd',\n                stat: 'bsd',\n            };\n        case 'linux':\n            return {\n                name: 'Linux',\n                shell: 'bash',\n                find: 'gnu',\n                stat: 'gnu',\n            };\n        case 'win32':\n            return {\n                name: 'Windows',\n                shell: 'cmd',\n                find: 'gnu', // Win32 find is different, but for AI context let's assume GNU style tools if they are there, or just label it.\n                stat: 'gnu',\n            };\n        default:\n            return {\n                name: process.platform,\n                shell: 'sh',\n                find: 'gnu',\n                stat: 'gnu',\n            };\n    }\n}\n",
    "tokens": 258
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/core/executionStore.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { ExecutionRecord, serializeExecutionRecord, deserializeExecutionRecord } from './executionRecord';\n\nconst RECORD_DIR = path.join(os.homedir(), '.yuangs', 'executions');\n\nexport function ensureRecordDir(): void {\n  if (!fs.existsSync(RECORD_DIR)) {\n    fs.mkdirSync(RECORD_DIR, { recursive: true });\n  }\n}\n\nexport function saveExecutionRecord(record: ExecutionRecord): string {\n  ensureRecordDir();\n\n  const filename = `${record.id}.json`;\n  const filepath = path.join(RECORD_DIR, filename);\n\n  fs.writeFileSync(filepath, serializeExecutionRecord(record), 'utf8');\n\n  return filepath;\n}\n\nexport function loadExecutionRecord(id: string): ExecutionRecord | null {\n  ensureRecordDir();\n\n  const filename = `${id}.json`;\n  const filepath = path.join(RECORD_DIR, filename);\n\n  if (!fs.existsSync(filepath)) {\n    return null;\n  }\n\n  try {\n    const content = fs.readFileSync(filepath, 'utf8');\n    return deserializeExecutionRecord(content);\n  } catch (error) {\n    console.error(`Failed to load execution record ${id}:`, error);\n    return null;\n  }\n}\n\nexport function listExecutionRecords(limit: number = 50): ExecutionRecord[] {\n  ensureRecordDir();\n\n  const files = fs.readdirSync(RECORD_DIR)\n    .filter(f => f.endsWith('.json'))\n    .sort((a, b) => {\n      const statA = fs.statSync(path.join(RECORD_DIR, a));\n      const statB = fs.statSync(path.join(RECORD_DIR, b));\n      return statB.mtimeMs - statA.mtimeMs;\n    })\n    .slice(0, limit);\n\n  const records: ExecutionRecord[] = [];\n\n  for (const file of files) {\n    const record = loadExecutionRecord(file.replace('.json', ''));\n    if (record) {\n      records.push(record);\n    }\n  }\n\n  return records;\n}\n\nexport function deleteExecutionRecord(id: string): boolean {\n  ensureRecordDir();\n\n  const filename = `${id}.json`;\n  const filepath = path.join(RECORD_DIR, filename);\n\n  if (!fs.existsSync(filepath)) {\n    return false;\n  }\n\n  try {\n    fs.unlinkSync(filepath);\n    return true;\n  } catch (error) {\n    console.error(`Failed to delete execution record ${id}:`, error);\n    return false;\n  }\n}\n\nexport function clearAllExecutionRecords(): void {\n  ensureRecordDir();\n\n  const files = fs.readdirSync(RECORD_DIR).filter(f => f.endsWith('.json'));\n\n  for (const file of files) {\n    const filepath = path.join(RECORD_DIR, file);\n    try {\n      fs.unlinkSync(filepath);\n    } catch (error) {\n      console.error(`Failed to delete ${filepath}:`, error);\n    }\n  }\n}\n",
    "tokens": 625
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/utils/history.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { parseCommandHistory, type HistoryEntry } from '../core/validation';\n\nconst HISTORY_FILE = path.join(os.homedir(), '.yuangs_cmd_history.json');\n\nexport type { HistoryEntry };\n\nexport function getCommandHistory(): HistoryEntry[] {\n    if (fs.existsSync(HISTORY_FILE)) {\n        try {\n            return parseCommandHistory(fs.readFileSync(HISTORY_FILE, 'utf8'));\n        } catch (e) { }\n    }\n    return [];\n}\n\nexport function saveHistory(entry: { question: string; command: string }) {\n    let history = getCommandHistory();\n    const newEntry: HistoryEntry = {\n        ...entry,\n        time: new Date().toLocaleString()\n    };\n    // Keep last 1000, unique commands\n    history = [newEntry, ...history.filter(item => item.command !== entry.command)].slice(0, 1000);\n    fs.writeFileSync(HISTORY_FILE, JSON.stringify(history, null, 2));\n}\n",
    "tokens": 229
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/utils/confirm.ts",
    "content": "import * as readline from 'node:readline/promises';\nimport chalk from 'chalk';\n\nexport async function confirm(message: string): Promise<boolean> {\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout,\n    });\n\n    try {\n        const answer = await rl.question(chalk.yellow(`\\n⚠️  ${message} (y/N) `));\n        return answer.toLowerCase() === 'y';\n    } finally {\n        rl.close();\n    }\n}\n\n",
    "tokens": 111
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/utils/renderer.ts",
    "content": "import chalk from 'chalk';\nimport { marked } from 'marked';\nimport TerminalRenderer from 'marked-terminal';\nimport ora, { Ora } from 'ora';\n\n// 初始化 marked 配置\nmarked.setOptions({\n    renderer: new TerminalRenderer({\n        tab: 2,\n        width: process.stdout.columns || 80,\n        showSectionPrefix: false\n    }) as any\n});\n\nexport class StreamMarkdownRenderer {\n    private fullResponse: string = '';\n    private prefix: string;\n    private isFirstOutput: boolean = true;\n    private spinner: Ora | null = null;\n    private startTime: number;\n\n    constructor(prefix: string = chalk.bold.blue('🤖 AI：'), spinner?: Ora) {\n        this.prefix = prefix;\n        this.spinner = spinner || null;\n        this.startTime = Date.now();\n    }\n\n    /**\n     * 处理流式数据块\n     */\n    public onChunk(chunk: string) {\n        if (this.spinner && this.spinner.isSpinning) {\n            this.spinner.stop();\n        }\n\n        if (this.isFirstOutput) {\n            process.stdout.write(this.prefix);\n            this.isFirstOutput = false;\n        }\n\n        this.fullResponse += chunk;\n        process.stdout.write(chunk);\n    }\n\n    /**\n     * 流结束，执行回滚并渲染 Markdown\n     */\n    public finish(): string {\n        // 如果 Spinner 还在转（说明没有任何输出），先停掉\n        if (this.spinner && this.spinner.isSpinning) {\n            this.spinner.stop();\n        }\n\n        const formatted = (marked.parse(this.fullResponse, { async: false }) as string).trim();\n\n        if (process.stdout.isTTY && this.fullResponse.trim()) {\n            const screenWidth = process.stdout.columns || 80;\n            const totalContent = this.prefix + this.fullResponse;\n\n            // 计算原始文本占用的可视行数\n            const lineCount = this.getVisualLineCount(totalContent, screenWidth);\n\n            // 1. 清除当前行剩余内容\n            process.stdout.write('\\r\\x1b[K');\n            // 2. 向上回滚并清除之前的行\n            for (let i = 0; i < lineCount - 1; i++) {\n                process.stdout.write('\\x1b[A\\x1b[K');\n            }\n\n            // 3. 输出格式化后的 Markdown\n            process.stdout.write(this.prefix + formatted + '\\n');\n        } else {\n            // 非 TTY 模式或无内容，直接补充换行（如果之前输出了内容）\n            if (this.fullResponse.trim()) {\n                process.stdout.write('\\n');\n            }\n        }\n\n        // 输出耗时统计\n        const elapsed = (Date.now() - this.startTime) / 1000;\n        process.stdout.write('\\n' + chalk.gray(`─`.repeat(20) + ` (耗时: ${elapsed.toFixed(2)}s) ` + `─`.repeat(20) + '\\n\\n'));\n\n        return this.fullResponse;\n    }\n\n    /**\n     * 计算文本在终端的可视行数\n     */\n    private getVisualLineCount(text: string, screenWidth: number): number {\n        const stripAnsi = (str: string) => str.replace(/[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');\n\n        const lines = text.split('\\n');\n        let totalLines = 0;\n\n        for (const line of lines) {\n            // Expand tabs\n            const expandedLine = line.replace(/\\t/g, '        ');\n            const cleanLine = stripAnsi(expandedLine);\n\n            let lineWidth = 0;\n            for (const char of cleanLine) {\n                const code = char.codePointAt(0) || 0;\n                // 大部分宽字符（如中文）占 2 格\n                lineWidth += code > 255 ? 2 : 1;\n            }\n\n            if (lineWidth === 0) {\n                totalLines += 1;\n            } else {\n                totalLines += Math.ceil(lineWidth / screenWidth);\n            }\n        }\n\n        return totalLines;\n    }\n}\n",
    "tokens": 859
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/utils/syntaxHandler.ts",
    "content": "import fs from 'fs';\nimport chalk from 'chalk';\nimport path from 'path';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport { buildPromptWithFileContent, readFilesContent } from '../core/fileReader';\nimport { ContextBuffer } from '../agent/contextBuffer';\nimport { loadContext, saveContext } from '../agent/contextStorage';\n\nconst execAsync = promisify(exec);\n\n/**\n * 解析并处理特殊语法（@、#、:ls 等）\n */\nexport async function handleSpecialSyntax(input: string, stdinData?: string): Promise<{ processed: boolean; result?: string }> {\n    const trimmed = input.trim();\n\n    // 处理 @ 文件引用语法\n    if (trimmed.startsWith('@')) {\n        // 检查是否是 @! 立即执行语法\n        const immediateExecMatch = trimmed.match(/^@\\s*!\\s*(.+?)$/);\n        if (immediateExecMatch) {\n            const filePath = immediateExecMatch[1].trim();\n            return await handleImmediateExec(filePath);\n        }\n\n        // 检查是否是带行号的语法 @file:start-end\n        const lineRangeMatch = trimmed.match(/^@\\s*(.+?)(?::(\\d+)(?:-(\\d+))?)?\\s*(?:\\n(.*))?$/s);\n        if (lineRangeMatch) {\n            const filePath = lineRangeMatch[1];\n            const startLine = lineRangeMatch[2] ? parseInt(lineRangeMatch[2]) : null;\n            const endLine = lineRangeMatch[3] ? parseInt(lineRangeMatch[3]) : null;\n            const question = lineRangeMatch[4] || (stdinData ? `分析以下文件内容：\\n\\n${stdinData}` : '请分析这个文件');\n\n            return await handleFileReference(filePath.trim(), startLine, endLine, question);\n        }\n    }\n\n    // 处理 # 目录引用语法\n    if (trimmed.startsWith('#')) {\n        const dirMatch = trimmed.match(/^#\\s*(.+?)\\s*(?:\\n(.*))?$/s);\n        if (dirMatch) {\n            const dirPath = dirMatch[1].trim();\n            const question = dirMatch[2] || (stdinData ? `分析以下目录内容：\\n\\n${stdinData}` : '请分析这个目录');\n            return await handleDirectoryReference(dirPath, question);\n        }\n    }\n\n    // 处理 :ls 命令\n    if (trimmed === ':ls') {\n        return await handleListContext();\n    }\n\n    // 场景 5.1: :exec 原子执行\n    if (trimmed.startsWith(':exec ')) {\n        const command = trimmed.slice(6).trim();\n        return await handleAtomicExec(command);\n    }\n\n    // 处理 :cat [index] 命令\n    if (trimmed === ':cat' || trimmed.startsWith(':cat ')) {\n        const parts = trimmed.split(' ');\n        const index = parts.length > 1 ? parseInt(parts[1]) : null;\n        return await handleCatContext(index);\n    }\n\n    // 处理 :clear 命令\n    if (trimmed === ':clear') {\n        return await handleClearContext();\n    }\n\n    // 如果不是特殊语法，返回未处理\n    return { processed: false };\n}\n\nasync function handleFileReference(filePath: string, startLine: number | null = null, endLine: number | null = null, question?: string): Promise<{ processed: boolean; result: string }> {\n    const fullPath = path.resolve(filePath);\n\n    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isFile()) {\n        return {\n            processed: true,\n            result: `错误: 文件 \"${filePath}\" 不存在或不是一个文件`\n        };\n    }\n\n    try {\n        let content = fs.readFileSync(fullPath, 'utf-8');\n\n        // 如果指定了行号范围，则提取相应行\n        if (startLine !== null) {\n            const lines = content.split('\\n');\n\n            // 验证行号范围\n            if (startLine < 1 || startLine > lines.length) {\n                return {\n                    processed: true,\n                    result: `错误: 起始行号 ${startLine} 超出文件范围 (文件共有 ${lines.length} 行)`\n                };\n            }\n\n            const startIdx = startLine - 1; // 转换为数组索引（从0开始）\n            let endIdx = endLine ? Math.min(endLine, lines.length) : lines.length; // 如果未指定结束行，则到文件末尾\n\n            if (endLine && (endLine < startLine || endLine > lines.length)) {\n                return {\n                    processed: true,\n                    result: `错误: 结束行号 ${endLine} 超出有效范围 (应在 ${startLine}-${lines.length} 之间)`\n                };\n            }\n\n            // 提取指定范围的行\n            content = lines.slice(startIdx, endIdx).join('\\n');\n        }\n\n        const contentMap = new Map<string, string>();\n        contentMap.set(filePath, content);\n\n        // 持久化到上下文\n        const contextBuffer = new ContextBuffer();\n        const persisted = await loadContext();\n        contextBuffer.import(persisted);\n\n        contextBuffer.add({\n            type: 'file',\n            path: filePath + (startLine !== null ? `:${startLine}${endLine ? `-${endLine}` : ''}` : ''),\n            content: content\n        });\n\n        await saveContext(contextBuffer.export());\n\n        const prompt = buildPromptWithFileContent(\n            `文件: ${filePath}${startLine !== null ? `:${startLine}${endLine ? `-${endLine}` : ''}` : ''}`,\n            [filePath],\n            contentMap,\n            question || `请分析文件: ${filePath}`\n        );\n\n        return { processed: true, result: prompt };\n    } catch (error) {\n        return {\n            processed: true,\n            result: `读取文件失败: ${error}`\n        };\n    }\n}\n\nasync function handleDirectoryReference(dirPath: string, question?: string): Promise<{ processed: boolean; result: string }> {\n    const fullPath = path.resolve(dirPath);\n\n    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isDirectory()) {\n        return {\n            processed: true,\n            result: `错误: 目录 \"${dirPath}\" 不存在或不是一个目录`\n        };\n    }\n\n    try {\n        const findCommand = process.platform === 'darwin' || process.platform === 'linux'\n            ? `find \"${fullPath}\" -type f`\n            : `dir /s /b \"${fullPath}\"`;\n\n        const { stdout } = await execAsync(findCommand);\n        const filePaths = stdout.trim().split('\\n').filter(f => f);\n\n        if (filePaths.length === 0) {\n            return {\n                processed: true,\n                result: `目录 \"${dirPath}\" 下没有文件`\n            };\n        }\n\n        const contentMap = readFilesContent(filePaths);\n\n        // 持久化到上下文\n        const contextBuffer = new ContextBuffer();\n        const persisted = await loadContext();\n        contextBuffer.import(persisted);\n\n        contextBuffer.add({\n            type: 'directory',\n            path: dirPath,\n            content: Array.from(contentMap.entries()).map(([p, c]) => `--- ${p} ---\\n${c}`).join('\\n\\n')\n        });\n\n        await saveContext(contextBuffer.export());\n\n        const prompt = buildPromptWithFileContent(\n            `目录: ${dirPath}\\n找到 ${filePaths.length} 个文件`,\n            filePaths.map(p => path.relative(process.cwd(), p)),\n            contentMap,\n            question\n        );\n\n        return { processed: true, result: prompt };\n    } catch (error) {\n        return {\n            processed: true,\n            result: `读取目录失败: ${error}`\n        };\n    }\n}\n\nasync function handleImmediateExec(filePath: string): Promise<{ processed: boolean; result: string }> {\n    const fullPath = path.resolve(filePath);\n\n    if (!fs.existsSync(fullPath)) {\n        return {\n            processed: true,\n            result: `错误: 文件 \"${filePath}\" 不存在`\n        };\n    }\n\n    try {\n        // 1. 读取脚本内容\n        const content = fs.readFileSync(fullPath, 'utf-8');\n\n        console.log(chalk.gray(`正在执行 ${filePath} 并捕获输出...`));\n\n        // 2. 执行脚本\n        // 注意：这里使用 execAsync 捕获输出\n        const { stdout, stderr } = await execAsync(`chmod +x \"${fullPath}\" && \"${fullPath}\"`, { cwd: process.cwd() });\n\n        // 3. 构造组合上下文 (契约要求：命令内容 + 实际输出)\n        const combinedContext = `\n=== 脚本内容 (${filePath}) ===\n\\`\\`\\`bash\n${content}\n\\`\\`\\`\n\n=== 执行标准输出 (stdout) ===\n\\`\\`\\`\n${stdout}\n\\`\\`\\`\n\n=== 执行标准错误 (stderr) ===\n\\`\\`\\`\n${stderr}\n\\`\\`\\`\n`;\n\n        // 持久化到上下文\n        const contextBuffer = new ContextBuffer();\n        const persisted = await loadContext();\n        contextBuffer.import(persisted);\n\n        contextBuffer.add({\n            type: 'file',\n            path: `${filePath} (Runtime Log)`,\n            content: combinedContext,\n            summary: '包含脚本源码和执行后的输出日志'\n        });\n\n        await saveContext(contextBuffer.export());\n\n        // 返回给 AI 的 Prompt\n        const result = `我执行了脚本 ${filePath}。\\n以下是脚本源码和执行输出：\\n${combinedContext}\\n\\n请分析为何会出现上述输出（特别是错误信息）？`;\n        return { processed: true, result };\n    } catch (error: any) {\n        const errorMsg = error.message || String(error);\n        const result = `执行脚本 ${filePath} 时发生错误：\\n${errorMsg}\\n\\n请分析原因。`;\n        return { processed: true, result };\n    }\n}\n\nasync function handleAtomicExec(command: string): Promise<{ processed: boolean; result: string }> {\n    console.log(chalk.cyan(`\\n⚡️ [Atomic Exec] 执行命令: ${command}\\n`));\n\n    try {\n        // 对于原子执行，我们希望用户能实时看到输出，所以用 inherit\n        const { spawn } = require('child_process');\n        const child = spawn(command, {\n            shell: true,\n            stdio: 'inherit'\n        });\n\n        await new Promise<void>((resolve, reject) => {\n            child.on('close', (code: number) => {\n                if (code === 0) resolve();\n                else reject(new Error(`Exit code ${code}`));\n            });\n            child.on('error', reject);\n        });\n\n        // 原子执行不将结果传给 AI，直接返回空结果表示处理完成\n        return { processed: true, result: '' };\n    } catch (error) {\n        console.error(chalk.red(`执行失败: ${error}`));\n        return { processed: true, result: '' };\n    }\n}\n\nasync function handleListContext(): Promise<{ processed: boolean; result: string }> {\n    try {\n        const persisted = await loadContext();\n        const contextBuffer = new ContextBuffer();\n        contextBuffer.import(persisted);\n\n        if (contextBuffer.isEmpty()) {\n            return { processed: true, result: '当前没有上下文' };\n        }\n\n        const list = contextBuffer.list();\n        let result = '当前上下文列表：\\n';\n        list.forEach((item, index) => {\n            result += `${index + 1}. ${item.type}: ${item.path} (${item.tokens} tokens)\\n`;\n        });\n\n        return { processed: true, result };\n    } catch (error) {\n        return {\n            processed: true,\n            result: `读取上下文失败: ${error}`\n        };\n    }\n}\n\nasync function handleCatContext(index: number | null): Promise<{ processed: boolean; result: string }> {\n    try {\n        const persisted = await loadContext();\n        const contextBuffer = new ContextBuffer();\n        contextBuffer.import(persisted);\n\n        if (contextBuffer.isEmpty()) {\n            return { processed: true, result: '当前没有上下文' };\n        }\n\n        const items = contextBuffer.export();\n\n        if (index !== null) {\n            // 查看指定索引\n            if (index < 1 || index > items.length) {\n                return { processed: true, result: `错误: 索引 ${index} 超出范围 (共有 ${items.length} 个项目)` };\n            }\n            const item = items[index - 1];\n            return {\n                processed: true,\n                result: `--- [${index}] ${item.type}: ${item.path} ---\\n${item.content}\\n--- End ---`\n            };\n        } else {\n            // 查看全部\n            let result = '=== 当前完整上下文内容 ===\\n\\n';\n            items.forEach((item, i) => {\n                result += `--- [${i + 1}] ${item.type}: ${item.path} ---\\n${item.content}\\n\\n`;\n            });\n            result += '==========================';\n            return { processed: true, result };\n        }\n    } catch (error) {\n        return {\n            processed: true,\n            result: `读取上下文失败: ${error}`\n        };\n    }\n}\n\nasync function handleClearContext(): Promise<{ processed: boolean; result: string }> {\n    try {\n        // 清除持久化存储\n        await saveContext([]);\n\n        return { processed: true, result: '上下文已清空（含持久化）' };\n    } catch (error) {\n        return {\n            processed: true,\n            result: `清除上下文失败: ${error}`\n        };\n    }\n}\n",
    "tokens": 2887
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/governance.ts",
    "content": "import { ProposedAction, GovernanceDecision } from './state';\nimport { evaluateProposal, PolicyRule, RiskEntry } from './governance/core';\nimport { RiskLedger } from './governance/ledger';\nimport { WasmGovernanceBridge } from './governance/bridge';\nimport jsyaml from 'js-yaml';\nimport fs from 'fs';\nimport path from 'path';\n\nexport class GovernanceService {\n  private static rules: PolicyRule[] = [];\n  private static ledger = new RiskLedger();\n  private static initialized = false;\n\n  static async init(basePath?: string) {\n    if (this.initialized) return;\n    this.loadPolicy(basePath);\n    await WasmGovernanceBridge.init(basePath);\n    this.initialized = true;\n  }\n\n  private static loadPolicy(basePath?: string) {\n    try {\n      const root = basePath || process.cwd();\n      const policyPath = path.join(root, 'policy.yaml');\n      if (fs.existsSync(policyPath)) {\n        const content = fs.readFileSync(policyPath, 'utf8');\n        const config = jsyaml.load(content) as any;\n        this.rules = config.rules || [];\n      }\n    } catch (e) {\n      this.rules = [];\n    }\n  }\n\n  static getRules(): PolicyRule[] {\n    return this.rules;\n  }\n\n  static getLedgerSnapshot(): RiskEntry[] {\n    return this.ledger.getSnapshot();\n  }\n\n  static getPolicyManual(): string {\n    return this.rules.map(r => `- ${r.id}: ${r.reason} (${r.effect})`).join('\\n');\n  }\n\n  static async adjudicate(action: ProposedAction): Promise<GovernanceDecision> {\n    await this.init();\n\n    // 1. WASM 物理层核验\n    const wasmResult = WasmGovernanceBridge.evaluate(action, this.rules, this.ledger.getSnapshot());\n    if (wasmResult.effect === 'deny') {\n      return { status: 'rejected', by: 'policy', reason: wasmResult.reason || 'WASM Denied', timestamp: Date.now() };\n    }\n\n    // 2. 逻辑层核验\n    const logicResult = evaluateProposal(action, this.rules, this.ledger.getSnapshot());\n    if (logicResult.effect === 'deny') {\n      return { status: 'rejected', by: 'policy', reason: logicResult.reason || 'Policy Denied', timestamp: Date.now() };\n    }\n\n    if (logicResult.effect === 'allow') {\n      this.ledger.record(action.type);\n      return { status: 'approved', by: 'policy', timestamp: Date.now() };\n    }\n\n    // 3. 人工干预兜底 (模拟)\n    return { status: 'approved', by: 'human', timestamp: Date.now() };\n  }\n}\n",
    "tokens": 573
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/state.ts",
    "content": "import { randomUUID } from 'crypto';\n\nexport type AgentState = \n  | 'IDLE' \n  | 'THINKING' \n  | 'PROPOSING' \n  | 'GOVERNING' \n  | 'EXECUTING' \n  | 'OBSERVING' \n  | 'EVALUATING' \n  | 'TERMINAL';\n\nexport type RiskLevel = 'low' | 'medium' | 'high';\n\nexport interface ProposedAction {\n  id: string;\n  type: 'tool_call' | 'code_diff' | 'shell_cmd' | 'answer';\n  payload: any;\n  riskLevel: RiskLevel;\n  reasoning: string;\n}\n\nexport type GovernanceDecision = \n  | { status: 'approved'; by: 'policy' | 'human'; timestamp: number }\n  | { status: 'rejected'; by: 'policy' | 'human'; reason: string; timestamp: number }\n  | { \n      status: 'modified'; \n      by: 'human'; \n      originalActionId: string;\n      modifiedAction: ProposedAction;\n      modificationReason: string;\n      timestamp: number;\n    };\n\nexport type EvaluationOutcome = \n  | { kind: 'continue'; reason: 'incomplete' | 'failure_retry' }\n  | { kind: 'terminate'; reason: 'goal_satisfied' | 'user_abort' | 'max_turns_exceeded' }\n  | { kind: 'pause'; reason: 'await_human_input' };\n\nexport interface AgentThought {\n  raw: string;\n  parsedPlan: any;\n  isDone: boolean;\n  type?: 'tool_call' | 'code_diff' | 'shell_cmd' | 'answer';\n  payload?: any;\n  reasoning?: string;\n}\n\nexport interface ExecutionTurn {\n  turnId: number;\n  startTime: number;\n  endTime?: number;\n  contextSnapshot: {\n    inputHash: string;\n    systemPromptVersion: string;\n    toolSetVersion: string;\n    recentMessages: Array<{ role: string; content: string; timestamp: number }>;\n  };\n  thought?: AgentThought;\n  proposedAction?: ProposedAction;\n  governance?: GovernanceDecision;\n  executionResult?: {\n    success: boolean;\n    output: string;\n    error?: string;\n    artifacts?: string[];\n  };\n  observation?: {\n    summary: string;\n    artifacts: string[];\n    truncated?: boolean;\n  };\n  evaluation?: EvaluationOutcome;\n}\n\nexport interface GovernanceLoopConfig {\n  maxTurns: number;\n  autoApproveLowRisk: boolean;\n  verbose: boolean;\n}\n\nexport interface ToolExecutionResult {\n  success: boolean;\n  output: string;\n  error?: string;\n  artifacts?: string[];\n}\n\nexport interface GovernanceContext {\n  input: string;\n  mode: 'chat' | 'command' | 'command+exec';\n  history: AIRequestMessage[];\n  files?: Array<{ path: string; content: string }>;\n}\n\ninterface AIRequestMessage {\n  role: 'user' | 'assistant' | 'system' | 'tool';\n  content: string;\n}\n",
    "tokens": 594
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/executor.ts",
    "content": "import { ProposedAction, ToolExecutionResult } from './state';\nimport { VSCodeExecutor } from '../../runtime/vscode/VSCodeExecutor';\n\n/**\n * VS Code 适配版的 ToolExecutor\n * 将所有执行逻辑重定向到 VS Code API\n */\nexport class ToolExecutor {\n  static async execute(action: ProposedAction): Promise<ToolExecutionResult> {\n    const { type, payload } = action;\n\n    try {\n      switch (type) {\n        case 'tool_call':\n          return await this.executeTool(payload);\n\n        case 'shell_cmd':\n          const shellResult = await VSCodeExecutor.runCommand(payload.command);\n          return { success: true, output: shellResult };\n\n        case 'code_diff':\n          const diffResult = await VSCodeExecutor.applyDiff(payload.diff);\n          return { success: true, output: diffResult };\n\n        case 'answer':\n          return {\n            success: true,\n            output: payload.content || payload.text || '',\n            artifacts: []\n          };\n\n        default:\n          return {\n            success: false,\n            error: `Unknown action type: ${type}`,\n            output: ''\n          };\n      }\n    } catch (error: any) {\n      return {\n        success: false,\n        error: error.message || String(error),\n        output: ''\n      };\n    }\n  }\n\n  private static async executeTool(payload: any): Promise<ToolExecutionResult> {\n    const toolName = payload.tool_name;\n    const params = payload.parameters || {};\n\n    switch (toolName) {\n      case 'read_file':\n        try {\n          const content = await VSCodeExecutor.readFile(params.path);\n          return { success: true, output: content };\n        } catch (e: any) {\n          return { success: false, error: e.message, output: \"\" };\n        }\n\n      case 'write_file':\n        const writeResult = await VSCodeExecutor.writeFile(params.path, params.content);\n        return { success: true, output: writeResult };\n\n      case 'list_files':\n        try {\n          const fileList = await VSCodeExecutor.listFiles(params.path || '.');\n          return { success: true, output: fileList };\n        } catch (e: any) {\n          return { success: false, error: e.message, output: \"\" };\n        }\n\n      default:\n        return {\n          success: false,\n          error: `Unknown tool: ${toolName}`,\n          output: ''\n        };\n    }\n  }\n}\n",
    "tokens": 577
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/AgentRuntime.ts",
    "content": "import chalk from \"chalk\";\nimport { randomUUID } from \"crypto\";\nimport { LLMAdapter } from \"./llmAdapter\";\nimport { GovernanceService } from \"./governance\";\nimport { ToolExecutor } from \"./executor\";\nimport { ContextManager } from \"./contextManager\";\nimport { evaluateProposal } from \"./governance/core\";\nimport { ProposedAction } from \"./state\";\n\nexport class AgentRuntime {\n  private context: ContextManager;\n  private executionId: string;\n\n  constructor(initialContext: any) {\n    this.context = new ContextManager(initialContext);\n    this.executionId = randomUUID();\n  }\n\n  async run(\n    userInput: string,\n    mode: \"chat\" | \"command\" = \"chat\",\n    onChunk?: (chunk: string) => void,\n    model?: string,\n  ) {\n    let turnCount = 0;\n    const maxTurns = 10;\n\n    if (userInput) {\n      this.context.addMessage(\"user\", userInput);\n    }\n\n    while (turnCount < maxTurns) {\n      const currentTurn = ++turnCount;\n      if (currentTurn > 1) {\n        console.log(chalk.blue(`\\n--- Turn ${currentTurn} ---`));\n      }\n\n      const messages = this.context.getMessages().map((msg) => ({\n        role: (msg.role === \"tool\" ? \"system\" : msg.role) as\n          | \"system\"\n          | \"user\"\n          | \"assistant\",\n        content: msg.content,\n      }));\n\n      const thought = await LLMAdapter.think(\n        messages,\n        mode as any,\n        onChunk,\n        model,\n        GovernanceService.getPolicyManual(),\n      );\n\n      const action: ProposedAction = {\n        id: randomUUID(),\n        type: (thought.type as any) || \"answer\",\n        payload: thought.payload || { text: thought.raw },\n        riskLevel: \"low\",\n        reasoning: thought.reasoning || \"\",\n      };\n\n      if (action.reasoning && !onChunk) {\n        console.log(chalk.gray(`\\n🤔 Reasoning: ${action.reasoning}`));\n      }\n\n      // 如果 LLM 认为已经完成或者当前的动作就是回答\n      if (thought.isDone || action.type === \"answer\") {\n        const result = await ToolExecutor.execute(action as any);\n        if (!onChunk) {\n          console.log(chalk.green(`\\n🤖 AI：${result.output}\\n`));\n        }\n        this.context.addMessage(\"assistant\", result.output);\n        break;\n      }\n\n      // === 预检 (Pre-flight) ===\n      const preCheck = evaluateProposal(\n        action,\n        GovernanceService.getRules(),\n        GovernanceService.getLedgerSnapshot(),\n      );\n      if (preCheck.effect === \"deny\") {\n        console.log(\n          chalk.red(`[PRE-FLIGHT] 🛡️ Policy Blocked: ${preCheck.reason}`),\n        );\n        this.context.addMessage(\n          \"system\",\n          `POLICY DENIED: ${preCheck.reason}. Find a different way.`,\n        );\n        continue;\n      }\n\n      // === 正式治理 (WASM + 人工/自动) ===\n      const decision = await GovernanceService.adjudicate(action);\n      if (decision.status === \"rejected\") {\n        console.log(chalk.red(`[GOVERNANCE] ❌ Rejected: ${decision.reason}`));\n        this.context.addMessage(\n          \"system\",\n          `Rejected by Governance: ${decision.reason}`,\n        );\n        continue;\n      }\n\n      // === 执行 ===\n      console.log(chalk.yellow(`[EXECUTING] ⚙️ ${action.type}...`));\n      const result = await ToolExecutor.execute(action as any);\n\n      if (result.success) {\n        this.context.addToolResult(action.type, result.output);\n        const preview = result.output.length > 300 \n          ? result.output.substring(0, 300) + '...' \n          : result.output;\n        console.log(chalk.green(`[SUCCESS] Result:\\n${preview}`));\n      } else {\n        this.context.addToolResult(action.type, `Error: ${result.error}`);\n        console.log(chalk.red(`[ERROR] ${result.error}`));\n      }\n    }\n\n    if (turnCount >= maxTurns) {\n      console.log(chalk.red(`\\n⚠️ Max turns (${maxTurns}) reached.`));\n    }\n  }\n}\n",
    "tokens": 935
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/prompt.ts",
    "content": "import {\n    AgentIntent,\n    AgentContext,\n    AgentMode,\n    AgentPrompt,\n} from './types';\nimport { buildCommandPrompt as buildCommandPromptString } from '../ai/prompt';\nimport { getOSProfile } from '../core/os';\nimport { getMacros } from '../core/macros';\nimport { aiCommandPlanSchema } from '../core/validation';\nimport { getRelevantSkills } from './skills';\n\nexport function buildPrompt(\n    intent: AgentIntent,\n    context: AgentContext,\n    mode: AgentMode,\n    input: string\n): AgentPrompt {\n    if (mode === 'chat') {\n        return buildChatPrompt(context, input);\n    }\n\n    return buildCommandPromptObject(input, context);\n}\n\nfunction buildChatPrompt(\n    context: AgentContext,\n    input: string\n): AgentPrompt {\n    const messages: any[] = [\n        ...(context.history ?? []),\n    ];\n\n    // Add context files if available\n    if (context.files && context.files.length > 0) {\n        const contextDesc = context.files.map(f =>\n            `File: ${f.path}\\n\\`\\`\\`\\n${f.content}\\n\\`\\`\\``\n        ).join('\\n\\n');\n\n        messages.push({\n            role: 'system',\n            content: `Context:\\n${contextDesc}`,\n        });\n    }\n\n    messages.push({\n        role: 'user',\n        content: input,\n    });\n\n    return {\n        system: 'You are a helpful AI assistant with expertise in software development, system administration, and problem-solving.',\n        messages,\n    };\n}\n\nfunction buildCommandPromptObject(\n    input: string,\n    context: AgentContext\n): AgentPrompt {\n    const os = getOSProfile();\n    const macros = getMacros();\n    const skills = getRelevantSkills(input);\n    let promptText = buildCommandPromptString(input, os, macros);\n\n    if (skills.length > 0) {\n        const skillList = skills.map(s => `- ${s.name}: 当遇到 \"${s.whenToUse}\" 时，你可以参考计划: ${s.planTemplate.goal}`).join('\\n');\n        promptText = `【参考技能库】\\n${skillList}\\n\\n${promptText}`;\n    }\n\n    return {\n        messages: [\n            {\n                role: 'user',\n                content: promptText,\n            },\n        ],\n        outputSchema: aiCommandPlanSchema,\n    };\n}\n",
    "tokens": 522
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/context.ts",
    "content": "import { AgentInput, AgentContext } from './types';\nimport { ContextBuffer } from './contextBuffer';\n\nexport function buildContext(input: AgentInput, contextBuffer: ContextBuffer): AgentContext {\n    const items = contextBuffer.export();\n\n    return {\n        files: items.map(item => ({\n            path: item.path,\n            content: item.content,\n        })),\n        gitDiff: undefined, // Will be enhanced later\n        history: [], // Will be populated from conversation history\n    };\n}\n",
    "tokens": 124
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/types.ts",
    "content": "import type { AIRequestMessage } from '../core/validation';\n// import { AgentPlan } from './plan';\n\nexport type AgentMode = 'chat' | 'command' | 'command+exec';\n\nexport interface AgentInput {\n    rawInput: string;\n    stdin?: string;\n    context?: AgentContext;\n    options?: {\n        model?: string;\n        stream?: boolean;\n        autoYes?: boolean;\n        verbose?: boolean;\n    };\n}\n\nexport interface AgentContext {\n    files?: Array<{ path: string; content: string }>;\n    gitDiff?: string;\n    history?: AIRequestMessage[];\n}\n\nexport interface AgentIntent {\n    type: 'chat' | 'shell' | 'analysis';\n    capabilities: {\n        reasoning?: boolean;\n        code?: boolean;\n        longContext?: boolean;\n        streaming?: boolean;\n    };\n}\n\nexport interface AgentPrompt {\n    system?: string;\n    messages: AIRequestMessage[];\n    outputSchema?: any;\n}\n\nexport interface LLMResult {\n    rawText: string;\n    parsed?: any;\n    plan?: any;\n    latencyMs: number;\n    tokens?: {\n        prompt: number;\n        completion: number;\n        total: number;\n    };\n    costUsd?: number;\n}\n\nexport type AgentAction =\n    | { type: 'print'; content: string }\n    | { type: 'confirm'; next: AgentAction }\n    | { type: 'execute'; command: string; risk: 'low' | 'medium' | 'high' };\n",
    "tokens": 321
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/llm.ts",
    "content": "import { AgentPrompt, LLMResult } from './types';\nimport { callAI_Stream } from '../ai/client';\nimport axios from 'axios';\nimport { DEFAULT_AI_PROXY_URL, DEFAULT_MODEL, DEFAULT_ACCOUNT_TYPE, type AIRequestMessage } from '../core/validation';\nimport fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { safeParseJSON } from '../core/validation';\n\nconst CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');\n\nfunction getUserConfig(): any {\n    if (fs.existsSync(CONFIG_FILE)) {\n        try {\n            const content = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(content);\n        } catch (e) { }\n    }\n    return {};\n}\n\nexport async function runLLM({\n    prompt,\n    model,\n    stream,\n    onChunk,\n}: {\n    prompt: AgentPrompt;\n    model: string;\n    stream: boolean;\n    onChunk?: (s: string) => void;\n}): Promise<LLMResult> {\n    const start = Date.now();\n\n    if (stream) {\n        let raw = '';\n        await callAI_Stream(prompt.messages, model, (chunk) => {\n            raw += chunk;\n            onChunk?.(chunk);\n        });\n        return {\n            rawText: raw,\n            latencyMs: Date.now() - start,\n        };\n    }\n\n    // Non-streaming mode with optional schema\n    const config = getUserConfig();\n    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;\n\n    const headers = {\n        'Content-Type': 'application/json',\n        'X-Client-ID': 'vscode',\n        'Origin': 'https://cli.want.biz',\n        'Referer': 'https://cli.want.biz/',\n        'account': config.accountType || DEFAULT_ACCOUNT_TYPE,\n        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',\n        'Accept': 'application/json'\n    };\n\n    const data = {\n        model: model || config.defaultModel || DEFAULT_MODEL,\n        messages: prompt.messages,\n        stream: false\n    };\n\n    try {\n        const response = await axios.post(url, data, { headers });\n        const rawText = response.data.choices[0]?.message?.content || '';\n\n        let parsed = undefined;\n        if (prompt.outputSchema) {\n            const parseResult = safeParseJSON(rawText, prompt.outputSchema, {});\n            if (parseResult.success) {\n                parsed = parseResult.data;\n            }\n        }\n\n        return {\n            rawText,\n            parsed,\n            latencyMs: Date.now() - start,\n        };\n    } catch (error: any) {\n        const errorMsg = error.response?.data?.error?.message || error.response?.data?.message || error.message || '未知错误';\n        throw new Error(`AI 请求失败: ${errorMsg}`);\n    }\n}\n",
    "tokens": 662
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/contextStorage.ts",
    "content": "import fs from 'fs/promises';\nimport path from 'path';\nimport { ContextItem } from './contextBuffer';\n\nconst CONTEXT_DIR = path.resolve(process.cwd(), '.ai');\nconst CONTEXT_FILE = path.join(CONTEXT_DIR, 'context.json');\n\nexport async function loadContext(): Promise<ContextItem[]> {\n    try {\n        const raw = await fs.readFile(CONTEXT_FILE, 'utf-8');\n        return JSON.parse(raw);\n    } catch {\n        return [];\n    }\n}\n\nexport async function saveContext(items: ContextItem[]) {\n    await fs.mkdir(CONTEXT_DIR, { recursive: true });\n    await fs.writeFile(CONTEXT_FILE, JSON.stringify(items, null, 2));\n}\n\nexport async function clearContextStorage() {\n    await fs.rm(CONTEXT_FILE, { force: true });\n}\n",
    "tokens": 178
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/actions.ts",
    "content": "import { AgentAction } from './types';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport chalk from 'chalk';\nimport readline from 'readline';\n\nconst execAsync = promisify(exec);\n\nexport async function executeAction(\n    action: AgentAction,\n    options?: { autoYes?: boolean }\n): Promise<void> {\n    if (action.type === 'print') {\n        console.log(action.content);\n        return;\n    }\n\n    if (action.type === 'confirm') {\n        const ok = options?.autoYes || await confirm('Execute this action?');\n        if (ok) {\n            await executeAction(action.next, options);\n        }\n        return;\n    }\n\n    if (action.type === 'execute') {\n        try {\n            console.log(chalk.cyan(`\\nExecuting: ${action.command}\\n`));\n            const { stdout, stderr } = await execAsync(action.command, {\n                shell: typeof process.env.SHELL === 'string' ? process.env.SHELL : undefined\n            });\n            if (stdout) console.log(stdout);\n            if (stderr) console.error(chalk.yellow(stderr));\n        } catch (error: any) {\n            console.error(chalk.red(`Execution failed: ${error.message}`));\n            throw error;\n        }\n    }\n}\n\nasync function confirm(message: string): Promise<boolean> {\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout,\n    });\n\n    return new Promise((resolve) => {\n        rl.question(chalk.cyan(`${message} (y/N): `), (answer) => {\n            rl.close();\n            resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');\n        });\n    });\n}\n",
    "tokens": 404
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/chatHistoryStorage.ts",
    "content": "import fs from 'fs';\nimport { promisify } from 'util';\nimport path from 'path';\nimport os from 'os';\nimport { AIRequestMessage } from '../core/validation';\n\nconst CHAT_HISTORY_DIR = path.resolve(os.homedir(), '.yuangs_chat_history');\nconst CHAT_HISTORY_FILE = path.join(CHAT_HISTORY_DIR, 'chat_history.json');\n\nconst readFileAsync = promisify(fs.readFile);\nconst writeFileAsync = promisify(fs.writeFile);\nconst mkdirAsync = promisify(fs.mkdir);\nconst rmAsync = promisify(fs.rm);\n\nexport async function loadChatHistory(): Promise<AIRequestMessage[]> {\n    if (fs.existsSync(CHAT_HISTORY_FILE)) {\n        try {\n            const raw = await readFileAsync(CHAT_HISTORY_FILE, 'utf-8');\n            const data = JSON.parse(raw);\n\n            // 验证数据结构\n            if (Array.isArray(data) && data.every(msg =>\n                typeof msg === 'object' &&\n                ['user', 'assistant', 'system'].includes(msg.role) &&\n                typeof msg.content === 'string'\n            )) {\n                return data as AIRequestMessage[];\n            }\n        } catch (e) {\n            console.warn('警告: 加载聊天历史记录失败，使用空历史记录');\n        }\n    }\n    return [];\n}\n\nexport async function saveChatHistory(history: AIRequestMessage[]) {\n    try {\n        await mkdirAsync(CHAT_HISTORY_DIR, { recursive: true });\n        await writeFileAsync(CHAT_HISTORY_FILE, JSON.stringify(history, null, 2));\n    } catch (e) {\n        console.error('错误: 保存聊天历史记录失败:', e);\n    }\n}\n\nexport async function clearChatHistory() {\n    try {\n        await rmAsync(CHAT_HISTORY_FILE, { force: true });\n    } catch (e) {\n        console.error('错误: 清除聊天历史记录失败:', e);\n    }\n}\n",
    "tokens": 410
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/governance/core.ts",
    "content": "import { ProposedAction } from '../state';\n\nexport interface PolicyRule {\n    id: string;\n    when: { type?: string; pattern?: string; max_per_minute?: number };\n    effect: 'allow' | 'deny' | 'require_approval';\n    reason?: string;\n}\n\nexport interface RiskEntry {\n    ts: number;\n    actionType: string;\n}\n\nexport function evaluateProposal(\n    action: ProposedAction,\n    rules: PolicyRule[],\n    ledger: RiskEntry[]\n): { effect: string; reason?: string } {\n    const now = Date.now();\n    for (const rule of rules) {\n        const typeMatch = !rule.when.type || rule.when.type === action.type;\n        const payloadStr = JSON.stringify(action.payload);\n        const patternMatch = !rule.when.pattern || new RegExp(rule.when.pattern, 'i').test(payloadStr);\n\n        if (typeMatch && patternMatch) {\n            if (rule.when.max_per_minute) {\n                const count = ledger.filter(e => e.ts > now - 60000 && e.actionType === action.type).length;\n                if (count >= rule.when.max_per_minute) return { effect: 'deny', reason: `Rate limit: ${rule.id}` };\n            }\n            return { effect: rule.effect, reason: rule.reason };\n        }\n    }\n    return { effect: 'require_approval', reason: 'Default human review required' };\n}\n",
    "tokens": 314
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/governance/bridge.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\n\nexport class WasmGovernanceBridge {\n    private static instance: any = null;\n\n    static async init(basePath?: string): Promise<boolean> {\n        try {\n            const loader = require('@assemblyscript/loader');\n            const wasmPath = path.join(basePath || process.cwd(), 'build', 'release.wasm');\n\n            if (!fs.existsSync(wasmPath)) {\n                console.error(`WASM not found at: ${wasmPath}`);\n                return false;\n            }\n\n            const wasmModule = await loader.instantiate(fs.readFileSync(wasmPath));\n            this.instance = wasmModule.exports;\n            return true;\n        } catch (e) {\n            console.error(`WASM init error: ${e}`);\n            return false;\n        }\n    }\n\n    static evaluate(proposal: any, rules: any, ledger: any): any {\n        if (!this.instance) return { effect: 'error', reason: 'WASM not initialized' };\n\n        const { __newString, __getString, evaluate } = this.instance;\n\n        const pPtr = __newString(JSON.stringify(proposal));\n        const rPtr = __newString(JSON.stringify(rules));\n        const lPtr = __newString(JSON.stringify(ledger));\n\n        const resultPtr = evaluate(pPtr, rPtr, lPtr);\n        return JSON.parse(__getString(resultPtr));\n    }\n}\n",
    "tokens": 325
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/governance/ledger.ts",
    "content": "import { RiskEntry } from './core';\n\nexport class RiskLedger {\n    private entries: RiskEntry[] = [];\n\n    record(actionType: string): void {\n        this.entries.push({\n            ts: Date.now(),\n            actionType\n        });\n        this.cleanup();\n    }\n\n    getSnapshot(): RiskEntry[] {\n        return [...this.entries];\n    }\n\n    private cleanup(): void {\n        const oneHourAgo = Date.now() - 3600000;\n        this.entries = this.entries.filter(e => e.ts > oneHourAgo);\n    }\n}\n",
    "tokens": 124
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/governance/sandbox/core.as.ts",
    "content": "/**\n * yuangs Governance WASM Sandbox\n * 这里的代码在执行时与 Node.js 内存完全隔离\n */\n\n// 简单的辅助函数：检查字符串包含（WASM 内部实现）\nfunction includes(source: string, target: string): boolean {\n    return source.indexOf(target) != -1;\n}\n\n/**\n * 核心裁决导出函数\n * @param proposal 提案字符串\n * @param rules 规则字符串（YAML 转换后的 JSON）\n * @param ledger 账本字符串\n */\nexport function evaluate(proposal: string, rules: string, ledger: string): string {\n    // 1. 暴力阻断：最底层的物理防线（即便外部逻辑被污染，这里也是死的）\n    if (proposal.includes(\"rm -rf /\") || proposal.includes(\"sudo rm\")) {\n        return '{\"effect\": \"deny\", \"reason\": \"WASM_SANDBOX: 检测到毁灭性命令，强制阻断\"}';\n    }\n\n    // 2. 检查速率（基于账本长度）\n    // 假设我们不想让 AI 在短时间内连续提议超过 50 次\n    if (ledger.length > 5000) { // 简单通过字符串长度模拟异常账本\n        return '{\"effect\": \"deny\", \"reason\": \"WASM_SANDBOX: 账本异常膨胀，可能遭受拒绝服务攻击\"}';\n    }\n\n    // 3. 逻辑透传\n    // 在实际生产中，我们会在这里解析 JSON rules。\n    // 目前版本我们先确保物理链路打通。\n    return '{\"effect\": \"allow\", \"reason\": \"WASM_SANDBOX: 物理隔离层验证通过\"}';\n}\n",
    "tokens": 236
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/llmAdapter.ts",
    "content": "import { AgentThought } from './state';\nimport { runLLM } from './llm';\nimport { AgentPrompt } from './types';\nimport type { AIRequestMessage } from '../core/validation';\nimport { getUserConfig } from '../ai/client';\n\nexport class LLMAdapter {\n  static async think(\n    messages: AIRequestMessage[],\n    mode: 'chat' | 'command' | 'command+exec' = 'chat',\n    onChunk?: (chunk: string) => void,\n    model?: string,\n    customSystemPrompt?: string\n  ): Promise<AgentThought> {\n    const prompt: AgentPrompt = {\n      system: customSystemPrompt || `[SYSTEM PROTOCOL V2]\n- ROLE: AUTOMATED EXECUTION AGENT\n- OUTPUT: STRICT JSON ONLY\n- TALK: FORBIDDEN\n- MODE: REACT (THINK -> ACTION -> PERCEIVE)\n\nJSON SCHEMA:\n{\n  \"action_type\": \"tool_call\" | \"shell_cmd\" | \"code_diff\" | \"answer\",\n  \"reasoning\": \"thought process\",\n  \"tool_name\": \"list_files\" | \"read_file\",\n  \"diff\": \"unified diff string\",\n  \"parameters\": {},\n  \"command\": \"shell string\",\n  \"content\": \"final answer string\"\n}\n\nEXECUTION RULES:\n1. If data is unknown (e.g. file list), use 'shell_cmd' or 'tool_call'.\n2. NEVER explain how to do it. JUST EXECUTE.\n3. Your output MUST start with '{' and end with '}'.\n\nExample Task: \"count files\"\nYour Output: {\"action_type\":\"shell_cmd\",\"reasoning\":\"count files\",\"command\":\"ls | wc -l\"}`,\n      messages,\n    };\n\n    const config = getUserConfig();\n    const finalModel = model || config.defaultModel || 'Assistant';\n\n    const result = await runLLM({\n      prompt,\n      model: finalModel,\n      stream: !!onChunk,\n      onChunk\n    });\n\n    return this.parseThought(result.rawText);\n  }\n\n  private static parseThought(raw: string): AgentThought {\n    try {\n      // 提取 JSON：支持 Markdown 块或纯 JSON 字符串\n      const jsonMatch = raw.match(/```json\\n([\\s\\S]*?)\\n```/) || raw.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        const parsed = JSON.parse(jsonMatch[1] || jsonMatch[0]);\n\n        // 如果明确标记为 done，或者动作为 answer，则视为任务结束\n        if (parsed.is_done === true || parsed.action_type === 'answer') {\n          return {\n            raw,\n            parsedPlan: parsed,\n            isDone: true,\n            type: 'answer',\n            payload: {\n              content: parsed.final_answer || parsed.content || parsed.text || raw\n            }\n          };\n        }\n\n        // 智能推断动作类型：如果 AI 没给 action_type，我们根据字段猜测\n        let inferredType = parsed.action_type;\n        if (!inferredType) {\n          if (parsed.tool_name || parsed.tool) inferredType = 'tool_call';\n          else if (parsed.command || parsed.cmd) inferredType = 'shell_cmd';\n          else if (parsed.diff || parsed.patch) inferredType = 'code_diff';\n          else inferredType = 'answer';\n        }\n\n        return {\n          raw,\n          parsedPlan: parsed,\n          isDone: inferredType === 'answer' || parsed.is_done === true,\n          type: inferredType,\n          payload: {\n            tool_name: parsed.tool_name || parsed.tool || '',\n            parameters: parsed.parameters || parsed.params || {},\n            command: parsed.command || parsed.cmd || '',\n            diff: parsed.diff || parsed.patch || '',\n            content: parsed.content || parsed.text || ''\n          },\n          reasoning: parsed.reasoning || ''\n        };\n      }\n    } catch (e) {\n      // 解析失败时，回退到将原始内容作为回答\n    }\n\n    return {\n      raw,\n      parsedPlan: {},\n      isDone: true,\n      type: 'answer',\n      payload: { content: raw },\n      reasoning: ''\n    };\n  }\n}\n",
    "tokens": 857
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/index.ts",
    "content": "export { AgentRuntime } from './AgentRuntime';\nexport * from './state';\nexport { LLMAdapter } from './llmAdapter';\nexport { GovernanceService } from './governance';\nexport { ToolExecutor } from './executor';\nexport { ContextManager } from './contextManager';\nexport * from './skills';\n",
    "tokens": 72
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/skills.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport chalk from 'chalk';\n\nexport interface Skill {\n    id: string;\n    name: string;\n    description: string;\n    whenToUse: string; // 触发场景描述\n    planTemplate: any;\n\n    // 评价指标\n    successCount: number;\n    failureCount: number;\n    confidence: number; // 0 ~ 1, 初始 0.5\n\n    // 时间戳\n    lastUsed: number;\n    createdAt: number;\n\n    // 是否启用\n    enabled: boolean;\n}\n\nconst SKILLS_FILE = path.join(os.homedir(), '.yuangs_skills.json');\nlet skillLibrary: Skill[] = [];\n\n// === Persistence Logic ===\n\nfunction loadSkills() {\n    if (fs.existsSync(SKILLS_FILE)) {\n        try {\n            const data = fs.readFileSync(SKILLS_FILE, 'utf-8');\n            skillLibrary = JSON.parse(data);\n        } catch (e) {\n            console.error(chalk.yellow(`Failed to load skills from ${SKILLS_FILE}, starting empty.`));\n            skillLibrary = [];\n        }\n    }\n}\n\nfunction saveSkills() {\n    try {\n        fs.writeFileSync(SKILLS_FILE, JSON.stringify(skillLibrary, null, 2));\n    } catch (e) {\n        console.error(chalk.red(`Failed to save skills to ${SKILLS_FILE}`));\n    }\n}\n\n// Initialize on load\nloadSkills();\n\n// === Existing Logic with Save Hooks ===\n\n/**\n * 计算技能分 (0 ~ 1)\n */\nexport function computeSkillScore(skill: Skill, now: number = Date.now()): number {\n    const totalUses = skill.successCount + skill.failureCount;\n    const successRate = totalUses === 0 ? 0.5 : skill.successCount / totalUses;\n\n    // 时间衰减 (Freshness): 半衰期约 14 天\n    const idleDays = (now - skill.lastUsed) / (1000 * 60 * 60 * 24);\n    const freshness = Math.exp(-idleDays / 14);\n\n    // 综合得分: 45% 成功率 + 35% 新鲜度 + 20% 置信度\n    return (0.45 * successRate) + (0.35 * freshness) + (0.20 * skill.confidence);\n}\n\n/**\n * 更新技能状态 (执行后调用)\n */\nexport function updateSkillStatus(skillId: string, success: boolean) {\n    const skill = skillLibrary.find(s => s.id === skillId);\n    if (!skill) return;\n\n    skill.lastUsed = Date.now();\n    if (success) {\n        skill.successCount++;\n        // 成功奖励: 置信度缓慢提升\n        skill.confidence = Math.min(1, skill.confidence + 0.05);\n    } else {\n        skill.failureCount++;\n        // 失败惩罚: 惩罚力度大于奖励，防止系统“自嗨”\n        skill.confidence = Math.max(0, skill.confidence - 0.1);\n    }\n\n    saveSkills(); // Persist changes\n}\n\n/**\n * 自动学习新技能\n */\nexport function learnSkillFromRecord(record: any, success: boolean = true) {\n    if (record.mode === 'chat' || !record.llmResult.plan) return;\n\n    const existingSkill = skillLibrary.find(s => s.name === record.llmResult.plan?.goal);\n\n    if (existingSkill) {\n        updateSkillStatus(existingSkill.id, success);\n        return;\n    }\n\n    // 只有成功的记录才被学为新技能\n    if (!success) return;\n\n    const now = Date.now();\n    skillLibrary.push({\n        id: record.id,\n        name: record.llmResult.plan.goal,\n        description: `自动学习的技能: ${record.llmResult.plan.goal}`,\n        whenToUse: record.input.rawInput,\n        planTemplate: record.llmResult.plan,\n        successCount: 1,\n        failureCount: 0,\n        confidence: 0.5,\n        lastUsed: now,\n        createdAt: now,\n        enabled: true\n    });\n\n    // 每学习一次，尝试清理一次“冷”技能\n    reapColdSkills();\n\n    saveSkills(); // Persist changes\n}\n\n/**\n * 筛选并排序技能 (用于注入 Prompt)\n */\nexport function getRelevantSkills(input: string, limit: number = 3): Skill[] {\n    const now = Date.now();\n\n    return skillLibrary\n        // 1. 基础筛选: 剔除评分过低的技能 (硬淘汰阈值 0.3)\n        .filter(s => computeSkillScore(s, now) >= 0.3)\n        // 2. 过滤已禁用的技能\n        .filter(s => s.enabled !== false)\n        // 3. 排序: 按综合分排序\n        .sort((a, b) => computeSkillScore(b, now) - computeSkillScore(a, now))\n        // 4. 取上限\n        .slice(0, limit);\n}\n\n/**\n * 清理过期或低质技能 (Reaper)\n */\nexport function reapColdSkills() {\n    const now = Date.now();\n    const initialCount = skillLibrary.length;\n\n    skillLibrary = skillLibrary.filter(skill => {\n        const score = computeSkillScore(skill, now);\n        const idleDays = (now - skill.lastUsed) / (1000 * 60 * 60 * 24);\n\n        // 满足以下任一条件则淘汰:\n        // 1. 得分极低且长期不用\n        if (score < 0.25 && idleDays > 30) return false;\n        // 2. 失败率极高且尝试过一定次数\n        if (skill.failureCount > 5 && (skill.successCount / (skill.successCount + skill.failureCount)) < 0.2) return false;\n\n        return true;\n    });\n\n    // 强制保持容量\n    if (skillLibrary.length > 100) {\n        // 如果还超标，移除得分最低的那个\n        skillLibrary.sort((a, b) => computeSkillScore(a, now) - computeSkillScore(b, now));\n        skillLibrary.shift();\n    }\n\n    if (skillLibrary.length !== initialCount) {\n        saveSkills(); // Persist if changes happened\n    }\n}\n\nexport function getAllSkills(): Skill[] {\n    return [...skillLibrary];\n}\n",
    "tokens": 1172
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/replay/recorder.ts",
    "content": "import { RuntimeEvent, EventRecorder } from './events';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { randomUUID } from 'crypto';\n\nexport class FileEventRecorder implements EventRecorder {\n  private events: RuntimeEvent[] = [];\n  private logFile: string;\n  private flushInterval: number = 1000;\n\n  constructor(logDir: string = '.yuangs_events') {\n    this.logFile = path.join(logDir, `events_${Date.now()}.jsonl`);\n  }\n\n  async record(event: RuntimeEvent): Promise<void> {\n    this.events.push(event);\n\n    if (this.events.length >= this.flushInterval) {\n      await this.flush();\n    }\n  }\n\n  async flush(): Promise<void> {\n    if (this.events.length === 0) return;\n\n    const logDir = path.dirname(this.logFile);\n    await fs.mkdir(logDir, { recursive: true });\n\n    const content = this.events\n      .map(e => JSON.stringify(e))\n      .join('\\n') + '\\n';\n\n    await fs.appendFile(this.logFile, content, 'utf8');\n    this.events = [];\n  }\n\n  getEvents(executionId?: string): RuntimeEvent[] {\n    if (!executionId) {\n      return [...this.events];\n    }\n\n    return this.events.filter(e => e.executionId === executionId);\n  }\n}\n\nexport const createEvent = (\n  executionId: string,\n  type: RuntimeEvent['type'],\n  data: RuntimeEvent['data'],\n  metadata?: RuntimeEvent['metadata']\n): RuntimeEvent => ({\n  id: randomUUID(),\n  timestamp: Date.now(),\n  executionId,\n  type,\n  data,\n  metadata\n});\n",
    "tokens": 353
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/replay/events.ts",
    "content": "export type EventType = \n  | 'state_transition'\n  | 'llm_call'\n  | 'tool_execution'\n  | 'governance_decision'\n  | 'observation_recorded'\n  | 'evaluation_result'\n  | 'error_occurred';\n\nexport interface RuntimeEvent {\n  id: string;\n  timestamp: number;\n  executionId: string;\n  type: EventType;\n  data: {\n    from?: string;\n    to?: string;\n    action?: any;\n    decision?: any;\n    result?: any;\n    error?: string;\n  };\n  metadata?: Record<string, any>;\n}\n\nexport interface EventRecorder {\n  record(event: RuntimeEvent): void;\n  flush(): Promise<void>;\n  getEvents(executionId?: string): RuntimeEvent[];\n}\n",
    "tokens": 152
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/replay/index.ts",
    "content": "export * from './events';\nexport * from './recorder';\nexport * from './replayer';\n",
    "tokens": 21
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/replay/replayer.ts",
    "content": "import { RuntimeEvent } from './events';\n\nexport interface ReplayerOptions {\n  speed?: number;\n  stopOnError?: boolean;\n  dryRun?: boolean;\n}\n\nexport class EventReplayer {\n  private events: RuntimeEvent[] = [];\n  private currentIndex: number = 0;\n  private options: Required<ReplayerOptions>;\n\n  constructor(events: RuntimeEvent[], options: ReplayerOptions = {}) {\n    this.events = events;\n    this.options = {\n      speed: options.speed || 1,\n      stopOnError: options.stopOnError !== undefined ? options.stopOnError : true,\n      dryRun: options.dryRun || false\n    };\n  }\n\n  hasNext(): boolean {\n    return this.currentIndex < this.events.length;\n  }\n\n  next(): RuntimeEvent | null {\n    if (!this.hasNext()) {\n      return null;\n    }\n\n    return this.events[this.currentIndex++];\n  }\n\n  reset(): void {\n    this.currentIndex = 0;\n  }\n\n  async replay(onEvent: (event: RuntimeEvent, options: Required<ReplayerOptions>) => Promise<void>): Promise<void> {\n    this.reset();\n    let hasError = false;\n\n    while (this.hasNext() && !hasError) {\n      const event = this.next();\n\n      if (!event) break;\n\n      try {\n        await onEvent(event, this.options);\n\n        if (event.type === 'error_occurred') {\n          hasError = true;\n          if (this.options.stopOnError) {\n            break;\n          }\n        }\n\n        if (this.options.speed > 1) {\n          const delay = 100 / this.options.speed;\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      } catch (error: any) {\n        console.error(`[Replay] Error at event ${event.id}:`, error.message);\n        hasError = true;\n      }\n    }\n\n    return;\n  }\n\n  getSummary(): {\n    total: number;\n    completed: number;\n    errors: number;\n  } {\n    const errors = this.events.filter(e => e.type === 'error_occurred').length;\n    \n    return {\n      total: this.events.length,\n      completed: this.currentIndex,\n      errors\n    };\n  }\n}\n",
    "tokens": 483
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/contextManager.ts",
    "content": "import crypto from 'crypto';\nimport { GovernanceContext } from './state';\n\nexport class ContextManager {\n  private messages: Array<{ role: string; content: string; timestamp: number }> = [];\n  private maxHistorySize = 50;\n\n  constructor(initialContext?: GovernanceContext) {\n    if (initialContext?.history) {\n      this.messages = initialContext.history.map(msg => ({\n        ...msg,\n        timestamp: Date.now()\n      }));\n    }\n\n    if (initialContext?.input) {\n      this.addMessage('user', initialContext.input);\n    }\n  }\n\n  addMessage(role: string, content: string): void {\n    this.messages.push({\n      role,\n      content,\n      timestamp: Date.now()\n    });\n\n    if (this.messages.length > this.maxHistorySize) {\n      this.messages = this.messages.slice(-this.maxHistorySize);\n    }\n  }\n\n  addToolResult(toolName: string, result: string): void {\n    const content = `Tool ${toolName} returned:\\n${result}`;\n    this.addMessage('tool', content);\n  }\n\n  addObservation(observation: string): void {\n    this.addMessage('system', observation);\n  }\n\n  getMessages(): Array<{ role: 'system' | 'user' | 'assistant' | 'tool'; content: string }> {\n    return this.messages.map(({ role, content }) => ({ \n      role: role as 'system' | 'user' | 'assistant' | 'tool', \n      content \n    }));\n  }\n\n  getRecentMessages(count: number): Array<{ role: string; content: string; timestamp: number }> {\n    return this.messages.slice(-count);\n  }\n\n  getHash(): string {\n    const content = JSON.stringify(this.messages);\n    return crypto.createHash('sha256').update(content).digest('hex');\n  }\n\n  getSnapshot() {\n    return {\n      inputHash: this.getHash(),\n      systemPromptVersion: 'v1.0.0',\n      toolSetVersion: 'v1.0.0',\n      recentMessages: this.getRecentMessages(10)\n    };\n  }\n\n  clear(): void {\n    this.messages = [];\n  }\n}\n",
    "tokens": 459
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/selectModel.ts",
    "content": "import { AgentIntent } from './types';\nimport { getUserConfig } from '../ai/client';\n\nexport function selectModel(\n    intent: AgentIntent,\n    override?: string\n): string {\n    if (override) return override;\n\n    const config = getUserConfig();\n    const defaultModel = config.defaultModel || 'Assistant';\n\n    return defaultModel;\n}\n",
    "tokens": 84
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/contextBuffer.ts",
    "content": "export type ContextItem = {\n    type: 'file' | 'directory';\n    path: string;\n    alias?: string;\n    content: string;\n    summary?: string;\n    tokens: number;\n};\n\nconst estimateTokens = (text: string) => Math.ceil(text.length / 4);\n\nexport class ContextBuffer {\n    private items: ContextItem[] = [];\n    private maxTokens = 32000; // 约 12.8 万字符\n\n    add(item: Omit<ContextItem, 'tokens'>, bypassTokenLimit: boolean = false) {\n        const tokens = estimateTokens(item.content);\n        this.items.push({ ...item, tokens });\n        if (!bypassTokenLimit) {\n            this.trimIfNeeded();\n        }\n    }\n\n    clear() {\n        this.items = [];\n    }\n\n    list() {\n        return this.items.map((item, i) => ({\n            index: i + 1,\n            type: item.type,\n            path: item.path,\n            alias: item.alias,\n            tokens: item.tokens,\n            summary: item.summary\n        }));\n    }\n\n    isEmpty() {\n        return this.items.length === 0;\n    }\n\n    export() {\n        return this.items;\n    }\n\n    import(items: ContextItem[]) {\n        this.items = items;\n    }\n\n    private totalTokens() {\n        return this.items.reduce((sum, i) => sum + i.tokens, 0);\n    }\n\n    private trimIfNeeded() {\n        while (this.totalTokens() > this.maxTokens) {\n            this.items.shift();\n        }\n    }\n\n    buildPrompt(userInput: string): string {\n        if (this.isEmpty()) return userInput;\n\n        const contextBlock = this.items.map(item => {\n            const title = item.alias\n                ? `[Context Item] ${item.type}: ${item.alias} (${item.path})`\n                : `[Context Item] ${item.type}: ${item.path}`;\n\n            const body = item.summary ?? item.content;\n\n            return `${title}\\n---\\n${body}\\n---`;\n        }).join('\\n\\n');\n\n        return `\n# 知识上下文 (Knowledge Context)\n你目前的会话已加载以下参考资料。在回答用户问题时，请优先参考这些内容：\n\n${contextBlock}\n\n# 任务说明\n基于上述提供的上下文（如果有），回答用户的问题。如果上下文中包含源码，请将其视为你当前的“真理来源”。\n\n用户问题：\n${userInput}\n`;\n    }\n}\n// Test change for git diff\n// Another test change (unstaged)\n",
    "tokens": 510
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/policy/engine.ts",
    "content": "import { Policy, PolicyContext, PolicyResult } from './types';\nimport { RiskLevel } from '../state';\n\nexport class PolicyEngine {\n  private policies: Map<string, Policy> = new Map();\n\n  registerPolicy(policy: Policy): void {\n    this.policies.set(policy.name, policy);\n  }\n\n  unregisterPolicy(name: string): void {\n    this.policies.delete(name);\n  }\n\n  async evaluate(context: PolicyContext): Promise<PolicyResult> {\n    let finalResult: PolicyResult = {\n      allowed: true,\n      reason: 'All policies passed'\n    };\n\n    for (const [name, policy] of this.policies) {\n      const result = await policy.evaluate(context);\n      \n      if (!result.allowed) {\n        return {\n          allowed: false,\n          reason: `Policy \"${name}\" blocked: ${result.reason}`,\n          requiresEscalation: result.requiresEscalation || false,\n          suggestedActions: result.suggestedActions\n        };\n      }\n\n      if (result.requiresEscalation) {\n        finalResult.requiresEscalation = true;\n        finalResult.suggestedActions = result.suggestedActions;\n      }\n    }\n\n    return finalResult;\n  }\n\n  evaluateRisk(action: { type: string; payload: any }): RiskLevel {\n    const { type, payload } = action;\n\n    if (type === 'tool_call') {\n      const toolName = payload.tool_name;\n      \n      const lowRiskTools = ['read_file', 'list_files', 'web_search'];\n      if (lowRiskTools.includes(toolName)) {\n        return 'low';\n      }\n\n      const mediumRiskTools = ['write_file', 'shell'];\n      if (mediumRiskTools.includes(toolName)) {\n        const cmd = payload.parameters?.command || payload.command || '';\n        if (this.containsDangerousCommand(cmd)) {\n          return 'high';\n        }\n        return 'medium';\n      }\n\n      return 'medium';\n    }\n\n    if (type === 'shell_cmd') {\n      const cmd = payload.command || '';\n      if (this.containsDangerousCommand(cmd)) {\n        return 'high';\n      }\n      return 'medium';\n    }\n\n    return 'low';\n  }\n\n  private containsDangerousCommand(cmd: string): boolean {\n    const dangerousPatterns = [\n      /rm\\s+-rf\\s+\\//,\n      /rm\\s+-rf\\s+~/,\n      />\\s*\\/dev\\/null/,\n      /dd\\s+if=/,\n      /mkfs/,\n      /format/,\n      /sudo\\s+rm/\n    ];\n\n    return dangerousPatterns.some(pattern => pattern.test(cmd));\n  }\n}\n\nexport const policyEngine = new PolicyEngine();\n",
    "tokens": 580
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/policy/policies/noDangerousShell.ts",
    "content": "import { Policy, PolicyContext, PolicyResult } from '../types';\nimport { RiskLevel } from '../../state';\n\nexport class NoDangerousShellPolicy implements Policy {\n  name = 'no-dangerous-shell';\n  description = 'Prevents execution of dangerous shell commands';\n\n  evaluate(context: PolicyContext): PolicyResult {\n    const { action } = context;\n\n    if (action.type === 'shell_cmd') {\n      const command = action.payload?.command || '';\n      \n      const dangerousPatterns = [\n        { pattern: /rm\\s+-rf\\s+\\//, name: 'rm -rf /', risk: 'high' },\n        { pattern: /rm\\s+-rf\\s+~/, name: 'rm -rf ~', risk: 'high' },\n        { pattern: />\\s*\\/dev\\/null/, name: 'Redirect to /dev/null', risk: 'medium' },\n        { pattern: /dd\\s+if=/, name: 'dd command', risk: 'high' },\n        { pattern: /mkfs/, name: 'mkfs (filesystem creation)', risk: 'high' },\n        { pattern: /format/, name: 'format command', risk: 'high' },\n        { pattern: /sudo\\s+rm/, name: 'sudo rm', risk: 'high' },\n        { pattern: /chmod\\s+777\\s+\\/(?!dev)/, name: 'chmod 777 on system', risk: 'high' },\n        { pattern: /:\\s*~\\(\\)/, name: 'fork bomb', risk: 'high' }\n      ];\n\n      for (const { pattern, name, risk } of dangerousPatterns) {\n        if (pattern.test(command)) {\n          return {\n            allowed: false,\n            reason: `Dangerous command detected: ${name} (${risk} risk)`,\n            requiresEscalation: risk === 'high',\n            suggestedActions: [\n              `Review the command: \"${command}\"`,\n              'Consider using safer alternatives',\n              'Break down the operation into smaller, safer steps'\n            ]\n          };\n        }\n      }\n    }\n\n    return {\n      allowed: true,\n      reason: 'No dangerous patterns detected'\n    };\n  }\n}\n\nexport const noDangerousShellPolicy = new NoDangerousShellPolicy();\n",
    "tokens": 460
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/policy/types.ts",
    "content": "import { RiskLevel } from '../state';\n\nexport interface PolicyContext {\n  action: {\n    type: string;\n    payload: any;\n  };\n  user?: {\n    permissions: string[];\n  };\n  environment?: {\n    isProduction: boolean;\n  };\n}\n\nexport interface PolicyResult {\n  allowed: boolean;\n  reason?: string;\n  requiresEscalation?: boolean;\n  suggestedActions?: string[];\n}\n\nexport interface Policy {\n  name: string;\n  description: string;\n  evaluate(context: PolicyContext): PolicyResult | Promise<PolicyResult>;\n}\n",
    "tokens": 125
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/agent/policy/index.ts",
    "content": "export * from './types';\nexport * from './engine';\nexport * from './policies/noDangerousShell';\n",
    "tokens": 24
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/ai/prompt.ts",
    "content": "import { OSProfile } from '../core/os';\nimport type { Macro } from '../core/validation';\n\nexport function buildCommandPrompt(\n    userInput: string,\n    os: OSProfile,\n    macros?: Record<string, Macro>,\n    context?: string\n): string {\n    const macroContext = macros && Object.keys(macros).length > 0\n        ? `\n【可复用的快捷指令 (Macros)】\n以下是可以直接复用的已验证命令。优先复用这些指令，而不是生成新命令：\n\n${Object.entries(macros).map(([name, macro]) => `  - ${name}: ${macro.description || '(无描述)'}`).join('\\n')}\n\n当用户的需求与某个 Macro 匹配或相似时：\n1. 优先使用该 Macro\n2. 在 JSON 输出中使用 \"macro\" 字段指定 Macro 名称，而不是 \"command\" 字段\n3. 仅在没有合适 Macro 时才生成新命令\n`\n        : '';\n\n    return `\n你是一个专业的命令行专家。\n\n【系统环境】\n- 操作系统: ${os.name}\n- Shell: ${os.shell}\n- find 实现: ${os.find}\n- stat 实现: ${os.stat}\n\n【规则】\n- 命令必须与当前系统兼容。\n- 如果是 macOS (BSD):\n  - 不允许使用 find -printf\n  - 优先使用 stat -f\n- 如果是 Linux (GNU):\n  - 可使用 find -printf\n- 默认不使用 sudo。\n- 确保输出的命令是单行或者使用 && 连接。\n- 不要解释，只输出符合以下 JSON 结构的文本。\n- 优先复用已验证的快捷指令（Macros），每个 Macro 都是经过人工验证的可靠命令。在生成新命令前，检查是否已有 Macro 可以完成任务。\n\n${macroContext}\n\n【输出 JSON 结构】\n{\n  \"plan\": \"简要说明你准备执行的步骤\",\n  \"command\": \"可直接执行的 shell 命令（仅当没有合适 Macro 时提供）\",\n  \"macro\": \"要复用的 Macro 名称（优先使用，与 command 二选一）\",\n  \"risk\": \"low | medium | high\"\n}\n\n【上下文信息】\n${context || '无'}\n\n【用户需求】\n${userInput}\n`;\n}\n\nexport function buildFixPrompt(\n    originalCmd: string,\n    stderr: string,\n    os: OSProfile\n): string {\n    return `\n该命令在 ${os.name} 上执行失败：\n\n命令：\n${originalCmd}\n\n错误信息：\n${stderr}\n\n请生成一个 **${os.name} 兼容** 的等价命令。\n依然只输出 JSON 格式。注意：这是修复命令，不需要检查 Macro。\n\n{\n  \"plan\": \"修复说明\",\n  \"command\": \"修复后的命令\",\n  \"risk\": \"low | medium | high\"\n}\n`;\n}\n",
    "tokens": 393
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/ai/types.ts",
    "content": "export { AICommandPlan, type AICommandPlan as AICommandPlanType } from '../core/validation';\n",
    "tokens": 24
  },
  {
    "type": "file",
    "path": "/Users/ygs/yuangs-vscode/src/engine/ai/client.ts",
    "content": "import axios from 'axios';\nimport fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { DEFAULT_AI_PROXY_URL, DEFAULT_MODEL, DEFAULT_ACCOUNT_TYPE, type UserConfig, type AIRequestMessage } from '../core/validation';\nimport { loadChatHistory, saveChatHistory } from '../agent/chatHistoryStorage';\n\nconst CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');\n\nlet conversationHistory: AIRequestMessage[] = [];\n\n// 初始化时加载持久化的聊天历史记录\nloadChatHistory().then(history => {\n    conversationHistory = history;\n});\n\nexport function addToConversationHistory(role: 'system' | 'user' | 'assistant', content: string) {\n    conversationHistory.push({ role, content });\n    if (conversationHistory.length > 20) {\n        conversationHistory = conversationHistory.slice(-20);\n    }\n    // 同时保存到持久化存储\n    saveChatHistory(conversationHistory);\n}\n\nexport function clearConversationHistory() {\n    conversationHistory = [];\n    // 同时清除持久化存储\n    saveChatHistory(conversationHistory);\n}\n\nexport function getConversationHistory() {\n    return conversationHistory;\n}\n\nexport function getUserConfig(): UserConfig {\n    if (fs.existsSync(CONFIG_FILE)) {\n        try {\n            const content = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(content) as UserConfig;\n        } catch (e) { }\n    }\n    return {};\n}\n\nexport async function askAI(prompt: string, model?: string): Promise<string> {\n    const config = getUserConfig();\n    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;\n\n    const headers = {\n        'Content-Type': 'application/json',\n        'X-Client-ID': 'vscode',\n        'Origin': 'https://cli.want.biz',\n        'Referer': 'https://cli.want.biz/',\n        'account': config.accountType || DEFAULT_ACCOUNT_TYPE,\n        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',\n        'Accept': 'application/json'\n    };\n\n    const data = {\n        model: model || config.defaultModel || DEFAULT_MODEL,\n        messages: [{ role: 'user', content: prompt }],\n        stream: false\n    };\n\n    try {\n        const response = await axios.post(url, data, { headers });\n        const content = response.data?.choices?.[0]?.message?.content;\n        return content || '';\n    } catch (error: any) {\n        const errorMsg = error.response?.data?.error?.message || error.response?.data?.message || error.message || '未知错误';\n        throw new Error(`AI 请求失败: ${errorMsg}`);\n    }\n}\n\nexport async function callAI_Stream(messages: AIRequestMessage[], model: string | undefined, onChunk: (content: string) => void): Promise<void> {\n    const config = getUserConfig();\n    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;\n\n    const response = await axios({\n        method: 'post',\n        url: url,\n        data: {\n            model: model || config.defaultModel || DEFAULT_MODEL,\n            messages: messages,\n            stream: true\n        },\n        responseType: 'stream',\n        headers: {\n            'Content-Type': 'application/json',\n            'X-Client-ID': 'vscode',\n            'Origin': 'https://cli.want.biz',\n            'Referer': 'https://cli.want.biz/',\n            'account': config.accountType || DEFAULT_ACCOUNT_TYPE,\n            'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',\n            'Accept': 'application/json'\n        }\n    });\n\n    return new Promise((resolve, reject) => {\n        let buffer = '';\n        response.data.on('data', (chunk: Buffer) => {\n            buffer += chunk.toString();\n            let lines = buffer.split('\\n');\n            buffer = lines.pop() || '';\n\n            for (const line of lines) {\n                const trimmedLine = line.trim();\n                if (trimmedLine.startsWith('data: ')) {\n                    const data = trimmedLine.slice(6);\n                    if (data === '[DONE]') {\n                        resolve();\n                        return;\n                    }\n                    try {\n                        const parsed = JSON.parse(data);\n                        const content = parsed.choices[0]?.delta?.content || '';\n                        if (content) onChunk(content);\n                    } catch (e) { }\n                }\n            }\n        });\n        response.data.on('error', reject);\n        response.data.on('end', () => {\n            resolve();\n        });\n    });\n}\n",
    "tokens": 1127
  }
]