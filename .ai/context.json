[
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextDiff.ts",
    "content": "import { ContextItem } from './contextBuffer';\n\nexport interface ContextSnapshot {\n  items: Array<{\n    path: string;\n    hash: string; // å†…å®¹å“ˆå¸Œï¼Œç”¨äºæ£€æµ‹å˜åŒ–\n    tokens: number;\n    semantic?: string; // è¯­ä¹‰ç±»å‹\n    summaryQuality?: number; // æ‘˜è¦è´¨é‡\n  }>;\n}\n\nexport interface ContextDiff {\n  added: string[];\n  removed: string[];\n  changed: string[];\n}\n\n/**\n * è®¡ç®—ä¸¤ä¸ªä¸Šä¸‹æ–‡å¿«ç…§ä¹‹é—´çš„å·®å¼‚\n * @param prev ä¸Šä¸€ä¸ªå¿«ç…§ï¼Œå¦‚æœä¸ºnullè¡¨ç¤ºé¦–æ¬¡å¿«ç…§\n * @param curr å½“å‰å¿«ç…§\n * @returns ä¸Šä¸‹æ–‡å·®å¼‚å¯¹è±¡\n */\nexport function diffContext(\n  prev: ContextSnapshot | null,\n  curr: ContextSnapshot\n): ContextDiff {\n  if (!prev) {\n    return {\n      added: curr.items.map(i => i.path),\n      removed: [],\n      changed: []\n    };\n  }\n\n  const prevMap = new Map(prev.items.map(i => [i.path, i]));\n  const currMap = new Map(curr.items.map(i => [i.path, i]));\n\n  const added: string[] = [];\n  const removed: string[] = [];\n  const changed: string[] = [];\n\n  for (const [path, item] of currMap) {\n    const old = prevMap.get(path);\n    if (!old) {\n      added.push(path);\n    } else if (old.hash !== item.hash) {\n      changed.push(path);\n    }\n  }\n\n  for (const path of prevMap.keys()) {\n    if (!currMap.has(path)) {\n      removed.push(path);\n    }\n  }\n\n  return { added, removed, changed };\n}\n\n/**\n * ä»ContextBufferåˆ›å»ºå¿«ç…§\n * @param buffer ContextBufferå®ä¾‹\n * @returns ContextSnapshot\n */\nexport function snapshotFromBuffer(buffer: { export(): ContextItem[] }): ContextSnapshot {\n  const items = buffer.export();\n  return {\n    items: items.map((item: ContextItem) => ({\n      path: item.path,\n      hash: item.summarySourceHash || item.stableId || calculateHash(item.content), // ä¼˜å…ˆä½¿ç”¨ç¨³å®šçš„hashå€¼\n      tokens: item.tokens,\n      semantic: item.semantic,\n      summaryQuality: item.summaryQuality\n    }))\n  };\n}\n\n/**\n * ç®€å•çš„å†…å®¹å“ˆå¸Œè®¡ç®—\n * @param content å†…å®¹å­—ç¬¦ä¸²\n * @returns å“ˆå¸Œå­—ç¬¦ä¸²\n */\nfunction calculateHash(content: string): string {\n  let hash = 0;\n  for (let i = 0; i < content.length; i++) {\n    const char = content.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash |= 0; // è½¬æ¢ä¸º32ä½æ•´æ•°\n  }\n  return hash.toString();\n}",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/contextDiff.ts:1769101059020",
    "tokens": 512,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/AgentRuntime.ts",
    "content": "import chalk from \"chalk\";\nimport { randomUUID } from \"crypto\";\nimport { LLMAdapter } from \"./llmAdapter\";\nimport { GovernanceService } from \"./governance\";\nimport { ToolExecutor } from \"./executor\";\nimport { ContextManager } from \"./contextManager\";\nimport { evaluateProposal } from \"./governance/core\";\nimport { ProposedAction, ExecutionTurn } from \"./state\";\nimport { ContextBuffer } from \"./contextBuffer\";\nimport { snapshotFromBuffer, diffContext, ContextSnapshot } from \"./contextDiff\";\nimport { ExecutionRecorder } from \"./executionRecorder\";\nimport { generateReferenceRetrospective, analyzeContextLifecycle } from \"./contextProtocol\";\nimport { ContextToSkillPromotionRules } from \"./contextSkillPromotion\";\nimport { Skill, updateSkillStatus, learnSkillFromRecord, addSkill } from \"./skills\";\n\nexport class AgentRuntime {\n  private context: ContextManager;\n  private lastContextSnapshot: ContextSnapshot | null = null;\n  private executionId: string;\n  private executionRecorder: ExecutionRecorder;\n\n  constructor(initialContext: any) {\n    this.context = new ContextManager(initialContext);\n    this.executionRecorder = new ExecutionRecorder();\n    this.executionId = randomUUID();\n  }\n\n  /**\n   * åˆå§‹åŒ–è¿è¡Œæ—¶ï¼ŒåŒ…æ‹¬ Context Bank\n   */\n  async initialize(): Promise<void> {\n    await this.context.initializeContextBank();\n  }\n\n  async run(\n    userInput: string,\n    mode: \"chat\" | \"command\" = \"chat\",\n    onChunk?: (chunk: string) => void,\n    model?: string,\n  ) {\n    // ç¡®ä¿ Context Bank å·²åˆå§‹åŒ–\n    await this.initialize();\n\n    let turnCount = 0;\n    const maxTurns = 10;\n\n    if (userInput) {\n      // æ£€æŸ¥ç”¨æˆ·è¾“å…¥æ˜¯å¦åŒ…å« DSL æŸ¥è¯¢ï¼Œå¦‚æœæœ‰åˆ™è‡ªåŠ¨æ·»åŠ ç›¸å…³ä¸Šä¸‹æ–‡\n      const dslContextItems = await this.context.getDSLContextForInput(userInput);\n\n      if (dslContextItems.length > 0) {\n        console.log(chalk.cyan(`\\n[DSL Query] Found ${dslContextItems.length} matching context items:`));\n        for (const item of dslContextItems) {\n          console.log(chalk.cyan(`  - ${item.path} (${item.type})`));\n        }\n      }\n\n      // ä» Context Bank æŸ¥è¯¢ä¸å½“å‰ä»»åŠ¡ç›¸å…³çš„ä¸Šä¸‹æ–‡\n      console.log(chalk.blue('\\n[Context Bank] Loading relevant context...'));\n      try {\n        await this.context.importFromContextBank({\n          input: userInput,\n          projectScope: process.cwd(), // ä½¿ç”¨å½“å‰å·¥ä½œç›®å½•ä½œä¸ºé¡¹ç›®ä½œç”¨åŸŸ\n          strategy: 'relevance',\n          limit: 5 // æœ€å¤šåŠ è½½5ä¸ªç›¸å…³ä¸Šä¸‹æ–‡\n        });\n        console.log(chalk.green('[Context Bank] Relevant context loaded'));\n      } catch (error) {\n        console.log(chalk.yellow(`[Context Bank] Could not load context: ${error}`));\n      }\n\n      this.context.addMessage(\"user\", userInput);\n    }\n\n    while (turnCount < maxTurns) {\n      const currentTurn = ++turnCount;\n      if (currentTurn > 1) {\n        console.log(chalk.blue(`\\n--- Turn ${currentTurn} ---`));\n      }\n\n      const messages = this.context.getMessages().map((msg) => ({\n        role: (msg.role === \"tool\" ? \"system\" : msg.role) as\n          | \"system\"\n          | \"user\"\n          | \"assistant\",\n        content: msg.content,\n      }));\n\n      // === Context Diff ===\n      const currentSnapshot = snapshotFromBuffer(this.context.getContextBuffer());\n      const contextDiff = diffContext(this.lastContextSnapshot, currentSnapshot);\n\n      if (\n        contextDiff.added.length ||\n        contextDiff.removed.length ||\n        contextDiff.changed.length\n      ) {\n        console.log(chalk.cyan('\\n[Context Diff]'));\n        if (contextDiff.added.length)\n          console.log('  + added:', contextDiff.added);\n        if (contextDiff.removed.length)\n          console.log('  - removed:', contextDiff.removed);\n        if (contextDiff.changed.length)\n          console.log('  ~ changed:', contextDiff.changed);\n      }\n\n      this.lastContextSnapshot = currentSnapshot;\n\n      // è®°å½•æ‰§è¡Œå›åˆ\n      const executionTurn: Omit<ExecutionTurn, 'turnId'> = {\n        startTime: Date.now(),\n        contextSnapshot: {\n          inputHash: this.context.getHash(),\n          systemPromptVersion: 'v1.0.0',\n          toolSetVersion: 'v1.0.0',\n          recentMessages: this.context.getRecentMessages(5)\n        },\n        contextDiff: contextDiff.added.length || contextDiff.removed.length || contextDiff.changed.length\n          ? contextDiff\n          : undefined\n      };\n\n      const thought = await LLMAdapter.think(\n        messages,\n        mode as any,\n        onChunk,\n        model,\n        GovernanceService.getPolicyManual(),\n        this.context  // ä¼ é€’ContextManagerä»¥ä¾¿è®¿é—®ContextBuffer\n      );\n\n      const action: ProposedAction = {\n        id: randomUUID(),\n        type: (thought.type as any) || \"answer\",\n        payload: thought.payload || { text: thought.raw },\n        riskLevel: \"low\",\n        reasoning: thought.reasoning || \"\",\n      };\n\n      // æ›´æ–°executionTurn\n      executionTurn.proposedAction = action;\n\n      if (action.reasoning && !onChunk) {\n        console.log(chalk.gray(`\\nğŸ¤” Reasoning: ${action.reasoning}`));\n      }\n\n      // å¦‚æœ LLM è®¤ä¸ºå·²ç»å®Œæˆæˆ–è€…å½“å‰çš„åŠ¨ä½œå°±æ˜¯å›ç­”\n      if (thought.isDone || action.type === \"answer\") {\n        const result = await ToolExecutor.execute(action as any);\n        if (!onChunk) {\n          console.log(chalk.green(`\\n\\n\\nğŸ¤– AIï¼š${result.output}\\n`));\n        }\n        this.context.addMessage(\"assistant\", result.output);\n\n        // æ›´æ–°executionTurn\n        executionTurn.executionResult = result;\n        executionTurn.endTime = Date.now();\n\n        // ä»»åŠ¡æˆåŠŸå®Œæˆï¼Œåªæ›´æ–°è¢«ä½¿ç”¨è¿‡çš„ContextItemçš„é‡è¦æ€§\n        for (const item of this.context.getContextBuffer().export()) {\n          if (item.importance && item.importance.useCount > 0) {\n            // æˆåŠŸå®Œæˆä»»åŠ¡ï¼Œå¢åŠ æˆåŠŸè®¡æ•°\n            item.importance.successCount++;\n            item.importance.confidence = Math.min(1, item.importance.confidence + 0.05);\n            item.importance.lastUsed = Date.now();\n          }\n        }\n\n        // è®°å½• ContextBank ä½¿ç”¨æƒ…å†µï¼ˆæˆåŠŸï¼‰\n        await this.context.recordBankUsage(true);\n\n        // ç”ŸæˆContextå¼•ç”¨å›æº¯æŠ¥å‘Š\n        const retrospectiveReport = generateReferenceRetrospective(\n          this.context.getContextBuffer(),\n          this.executionId,\n          userInput,\n          result.output\n        );\n\n        console.log(chalk.magenta('\\nğŸ” Context Reference Retrospective:'));\n        console.log(retrospectiveReport);\n\n        // åˆ†æContextItemçš„ç”Ÿå‘½å‘¨æœŸ\n        const lifecycleAnalysis = analyzeContextLifecycle(this.context.getContextBuffer());\n        const recommendations = lifecycleAnalysis.filter(item => item.recommendation !== 'keep');\n\n        if (recommendations.length > 0) {\n          console.log(chalk.magenta('\\nğŸ’¡ Context Lifecycle Recommendations:'));\n          for (const rec of recommendations) {\n            console.log(chalk.yellow(`  ${rec.recommendation.toUpperCase()}: ${rec.path} (quality: ${rec.qualityScore.toFixed(2)}, relevance: ${rec.relevanceScore.toFixed(2)})`));\n          }\n        }\n\n        // æ£€æŸ¥æ˜¯å¦å¯ä»¥å°†æŸäº›ContextItemæ™‹å‡ä¸ºSkill\n        const contextItems = this.context.getContextBuffer().export();\n        for (const item of contextItems) {\n          const promotedSkill = ContextToSkillPromotionRules.evaluatePromotion(item);\n          if (promotedSkill) {\n            console.log(chalk.green(`\\nğŸš€ PROMOTION: Context \"${item.path}\" qualifies to be promoted to Skill \"${promotedSkill.name}\"`));\n            console.log(chalk.gray(`   Description: ${promotedSkill.description}`));\n\n            // è¯¢é—®ç”¨æˆ·æ˜¯å¦ç¡®è®¤åˆ›å»ºæŠ€èƒ½\n            const confirmed = await this.confirmSkillCreation(promotedSkill);\n            if (confirmed) {\n              try {\n                // é€šè¿‡æ²»ç†æœåŠ¡å®¡æ‰¹\n                const governanceDecision = await GovernanceService.adjudicate({\n                  id: randomUUID(),\n                  type: 'tool_call',\n                  payload: {\n                    tool_name: 'skill_create',\n                    parameters: promotedSkill\n                  },\n                  riskLevel: 'low',\n                  reasoning: 'Auto promotion from context'\n                });\n\n                if (governanceDecision.status === 'approved') {\n                  // ä¿å­˜æŠ€èƒ½\n                  await this.saveSkill(promotedSkill);\n                  // æ ‡è®° ContextItem å·²è¢«æ™‹å‡\n                  (item as any).metadata = {\n                    ...(item as any).metadata,\n                    promotedToSkill: true\n                  };\n                  console.log(chalk.green(`âœ… Skill \"${promotedSkill.name}\" created successfully`));\n                } else {\n                  console.log(chalk.yellow(`âš ï¸  Skill creation rejected by governance: ${'reason' in governanceDecision ? governanceDecision.reason : 'Unknown reason'}`));\n                }\n              } catch (error) {\n                console.log(chalk.red(`âŒ Failed to create skill: ${error}`));\n              }\n            }\n          }\n        }\n\n        // è®°å½•æ‰§è¡Œå›åˆï¼ˆåªåœ¨è¿™é‡Œè®°å½•ä¸€æ¬¡ï¼‰\n        this.executionRecorder.recordTurn({ ...executionTurn, turnId: 0 } as any);\n\n        // æ‰§è¡Œå›é¡¾æ€§åˆ†æ\n        await this.retrospective({ ...executionTurn, turnId: 0 });\n\n        break;\n      }\n\n      // === é¢„æ£€ (Pre-flight) ===\n      const preCheck = evaluateProposal(\n        action,\n        GovernanceService.getRules(),\n        GovernanceService.getLedgerSnapshot(),\n      );\n      if (preCheck.effect === \"deny\") {\n        console.log(\n          chalk.red(`[PRE-FLIGHT] ğŸ›¡ï¸ Policy Blocked: ${preCheck.reason}`),\n        );\n        this.context.addMessage(\n          \"system\",\n          `POLICY DENIED: ${preCheck.reason}. Find a different way.`,\n        );\n\n        // æ›´æ–°executionTurn\n        executionTurn.executionResult = {\n          success: false,\n          output: `POLICY DENIED: ${preCheck.reason}`,\n          error: preCheck.reason\n        };\n        executionTurn.endTime = Date.now();\n\n        // è®°å½•æ‰§è¡Œå›åˆ\n        this.executionRecorder.recordTurn({ ...executionTurn, turnId: 0 } as any);\n\n        continue;\n      }\n\n      // === æ­£å¼æ²»ç† (WASM + äººå·¥/è‡ªåŠ¨) ===\n      const decision = await GovernanceService.adjudicate(action);\n      if (decision.status === \"rejected\") {\n        console.log(chalk.red(`[GOVERNANCE] âŒ Rejected: ${'reason' in decision ? decision.reason : 'Unknown reason'}`));\n        this.context.addMessage(\n          \"system\",\n          `Rejected by Governance: ${'reason' in decision ? decision.reason : 'Unknown reason'}`,\n        );\n\n        // æ›´æ–°executionTurn\n        executionTurn.governance = decision;\n        executionTurn.executionResult = {\n          success: false,\n          output: `GOVERNANCE REJECTED: ${'reason' in decision ? decision.reason : 'Unknown reason'}`,\n          error: 'reason' in decision ? decision.reason : 'Unknown reason'\n        };\n        executionTurn.endTime = Date.now();\n\n        // ä»»åŠ¡è¢«æ‹’ç»ï¼Œåªæ›´æ–°è¢«ä½¿ç”¨è¿‡çš„ContextItemçš„é‡è¦æ€§ï¼ˆå¤±è´¥æƒ©ç½šï¼‰\n        for (const item of this.context.getContextBuffer().export()) {\n          if (item.importance && item.importance.useCount > 0) {\n            // ä»»åŠ¡å¤±è´¥ï¼Œå¢åŠ å¤±è´¥è®¡æ•°\n            item.importance.failureCount++;\n            item.importance.confidence = Math.max(0, item.importance.confidence - 0.1);\n            item.importance.lastUsed = Date.now();\n          }\n        }\n\n        // è®°å½• ContextBank ä½¿ç”¨æƒ…å†µï¼ˆå¤±è´¥ï¼‰\n        await this.context.recordBankUsage(false);\n\n        // è®°å½•æ‰§è¡Œå›åˆ\n        this.executionRecorder.recordTurn({ ...executionTurn, turnId: 0 } as any);\n\n        continue;\n      }\n\n      // æ›´æ–°executionTurn\n      executionTurn.governance = decision;\n\n      // === æ‰§è¡Œ ===\n      console.log(chalk.yellow(`[EXECUTING] âš™ï¸ ${action.type}...`));\n      const result = await ToolExecutor.execute(action as any);\n\n      // æ›´æ–°executionTurn\n      executionTurn.executionResult = result;\n      executionTurn.endTime = Date.now();\n\n      if (result.success) {\n        this.context.addToolResult(action.type, result.output);\n        const preview = result.output.length > 300\n          ? result.output.substring(0, 300) + '...'\n          : result.output;\n        console.log(chalk.green(`[SUCCESS] Result:\\n${preview}`));\n\n        // æ›´æ–°ContextBufferä¸­ç›¸å…³é¡¹çš„é‡è¦æ€§ï¼ˆæ ‡è®°ä¸ºè¢«ä½¿ç”¨ï¼‰\n        for (const item of this.context.getContextBuffer().export()) {\n          if (result.output.includes(item.path)) {\n            if (item.importance) {\n              item.importance.useCount++;\n              item.importance.lastUsed = Date.now();\n            }\n          }\n        }\n\n        // è®°å½• ContextBank ä½¿ç”¨æƒ…å†µï¼ˆæˆåŠŸï¼‰\n        await this.context.recordBankUsage(true);\n      } else {\n        this.context.addToolResult(action.type, `Error: ${result.error}`);\n        console.log(chalk.red(`[ERROR] ${result.error}`));\n\n        // è®°å½• ContextBank ä½¿ç”¨æƒ…å†µï¼ˆå¤±è´¥ï¼‰\n        await this.context.recordBankUsage(false);\n      }\n\n      // è®°å½•æ‰§è¡Œå›åˆ\n      this.executionRecorder.recordTurn({ ...executionTurn, turnId: 0 } as any);\n    }\n\n    if (turnCount >= maxTurns) {\n      console.log(chalk.red(`\\nâš ï¸ Max turns (${maxTurns}) reached.`));\n    }\n  }\n\n  getContextManager(): ContextManager {\n    return this.context;\n  }\n\n  /**\n   * è¯¢é—®ç”¨æˆ·æ˜¯å¦ç¡®è®¤åˆ›å»ºæŠ€èƒ½\n   */\n  private async confirmSkillCreation(skill: Skill): Promise<boolean> {\n    // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œå¯èƒ½ä¼šæœ‰æ›´å¤æ‚çš„ç¡®è®¤é€»è¾‘\n    // ç›®å‰è¿”å› true ä»¥è‡ªåŠ¨åˆ›å»ºæŠ€èƒ½\n    console.log(chalk.blue(`\\nğŸ“ Creating skill: ${skill.name}`));\n    return true; // è‡ªåŠ¨ç¡®è®¤ï¼Œå¯æ ¹æ®é…ç½®è°ƒæ•´\n  }\n\n  /**\n   * ä¿å­˜æŠ€èƒ½\n   */\n  private async saveSkill(skill: Skill): Promise<void> {\n    // å°†æŠ€èƒ½æ·»åŠ åˆ°æŠ€èƒ½åº“\n    const now = Date.now();\n    const skillToAdd = {\n      ...skill,\n      successCount: skill.metadata?.promotionCriteria?.successCount || 0,\n      failureCount: 0, // æ–°åˆ›å»ºçš„æŠ€èƒ½æ²¡æœ‰å¤±è´¥è®°å½•\n      confidence: skill.metadata?.promotionCriteria?.successRate || 0.5,\n      lastUsed: now,\n      createdAt: now,\n      enabled: true\n    };\n\n    // ä½¿ç”¨ addSkill å‡½æ•°æ·»åŠ æŠ€èƒ½\n    addSkill(skillToAdd);\n  }\n\n  /**\n   * æ‰§è¡Œå›åˆå›é¡¾åˆ†æ\n   */\n  private async retrospective(turn: ExecutionTurn) {\n    // å¯¼å‡ºé«˜ä»·å€¼ä¸Šä¸‹æ–‡åˆ° Context Bank\n    console.log(chalk.blue('\\n[Context Bank] Exporting high-value context...'));\n    try {\n      await this.context.exportToContextBank(process.cwd()); // ä½¿ç”¨å½“å‰å·¥ä½œç›®å½•ä½œä¸ºé¡¹ç›®ä½œç”¨åŸŸ\n      console.log(chalk.green('[Context Bank] High-value context exported'));\n    } catch (error) {\n      console.log(chalk.yellow(`[Context Bank] Could not export context: ${error}`));\n    }\n\n    // è¯„ä¼°ä¸Šä¸‹æ–‡æ™‹å‡\n    await this.evaluateContextPromotion();\n  }\n\n  /**\n   * è¯„ä¼°ä¸Šä¸‹æ–‡æ™‹å‡\n   */\n  private async evaluateContextPromotion() {\n    const contextItems = this.context.getContextBuffer().export();\n    for (const item of contextItems) {\n      const promotedSkill = ContextToSkillPromotionRules.evaluatePromotion(item);\n      if (promotedSkill) {\n        console.log(chalk.green(`\\nğŸš€ PROMOTION: Context \"${item.path}\" qualifies to be promoted to Skill \"${promotedSkill.name}\"`));\n        console.log(chalk.gray(`   Description: ${promotedSkill.description}`));\n\n        // è¯¢é—®ç”¨æˆ·æ˜¯å¦ç¡®è®¤åˆ›å»ºæŠ€èƒ½\n        const confirmed = await this.confirmSkillCreation(promotedSkill);\n        if (confirmed) {\n          try {\n            // é€šè¿‡æ²»ç†æœåŠ¡å®¡æ‰¹\n            const governanceDecision = await GovernanceService.adjudicate({\n              id: randomUUID(),\n              type: 'tool_call',\n              payload: {\n                tool_name: 'skill_create',\n                parameters: promotedSkill\n              },\n              riskLevel: 'low',\n              reasoning: 'Auto promotion from context'\n            });\n\n            if (governanceDecision.status === 'approved') {\n              // ä¿å­˜æŠ€èƒ½\n              await this.saveSkill(promotedSkill);\n              console.log(chalk.green(`âœ… Skill \"${promotedSkill.name}\" created successfully`));\n            } else {\n              console.log(chalk.yellow(`âš ï¸  Skill creation rejected by governance: ${'reason' in governanceDecision ? governanceDecision.reason : 'Unknown reason'}`));\n            }\n          } catch (error) {\n            console.log(chalk.red(`âŒ Failed to create skill: ${error}`));\n          }\n        }\n      }\n    }\n  }\n\n  getExecutionRecorder(): ExecutionRecorder {\n    return this.executionRecorder;\n  }\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/AgentRuntime.ts:1769101059020",
    "tokens": 3936,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/prompt.ts",
    "content": "import {\n    AgentIntent,\n    AgentContext,\n    AgentMode,\n    AgentPrompt,\n} from './types';\nimport { buildCommandPrompt as buildCommandPromptString } from '../ai/prompt';\nimport { getOSProfile } from '../core/os';\nimport { getMacros } from '../core/macros';\nimport { aiCommandPlanSchema } from '../core/validation';\nimport { getRelevantSkills } from './skills';\n\nexport function buildPrompt(\n    intent: AgentIntent,\n    context: AgentContext,\n    mode: AgentMode,\n    input: string\n): AgentPrompt {\n    if (mode === 'chat') {\n        return buildChatPrompt(context, input);\n    }\n\n    return buildCommandPromptObject(input, context);\n}\n\nfunction buildChatPrompt(\n    context: AgentContext,\n    input: string\n): AgentPrompt {\n    const messages: any[] = [\n        ...(context.history ?? []),\n    ];\n\n    // Add context files if available\n    if (context.files && context.files.length > 0) {\n        const contextDesc = context.files.map(f =>\n            `File: ${f.path}\\n\\`\\`\\`\\n${f.content}\\n\\`\\`\\``\n        ).join('\\n\\n');\n\n        messages.push({\n            role: 'system',\n            content: `Context:\\n${contextDesc}`,\n        });\n    }\n\n    messages.push({\n        role: 'user',\n        content: input,\n    });\n\n    return {\n        system: 'You are a helpful AI assistant with expertise in software development, system administration, and problem-solving.',\n        messages,\n    };\n}\n\nfunction buildCommandPromptObject(\n    input: string,\n    context: AgentContext\n): AgentPrompt {\n    const os = getOSProfile();\n    const macros = getMacros();\n    const skills = getRelevantSkills(input);\n    let promptText = buildCommandPromptString(input, os, macros);\n\n    if (skills.length > 0) {\n        const skillList = skills.map(s => `- ${s.name}: å½“é‡åˆ° \"${s.whenToUse}\" æ—¶ï¼Œä½ å¯ä»¥å‚è€ƒè®¡åˆ’: ${s.planTemplate.goal}`).join('\\n');\n        promptText = `ã€å‚è€ƒæŠ€èƒ½åº“ã€‘\\n${skillList}\\n\\n${promptText}`;\n    }\n\n    return {\n        messages: [\n            {\n                role: 'user',\n                content: promptText,\n            },\n        ],\n        outputSchema: aiCommandPlanSchema,\n    };\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/prompt.ts:1769101059020",
    "tokens": 522,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextSkillBridge.ts",
    "content": "import { ContextItem } from './contextBuffer';\nimport { Skill } from './skills';\nimport { ContextToSkillPromotionRules } from './contextSkillPromotion';\nimport { recordEdge } from './knowledgeGraph';\n\nexport interface ContextSkillHint {\n  source: 'context';\n  path: string;\n  suggestedSkillName: string;\n  confidence: number; // 0-1, how certain we are this should become a skill\n  usageCount: number; // how many times this context was used\n  lastUsed: number; // timestamp\n  description: string; // description of what this context enables\n}\n\n/**\n * åˆ†æContextItemsä»¥ç”ŸæˆSkillHints\n * å½“ContextItemè¢«é¢‘ç¹ä½¿ç”¨ä¸”ä¸æˆåŠŸä»»åŠ¡ç›¸å…³è”æ—¶ï¼Œå»ºè®®å°†å…¶è½¬æ¢ä¸ºSkill\n *\n * @param contextItems ContextItemæ•°ç»„\n * @returns ContextSkillHintæ•°ç»„\n */\nexport function generateSkillHintsFromContext(contextItems: ContextItem[]): ContextSkillHint[] {\n  const hints: ContextSkillHint[] = [];\n\n  for (const item of contextItems) {\n    // ä½¿ç”¨æ–°çš„æ™‹å‡è§„åˆ™æ¥è¯„ä¼°æ˜¯å¦åº”è¯¥æ™‹å‡ä¸ºæŠ€èƒ½\n    const promotedSkill = ContextToSkillPromotionRules.evaluatePromotion(item);\n\n    if (promotedSkill) {\n      // å¦‚æœç¬¦åˆæ™‹å‡æ¡ä»¶ï¼Œç”Ÿæˆæç¤º\n      const { useCount, successCount, lastUsed } = item.importance || {\n        useCount: 0,\n        successCount: 0,\n        lastUsed: Date.now()\n      };\n\n      hints.push({\n        source: 'context',\n        path: item.path,\n        suggestedSkillName: promotedSkill.name,\n        confidence: promotedSkill.metadata?.promotionCriteria?.successRate ||\n                   promotedSkill.metadata?.promotionCriteria?.importanceScore ||\n                   0.8, // é»˜è®¤é«˜ç½®ä¿¡åº¦\n        usageCount: useCount,\n        lastUsed,\n        description: promotedSkill.description\n      });\n\n      // === C5-B-1: Knowledge Graph Record (Context -> Skill Candidate) ===\n      if (item.id) {\n        recordEdge({\n            from: item.id,\n            to: `skill_candidate:${promotedSkill.name}`,\n            type: 'promoted_to',\n            timestamp: Date.now(),\n            meta: {\n                confidence: promotedSkill.confidence\n            }\n        });\n      }\n    } else {\n      // ä½¿ç”¨æ—§çš„é€»è¾‘ä½œä¸ºåå¤‡\n      if (item.importance) {\n        const { useCount, successCount, lastUsed } = item.importance;\n\n        // å¦‚æœä½¿ç”¨æ¬¡æ•°è¶…è¿‡é˜ˆå€¼ï¼Œä¸”æœ‰ä¸€å®šæˆåŠŸç‡ï¼Œç”ŸæˆSkillå»ºè®®\n        if (useCount >= 3 && successCount > 0) {\n          const successRate = successCount / useCount;\n          const daysSinceLastUse = (Date.now() - lastUsed) / (1000 * 60 * 60 * 24);\n\n          // è®¡ç®—å»ºè®®çš„ç½®ä¿¡åº¦\n          const confidence = Math.min(1,\n            (successRate * 0.6) +  // æˆåŠŸç‡æƒé‡\n            (Math.min(1, useCount / 10) * 0.3) +  // ä½¿ç”¨é¢‘ç‡æƒé‡\n            (Math.max(0, (7 - daysSinceLastUse) / 7) * 0.1)  // æ–°é²œåº¦æƒé‡\n          );\n\n          if (confidence > 0.5) { // åªæœ‰ç½®ä¿¡åº¦è¶…è¿‡0.5æ‰ç”Ÿæˆå»ºè®®\n            hints.push({\n              source: 'context',\n              path: item.path,\n              suggestedSkillName: generateSkillNameFromPath(item.path),\n              confidence,\n              usageCount: useCount,\n              lastUsed,\n              description: `Frequently used context from ${item.path} that contributed to ${successCount} successful tasks`\n            });\n          }\n        }\n      }\n    }\n  }\n\n  return hints;\n}\n\n/**\n * ä»è·¯å¾„ç”ŸæˆSkillåç§°\n * @param path æ–‡ä»¶è·¯å¾„\n * @returns å»ºè®®çš„Skillåç§°\n */\nfunction generateSkillNameFromPath(path: string): string {\n  // ç§»é™¤æ–‡ä»¶æ‰©å±•åå¹¶ä½¿ç”¨é©¼å³°å‘½å\n  const basename = path.split('/').pop()?.split('.')[0] || path;\n  return basename\n    .split(/[^a-zA-Z0-9]/)  // æŒ‰éå­—æ¯æ•°å­—å­—ç¬¦åˆ†å‰²\n    .map((part, index) =>\n      index === 0\n        ? part.toLowerCase()\n        : part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()\n    )\n    .join('');\n}\n\n/**\n * å°†ContextItemç›´æ¥æ™‹å‡ä¸ºSkill\n * @param contextItem è¦æ™‹å‡çš„ContextItem\n * @returns æ™‹å‡åçš„Skillï¼Œå¦‚æœä¸ç¬¦åˆæ¡ä»¶åˆ™è¿”å›null\n */\nexport function promoteContextToSkill(contextItem: ContextItem): Skill | null {\n  return ContextToSkillPromotionRules.evaluatePromotion(contextItem);\n}\n\n/**\n * å°†ContextSkillHintsè½¬æ¢ä¸ºå¯æ˜¾ç¤ºçš„æ–‡æœ¬\n * @param hints ContextSkillHintæ•°ç»„\n * @returns æ ¼å¼åŒ–çš„å­—ç¬¦ä¸²\n */\nexport function formatSkillHints(hints: ContextSkillHint[]): string {\n  if (hints.length === 0) {\n    return \"No skill suggestions generated from context.\";\n  }\n\n  const lines: string[] = [\"Skill Suggestions from Context:\", \"\"];\n\n  for (const hint of hints) {\n    lines.push(`- ${hint.suggestedSkillName} (confidence: ${(hint.confidence * 100).toFixed(1)}%)`);\n    lines.push(`  Path: ${hint.path}`);\n    lines.push(`  Usage: ${hint.usageCount}, Last used: ${new Date(hint.lastUsed).toLocaleDateString()}`);\n    lines.push(`  Description: ${hint.description}`);\n    lines.push(\"\");\n  }\n\n  return lines.join(\"\\n\");\n}",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/contextSkillBridge.ts:1769101059020",
    "tokens": 1127,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/context.ts",
    "content": "import { AgentInput, AgentContext } from './types';\nimport { ContextBuffer } from './contextBuffer';\nimport { ExtendedContextProtocol } from './contextDSL';\nimport { computeContextImportance } from './contextImportance';\n\nexport function buildContext(input: AgentInput, contextBuffer: ContextBuffer): AgentContext {\n    // åŒæ­¥è·å–æ‰€æœ‰ä¸Šä¸‹æ–‡é¡¹\n    const items = contextBuffer.export();\n\n    return {\n        files: items.map(item => ({\n            path: item.path,\n            content: item.content,\n        })),\n        gitDiff: undefined, // Will be enhanced later\n        history: [], // Will be populated from conversation history\n        contextItems: items,\n        totalTokens: items.reduce((sum, item) => sum + item.tokens, 0),\n        highConfidenceItems: items.filter(item =>\n            item.importance && computeContextImportance(item.importance) > 0.7\n        ),\n        mediumConfidenceItems: items.filter(item =>\n            item.importance &&\n            computeContextImportance(item.importance) > 0.3 &&\n            computeContextImportance(item.importance) <= 0.7\n        ),\n        lowConfidenceItems: items.filter(item =>\n            !item.importance || computeContextImportance(item.importance) <= 0.3\n        )\n    };\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/context.ts:1769101059020",
    "tokens": 309,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextProtocol.ts",
    "content": "import { ContextBuffer, ContextItem } from './contextBuffer';\nimport { randomUUID } from 'crypto';\nimport { ExtendedContextProtocol } from './contextDSL';\n\n/**\n * Contextå¼•ç”¨åè®®v1å®ç°\n * å®šä¹‰äº†ContextItemå¦‚ä½•è¢«æ˜¾å¼å¼•ç”¨ã€ç®¡ç†å’Œæ³¨å…¥çš„åè®®\n */\n\nexport interface ContextReference {\n  path: string;\n  alias?: string;\n  lineRange?: { start: number; end?: number };\n  timestamp: number;\n  responseId?: string;\n}\n\nexport interface ContextProtocolResult {\n  referencedItems: ContextReference[];\n  extractedContent: string;\n  isValid: boolean;\n  errors: string[];\n}\n\n/**\n * è§£æAIå“åº”ä¸­çš„Contextå¼•ç”¨\n * @param response AIçš„å“åº”å†…å®¹\n * @returns è§£æå‡ºçš„Contextå¼•ç”¨ä¿¡æ¯\n */\nexport function parseContextReferences(response: string): ContextProtocolResult {\n  const result: ContextProtocolResult = {\n    referencedItems: [],\n    extractedContent: response,\n    isValid: true,\n    errors: []\n  };\n\n  // åŒ¹é…æ˜¾å¼å¼•ç”¨æ ¼å¼ï¼Œå¦‚ [Reference] file: path/to/file.ts (path/to/file.ts) æˆ–ç±»ä¼¼æ ¼å¼\n  const referenceRegex = /\\[Reference\\]\\s+([^:\\s]+):\\s*([^(]+?)\\s*\\(([^)]+)\\)/g;\n  let match;\n\n  while ((match = referenceRegex.exec(response)) !== null) {\n    const [, type, description, path] = match;\n\n    const reference: ContextReference = {\n      path: path.trim(),\n      timestamp: Date.now()\n    };\n\n    result.referencedItems.push(reference);\n  }\n\n  // åŒ¹é… DSL æŸ¥è¯¢è¯­æ³• (ä¾‹å¦‚: type:file importance:>0.5)\n  const dslRegex = /[@#][^{}`]+|\"[^\"]*\"|'[^']*'|[a-z_]+:[^\\\\s]+/gi;\n  let dslMatch;\n  while ((dslMatch = dslRegex.exec(response)) !== null) {\n    const dslPart = dslMatch[0];\n\n    // æ£€æŸ¥æ˜¯å¦æ˜¯ DSL æŸ¥è¯¢è¯­æ³• (åŒ…å«å†’å·ä¸”ä¸æ˜¯æ–‡ä»¶è·¯å¾„)\n    if (dslPart.includes(':') && !dslPart.startsWith('/') && !dslPart.includes('.')) {\n      // è¿™å¯èƒ½æ˜¯ DSL æŸ¥è¯¢çš„ä¸€éƒ¨åˆ†ï¼Œæš‚æ—¶è·³è¿‡ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦å®Œæ•´çš„æŸ¥è¯¢\n      continue;\n    }\n\n    // æ£€æŸ¥æ˜¯å¦æ˜¯è·¯å¾„å¼•ç”¨ (@file æˆ– #dir)\n    if (dslPart.startsWith('@') || dslPart.startsWith('#')) {\n      const path = dslPart.substring(1);\n      if (!result.referencedItems.some(ref => ref.path === path)) {\n        result.referencedItems.push({\n          path,\n          timestamp: Date.now()\n        });\n      }\n    }\n  }\n\n  // ä¹Ÿå¯ä»¥åŒ¹é…JSONæ ¼å¼çš„å¼•ç”¨ï¼ˆå¦‚æœAIè¾“å‡ºéµå¾ªç‰¹å®šæ ¼å¼ï¼‰\n  try {\n    // å°è¯•æŸ¥æ‰¾JSONå—ä¸­çš„å¼•ç”¨ä¿¡æ¯\n    const jsonMatch = response.match(/```json\\n([\\s\\S]*?)\\n```/);\n    if (jsonMatch) {\n      const jsonData = JSON.parse(jsonMatch[1]);\n\n      // å¦‚æœJSONä¸­åŒ…å«used_contextå­—æ®µ\n      if (jsonData.used_context && Array.isArray(jsonData.used_context)) {\n        for (const path of jsonData.used_context) {\n          if (!result.referencedItems.some(ref => ref.path === path)) {\n            result.referencedItems.push({\n              path,\n              timestamp: Date.now()\n            });\n          }\n        }\n      }\n    }\n  } catch (e) {\n    // å¦‚æœJSONè§£æå¤±è´¥ï¼Œç»§ç»­å¤„ç†\n  }\n\n  return result;\n}\n\n/**\n * éªŒè¯Contextå¼•ç”¨çš„æœ‰æ•ˆæ€§\n * @param references Contextå¼•ç”¨åˆ—è¡¨\n * @param availableItems å¯ç”¨çš„ContextItemåˆ—è¡¨\n * @returns éªŒè¯ç»“æœ\n */\nexport function validateContextReferences(references: ContextReference[], availableItems: ContextItem[]): {\n  valid: ContextReference[];\n  invalid: ContextReference[];\n  warnings: string[];\n} {\n  const valid: ContextReference[] = [];\n  const invalid: ContextReference[] = [];\n  const warnings: string[] = [];\n\n  for (const ref of references) {\n    const foundItem = availableItems.find(item => \n      item.path === ref.path || \n      (item.alias && item.alias === ref.path)\n    );\n\n    if (foundItem) {\n      valid.push(ref);\n    } else {\n      invalid.push(ref);\n      warnings.push(`Context item not found: ${ref.path}`);\n    }\n  }\n\n  return { valid, invalid, warnings };\n}\n\n/**\n * æ ¹æ®å¼•ç”¨åè®®æ„å»ºä¸Šä¸‹æ–‡æç¤º\n * @param contextBuffer ContextBufferå®ä¾‹\n * @param userInput ç”¨æˆ·è¾“å…¥\n * @param referencedPaths æ˜¾å¼å¼•ç”¨çš„è·¯å¾„åˆ—è¡¨\n * @returns æ„å»ºçš„æç¤ºå­—ç¬¦ä¸²\n */\nexport async function buildContextPromptWithReferences(\n  contextBuffer: ContextBuffer,\n  userInput: string,\n  referencedPaths?: string[]\n): Promise<string> {\n  // é¦–å…ˆæ£€æŸ¥ç”¨æˆ·è¾“å…¥æ˜¯å¦åŒ…å« DSL æŸ¥è¯¢\n  const dslContextItems = await contextBuffer.getDSLContextForInput(userInput);\n\n  let filteredItems: ContextItem[];\n\n  if (dslContextItems.length > 0) {\n    // å¦‚æœæœ‰ DSL æŸ¥è¯¢ç»“æœï¼Œä½¿ç”¨ DSL ç»“æœ\n    filteredItems = dslContextItems;\n  } else if (referencedPaths && referencedPaths.length > 0) {\n    // å¦‚æœæä¾›äº†æ˜¾å¼å¼•ç”¨è·¯å¾„ï¼Œä¼˜å…ˆå¤„ç†è¿™äº›é¡¹\n    const allItems = contextBuffer.export();\n    filteredItems = allItems.filter(item =>\n      referencedPaths.includes(item.path) ||\n      (item.alias && referencedPaths.includes(item.alias))\n    );\n  } else {\n    // å¦åˆ™ä½¿ç”¨æ‰€æœ‰å¯ç”¨é¡¹\n    filteredItems = contextBuffer.export();\n  }\n\n  // æŒ‰é‡è¦æ€§åˆ†ç»„\n  const highConfidenceItems = filteredItems.filter(item =>\n    item.importance && computeContextImportance(item.importance) > 0.7\n  );\n  const mediumConfidenceItems = filteredItems.filter(item =>\n    item.importance &&\n    computeContextImportance(item.importance) > 0.3 &&\n    computeContextImportance(item.importance) <= 0.7\n  );\n  const lowConfidenceItems = filteredItems.filter(item =>\n    !item.importance || computeContextImportance(item.importance) <= 0.3\n  );\n\n  // æ„å»ºä¸åŒéƒ¨åˆ†çš„ä¸Šä¸‹æ–‡\n  const sections = [];\n\n  if (highConfidenceItems.length > 0) {\n    // æŒ‰è¯­ä¹‰ç±»å‹è¿›ä¸€æ­¥ç»†åˆ†é«˜ç½®ä¿¡åº¦é¡¹\n    const semanticGroups: Record<string, typeof highConfidenceItems> = {};\n    for (const item of highConfidenceItems) {\n      const semantic = item.semantic || 'other';\n      if (!semanticGroups[semantic]) {\n        semanticGroups[semantic] = [];\n      }\n      semanticGroups[semantic].push(item);\n    }\n\n    for (const [semantic, items] of Object.entries(semanticGroups)) {\n      const semanticBlock = items.map(item => {\n        const title = item.alias\n          ? `[Reference] ${item.type}: ${item.alias} (${item.path})`\n          : `[Reference] ${item.type}: ${item.path}`;\n\n        const body = item.summary ?? item.content;\n\n        return `${title}\\n---\\n${body}\\n---`;\n      }).join('\\n\\n');\n\n      sections.push(`# Background Knowledge (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - High Confidence)\\n${semanticBlock}`);\n    }\n  }\n\n  if (mediumConfidenceItems.length > 0) {\n    // æŒ‰è¯­ä¹‰ç±»å‹è¿›ä¸€æ­¥ç»†åˆ†ä¸­ç½®ä¿¡åº¦é¡¹\n    const semanticGroups: Record<string, typeof mediumConfidenceItems> = {};\n    for (const item of mediumConfidenceItems) {\n      const semantic = item.semantic || 'other';\n      if (!semanticGroups[semantic]) {\n        semanticGroups[semantic] = [];\n      }\n      semanticGroups[semantic].push(item);\n    }\n\n    for (const [semantic, items] of Object.entries(semanticGroups)) {\n      const semanticBlock = items.map(item => {\n        const title = item.alias\n          ? `[Reference] ${item.type}: ${item.alias} (${item.path})`\n          : `[Reference] ${item.type}: ${item.path}`;\n\n        const body = item.summary ?? item.content;\n\n        return `${title}\\n---\\n${body}\\n---`;\n      }).join('\\n\\n');\n\n      sections.push(`# Supporting Information (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - Medium Confidence)\\n${semanticBlock}`);\n    }\n  }\n\n  if (lowConfidenceItems.length > 0) {\n    // æŒ‰è¯­ä¹‰ç±»å‹è¿›ä¸€æ­¥ç»†åˆ†ä½ç½®ä¿¡åº¦é¡¹\n    const semanticGroups: Record<string, typeof lowConfidenceItems> = {};\n    for (const item of lowConfidenceItems) {\n      const semantic = item.semantic || 'other';\n      if (!semanticGroups[semantic]) {\n        semanticGroups[semantic] = [];\n      }\n      semanticGroups[semantic].push(item);\n    }\n\n    for (const [semantic, items] of Object.entries(semanticGroups)) {\n      const semanticBlock = items.map(item => {\n        const title = item.alias\n          ? `[Reference] ${item.type}: ${item.alias} (${item.path})`\n          : `[Reference] ${item.type}: ${item.path}`;\n\n        const body = item.summary ?? item.content;\n\n        return `${title}\\n---\\n${body}\\n---`;\n      }).join('\\n\\n');\n\n      sections.push(`# Archived References (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - Low Confidence)\\n${semanticBlock}`);\n    }\n  }\n\n  const contextBlock = sections.join('\\n\\n');\n\n  return `\n${contextBlock}\n\n# Task Instructions\nBased on the provided context (if any), answer the user's question. If the context contains source code, treat it as your \"source of truth.\"\n\nUser Question:\n${userInput}\n`;\n}\n\n/**\n * éªŒè¯Contextå¼•ç”¨çš„æœ‰æ•ˆæ€§\n * @param responseId å“åº”ID\n * @param expectedPaths æœŸæœ›è¢«å¼•ç”¨çš„è·¯å¾„\n * @param actualReferences å®é™…å¼•ç”¨çš„è·¯å¾„\n * @returns éªŒè¯ç»“æœ\n */\nexport function validateResponseReferences(\n  responseId: string,\n  expectedPaths: string[],\n  actualReferences: ContextReference[]\n): {\n  success: boolean;\n  matched: string[];\n  missing: string[];\n  extra: string[];\n  accuracy: number; // 0-1, å¼•ç”¨å‡†ç¡®ç‡\n} {\n  const actualPaths = actualReferences.map(ref => ref.path);\n  const matched = expectedPaths.filter(path => actualPaths.includes(path));\n  const missing = expectedPaths.filter(path => !actualPaths.includes(path));\n  const extra = actualPaths.filter(path => !expectedPaths.includes(path));\n\n  const totalExpected = expectedPaths.length;\n  const totalActual = actualReferences.length;\n  const correctlyReferenced = matched.length;\n\n  // è®¡ç®—å‡†ç¡®ç‡ï¼šè€ƒè™‘æ­£ç¡®å¼•ç”¨å’Œé¢å¤–å¼•ç”¨çš„å¹³è¡¡\n  const accuracy = totalExpected > 0\n    ? correctlyReferenced / totalExpected  // æŸ¥å…¨ç‡\n    : (totalActual - extra.length) / Math.max(totalActual, 1); // å¦‚æœæ²¡æœ‰é¢„æœŸå¼•ç”¨ï¼Œåˆ™çœ‹æœ‰å¤šå°‘æ˜¯ç›¸å…³çš„\n\n  return {\n    success: missing.length === 0 && extra.length <= Math.floor(expectedPaths.length * 0.2), // å…è®¸æœ€å¤š20%çš„é¢å¤–å¼•ç”¨\n    matched,\n    missing,\n    extra,\n    accuracy\n  };\n}\n\n/**\n * ç”ŸæˆContextå¼•ç”¨å›æº¯æŠ¥å‘Š\n * @param contextBuffer ContextBufferå®ä¾‹\n * @param responseId å“åº”ID\n * @param userInput ç”¨æˆ·è¾“å…¥\n * @param response AIå“åº”\n * @returns å›æº¯æŠ¥å‘Š\n */\nexport async function generateReferenceRetrospective(\n  contextBuffer: ContextBuffer,\n  responseId: string,\n  userInput: string,\n  response: string\n): Promise<string> {\n  const allItems = contextBuffer.export();\n  const references = parseContextReferences(response);\n\n  // ç»Ÿè®¡å¼•ç”¨æƒ…å†µ\n  const referencedItems = allItems.filter(item =>\n    references.referencedItems.some(ref => ref.path === item.path)\n  );\n\n  // éªŒè¯å¼•ç”¨çš„æœ‰æ•ˆæ€§\n  const validation = validateContextReferences(\n    references.referencedItems,\n    allItems\n  );\n\n  // è®¡ç®—å¼•ç”¨ç»Ÿè®¡\n  const stats = {\n    totalContextItems: allItems.length,\n    referencedItemsCount: referencedItems.length,\n    validReferences: validation.valid.length,\n    invalidReferences: validation.invalid.length,\n    referenceAccuracy: allItems.length > 0\n      ? validation.valid.length / (validation.valid.length + validation.invalid.length || 1)\n      : 0\n  };\n\n  // ç”ŸæˆæŠ¥å‘Š\n  const reportLines = [\n    '# Context Reference Retrospective Report',\n    '',\n    '## Query',\n    userInput,\n    '',\n    '## Statistics',\n    `- Total Context Items: ${stats.totalContextItems}`,\n    `- Referenced Items: ${stats.referencedItemsCount}`,\n    `- Valid References: ${stats.validReferences}`,\n    `- Invalid References: ${stats.invalidReferences}`,\n    `- Reference Accuracy: ${(stats.referenceAccuracy * 100).toFixed(2)}%`,\n    '',\n    '## Referenced Context Items',\n    ...(referencedItems.length > 0\n      ? referencedItems.map(item => `- ${item.path} (${item.type})`)\n      : ['None']),\n    '',\n    '## Invalid References',\n    ...(validation.invalid.length > 0\n      ? validation.invalid.map(ref => `- ${ref.path}`)\n      : ['None']),\n    '',\n    '## Response Excerpt',\n    response.length > 200\n      ? response.substring(0, 200) + '...'\n      : response\n  ];\n\n  return reportLines.join('\\n');\n}\n\n/**\n * åˆ†æContextItemçš„ç”Ÿå‘½å‘¨æœŸå’Œæ¼”å˜\n * @param contextBuffer ContextBufferå®ä¾‹\n * @returns ContextItemç”Ÿå‘½å‘¨æœŸåˆ†æ\n */\nexport function analyzeContextLifecycle(\n  contextBuffer: ContextBuffer\n): Array<{\n  path: string;\n  usageTrend: number; // ä½¿ç”¨è¶‹åŠ¿ (-1 to 1)\n  qualityScore: number; // è´¨é‡è¯„åˆ† (0 to 1)\n  relevanceScore: number; // ç›¸å…³æ€§è¯„åˆ† (0 to 1)\n  recommendation: 'keep' | 'archive' | 'remove' | 'enhance';\n}> {\n  const items = contextBuffer.export();\n\n  return items.map(item => {\n    // è®¡ç®—ä½¿ç”¨è¶‹åŠ¿ (åŸºäºuseCountå’Œæ—¶é—´)\n    const now = Date.now();\n    const daysSinceCreated = (now - (item.importance?.createdAt || now)) / (1000 * 60 * 60 * 24);\n    const avgUsesPerDay = item.importance ? item.importance.useCount / (daysSinceCreated || 1) : 0;\n\n    // ä½¿ç”¨è¶‹åŠ¿ï¼šæ­£å€¼è¡¨ç¤ºä½¿ç”¨é¢‘ç‡å¢åŠ ï¼Œè´Ÿå€¼è¡¨ç¤ºå‡å°‘\n    const usageTrend = avgUsesPerDay > 0.5 ? 1 : (avgUsesPerDay > 0.1 ? 0.5 : 0);\n\n    // è´¨é‡è¯„åˆ†ï¼šç»“åˆæ˜¾å¼å¼•ç”¨å’ŒéªŒè¯ç»“æœ\n    const qualityScore = item.usageStats\n      ? (item.usageStats.verifiedUseful + 1) /\n        (item.usageStats.verifiedUseful + item.usageStats.verifiedNotUseful + 2)\n      : 0.5; // é»˜è®¤ä¸­ç­‰è¯„åˆ†\n\n    // ç›¸å…³æ€§è¯„åˆ†ï¼šç»“åˆé‡è¦æ€§åˆ†æ•°å’Œæ˜¾å¼å¼•ç”¨æ¬¡æ•°\n    const relevanceScore = item.importance\n      ? (computeContextImportance(item.importance) +\n         (item.usageStats ? Math.min(1, item.usageStats.referencedCount / 10) : 0)) / 2\n      : 0.5;\n\n    // ç”Ÿæˆæ¨è\n    let recommendation: 'keep' | 'archive' | 'remove' | 'enhance' = 'keep';\n    if (relevanceScore < 0.2 && qualityScore < 0.3) {\n      recommendation = 'remove';\n    } else if (relevanceScore < 0.4 && qualityScore < 0.5) {\n      recommendation = 'archive';\n    } else if (relevanceScore > 0.7 && qualityScore > 0.8) {\n      recommendation = 'enhance'; // é«˜ä»·å€¼ï¼Œå»ºè®®å¢å¼º\n    }\n\n    return {\n      path: item.path,\n      usageTrend,\n      qualityScore,\n      relevanceScore,\n      recommendation\n    };\n  });\n}\n\n// å¯¼å…¥å¿…è¦çš„å‡½æ•°\nimport { computeContextImportance } from './contextImportance';",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/contextProtocol.ts:1769101059020",
    "tokens": 3238,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/types.ts",
    "content": "import type { AIRequestMessage } from '../core/validation';\n// import { AgentPlan } from './plan';\n\nexport type AgentMode = 'chat' | 'command' | 'command+exec';\n\nexport interface AgentInput {\n    rawInput: string;\n    stdin?: string;\n    context?: AgentContext;\n    options?: {\n        model?: string;\n        stream?: boolean;\n        autoYes?: boolean;\n        verbose?: boolean;\n    };\n}\n\nexport interface AgentContext {\n    files?: Array<{ path: string; content: string }>;\n    gitDiff?: string;\n    history?: AIRequestMessage[];\n    contextItems?: import('./contextBuffer').ContextItem[];\n    totalTokens?: number;\n    highConfidenceItems?: import('./contextBuffer').ContextItem[];\n    mediumConfidenceItems?: import('./contextBuffer').ContextItem[];\n    lowConfidenceItems?: import('./contextBuffer').ContextItem[];\n}\n\nexport interface AgentIntent {\n    type: 'chat' | 'shell' | 'analysis';\n    capabilities: {\n        reasoning?: boolean;\n        code?: boolean;\n        longContext?: boolean;\n        streaming?: boolean;\n    };\n}\n\nexport interface AgentPrompt {\n    system?: string;\n    messages: AIRequestMessage[];\n    outputSchema?: any;\n}\n\nexport interface LLMResult {\n    rawText: string;\n    parsed?: any;\n    plan?: any;\n    latencyMs: number;\n    tokens?: {\n        prompt: number;\n        completion: number;\n        total: number;\n    };\n    costUsd?: number;\n}\n\nexport type AgentAction =\n    | { type: 'print'; content: string }\n    | { type: 'confirm'; next: AgentAction }\n    | { type: 'execute'; command: string; risk: 'low' | 'medium' | 'high' };\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/types.ts:1769101059020",
    "tokens": 393,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/knowledgeGraph.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\n\nexport type KGNodeType = 'context' | 'execution' | 'skill';\n\nexport type KGEdgeType =\n  | 'used_in'        // Context -> Execution\n  | 'validated_by'   // Execution -> Skill\n  | 'promoted_to'    // Context -> Skill\n  | 'derived_from';  // Skill -> Context (optional)\n\nexport interface KnowledgeGraphEdge {\n  from: string;\n  to: string;\n  type: KGEdgeType;\n  timestamp: number;\n  meta?: Record<string, any>;\n}\n\nconst KG_DIR = path.join(os.homedir(), '.yuangs', 'knowledge');\nconst KG_FILE = path.join(KG_DIR, 'graph.jsonl');\n\nfunction ensureDir() {\n  if (!fs.existsSync(KG_DIR)) {\n    fs.mkdirSync(KG_DIR, { recursive: true });\n  }\n}\n\n/**\n * è®°å½•ä¸€æ¡ä¸å¯å˜çš„çŸ¥è¯†å›¾è°±è¾¹ (Append-only Fact)\n */\nexport function recordEdge(edge: KnowledgeGraphEdge) {\n  try {\n    ensureDir();\n    // ç®€å•çš„ JSONL æ ¼å¼ï¼šä¸€è¡Œä¸€ä¸ª JSON å¯¹è±¡\n    const line = JSON.stringify({\n        ...edge,\n        // ç¡®ä¿ timestamp å­˜åœ¨\n        timestamp: edge.timestamp || Date.now()\n    });\n    \n    fs.appendFileSync(KG_FILE, line + '\\n', 'utf8');\n  } catch (error) {\n    // å®¹é”™ï¼šKG è®°å½•å¤±è´¥ä¸åº”é˜»æ–­ä¸»æµç¨‹\n    console.warn('[KnowledgeGraph] Failed to record edge:', error);\n  }\n  // NOTE: sync write is acceptable at current scale (<100 edges / run)\n}",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/knowledgeGraph.ts:1769101059020",
    "tokens": 311,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/llm.ts",
    "content": "import { AgentPrompt, LLMResult } from './types';\nimport { callAI_Stream } from '../ai/client';\nimport axios from 'axios';\nimport { DEFAULT_AI_PROXY_URL, DEFAULT_MODEL, DEFAULT_ACCOUNT_TYPE, type AIRequestMessage } from '../core/validation';\nimport fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { safeParseJSON } from '../core/validation';\n\nconst CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');\n\nfunction getUserConfig(): any {\n    if (fs.existsSync(CONFIG_FILE)) {\n        try {\n            const content = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(content);\n        } catch (e) { }\n    }\n    return {};\n}\n\nexport async function runLLM({\n    prompt,\n    model,\n    stream,\n    onChunk,\n}: {\n    prompt: AgentPrompt;\n    model: string;\n    stream: boolean;\n    onChunk?: (s: string) => void;\n}): Promise<LLMResult> {\n    const start = Date.now();\n\n    if (stream) {\n        let raw = '';\n        let buffer = '';\n        let lastFlush = Date.now();\n\n        await callAI_Stream(prompt.messages, model, (chunk) => {\n            raw += chunk;\n            buffer += chunk;\n\n            // èŠ‚æµï¼šæ¯50msæœ€å¤šè§¦å‘ä¸€æ¬¡onChunkï¼Œçº¦20FPS\n            if (Date.now() - lastFlush > 50) {\n                onChunk?.(buffer);\n                buffer = '';\n                lastFlush = Date.now();\n            }\n        });\n\n        // ç¡®ä¿æœ€åçš„ç¼“å†²åŒºå†…å®¹ä¹Ÿè¢«å‘é€\n        if (buffer) {\n            onChunk?.(buffer);\n        }\n\n        return {\n            rawText: raw,\n            latencyMs: Date.now() - start,\n        };\n    }\n\n    // Non-streaming mode with optional schema\n    const config = getUserConfig();\n    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;\n\n    const headers = {\n        'Content-Type': 'application/json',\n        'X-Client-ID': 'vscode',\n        'Origin': 'https://cli.want.biz',\n        'Referer': 'https://cli.want.biz/',\n        'account': config.accountType || DEFAULT_ACCOUNT_TYPE,\n        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',\n        'Accept': 'application/json'\n    };\n\n    const data = {\n        model: model || config.defaultModel || DEFAULT_MODEL,\n        messages: prompt.messages,\n        stream: false\n    };\n\n    try {\n        const response = await axios.post(url, data, { headers });\n        const rawText = response.data.choices[0]?.message?.content || '';\n\n        let parsed = undefined;\n        if (prompt.outputSchema) {\n            const parseResult = safeParseJSON(rawText, prompt.outputSchema, {});\n            if (parseResult.success) {\n                parsed = parseResult.data;\n            }\n        }\n\n        return {\n            rawText,\n            parsed,\n            latencyMs: Date.now() - start,\n        };\n    } catch (error: any) {\n        const errorMsg = error.response?.data?.error?.message || error.response?.data?.message || error.message || 'æœªçŸ¥é”™è¯¯';\n        throw new Error(`AI è¯·æ±‚å¤±è´¥: ${errorMsg}`);\n    }\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/llm.ts:1769101059020",
    "tokens": 753,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/executionRecorder.ts",
    "content": "import { ExecutionTurn } from './state';\nimport { ContextDiff } from './contextDiff';\n\nexport class ExecutionRecorder {\n  private turns: ExecutionTurn[] = [];\n  private turnCounter = 0;\n\n  recordTurn(turn: Omit<ExecutionTurn, 'turnId'>): ExecutionTurn {\n    const executionTurn: ExecutionTurn = {\n      ...turn,\n      turnId: ++this.turnCounter\n    };\n\n    this.turns.push(executionTurn);\n    return executionTurn;\n  }\n\n  getTurns(): ExecutionTurn[] {\n    return [...this.turns];\n  }\n\n  clear(): void {\n    this.turns = [];\n    this.turnCounter = 0;\n  }\n\n  getSummary(): {\n    totalTurns: number;\n    totalAddedContext: number;\n    totalRemovedContext: number;\n    totalChangedContext: number;\n  } {\n    return {\n      totalTurns: this.turns.length,\n      totalAddedContext: this.turns.reduce((sum, turn) => \n        sum + (turn.contextDiff?.added.length || 0), 0),\n      totalRemovedContext: this.turns.reduce((sum, turn) => \n        sum + (turn.contextDiff?.removed.length || 0), 0),\n      totalChangedContext: this.turns.reduce((sum, turn) => \n        sum + (turn.contextDiff?.changed.length || 0), 0)\n    };\n  }\n}",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/executionRecorder.ts:1769101059020",
    "tokens": 280,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextStorage.ts",
    "content": "import fs from 'fs/promises';\nimport path from 'path';\nimport { ContextItem } from './contextBuffer';\n\nconst CONTEXT_DIR = path.resolve(process.cwd(), '.ai');\nconst CONTEXT_FILE = path.join(CONTEXT_DIR, 'context.json');\n\nexport async function loadContext(): Promise<ContextItem[]> {\n    try {\n        const raw = await fs.readFile(CONTEXT_FILE, 'utf-8');\n        return JSON.parse(raw);\n    } catch {\n        return [];\n    }\n}\n\nexport async function saveContext(items: ContextItem[]) {\n    await fs.mkdir(CONTEXT_DIR, { recursive: true });\n    await fs.writeFile(CONTEXT_FILE, JSON.stringify(items, null, 2));\n}\n\nexport async function clearContextStorage() {\n    await fs.rm(CONTEXT_FILE, { force: true });\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/contextStorage.ts:1769101059020",
    "tokens": 178,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/actions.ts",
    "content": "import { AgentAction } from './types';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport chalk from 'chalk';\nimport readline from 'readline';\n\nconst execAsync = promisify(exec);\n\nexport async function executeAction(\n    action: AgentAction,\n    options?: { autoYes?: boolean }\n): Promise<void> {\n    if (action.type === 'print') {\n        console.log(action.content);\n        return;\n    }\n\n    if (action.type === 'confirm') {\n        const ok = options?.autoYes || await confirm('Execute this action?');\n        if (ok) {\n            await executeAction(action.next, options);\n        }\n        return;\n    }\n\n    if (action.type === 'execute') {\n        try {\n            console.log(chalk.cyan(`\\nExecuting: ${action.command}\\n`));\n            const { stdout, stderr } = await execAsync(action.command, {\n                shell: typeof process.env.SHELL === 'string' ? process.env.SHELL : undefined\n            });\n            if (stdout) console.log(stdout);\n            if (stderr) console.error(chalk.yellow(stderr));\n        } catch (error: any) {\n            console.error(chalk.red(`Execution failed: ${error.message}`));\n            throw error;\n        }\n    }\n}\n\nasync function confirm(message: string): Promise<boolean> {\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout,\n    });\n\n    return new Promise((resolve) => {\n        rl.question(chalk.cyan(`${message} (y/N): `), (answer) => {\n            rl.close();\n            resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');\n        });\n    });\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/actions.ts:1769101059020",
    "tokens": 404,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextImportance.ts",
    "content": "import { randomUUID } from 'crypto';\n\nexport interface ContextImportance {\n  id: string;              // stable id\n  path: string;            // file / dir path\n  type: 'file' | 'directory';\n\n  // === Usage stats ===\n  useCount: number;\n  successCount: number;\n  failureCount: number;\n\n  // === Time ===\n  lastUsed: number;\n  createdAt: number;\n\n  // === Learned weight ===\n  confidence: number;      // 0 ~ 1, init 0.5\n}\n\n/**\n * è®¡ç®—ä¸Šä¸‹æ–‡é‡è¦æ€§åˆ†æ•°\n * è¯„åˆ†å…¬å¼ä¸Skillç³»ç»Ÿä¿æŒä¸€è‡´\n * @param ctx ContextImportanceå¯¹è±¡\n * @param now å½“å‰æ—¶é—´æˆ³\n * @returns é‡è¦æ€§åˆ†æ•° (0-1)\n */\nexport function computeContextImportance(\n  ctx: ContextImportance,\n  now = Date.now()\n): number {\n  const total = ctx.successCount + ctx.failureCount;\n  const successRate = total === 0 ? 0.5 : ctx.successCount / total;\n\n  const idleDays = (now - ctx.lastUsed) / (1000 * 60 * 60 * 24);\n  const freshness = Math.exp(-idleDays / 14); // 14 å¤©åŠè¡°\n\n  return (\n    0.45 * successRate +\n    0.35 * freshness +\n    0.20 * ctx.confidence\n  );\n}\n\n/**\n * åˆ›å»ºæ–°çš„ContextImportanceå¯¹è±¡\n * @param path æ–‡ä»¶æˆ–ç›®å½•è·¯å¾„\n * @param type ç±»å‹\n * @returns ContextImportanceå¯¹è±¡\n */\nexport function createContextImportance(path: string, type: 'file' | 'directory'): ContextImportance {\n  const now = Date.now();\n  return {\n    id: randomUUID(),\n    path,\n    type,\n    useCount: 0,\n    successCount: 0,\n    failureCount: 0,\n    confidence: 0.5,\n    createdAt: now,\n    lastUsed: now\n  };\n}\n\n/**\n * æ›´æ–°ContextImportanceçŠ¶æ€\n * @param ctx ContextImportanceå¯¹è±¡\n * @param success æ˜¯å¦æˆåŠŸ\n */\nexport function updateContextImportance(ctx: ContextImportance, success: boolean) {\n  ctx.useCount++;\n  ctx.lastUsed = Date.now();\n\n  if (success) {\n    ctx.successCount++;\n    ctx.confidence = Math.min(1, ctx.confidence + 0.05);\n  } else {\n    ctx.failureCount++;\n    ctx.confidence = Math.max(0, ctx.confidence - 0.1);\n  }\n}",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/contextImportance.ts:1769101059020",
    "tokens": 453,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextSummary.ts",
    "content": "import { askAI } from '../ai/client';\n\nexport function buildContextSummaryPrompt(\n  type: 'file' | 'directory',\n  path: string,\n  content: string\n) {\n  return `\nä½ æ˜¯ä¸€ä¸ªä»£ç ä¸æ–‡æ¡£å‹ç¼©å™¨ã€‚\n\nç›®æ ‡ï¼š\n- æœ€å¤§é™åº¦ä¿ç•™\"ä¹‹åå›ç­”é—®é¢˜æ‰€éœ€çš„ä¿¡æ¯\"\n- åˆ é™¤å®ç°ç»†èŠ‚ã€é‡å¤å†…å®¹ã€å™ªå£°\n- ä¸è¦åŠ å…¥æ¨æµ‹\n\nè¯·å°†ä»¥ä¸‹ ${type} å†…å®¹å‹ç¼©ä¸º **ç»“æ„åŒ–æ‘˜è¦**ï¼š\n\nè·¯å¾„: ${path}\n\nè¦æ±‚æ ¼å¼ï¼š\n- ç”¨é¡¹ç›®ç¬¦å·\n- ä¿ç•™ï¼šèŒè´£ / æ¥å£ / å…³é”®æ•°æ®ç»“æ„ / å…³é”®è¡Œä¸º\n- ä»£ç åªä¿ç•™å‡½æ•°ç­¾åæˆ–æ ¸å¿ƒé€»è¾‘æè¿°\n- ä¸è¶…è¿‡åŸå†…å®¹çš„ 20%\n\nå†…å®¹ï¼š\n\\`\\`\\`\n${content}\n\\`\\`\\`\n`;\n}\n\nexport async function summarizeContext(\n  item: { type: 'file' | 'directory'; path: string; content: string }\n): Promise<string> {\n  const prompt = buildContextSummaryPrompt(\n    item.type,\n    item.path,\n    item.content\n  );\n\n  const summary = await askAI(prompt);\n  return summary.trim();\n}",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/contextSummary.ts:1769101059020",
    "tokens": 170,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/chatHistoryStorage.ts",
    "content": "import fs from 'fs';\nimport { promisify } from 'util';\nimport path from 'path';\nimport os from 'os';\nimport { AIRequestMessage } from '../core/validation';\n\nconst CHAT_HISTORY_DIR = path.resolve(os.homedir(), '.yuangs_chat_history');\nconst CHAT_HISTORY_FILE = path.join(CHAT_HISTORY_DIR, 'chat_history.json');\n\nconst readFileAsync = promisify(fs.readFile);\nconst writeFileAsync = promisify(fs.writeFile);\nconst mkdirAsync = promisify(fs.mkdir);\nconst rmAsync = promisify(fs.rm);\n\nexport async function loadChatHistory(): Promise<AIRequestMessage[]> {\n    if (fs.existsSync(CHAT_HISTORY_FILE)) {\n        try {\n            const raw = await readFileAsync(CHAT_HISTORY_FILE, 'utf-8');\n            const data = JSON.parse(raw);\n\n            // éªŒè¯æ•°æ®ç»“æ„\n            if (Array.isArray(data) && data.every(msg =>\n                typeof msg === 'object' &&\n                ['user', 'assistant', 'system'].includes(msg.role) &&\n                typeof msg.content === 'string'\n            )) {\n                return data as AIRequestMessage[];\n            }\n        } catch (e) {\n            console.warn('è­¦å‘Š: åŠ è½½èŠå¤©å†å²è®°å½•å¤±è´¥ï¼Œä½¿ç”¨ç©ºå†å²è®°å½•');\n        }\n    }\n    return [];\n}\n\nexport async function saveChatHistory(history: AIRequestMessage[]) {\n    try {\n        await mkdirAsync(CHAT_HISTORY_DIR, { recursive: true });\n        await writeFileAsync(CHAT_HISTORY_FILE, JSON.stringify(history, null, 2));\n    } catch (e) {\n        console.error('é”™è¯¯: ä¿å­˜èŠå¤©å†å²è®°å½•å¤±è´¥:', e);\n    }\n}\n\nexport async function clearChatHistory() {\n    try {\n        await rmAsync(CHAT_HISTORY_FILE, { force: true });\n    } catch (e) {\n        console.error('é”™è¯¯: æ¸…é™¤èŠå¤©å†å²è®°å½•å¤±è´¥:', e);\n    }\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/chatHistoryStorage.ts:1769101059020",
    "tokens": 410,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/core.ts",
    "content": "import { ProposedAction } from '../state';\n\nexport interface PolicyRule {\n    id: string;\n    when: { type?: string; pattern?: string; max_per_minute?: number };\n    effect: 'allow' | 'deny' | 'require_approval';\n    reason?: string;\n}\n\nexport interface RiskEntry {\n    ts: number;\n    actionType: string;\n}\n\nexport function evaluateProposal(\n    action: ProposedAction,\n    rules: PolicyRule[],\n    ledger: RiskEntry[]\n): { effect: string; reason?: string } {\n    const now = Date.now();\n    for (const rule of rules) {\n        const typeMatch = !rule.when.type || rule.when.type === action.type;\n        const payloadStr = JSON.stringify(action.payload);\n        const patternMatch = !rule.when.pattern || new RegExp(rule.when.pattern, 'i').test(payloadStr);\n\n        if (typeMatch && patternMatch) {\n            if (rule.when.max_per_minute) {\n                const count = ledger.filter(e => e.ts > now - 60000 && e.actionType === action.type).length;\n                if (count >= rule.when.max_per_minute) return { effect: 'deny', reason: `Rate limit: ${rule.id}` };\n            }\n            return { effect: rule.effect, reason: rule.reason };\n        }\n    }\n    return { effect: 'require_approval', reason: 'Default human review required' };\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/core.ts:1769101059020",
    "tokens": 314,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/bridge.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\n\nexport class WasmGovernanceBridge {\n    private static instance: any = null;\n\n    static async init(basePath?: string): Promise<boolean> {\n        try {\n            const loader = require('@assemblyscript/loader');\n            const wasmPath = path.join(basePath || process.cwd(), 'build', 'release.wasm');\n\n            if (!fs.existsSync(wasmPath)) {\n                console.error(`WASM not found at: ${wasmPath}`);\n                return false;\n            }\n\n            const wasmModule = await loader.instantiate(fs.readFileSync(wasmPath));\n            this.instance = wasmModule.exports;\n            return true;\n        } catch (e) {\n            console.error(`WASM init error: ${e}`);\n            return false;\n        }\n    }\n\n    static evaluate(proposal: any, rules: any, ledger: any): any {\n        if (!this.instance) return { effect: 'error', reason: 'WASM not initialized' };\n\n        const { __newString, __getString, evaluate } = this.instance;\n\n        const pPtr = __newString(JSON.stringify(proposal));\n        const rPtr = __newString(JSON.stringify(rules));\n        const lPtr = __newString(JSON.stringify(ledger));\n\n        const resultPtr = evaluate(pPtr, rPtr, lPtr);\n        return JSON.parse(__getString(resultPtr));\n    }\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/bridge.ts:1769101059020",
    "tokens": 325,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/ledger.ts",
    "content": "import { RiskEntry } from './core';\n\nexport class RiskLedger {\n    private entries: RiskEntry[] = [];\n\n    record(actionType: string): void {\n        this.entries.push({\n            ts: Date.now(),\n            actionType\n        });\n        this.cleanup();\n    }\n\n    getSnapshot(): RiskEntry[] {\n        return [...this.entries];\n    }\n\n    private cleanup(): void {\n        const oneHourAgo = Date.now() - 3600000;\n        this.entries = this.entries.filter(e => e.ts > oneHourAgo);\n    }\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/ledger.ts:1769101059020",
    "tokens": 124,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/sandbox/core.as.ts",
    "content": "/**\n * yuangs Governance WASM Sandbox\n * è¿™é‡Œçš„ä»£ç åœ¨æ‰§è¡Œæ—¶ä¸ Node.js å†…å­˜å®Œå…¨éš”ç¦»\n */\n\n// ç®€å•çš„è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥å­—ç¬¦ä¸²åŒ…å«ï¼ˆWASM å†…éƒ¨å®ç°ï¼‰\nfunction includes(source: string, target: string): boolean {\n    return source.indexOf(target) != -1;\n}\n\n/**\n * æ ¸å¿ƒè£å†³å¯¼å‡ºå‡½æ•°\n * @param proposal ææ¡ˆå­—ç¬¦ä¸²\n * @param rules è§„åˆ™å­—ç¬¦ä¸²ï¼ˆYAML è½¬æ¢åçš„ JSONï¼‰\n * @param ledger è´¦æœ¬å­—ç¬¦ä¸²\n */\nexport function evaluate(proposal: string, rules: string, ledger: string): string {\n    // 1. æš´åŠ›é˜»æ–­ï¼šæœ€åº•å±‚çš„ç‰©ç†é˜²çº¿ï¼ˆå³ä¾¿å¤–éƒ¨é€»è¾‘è¢«æ±¡æŸ“ï¼Œè¿™é‡Œä¹Ÿæ˜¯æ­»çš„ï¼‰\n    if (proposal.includes(\"rm -rf /\") || proposal.includes(\"sudo rm\")) {\n        return '{\"effect\": \"deny\", \"reason\": \"WASM_SANDBOX: æ£€æµ‹åˆ°æ¯ç­æ€§å‘½ä»¤ï¼Œå¼ºåˆ¶é˜»æ–­\"}';\n    }\n\n    // 2. æ£€æŸ¥é€Ÿç‡ï¼ˆåŸºäºè´¦æœ¬é•¿åº¦ï¼‰\n    // å‡è®¾æˆ‘ä»¬ä¸æƒ³è®© AI åœ¨çŸ­æ—¶é—´å†…è¿ç»­æè®®è¶…è¿‡ 50 æ¬¡\n    if (ledger.length > 5000) { // ç®€å•é€šè¿‡å­—ç¬¦ä¸²é•¿åº¦æ¨¡æ‹Ÿå¼‚å¸¸è´¦æœ¬\n        return '{\"effect\": \"deny\", \"reason\": \"WASM_SANDBOX: è´¦æœ¬å¼‚å¸¸è†¨èƒ€ï¼Œå¯èƒ½é­å—æ‹’ç»æœåŠ¡æ”»å‡»\"}';\n    }\n\n    // 3. é€»è¾‘é€ä¼ \n    // åœ¨å®é™…ç”Ÿäº§ä¸­ï¼Œæˆ‘ä»¬ä¼šåœ¨è¿™é‡Œè§£æ JSON rulesã€‚\n    // ç›®å‰ç‰ˆæœ¬æˆ‘ä»¬å…ˆç¡®ä¿ç‰©ç†é“¾è·¯æ‰“é€šã€‚\n    return '{\"effect\": \"allow\", \"reason\": \"WASM_SANDBOX: ç‰©ç†éš”ç¦»å±‚éªŒè¯é€šè¿‡\"}';\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/governance/sandbox/core.as.ts:1769101059020",
    "tokens": 236,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/llmAdapter.ts",
    "content": "import { AgentThought } from './state';\nimport { runLLM } from './llm';\nimport { AgentPrompt } from './types';\nimport type { AIRequestMessage } from '../core/validation';\nimport { getUserConfig } from '../ai/client';\nimport { ContextManager } from './contextManager';\nimport { ExtendedContextProtocol } from './contextDSL';\nimport { parseContextReferences, validateContextReferences, buildContextPromptWithReferences } from './contextProtocol';\nimport { randomUUID } from 'crypto';\n\nexport class LLMAdapter {\n  static async think(\n    messages: AIRequestMessage[],\n    mode: 'chat' | 'command' | 'command+exec' = 'chat',\n    onChunk?: (chunk: string) => void,\n    model?: string,\n    customSystemPrompt?: string,\n    contextManager?: ContextManager\n  ): Promise<AgentThought> {\n    // ç”Ÿæˆå”¯ä¸€çš„å“åº”IDç”¨äºå¼•ç”¨è·Ÿè¸ª\n    const responseId = randomUUID();\n\n    // æ„å»ºåŒ…å«ContextBufferå†…å®¹çš„å®Œæ•´ä¸Šä¸‹æ–‡\n    let fullMessages = [...messages];\n\n    if (contextManager) {\n      const contextBuffer = contextManager.getContextBuffer();\n      if (!contextBuffer.isEmpty()) {\n        // æ£€æŸ¥ç”¨æˆ·æ¶ˆæ¯ä¸­æ˜¯å¦æœ‰ DSL æŸ¥è¯¢\n        const userInput = messages[messages.length - 1]?.content || '';\n        const dslContextItems = await contextBuffer.getDSLContextForInput(userInput);\n\n        let contextPrompt: string;\n\n        if (dslContextItems.length > 0) {\n          // å¦‚æœæœ‰ DSL æŸ¥è¯¢ç»“æœï¼Œä½¿ç”¨ buildContextPromptWithReferences æ¥æ„å»ºæç¤º\n          contextPrompt = await buildContextPromptWithReferences(contextBuffer, userInput);\n        } else {\n          // åŒºåˆ†æµå¼ä¼ è¾“å’Œéæµå¼ä¼ è¾“ï¼Œæµå¼ä¼ è¾“æ—¶ä½¿ç”¨æ›´ç®€æ´çš„ç­–ç•¥ä»¥æé«˜æ€§èƒ½\n          if (onChunk) {\n            // æµå¼ä¼ è¾“æ—¶ä½¿ç”¨æœ€è¿‘çš„ä¸Šä¸‹æ–‡ï¼Œå‡å°‘å¤æ‚åº¦å’Œæ¸²æŸ“æŠ–åŠ¨\n            contextPrompt = contextBuffer.buildPrompt('', {\n              strategy: 'recent',  // ä½¿ç”¨æœ€è¿‘ç­–ç•¥ï¼Œæ›´ç¨³å®š\n              maxTokens: 4000      // å‡å°‘tokenæ•°é‡ï¼Œé™ä½æ¸²æŸ“è´Ÿæ‹…\n            });\n          } else {\n            // éæµå¼ä¼ è¾“æ—¶ä½¿ç”¨å®Œæ•´çš„æ’åç­–ç•¥\n            contextPrompt = contextBuffer.buildPrompt('', {\n              strategy: 'ranked',  // ä½¿ç”¨æ’åç­–ç•¥\n              maxTokens: 16000     // è®¾ç½®æœ€å¤§tokené™åˆ¶\n            });\n          }\n        }\n\n        // å°†ContextBufferå†…å®¹ä½œä¸ºsystemæ¶ˆæ¯æ·»åŠ åˆ°æ¶ˆæ¯åˆ—è¡¨å¼€å¤´\n        fullMessages = [\n          { role: 'system', content: contextPrompt },\n          ...fullMessages\n        ];\n      }\n    }\n\n    const prompt: AgentPrompt = {\n      system: customSystemPrompt || `[SYSTEM PROTOCOL V3 - CONTEXT REFERENCE ENABLED]\n- ROLE: AUTOMATED EXECUTION AGENT WITH CONTEXT REFERENCE\n- OUTPUT: STRICT JSON ONLY\n- TALK: FORBIDDEN\n- MODE: REACT (THINK -> ACTION -> PERCEIVE)\n- CONTEXT REFERENCE: When using information from the provided context, explicitly reference it in your response using [Reference] notation or in the JSON output\n\nJSON SCHEMA:\n{\n  \"action_type\": \"tool_call\" | \"shell_cmd\" | \"code_diff\" | \"answer\",\n  \"reasoning\": \"thought process\",\n  \"tool_name\": \"list_files\" | \"read_file\",\n  \"diff\": \"unified diff string\",\n  \"parameters\": {},\n  \"command\": \"shell string\",\n  \"content\": \"final answer string\",\n  \"used_context\": [\"path/to/file.ts\", \"path/to/dir\"] // OPTIONAL: List paths of context items used\n}\n\nEXECUTION RULES:\n1. If data is unknown (e.g. file list), use 'shell_cmd' or 'tool_call'.\n2. NEVER explain how to do it. JUST EXECUTE.\n3. Your output MUST start with '{' and end with '}'.\n4. When referencing information from provided context, include the path in \"used_context\" array or use [Reference] notation.\n\nExample Task: \"count files\"\nYour Output: {\"action_type\":\"shell_cmd\",\"reasoning\":\"count files\",\"command\":\"ls | wc -l\",\"used_context\":[\"/path/to/config.json\"]}`,\n      messages: fullMessages,\n    };\n\n    const config = getUserConfig();\n    const finalModel = model || config.defaultModel || 'Assistant';\n\n    const result = await runLLM({\n      prompt,\n      model: finalModel,\n      stream: !!onChunk,\n      onChunk\n    });\n\n    // è§£æå“åº”å¹¶å¤„ç†Contextå¼•ç”¨\n    const thought = this.parseThought(result.rawText);\n\n    // å¦‚æœæœ‰ContextManagerï¼Œè§£æå¹¶è®°å½•å¼•ç”¨\n    if (contextManager) {\n      const contextBuffer = contextManager.getContextBuffer();\n      const references = parseContextReferences(result.rawText);\n\n      // è®°å½•æ˜¾å¼å¼•ç”¨\n      for (const ref of references.referencedItems) {\n        contextBuffer.recordExplicitReference(ref.path, responseId);\n      }\n\n      // éªŒè¯å¼•ç”¨çš„æœ‰æ•ˆæ€§\n      const validation = validateContextReferences(\n        references.referencedItems,\n        contextBuffer.export()\n      );\n\n      // æ›´æ–°å¼•ç”¨çš„æœ‰æ•ˆæ€§\n      for (const validRef of validation.valid) {\n        contextBuffer.validateReference(validRef.path, true);\n      }\n\n      for (const invalidRef of validation.invalid) {\n        contextBuffer.validateReference(invalidRef.path, false);\n      }\n    }\n\n    return thought;\n  }\n\n  private static parseThought(raw: string): AgentThought {\n    try {\n      // æå– JSONï¼šæ”¯æŒ Markdown å—æˆ–çº¯ JSON å­—ç¬¦ä¸²\n      const jsonMatch = raw.match(/```json\\n([\\s\\S]*?)\\n```/) || raw.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        const parsed = JSON.parse(jsonMatch[1] || jsonMatch[0]);\n\n        // å¦‚æœæ˜ç¡®æ ‡è®°ä¸º doneï¼Œæˆ–è€…åŠ¨ä½œä¸º answerï¼Œåˆ™è§†ä¸ºä»»åŠ¡ç»“æŸ\n        if (parsed.is_done === true || parsed.action_type === 'answer') {\n          return {\n            raw,\n            parsedPlan: parsed,\n            isDone: true,\n            type: 'answer',\n            payload: {\n              content: parsed.final_answer || parsed.content || parsed.text || raw\n            }\n          };\n        }\n\n        // æ™ºèƒ½æ¨æ–­åŠ¨ä½œç±»å‹ï¼šå¦‚æœ AI æ²¡ç»™ action_typeï¼Œæˆ‘ä»¬æ ¹æ®å­—æ®µçŒœæµ‹\n        let inferredType = parsed.action_type;\n        if (!inferredType) {\n          if (parsed.tool_name || parsed.tool) inferredType = 'tool_call';\n          else if (parsed.command || parsed.cmd) inferredType = 'shell_cmd';\n          else if (parsed.diff || parsed.patch) inferredType = 'code_diff';\n          else inferredType = 'answer';\n        }\n\n        return {\n          raw,\n          parsedPlan: parsed,\n          isDone: inferredType === 'answer' || parsed.is_done === true,\n          type: inferredType,\n          payload: {\n            tool_name: parsed.tool_name || parsed.tool || '',\n            parameters: parsed.parameters || parsed.params || {},\n            command: parsed.command || parsed.cmd || '',\n            diff: parsed.diff || parsed.patch || '',\n            content: parsed.content || parsed.text || ''\n          },\n          reasoning: parsed.reasoning || ''\n        };\n      }\n    } catch (e) {\n      // è§£æå¤±è´¥æ—¶ï¼Œå›é€€åˆ°å°†åŸå§‹å†…å®¹ä½œä¸ºå›ç­”\n    }\n\n    return {\n      raw,\n      parsedPlan: {},\n      isDone: true,\n      type: 'answer',\n      payload: { content: raw },\n      reasoning: ''\n    };\n  }\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/llmAdapter.ts:1769101059020",
    "tokens": 1611,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/index.ts",
    "content": "export { AgentRuntime } from './AgentRuntime';\nexport * from './state';\nexport { LLMAdapter } from './llmAdapter';\nexport { GovernanceService } from './governance';\nexport { ToolExecutor } from './executor';\nexport { ContextManager } from './contextManager';\nexport { ContextBuffer } from './contextBuffer';\nexport { ContextImportance, computeContextImportance, createContextImportance, updateContextImportance } from './contextImportance';\nexport { buildContextSummaryPrompt, summarizeContext } from './contextSummary';\nexport { diffContext, snapshotFromBuffer, ContextDiff, ContextSnapshot } from './contextDiff';\nexport { ExecutionRecorder } from './executionRecorder';\nexport { explainExecution, replayExecution } from './replayExplain';\nexport { generateSkillHintsFromContext, formatSkillHints, ContextSkillHint } from './contextSkillBridge';\nexport * from './skills';\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/index.ts:1769101059020",
    "tokens": 219,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/skills.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport chalk from 'chalk';\nimport { recordEdge } from './knowledgeGraph';\n\nexport interface Skill {\n    id: string;\n    name: string;\n    description: string;\n    whenToUse: string; // è§¦å‘åœºæ™¯æè¿°\n    planTemplate: any;\n\n    // è¯„ä»·æŒ‡æ ‡\n    successCount: number;\n    failureCount: number;\n    confidence: number; // 0 ~ 1, åˆå§‹ 0.5\n\n    // æ—¶é—´æˆ³\n    lastUsed: number;\n    createdAt: number;\n\n    // æ˜¯å¦å¯ç”¨\n    enabled: boolean;\n\n    // å¯é€‰å±æ€§\n    parameters?: any;\n    implementation?: string;\n    metadata?: {\n        source?: string;\n        originalContextId?: string;\n        originalContextPath?: string;\n        originalContextStableId?: string;\n        promotionCriteria?: any;\n        usageStats?: {\n            useCount: number;\n            successCount: number;\n            failureCount: number;\n            confidence: number;\n            lastUsed: number;\n        };\n        createdAt?: number;\n    };\n}\n\nconst SKILLS_FILE = path.join(os.homedir(), '.yuangs_skills.json');\nlet skillLibrary: Skill[] = [];\n\n// === Persistence Logic ===\n\nfunction loadSkills() {\n    if (fs.existsSync(SKILLS_FILE)) {\n        try {\n            const data = fs.readFileSync(SKILLS_FILE, 'utf-8');\n            skillLibrary = JSON.parse(data);\n        } catch (e) {\n            console.error(chalk.yellow(`Failed to load skills from ${SKILLS_FILE}, starting empty.`));\n            skillLibrary = [];\n        }\n    }\n}\n\nfunction saveSkills() {\n    try {\n        fs.writeFileSync(SKILLS_FILE, JSON.stringify(skillLibrary, null, 2));\n    } catch (e) {\n        console.error(chalk.red(`Failed to save skills to ${SKILLS_FILE}`));\n    }\n}\n\n// Initialize on load\nloadSkills();\n\n// === Existing Logic with Save Hooks ===\n\n/**\n * è®¡ç®—æŠ€èƒ½åˆ† (0 ~ 1)\n */\nexport function computeSkillScore(skill: Skill, now: number = Date.now()): number {\n    const totalUses = skill.successCount + skill.failureCount;\n    const successRate = totalUses === 0 ? 0.5 : skill.successCount / totalUses;\n\n    // æ—¶é—´è¡°å‡ (Freshness): åŠè¡°æœŸçº¦ 14 å¤©\n    const idleDays = (now - skill.lastUsed) / (1000 * 60 * 60 * 24);\n    const freshness = Math.exp(-idleDays / 14);\n\n    // ç»¼åˆå¾—åˆ†: 45% æˆåŠŸç‡ + 35% æ–°é²œåº¦ + 20% ç½®ä¿¡åº¦\n    return (0.45 * successRate) + (0.35 * freshness) + (0.20 * skill.confidence);\n}\n\n/**\n * æ›´æ–°æŠ€èƒ½çŠ¶æ€ (æ‰§è¡Œåè°ƒç”¨)\n */\nexport function updateSkillStatus(skillId: string, success: boolean) {\n    const skill = skillLibrary.find(s => s.id === skillId);\n    if (!skill) return;\n\n    skill.lastUsed = Date.now();\n    if (success) {\n        skill.successCount++;\n        // æˆåŠŸå¥–åŠ±: ç½®ä¿¡åº¦ç¼“æ…¢æå‡\n        skill.confidence = Math.min(1, skill.confidence + 0.05);\n    } else {\n        skill.failureCount++;\n        // å¤±è´¥æƒ©ç½š: æƒ©ç½šåŠ›åº¦å¤§äºå¥–åŠ±ï¼Œé˜²æ­¢ç³»ç»Ÿ\"è‡ªå—¨\"\n        skill.confidence = Math.max(0, skill.confidence - 0.1);\n    }\n\n    // === C5-B-1: Knowledge Graph Record (Execution -> Skill) ===\n    recordEdge({\n        from: 'current_execution', // TODO(KG): replace with real executionId (v2)\n        to: skill.id,\n        type: 'validated_by',\n        timestamp: Date.now(),\n        meta: { success, skillName: skill.name }\n    });\n\n    saveSkills(); // Persist changes\n}\n\n/**\n * è‡ªåŠ¨å­¦ä¹ æ–°æŠ€èƒ½\n */\nexport function learnSkillFromRecord(record: any, success: boolean = true) {\n    if (record.mode === 'chat' || !record.llmResult.plan) return;\n\n    const existingSkill = skillLibrary.find(s => s.name === record.llmResult.plan?.goal);\n\n    if (existingSkill) {\n        updateSkillStatus(existingSkill.id, success);\n        return;\n    }\n\n    // åªæœ‰æˆåŠŸçš„è®°å½•æ‰è¢«å­¦ä¸ºæ–°æŠ€èƒ½\n    if (!success) return;\n\n    const now = Date.now();\n    skillLibrary.push({\n        id: record.id,\n        name: record.llmResult.plan.goal,\n        description: `è‡ªåŠ¨å­¦ä¹ çš„æŠ€èƒ½: ${record.llmResult.plan.goal}`,\n        whenToUse: record.input.rawInput,\n        planTemplate: record.llmResult.plan,\n        successCount: 1,\n        failureCount: 0,\n        confidence: 0.5,\n        lastUsed: now,\n        createdAt: now,\n        enabled: true\n    });\n\n    // æ¯å­¦ä¹ ä¸€æ¬¡ï¼Œå°è¯•æ¸…ç†ä¸€æ¬¡â€œå†·â€æŠ€èƒ½\n    reapColdSkills();\n\n    saveSkills(); // Persist changes\n}\n\n/**\n * ç­›é€‰å¹¶æ’åºæŠ€èƒ½ (ç”¨äºæ³¨å…¥ Prompt)\n */\nexport function getRelevantSkills(input: string, limit: number = 3): Skill[] {\n    const now = Date.now();\n\n    return skillLibrary\n        // 1. åŸºç¡€ç­›é€‰: å‰”é™¤è¯„åˆ†è¿‡ä½çš„æŠ€èƒ½ (ç¡¬æ·˜æ±°é˜ˆå€¼ 0.3)\n        .filter(s => computeSkillScore(s, now) >= 0.3)\n        // 2. è¿‡æ»¤å·²ç¦ç”¨çš„æŠ€èƒ½\n        .filter(s => s.enabled !== false)\n        // 3. æ’åº: æŒ‰ç»¼åˆåˆ†æ’åº\n        .sort((a, b) => computeSkillScore(b, now) - computeSkillScore(a, now))\n        // 4. å–ä¸Šé™\n        .slice(0, limit);\n}\n\n/**\n * æ¸…ç†è¿‡æœŸæˆ–ä½è´¨æŠ€èƒ½ (Reaper)\n */\nexport function reapColdSkills() {\n    const now = Date.now();\n    const initialCount = skillLibrary.length;\n\n    skillLibrary = skillLibrary.filter(skill => {\n        const score = computeSkillScore(skill, now);\n        const idleDays = (now - skill.lastUsed) / (1000 * 60 * 60 * 24);\n\n        // æ»¡è¶³ä»¥ä¸‹ä»»ä¸€æ¡ä»¶åˆ™æ·˜æ±°:\n        // 1. å¾—åˆ†æä½ä¸”é•¿æœŸä¸ç”¨\n        if (score < 0.25 && idleDays > 30) return false;\n        // 2. å¤±è´¥ç‡æé«˜ä¸”å°è¯•è¿‡ä¸€å®šæ¬¡æ•°\n        if (skill.failureCount > 5 && (skill.successCount / (skill.successCount + skill.failureCount)) < 0.2) return false;\n\n        return true;\n    });\n\n    // å¼ºåˆ¶ä¿æŒå®¹é‡\n    if (skillLibrary.length > 100) {\n        // å¦‚æœè¿˜è¶…æ ‡ï¼Œç§»é™¤å¾—åˆ†æœ€ä½çš„é‚£ä¸ª\n        skillLibrary.sort((a, b) => computeSkillScore(a, now) - computeSkillScore(b, now));\n        skillLibrary.shift();\n    }\n\n    if (skillLibrary.length !== initialCount) {\n        saveSkills(); // Persist if changes happened\n    }\n}\n\nexport function getAllSkills(): Skill[] {\n    return [...skillLibrary];\n}\n\n/**\n * æ·»åŠ æ–°æŠ€èƒ½\n */\nexport function addSkill(skill: Skill) {\n    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨åŒåæŠ€èƒ½\n    const existingSkill = skillLibrary.find(s => s.name === skill.name);\n    if (existingSkill) {\n        console.log(`Skill with name \"${skill.name}\" already exists, skipping.`);\n        return false;\n    }\n\n    skillLibrary.push(skill);\n    saveSkills(); // ä¿å­˜æ›´æ”¹\n    return true;\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/skills.ts:1769101059020",
    "tokens": 1472,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/recorder.ts",
    "content": "import { RuntimeEvent, EventRecorder } from './events';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { randomUUID } from 'crypto';\n\nexport class FileEventRecorder implements EventRecorder {\n  private events: RuntimeEvent[] = [];\n  private logFile: string;\n  private flushInterval: number = 1000;\n\n  constructor(logDir: string = '.yuangs_events') {\n    this.logFile = path.join(logDir, `events_${Date.now()}.jsonl`);\n  }\n\n  async record(event: RuntimeEvent): Promise<void> {\n    this.events.push(event);\n\n    if (this.events.length >= this.flushInterval) {\n      await this.flush();\n    }\n  }\n\n  async flush(): Promise<void> {\n    if (this.events.length === 0) return;\n\n    const logDir = path.dirname(this.logFile);\n    await fs.mkdir(logDir, { recursive: true });\n\n    const content = this.events\n      .map(e => JSON.stringify(e))\n      .join('\\n') + '\\n';\n\n    await fs.appendFile(this.logFile, content, 'utf8');\n    this.events = [];\n  }\n\n  getEvents(executionId?: string): RuntimeEvent[] {\n    if (!executionId) {\n      return [...this.events];\n    }\n\n    return this.events.filter(e => e.executionId === executionId);\n  }\n}\n\nexport const createEvent = (\n  executionId: string,\n  type: RuntimeEvent['type'],\n  data: RuntimeEvent['data'],\n  metadata?: RuntimeEvent['metadata']\n): RuntimeEvent => ({\n  id: randomUUID(),\n  timestamp: Date.now(),\n  executionId,\n  type,\n  data,\n  metadata\n});\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/recorder.ts:1769101059020",
    "tokens": 353,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/events.ts",
    "content": "export type EventType = \n  | 'state_transition'\n  | 'llm_call'\n  | 'tool_execution'\n  | 'governance_decision'\n  | 'observation_recorded'\n  | 'evaluation_result'\n  | 'error_occurred';\n\nexport interface RuntimeEvent {\n  id: string;\n  timestamp: number;\n  executionId: string;\n  type: EventType;\n  data: {\n    from?: string;\n    to?: string;\n    action?: any;\n    decision?: any;\n    result?: any;\n    error?: string;\n  };\n  metadata?: Record<string, any>;\n}\n\nexport interface EventRecorder {\n  record(event: RuntimeEvent): void;\n  flush(): Promise<void>;\n  getEvents(executionId?: string): RuntimeEvent[];\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/events.ts:1769101059020",
    "tokens": 152,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/index.ts",
    "content": "export * from './events';\nexport * from './recorder';\nexport * from './replayer';\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/index.ts:1769101059020",
    "tokens": 21,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/replayer.ts",
    "content": "import { RuntimeEvent } from './events';\n\nexport interface ReplayerOptions {\n  speed?: number;\n  stopOnError?: boolean;\n  dryRun?: boolean;\n}\n\nexport class EventReplayer {\n  private events: RuntimeEvent[] = [];\n  private currentIndex: number = 0;\n  private options: Required<ReplayerOptions>;\n\n  constructor(events: RuntimeEvent[], options: ReplayerOptions = {}) {\n    this.events = events;\n    this.options = {\n      speed: options.speed || 1,\n      stopOnError: options.stopOnError !== undefined ? options.stopOnError : true,\n      dryRun: options.dryRun || false\n    };\n  }\n\n  hasNext(): boolean {\n    return this.currentIndex < this.events.length;\n  }\n\n  next(): RuntimeEvent | null {\n    if (!this.hasNext()) {\n      return null;\n    }\n\n    return this.events[this.currentIndex++];\n  }\n\n  reset(): void {\n    this.currentIndex = 0;\n  }\n\n  async replay(onEvent: (event: RuntimeEvent, options: Required<ReplayerOptions>) => Promise<void>): Promise<void> {\n    this.reset();\n    let hasError = false;\n\n    while (this.hasNext() && !hasError) {\n      const event = this.next();\n\n      if (!event) break;\n\n      try {\n        await onEvent(event, this.options);\n\n        if (event.type === 'error_occurred') {\n          hasError = true;\n          if (this.options.stopOnError) {\n            break;\n          }\n        }\n\n        if (this.options.speed > 1) {\n          const delay = 100 / this.options.speed;\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      } catch (error: any) {\n        console.error(`[Replay] Error at event ${event.id}:`, error.message);\n        hasError = true;\n      }\n    }\n\n    return;\n  }\n\n  getSummary(): {\n    total: number;\n    completed: number;\n    errors: number;\n  } {\n    const errors = this.events.filter(e => e.type === 'error_occurred').length;\n    \n    return {\n      total: this.events.length,\n      completed: this.currentIndex,\n      errors\n    };\n  }\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/replay/replayer.ts:1769101059020",
    "tokens": 483,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextManager.ts",
    "content": "import crypto from 'crypto';\nimport { GovernanceContext } from './state';\nimport { ContextBuffer } from './contextBuffer';\nimport { ExtendedContextProtocol } from './contextDSL';\nimport { ContextBank } from './contextBank';\n\nexport class ContextManager {\n  private messages: Array<{ role: string; content: string; timestamp: number }> = [];\n  private contextBuffer: ContextBuffer;\n  private contextBank: ContextBank;\n  private maxHistorySize = 50;\n\n  constructor(initialContext?: GovernanceContext) {\n    this.contextBuffer = new ContextBuffer();\n    this.contextBank = new ContextBank();\n\n    if (initialContext?.history) {\n      this.messages = initialContext.history.map(msg => ({\n        ...msg,\n        timestamp: Date.now()\n      }));\n    }\n\n    if (initialContext?.input) {\n      this.addMessage('user', initialContext.input);\n    }\n  }\n\n  addMessage(role: string, content: string): void {\n    this.messages.push({\n      role,\n      content,\n      timestamp: Date.now()\n    });\n\n    if (this.messages.length > this.maxHistorySize) {\n      this.messages = this.messages.slice(-this.maxHistorySize);\n    }\n  }\n\n  addToolResult(toolName: string, result: string): void {\n    const content = `Tool ${toolName} returned:\\n${result}`;\n    this.addMessage('tool', content);\n  }\n\n  addObservation(observation: string): void {\n    this.addMessage('system', observation);\n  }\n\n  getMessages(): Array<{ role: 'system' | 'user' | 'assistant' | 'tool'; content: string }> {\n    return this.messages.map(({ role, content }) => ({\n      role: role as 'system' | 'user' | 'assistant' | 'tool',\n      content\n    }));\n  }\n\n  getContextBuffer(): ContextBuffer {\n    return this.contextBuffer;\n  }\n\n  addContextItem(item: Omit<import('./contextBuffer').ContextItem, 'tokens'>) {\n    this.contextBuffer.add(item);\n  }\n\n  async addContextItemAsync(item: Omit<import('./contextBuffer').ContextItem, 'tokens'>) {\n    await this.contextBuffer.addAsync(item);\n  }\n\n  buildContextPrompt(userInput: string, options?: import('./contextBuffer').BuildPromptOptions) {\n    return this.contextBuffer.buildPrompt(userInput, options);\n  }\n\n  /**\n   * ä½¿ç”¨ DSL æŸ¥è¯¢ä¸Šä¸‹æ–‡\n   */\n  async queryDSL(dslQuery: string) {\n    return await this.contextBuffer.queryDSL(dslQuery, this.contextBank);\n  }\n\n  /**\n   * è§£æåŒ…å« DSL çš„ç”¨æˆ·è¾“å…¥å¹¶è·å–ç›¸å…³ä¸Šä¸‹æ–‡\n   */\n  async getDSLContextForInput(input: string) {\n    return await this.contextBuffer.getDSLContextForInput(input, this.contextBank);\n  }\n\n  /**\n   * åˆå§‹åŒ– Context Bank\n   */\n  async initializeContextBank(): Promise<void> {\n    await this.contextBank.initialize();\n  }\n\n  /**\n   * ä» ContextBuffer å¯¼å‡ºé«˜ä»·å€¼ä¸Šä¸‹æ–‡åˆ°é“¶è¡Œ\n   */\n  async exportToContextBank(projectScope?: string): Promise<void> {\n    await this.contextBank.exportFromContextBuffer(this.contextBuffer, projectScope);\n  }\n\n  /**\n   * ä» Context Bank æŸ¥è¯¢ä¸Šä¸‹æ–‡\n   */\n  async queryContextBank(options: import('./contextBank').BankQueryOptions): Promise<import('./contextBank').BankContextItem[]> {\n    return await this.contextBank.query(options);\n  }\n\n  /**\n   * å°† Context Bank ä¸­çš„é¡¹ç›®æ·»åŠ åˆ°å½“å‰ä¸Šä¸‹æ–‡\n   */\n  async importFromContextBank(options: import('./contextBank').BankQueryOptions): Promise<void> {\n    const bankItems = await this.contextBank.query(options);\n\n    for (const item of bankItems) {\n      // å°† BankContextItem è½¬æ¢ä¸º ContextItem å¹¶æ·»åŠ åˆ°ç¼“å†²åŒº\n      this.contextBuffer.add({\n        type: item.type,\n        path: item.path,\n        stableId: item.stableId,\n        content: item.content,\n        summary: item.summary,\n        summarized: item.summarized,\n        semantic: item.semantic,\n        summaryQuality: item.summaryQuality,\n        referencedBy: item.referencedBy,\n        usageStats: item.usageStats,\n        importance: item.importance,\n        metadata: {\n          source: 'context_bank',\n          bankItemId: item.id\n        }\n      });\n    }\n  }\n\n  /**\n   * è®°å½• ContextBank é¡¹ç›®çš„ä½¿ç”¨æƒ…å†µ\n   */\n  async recordBankUsage(success: boolean): Promise<void> {\n    const contextItems = this.contextBuffer.export();\n\n    for (const item of contextItems) {\n      // æ£€æŸ¥é¡¹ç›®æ˜¯å¦æ¥è‡ªé“¶è¡Œï¼ˆæœ‰ bankItemIdï¼‰\n      const bankItemId = (item as any).metadata?.bankItemId;\n      if (bankItemId) {\n        try {\n          // ä½¿ç”¨é“¶è¡Œé¡¹ç›® ID è€Œä¸æ˜¯è·¯å¾„è¿›è¡Œè®°å½•\n          await this.contextBank.recordUsage(bankItemId, success);\n        } catch (error) {\n          console.warn(`[ContextManager] Could not record bank usage for ${bankItemId}:`, error);\n        }\n      }\n    }\n  }\n\n  getRecentMessages(count: number): Array<{ role: string; content: string; timestamp: number }> {\n    return this.messages.slice(-count);\n  }\n\n  getHash(): string {\n    const content = JSON.stringify(this.messages);\n    return crypto.createHash('sha256').update(content).digest('hex');\n  }\n\n  getSnapshot() {\n    return {\n      inputHash: this.getHash(),\n      systemPromptVersion: 'v1.0.0',\n      toolSetVersion: 'v1.0.0',\n      recentMessages: this.getRecentMessages(10)\n    };\n  }\n\n  clear(): void {\n    this.messages = [];\n    this.contextBuffer.clear();\n  }\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/contextManager.ts:1769101059020",
    "tokens": 1237,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/selectModel.ts",
    "content": "import { AgentIntent } from './types';\nimport { getUserConfig } from '../ai/client';\n\nexport function selectModel(\n    intent: AgentIntent,\n    override?: string\n): string {\n    if (override) return override;\n\n    const config = getUserConfig();\n    const defaultModel = config.defaultModel || 'Assistant';\n\n    return defaultModel;\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/selectModel.ts:1769101059020",
    "tokens": 84,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextBank.ts",
    "content": "/**\n * Context Bank v1 â€” è·¨ä¼šè¯ä¸Šä¸‹æ–‡é“¶è¡Œ\n * \n * ä¸€ä¸ªè·¨ä¼šè¯ã€è·¨æ‰§è¡Œå‘¨æœŸçš„é•¿æœŸä¸Šä¸‹æ–‡å­˜å‚¨ç³»ç»Ÿï¼Œ\n * å°†çŸ­æœŸ ContextBuffer ä¸­è¢«è¯æ˜æœ‰ä»·å€¼çš„ä¸Šä¸‹æ–‡æ²‰æ·€ä¸ºå¯å¤ç”¨èµ„äº§ã€‚\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { ContextItem } from './contextBuffer';\nimport { ContextImportance, computeContextImportance } from './contextImportance';\nimport { randomUUID } from 'crypto';\n\nexport interface BankContextItem extends ContextItem {\n  id: string;\n  stableId: string;        // ç¨³å®šèº«ä»½\n  source: 'project' | 'global' | 'external'; // ä¸Šä¸‹æ–‡æ¥æº\n  projectScope?: string;   // é¡¹ç›®ä½œç”¨åŸŸ (repo hash / path)\n  tags?: string[];         // æ ‡ç­¾ (e.g. ['build', 'infra', 'ci'])\n  frozen?: boolean;        // ç¦æ­¢è‡ªåŠ¨ä¿®æ”¹\n  deprecated?: boolean;    // å·²å¼ƒç”¨\n  firstSeenAt: number;     // é¦–æ¬¡å‡ºç°æ—¶é—´\n  lastUsedAt: number;      // æœ€åä½¿ç”¨æ—¶é—´\n}\n\nexport interface BankIndexEntry {\n  id: string;\n  path: string;\n  stableId: string;\n  type: 'file' | 'directory' | 'runtime';\n  confidence: number;      // é‡è¦æ€§è¯„åˆ†\n  useCount: number;        // ä½¿ç”¨æ¬¡æ•°\n  lastUsed: number;        // æœ€åä½¿ç”¨æ—¶é—´æˆ³\n  tags?: string[];         // æ ‡ç­¾\n  projectScope?: string;   // é¡¹ç›®ä½œç”¨åŸŸ\n  source?: 'project' | 'global' | 'external'; // ä¸Šä¸‹æ–‡æ¥æº\n}\n\nexport interface BankQueryOptions {\n  input?: string;          // ç”¨æˆ·è¾“å…¥ï¼Œç”¨äºç›¸å…³æ€§åŒ¹é…\n  projectScope?: string;   // é¡¹ç›®ä½œç”¨åŸŸè¿‡æ»¤\n  strategy?: 'ranked' | 'recent' | 'relevance'; // æŸ¥è¯¢ç­–ç•¥\n  limit?: number;          // é™åˆ¶è¿”å›æ•°é‡\n  tags?: string[];         // æ ‡ç­¾è¿‡æ»¤\n}\n\nexport interface BankStats {\n  totalItems: number;\n  totalTokens: number;\n  lastUpdated: number;\n  usageLogSize: number;\n}\n\nexport class ContextBank {\n  private bankDir: string;\n  private indexPath: string;\n  private itemsDir: string;\n  private snapshotsDir: string;\n  private statsDir: string;\n\n  constructor(bankPath?: string) {\n    this.bankDir = bankPath || path.join(require('os').homedir(), '.yuangs', 'context-bank');\n    this.indexPath = path.join(this.bankDir, 'index.json');\n    this.itemsDir = path.join(this.bankDir, 'items');\n    this.snapshotsDir = path.join(this.bankDir, 'snapshots');\n    this.statsDir = path.join(this.bankDir, 'stats');\n  }\n\n  /**\n   * åˆå§‹åŒ– Context Bank\n   */\n  async initialize(): Promise<void> {\n    await fs.mkdir(this.bankDir, { recursive: true });\n    await fs.mkdir(this.itemsDir, { recursive: true });\n    await fs.mkdir(this.snapshotsDir, { recursive: true });\n    await fs.mkdir(this.statsDir, { recursive: true });\n\n    // åˆå§‹åŒ–ç´¢å¼•æ–‡ä»¶\n    try {\n      await fs.access(this.indexPath);\n    } catch {\n      // å¦‚æœç´¢å¼•æ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªç©ºçš„\n      await this.saveIndex([]);\n    }\n  }\n\n  /**\n   * ä» ContextBuffer å¯¼å‡ºé«˜ä»·å€¼ä¸Šä¸‹æ–‡åˆ°é“¶è¡Œ\n   */\n  async exportFromContextBuffer(contextBuffer: { export(): ContextItem[] }, projectScope?: string): Promise<void> {\n    const items = contextBuffer.export();\n    const highValueItems = this.filterHighValueItems(items);\n\n    for (const item of highValueItems) {\n      // æ·»åŠ é¡¹ç›®ä½œç”¨åŸŸä¿¡æ¯\n      const bankItem: BankContextItem = {\n        ...item,\n        id: `bank_${randomUUID()}`,\n        stableId: item.stableId || item.path, // ç¡®ä¿ stableId å­˜åœ¨\n        source: projectScope ? 'project' : 'global',\n        projectScope,\n        firstSeenAt: Date.now(),\n        lastUsedAt: Date.now()\n      };\n\n      await this.upsertItem(bankItem);\n    }\n  }\n\n  /**\n   * è¿‡æ»¤é«˜ä»·å€¼ ContextItem\n   */\n  private filterHighValueItems(items: ContextItem[]): ContextItem[] {\n    return items.filter(item => {\n      if (!item.importance) return false;\n\n      const { useCount, successCount } = item.importance;\n      const totalInteractions = useCount + item.importance.failureCount;\n      const successRate = totalInteractions > 0 ? successCount / totalInteractions : 0;\n\n      // è§¦å‘æ¡ä»¶ï¼šä½¿ç”¨æ¬¡æ•°â‰¥3 ä¸” æˆåŠŸç‡â‰¥0.6\n      return useCount >= 3 && successRate >= 0.6;\n    });\n  }\n\n  /**\n   * æ’å…¥æˆ–æ›´æ–°é“¶è¡Œä¸­çš„é¡¹ç›®\n   */\n  async upsertItem(item: BankContextItem): Promise<void> {\n    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒ stableId çš„é¡¹ç›®\n    const existingItems = await this.loadIndex();\n    const existingIndex = existingItems.findIndex(idx => idx.stableId === item.stableId);\n\n    if (existingIndex !== -1) {\n      // æ›´æ–°ç°æœ‰é¡¹ç›®\n      const existingItemPath = path.join(this.itemsDir, `${existingItems[existingIndex].id}.json`);\n      const existingItem: BankContextItem = JSON.parse(await fs.readFile(existingItemPath, 'utf-8'));\n\n      // åˆå¹¶é‡è¦æ€§ç»Ÿè®¡\n      if (item.importance && existingItem.importance) {\n        existingItem.importance.useCount += item.importance.useCount;\n        existingItem.importance.successCount += item.importance.successCount;\n        existingItem.importance.failureCount += item.importance.failureCount;\n        existingItem.importance.confidence = Math.max(\n          existingItem.importance.confidence,\n          item.importance.confidence\n        );\n      }\n\n      // æ›´æ–°æœ€åä½¿ç”¨æ—¶é—´\n      existingItem.lastUsedAt = Math.max(existingItem.lastUsedAt, item.lastUsedAt);\n      \n      // æ›´æ–°å†…å®¹ï¼ˆå¦‚æœå†…å®¹ä¸åŒï¼‰\n      if (item.content !== existingItem.content) {\n        existingItem.content = item.content;\n        existingItem.tokens = item.tokens;\n        existingItem.summary = item.summary;\n        existingItem.summarized = item.summarized;\n      }\n\n      // ä¿å­˜æ›´æ–°åçš„é¡¹ç›®\n      await fs.writeFile(existingItemPath, JSON.stringify(existingItem, null, 2));\n      \n      // æ›´æ–°ç´¢å¼•\n      existingItems[existingIndex] = {\n        id: existingItem.id,\n        path: existingItem.path,\n        stableId: existingItem.stableId,\n        type: existingItem.type,\n        confidence: computeContextImportance(existingItem.importance!),\n        useCount: existingItem.importance?.useCount || 0,\n        lastUsed: existingItem.lastUsedAt,\n        tags: existingItem.tags,\n        projectScope: existingItem.projectScope\n      };\n    } else {\n      // æ·»åŠ æ–°é¡¹ç›®\n      const itemId = item.id || `bank_${randomUUID()}`;\n      const itemPath = path.join(this.itemsDir, `${itemId}.json`);\n\n      await fs.writeFile(itemPath, JSON.stringify(item, null, 2));\n\n      // æ·»åŠ åˆ°ç´¢å¼•\n      const indexEntry: BankIndexEntry = {\n        id: itemId,\n        path: item.path,\n        stableId: item.stableId,\n        type: item.type,\n        confidence: computeContextImportance(item.importance!),\n        useCount: item.importance?.useCount || 0,\n        lastUsed: item.lastUsedAt,\n        tags: item.tags,\n        projectScope: item.projectScope\n      };\n\n      existingItems.push(indexEntry);\n    }\n\n    await this.saveIndex(existingItems);\n  }\n\n  /**\n   * æ ¹æ®æŸ¥è¯¢é€‰é¡¹ä»é“¶è¡Œæ£€ç´¢ä¸Šä¸‹æ–‡\n   */\n  async query(options: BankQueryOptions): Promise<BankContextItem[]> {\n    const index = await this.loadIndex();\n    let filteredIndex = [...index];\n\n    // è¿‡æ»¤é¡¹ç›®ä½œç”¨åŸŸ\n    if (options.projectScope) {\n      filteredIndex = filteredIndex.filter(item => \n        item.projectScope === options.projectScope || item.source === 'global'\n      );\n    }\n\n    // è¿‡æ»¤æ ‡ç­¾\n    if (options.tags && options.tags.length > 0) {\n      filteredIndex = filteredIndex.filter(item => \n        item.tags && options.tags?.every(tag => item.tags?.includes(tag))\n      );\n    }\n\n    // æ ¹æ®ç­–ç•¥æ’åº\n    switch (options.strategy || 'ranked') {\n      case 'ranked':\n        filteredIndex.sort((a, b) => b.confidence - a.confidence);\n        break;\n      case 'recent':\n        filteredIndex.sort((a, b) => b.lastUsed - a.lastUsed);\n        break;\n      case 'relevance':\n        // ç®€å•çš„ç›¸å…³æ€§è®¡ç®—ï¼šåŸºäºè·¯å¾„åŒ¹é…\n        if (options.input) {\n          filteredIndex.sort((a, b) => {\n            const aRelevance = this.calculateRelevance(a.path, options.input!);\n            const bRelevance = this.calculateRelevance(b.path, options.input!);\n            return bRelevance - aRelevance;\n          });\n        }\n        break;\n    }\n\n    // é™åˆ¶è¿”å›æ•°é‡\n    if (options.limit) {\n      filteredIndex = filteredIndex.slice(0, options.limit);\n    }\n\n    // åŠ è½½åŒ¹é…çš„é¡¹ç›®\n    const results: BankContextItem[] = [];\n    for (const entry of filteredIndex) {\n      try {\n        const itemPath = path.join(this.itemsDir, `${entry.id}.json`);\n        const item: BankContextItem = JSON.parse(await fs.readFile(itemPath, 'utf-8'));\n        results.push(item);\n      } catch (error) {\n        console.warn(`[ContextBank] Failed to load item ${entry.id}:`, error);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * è®¡ç®—è·¯å¾„ä¸è¾“å…¥çš„ç›¸å…³æ€§\n   */\n  private calculateRelevance(itemPath: string, input: string): number {\n    const pathLower = itemPath.toLowerCase();\n    const inputLower = input.toLowerCase();\n    \n    // è®¡ç®—å…³é”®è¯åŒ¹é…åº¦\n    const inputWords = inputLower.split(/\\W+/).filter(Boolean);\n    const matches = inputWords.filter(word => pathLower.includes(word)).length;\n    \n    return matches / inputWords.length; // è¿”å›åŒ¹é…æ¯”ä¾‹\n  }\n\n  /**\n   * åŠ è½½ç´¢å¼•\n   */\n  private async loadIndex(): Promise<BankIndexEntry[]> {\n    try {\n      const content = await fs.readFile(this.indexPath, 'utf-8');\n      const data = JSON.parse(content);\n\n      if (!data || data.version !== '1.0' || !Array.isArray(data.items)) {\n        throw new Error('Invalid ContextBank index format');\n      }\n\n      return data.items;\n    } catch (error) {\n      console.warn(`[ContextBank] Failed to load index:`, error);\n      return [];\n    }\n  }\n\n  /**\n   * ä¿å­˜ç´¢å¼•\n   */\n  private async saveIndex(index: BankIndexEntry[]): Promise<void> {\n    const data = {\n      version: '1.0',\n      updatedAt: Date.now(),\n      items: index\n    };\n    await fs.writeFile(this.indexPath, JSON.stringify(data, null, 2));\n  }\n\n  /**\n   * è·å–é“¶è¡Œç»Ÿè®¡ä¿¡æ¯\n   */\n  async getStats(): Promise<BankStats> {\n    const index = await this.loadIndex();\n    let totalTokens = 0;\n\n    for (const entry of index) {\n      try {\n        const itemPath = path.join(this.itemsDir, `${entry.id}.json`);\n        const item: BankContextItem = JSON.parse(await fs.readFile(itemPath, 'utf-8'));\n        totalTokens += item.tokens;\n      } catch (error) {\n        console.warn(`[ContextBank] Failed to load item for stats ${entry.id}:`, error);\n      }\n    }\n\n    // è·å–ä½¿ç”¨æ—¥å¿—å¤§å°\n    let usageLogSize = 0;\n    try {\n      const usageLogPath = path.join(this.statsDir, 'usage.log');\n      const stat = await fs.stat(usageLogPath);\n      usageLogSize = stat.size;\n    } catch {\n      // å¦‚æœæ—¥å¿—æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå¤§å°ä¸º0\n    }\n\n    return {\n      totalItems: index.length,\n      totalTokens,\n      lastUpdated: Date.now(), // å®é™…ä¸Šåº”è¯¥æ˜¯ç´¢å¼•æ–‡ä»¶çš„ä¿®æ”¹æ—¶é—´\n      usageLogSize\n    };\n  }\n\n  /**\n   * åˆ›å»ºé“¶è¡Œå¿«ç…§\n   */\n  async createSnapshot(name?: string): Promise<string> {\n    const snapshotName = name || `snapshot_${Date.now()}`;\n    const snapshotPath = path.join(this.snapshotsDir, `${snapshotName}.json`);\n    \n    const index = await this.loadIndex();\n    const snapshot = {\n      name: snapshotName,\n      createdAt: Date.now(),\n      items: [] as BankContextItem[]\n    };\n\n    for (const entry of index) {\n      try {\n        const itemPath = path.join(this.itemsDir, `${entry.id}.json`);\n        const item: BankContextItem = JSON.parse(await fs.readFile(itemPath, 'utf-8'));\n        snapshot.items.push(item);\n      } catch (error) {\n        console.warn(`[ContextBank] Failed to load item for snapshot ${entry.id}:`, error);\n      }\n    }\n\n    await fs.writeFile(snapshotPath, JSON.stringify(snapshot, null, 2));\n    return snapshotPath;\n  }\n\n  /**\n   * ä»å¿«ç…§æ¢å¤é“¶è¡Œ\n   */\n  async restoreFromSnapshot(snapshotName: string): Promise<void> {\n    const snapshotPath = path.join(this.snapshotsDir, `${snapshotName}.json`);\n    const snapshotContent = await fs.readFile(snapshotPath, 'utf-8');\n    const snapshot = JSON.parse(snapshotContent);\n\n    // æ¸…ç©ºå½“å‰é¡¹ç›®\n    const files = await fs.readdir(this.itemsDir);\n    for (const file of files) {\n      if (file.endsWith('.json')) {\n        await fs.unlink(path.join(this.itemsDir, file));\n      }\n    }\n\n    // æ¢å¤é¡¹ç›®\n    for (const item of snapshot.items) {\n      const itemPath = path.join(this.itemsDir, `${item.id}.json`);\n      await fs.writeFile(itemPath, JSON.stringify(item, null, 2));\n    }\n\n    // é‡å»ºç´¢å¼•\n    const newIndex: BankIndexEntry[] = snapshot.items.map((item: BankContextItem) => ({\n      id: item.id,\n      path: item.path,\n      type: item.type,\n      confidence: computeContextImportance(item.importance!),\n      useCount: item.importance?.useCount || 0,\n      lastUsed: item.lastUsedAt,\n      tags: item.tags,\n      projectScope: item.projectScope\n    }));\n\n    await this.saveIndex(newIndex);\n  }\n\n  /**\n   * è®°å½•ä½¿ç”¨æƒ…å†µ\n   */\n  async recordUsage(identifier: string, success: boolean): Promise<void> {\n    // é¦–å…ˆå°è¯•æŒ‰ ID æŸ¥æ‰¾é¡¹ç›®\n    let itemPath = path.join(this.itemsDir, `${identifier}.json`);\n    let itemExists = false;\n    let actualId = identifier;\n\n    try {\n      await fs.access(itemPath);\n      itemExists = true;\n    } catch {\n      // ID ä¸å­˜åœ¨ï¼Œå°è¯•æŒ‰è·¯å¾„æŸ¥æ‰¾\n      const index = await this.loadIndex();\n      let indexEntry = index.find(entry => entry.path === identifier);\n\n      // å¦‚æœè¿˜æ˜¯æ‰¾ä¸åˆ°ï¼Œå°è¯•æŒ‰ stableId æŸ¥æ‰¾\n      if (!indexEntry) {\n        indexEntry = index.find(entry => entry.stableId === identifier);\n      }\n\n      if (indexEntry) {\n        itemPath = path.join(this.itemsDir, `${indexEntry.id}.json`);\n        actualId = indexEntry.id; // ä½¿ç”¨å®é™…çš„ ID\n        itemExists = true;\n      }\n    }\n\n    if (!itemExists) {\n      console.warn(`[ContextBank] Item with identifier \"${identifier}\" not found`);\n      return;\n    }\n\n    try {\n      const item: BankContextItem = JSON.parse(await fs.readFile(itemPath, 'utf-8'));\n\n      if (item.importance) {\n        item.importance.useCount++;\n        if (success) {\n          item.importance.successCount++;\n          item.importance.confidence = Math.min(1, item.importance.confidence + 0.05);\n        } else {\n          item.importance.failureCount++;\n          item.importance.confidence = Math.max(0, item.importance.confidence - 0.1);\n        }\n        item.lastUsedAt = Date.now();\n      }\n\n      await fs.writeFile(itemPath, JSON.stringify(item, null, 2));\n\n      // æ›´æ–°ç´¢å¼•\n      const index = await this.loadIndex();\n      const indexEntry = index.find(entry => entry.id === actualId);\n      if (indexEntry) {\n        indexEntry.useCount = item.importance?.useCount || 0;\n        indexEntry.lastUsed = item.lastUsedAt;\n        indexEntry.confidence = computeContextImportance(item.importance!);\n        await this.saveIndex(index);\n      }\n    } catch (error) {\n      console.warn(`[ContextBank] Failed to update usage for item ${identifier}:`, error);\n    }\n\n    // è®°å½•åˆ°ä½¿ç”¨æ—¥å¿—\n    const logPath = path.join(this.statsDir, 'usage.log');\n    const logEntry = {\n      timestamp: Date.now(),\n      itemId: actualId,\n      success,\n      userAgent: 'ContextBank/v1'\n    };\n\n    try {\n      await fs.appendFile(logPath, JSON.stringify(logEntry) + '\\n');\n    } catch (error) {\n      console.warn('[ContextBank] Failed to write to usage log:', error);\n    }\n  }\n\n  /**\n   * æ¸…ç†è¿‡æœŸæˆ–ä½ä»·å€¼é¡¹ç›®\n   */\n  async cleanup(options: {\n    minConfidence?: number;\n    maxAgeDays?: number;\n    dryRun?: boolean\n  } = {}): Promise<number> {\n    const {\n      minConfidence = 0.3,\n      maxAgeDays = 180,\n      dryRun = false\n    } = options;\n\n    const index = await this.loadIndex();\n    const cutoffTime = Date.now() - (maxAgeDays * 24 * 60 * 60 * 1000);\n    let cleanedCount = 0;\n\n    const remainingIndex: BankIndexEntry[] = [];\n\n    for (const entry of index) {\n      try {\n        const itemPath = path.join(this.itemsDir, `${entry.id}.json`);\n        const item: BankContextItem = JSON.parse(await fs.readFile(itemPath, 'utf-8'));\n\n        // æ£€æŸ¥æ˜¯å¦åº”è¯¥ä¿ç•™è¯¥é¡¹ç›®\n        const isHighConfidence = entry.confidence >= minConfidence;\n        const isRecentlyUsed = entry.lastUsed >= cutoffTime;\n        const isFrozen = item.frozen === true;\n        const isDeprecated = item.deprecated === true;\n\n        const shouldKeep = isHighConfidence || isRecentlyUsed || isFrozen || isDeprecated;\n\n        if (!shouldKeep && !dryRun) {\n          // åˆ é™¤é¡¹ç›®æ–‡ä»¶\n          await fs.unlink(itemPath);\n          cleanedCount++;\n        } else {\n          // ä¿ç•™é¡¹ç›®\n          remainingIndex.push(entry);\n        }\n      } catch (error) {\n        console.warn(`[ContextBank] Failed to evaluate item for cleanup ${entry.id}:`, error);\n        // å¦‚æœæ— æ³•è¯»å–é¡¹ç›®ï¼Œä¿ç•™å®ƒä»¥é˜²ä¸‡ä¸€\n        remainingIndex.push(entry);\n      }\n    }\n\n    if (!dryRun) {\n      await this.saveIndex(remainingIndex);\n    }\n\n    return cleanedCount;\n  }\n}",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/contextBank.ts:1769101059020",
    "tokens": 3986,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/contextBuffer.ts",
    "content": "import { randomUUID } from 'crypto';\nimport { ContextImportance, createContextImportance, computeContextImportance } from './contextImportance';\nimport { summarizeContext } from './contextSummary';\nimport { ExtendedContextProtocol, DSLQueryEngine, DSLParser } from './contextDSL';\nimport { recordEdge } from './knowledgeGraph';\nimport crypto from 'crypto';\n\nfunction computeStableId(item: {\n  path: string;\n  semantic?: string;\n  content: string;\n}) {\n  const sig = `${item.path}::${item.semantic ?? ''}::${item.content.slice(0, 512)}`;\n  return crypto.createHash('sha256').update(sig).digest('hex');\n}\n\nexport type ContextItem = {\n    schemaVersion?: 1; // Schema ç‰ˆæœ¬\n    type: 'file' | 'directory';\n    path: string;\n    id?: string;\n    stableId?: string;   // ç¨³å®šèº«ä»½ï¼ˆè·¨ sessionï¼‰\n    importance?: ContextImportance;\n    alias?: string;\n    content: string;\n    summary?: string;\n    summarized?: boolean;\n    tokens: number;\n    // å¼•ç”¨åè®®ç›¸å…³å­—æ®µ\n    semantic?: 'source_code' | 'log' | 'config' | 'decision' | 'evidence' | 'documentation' | 'test' | 'requirement';\n    summaryQuality?: number; // æ‘˜è¦è´¨é‡è¯„åˆ† (0-1)\n    summarySourceHash?: string; // æ‘˜è¦æ¥æºå†…å®¹çš„å“ˆå¸Œå€¼\n    referencedBy?: string[]; // å¼•ç”¨æ­¤ContextItemçš„AIå“åº”IDåˆ—è¡¨\n    usageStats?: {\n        referencedCount: number; // è¢«æ˜¾å¼å¼•ç”¨çš„æ¬¡æ•°\n        verifiedUseful: number; // ç»éªŒè¯æœ‰ç”¨çš„å¼•ç”¨æ¬¡æ•°\n        verifiedNotUseful: number; // ç»éªŒè¯æ— ç”¨çš„å¼•ç”¨æ¬¡æ•°\n    };\n    tags?: string[]; // æ ‡ç­¾\n    projectScope?: string; // é¡¹ç›®ä½œç”¨åŸŸ\n    metadata?: {\n        promotedToSkill?: boolean;\n        bankItemId?: string;\n        source?: string;\n    }; // å…ƒæ•°æ®\n};\n\nexport type InjectionStrategy = 'ranked' | 'recent' | 'all';\n\nexport interface BuildPromptOptions {\n  maxTokens?: number;\n  strategy?: InjectionStrategy;\n}\n\nconst estimateTokens = (text: string) => Math.ceil(text.length / 4);\n\nexport class ContextBuffer {\n    private items: ContextItem[] = [];\n    private maxTokens = 32000; // çº¦ 12.8 ä¸‡å­—ç¬¦\n\n    async addAsync(item: Omit<ContextItem, 'tokens'>, bypassTokenLimit: boolean = false) {\n        const tokens = estimateTokens(item.content);\n        this.items.push({\n            ...item,\n            schemaVersion: item.schemaVersion ?? 1,\n            stableId: item.stableId ?? computeStableId(item),\n            id: item.id ?? randomUUID(),\n            importance: item.importance ?? createContextImportance(item.path, item.type),\n            tokens,\n            usageStats: item.usageStats ?? {\n                referencedCount: 0,\n                verifiedUseful: 0,\n                verifiedNotUseful: 0\n            }\n        });\n        if (!bypassTokenLimit) {\n            await this.trimIfNeeded();\n        }\n    }\n\n    add(item: Omit<ContextItem, 'tokens'>, bypassTokenLimit: boolean = false) {\n        const tokens = estimateTokens(item.content);\n        this.items.push({\n            ...item,\n            schemaVersion: item.schemaVersion ?? 1,\n            stableId: item.stableId ?? computeStableId(item),\n            id: item.id ?? randomUUID(),\n            importance: item.importance ?? createContextImportance(item.path, item.type),\n            tokens,\n            usageStats: item.usageStats ?? {\n                referencedCount: 0,\n                verifiedUseful: 0,\n                verifiedNotUseful: 0\n            }\n        });\n        if (!bypassTokenLimit) {\n            // å¯¹äºåŒæ­¥æ–¹æ³•ï¼Œæˆ‘ä»¬åªåšåŸºæœ¬ä¿®å‰ªï¼ˆä¸è¿›è¡Œæ‘˜è¦ï¼‰\n            this.basicTrimIfNeeded();\n        }\n    }\n\n    private basicTrimIfNeeded() {\n        while (this.totalTokens() > this.maxTokens) {\n            // æŒ‰é‡è¦æ€§è¯„åˆ†æ’åºï¼Œä½é‡è¦æ€§çš„åœ¨å‰é¢\n            this.items.sort((a, b) =>\n                computeContextImportance(a.importance!) -\n                computeContextImportance(b.importance!)\n            );\n\n            const removed = this.items.shift();\n\n            if (removed) {\n                console.log(\n                    `[Context Trim] removed low-importance: ${removed.path}`\n                );\n            }\n        }\n    }\n\n    clear() {\n        this.items = [];\n    }\n\n    list() {\n        return this.items.map((item, i) => ({\n            index: i + 1,\n            type: item.type,\n            path: item.path,\n            alias: item.alias,\n            tokens: item.tokens,\n            summary: item.summary\n        }));\n    }\n\n    isEmpty() {\n        return this.items.length === 0;\n    }\n\n    export() {\n        return this.items;\n    }\n\n    import(items: ContextItem[]) {\n        this.items = items;\n    }\n\n    private totalTokens() {\n        return this.items.reduce((sum, i) => sum + i.tokens, 0);\n    }\n\n    private async trimIfNeeded() {\n        while (this.totalTokens() > this.maxTokens) {\n            // 1. æ‰¾ä¸€ä¸ªã€Œå°šæœª summaryã€ä¸”é‡è¦æ€§æœ€ä½çš„\n            const candidates = this.items\n                .filter(i => !i.summarized)\n                .sort((a, b) =>\n                    computeContextImportance(a.importance!) -\n                    computeContextImportance(b.importance!)\n                );\n\n            if (candidates.length > 0) {\n                const candidate = candidates[0];\n\n                // 2. æ‰§è¡Œ summary\n                try {\n                    const summary = await summarizeContext({\n                        type: candidate.type,\n                        path: candidate.path,\n                        content: candidate.content\n                    });\n\n                    candidate.summary = summary;\n                    candidate.summarized = true;\n\n                    // 3. ç”¨ summary é‡æ–°è®¡ç®— token\n                    candidate.tokens = estimateTokens(summary);\n\n                    // 4. é‡Šæ”¾åŸå§‹å†…å®¹ä»¥èŠ‚çœå†…å­˜ï¼ˆä¿ç•™åŸå§‹å†…å®¹çš„æ ‡è®°ï¼‰\n                    const originalContentSize = estimateTokens(candidate.content);\n                    candidate.content = `[ARCHIVED: Original content was ${originalContentSize} tokens, summarized to ${candidate.tokens} tokens]`;\n\n                    console.log(\n                        `[Context Summary] ${candidate.path} reduced from ${originalContentSize} to ${candidate.tokens} tokens`\n                    );\n\n                    continue; // é‡æ–°è¯„ä¼°tokenæ•°é‡\n                } catch (error) {\n                    console.warn(`[Context Summary] Failed to summarize ${candidate.path}:`, error);\n                }\n            }\n\n            // å¦‚æœæ²¡æœ‰å¯æ‘˜è¦çš„é¡¹æˆ–æ‘˜è¦å¤±è´¥ï¼Œåˆ™æŒ‰é‡è¦æ€§åˆ é™¤\n            this.items.sort((a, b) =>\n                computeContextImportance(a.importance!) -\n                computeContextImportance(b.importance!)\n            );\n\n            const removed = this.items.shift();\n\n            if (removed) {\n                console.log(\n                    `[Context Trim] removed low-importance: ${removed.path}`\n                );\n            }\n        }\n    }\n\n    /**\n     * è®°å½•ContextItemè¢«æ˜¾å¼å¼•ç”¨\n     * @param path ContextItemçš„è·¯å¾„\n     * @param responseId å¼•ç”¨è¯¥ContextItemçš„AIå“åº”ID\n     */\n    recordExplicitReference(path: string, responseId?: string) {\n        const item = this.items.find(i => i.path === path);\n        if (item) {\n            if (!item.usageStats) {\n                item.usageStats = {\n                    referencedCount: 0,\n                    verifiedUseful: 0,\n                    verifiedNotUseful: 0\n                };\n            }\n            item.usageStats.referencedCount++;\n\n            if (responseId) {\n                if (!item.referencedBy) {\n                    item.referencedBy = [];\n                }\n                if (!item.referencedBy.includes(responseId)) {\n                    item.referencedBy.push(responseId);\n                }\n\n                // === C5-B-1: Knowledge Graph Record (Context -> Execution) ===\n                if (item.id) {\n                    recordEdge({\n                        from: item.id,\n                        to: responseId, // ä½¿ç”¨ AI å“åº” ID ä½œä¸ºæ‰§è¡ŒèŠ‚ç‚¹çš„ä»£ç† ID\n                        type: 'used_in',\n                        timestamp: Date.now(),\n                        meta: { path: item.path, type: item.type }\n                    });\n                }\n            }\n\n            // åŒæ—¶æ›´æ–°importanceä¸­çš„useCount\n            if (item.importance) {\n                item.importance.useCount++;\n                item.importance.lastUsed = Date.now();\n            }\n        }\n    }\n\n    /**\n     * éªŒè¯ContextItemå¼•ç”¨çš„æœ‰æ•ˆæ€§\n     * @param path ContextItemçš„è·¯å¾„\n     * @param wasUseful å¼•ç”¨æ˜¯å¦è¢«è¯æ˜æœ‰ç”¨\n     */\n    validateReference(path: string, wasUseful: boolean) {\n        const item = this.items.find(i => i.path === path);\n        if (item && item.usageStats) {\n            if (wasUseful) {\n                item.usageStats.verifiedUseful++;\n            } else {\n                item.usageStats.verifiedNotUseful++;\n            }\n        }\n    }\n\n    /**\n     * è®¡ç®—ContextItemçš„ç»¼åˆè¯„åˆ†\n     * @param item ContextItem\n     * @returns è¯„åˆ†å€¼\n     */\n    private computeItemScore(item: ContextItem): number {\n        if (!item.importance) {\n            // å¦‚æœæ²¡æœ‰é‡è¦æ€§ä¿¡æ¯ï¼Œé»˜è®¤ä¸ºä¸­ç­‰è¯„åˆ†\n            return 0.5;\n        }\n\n        const baseScore = computeContextImportance(item.importance);\n\n        // ä½¿ç”¨æ¬¡æ•°çš„å½±å“ï¼ˆå¯¹æ•°å¢é•¿ï¼Œé¿å…è¿‡åº¦æ”¾å¤§ï¼‰\n        const useFactor = Math.log(1 + item.importance.useCount);\n\n        // æ–°é²œåº¦è¡°å‡ï¼ˆæœ€è¿‘ä½¿ç”¨çš„é¡¹ç›®è·å¾—æ›´é«˜è¯„åˆ†ï¼‰\n        const now = Date.now();\n        const daysSinceLastUse = (now - item.importance.lastUsed) / (1000 * 60 * 60 * 24);\n        const freshnessFactor = Math.exp(-daysSinceLastUse / 7); // 7å¤©åŠè¡°æœŸ\n\n        // æ˜¾å¼å¼•ç”¨çš„å½±å“\n        const explicitReferenceFactor = item.usageStats ?\n            Math.log(1 + item.usageStats.referencedCount) : 0;\n\n        return baseScore * useFactor * freshnessFactor * (1 + explicitReferenceFactor * 0.1);\n    }\n\n    /**\n     * æ ¹æ®ç­–ç•¥å¯¹ContextItemsè¿›è¡Œæ’åº\n     * @param items ContextItemæ•°ç»„\n     * @param strategy æ’åºç­–ç•¥\n     * @returns æ’åºåçš„æ•°ç»„\n     */\n    private sortItemsByStrategy(items: ContextItem[], strategy: InjectionStrategy): ContextItem[] {\n        switch (strategy) {\n            case 'ranked':\n                // æŒ‰ç»¼åˆè¯„åˆ†é™åºæ’åˆ—\n                return [...items].sort((a, b) =>\n                    this.computeItemScore(b) - this.computeItemScore(a)\n                );\n            case 'recent':\n                // æŒ‰æœ€è¿‘ä½¿ç”¨æ—¶é—´é™åºæ’åˆ—\n                return [...items].sort((a, b) =>\n                    (b.importance?.lastUsed || 0) - (a.importance?.lastUsed || 0)\n                );\n            case 'all':\n            default:\n                // ä¿æŒåŸæœ‰é¡ºåº\n                return [...items];\n        }\n    }\n\n    buildPrompt(userInput: string, options: BuildPromptOptions = {}): string {\n        const { maxTokens, strategy = 'ranked' } = options;\n\n        if (this.isEmpty()) return userInput;\n\n        // æ ¹æ®ç­–ç•¥æ’åºitems\n        const sortedItems = this.sortItemsByStrategy([...this.items], strategy);\n\n        // å¦‚æœæŒ‡å®šäº†maxTokensï¼Œæˆ‘ä»¬éœ€è¦æˆªæ–­å†…å®¹ä»¥æ»¡è¶³é™åˆ¶\n        let filteredItems = sortedItems;\n        if (maxTokens) {\n            filteredItems = [];\n            let currentTokens = 0;\n\n            for (const item of sortedItems) {\n                if (currentTokens + item.tokens > maxTokens) {\n                    break;\n                }\n                filteredItems.push(item);\n                currentTokens += item.tokens;\n            }\n        }\n\n        // æŒ‰é‡è¦æ€§å’Œè¯­ä¹‰ç±»å‹åˆ†ç»„\n        const highConfidenceItems = filteredItems.filter(item =>\n            item.importance && computeContextImportance(item.importance) > 0.7\n        );\n        const mediumConfidenceItems = filteredItems.filter(item =>\n            item.importance &&\n            computeContextImportance(item.importance) > 0.3 &&\n            computeContextImportance(item.importance) <= 0.7\n        );\n        const lowConfidenceItems = filteredItems.filter(item =>\n            !item.importance || computeContextImportance(item.importance) <= 0.3\n        );\n\n        // æ„å»ºä¸åŒéƒ¨åˆ†çš„ä¸Šä¸‹æ–‡\n        const sections = [];\n\n        if (highConfidenceItems.length > 0) {\n            // æŒ‰è¯­ä¹‰ç±»å‹è¿›ä¸€æ­¥ç»†åˆ†é«˜ç½®ä¿¡åº¦é¡¹\n            const semanticGroups: Record<string, typeof highConfidenceItems> = {};\n            for (const item of highConfidenceItems) {\n                const semantic = item.semantic || 'other';\n                if (!semanticGroups[semantic]) {\n                    semanticGroups[semantic] = [];\n                }\n                semanticGroups[semantic].push(item);\n            }\n\n            for (const [semantic, items] of Object.entries(semanticGroups)) {\n                const semanticBlock = items.map(item => {\n                    const title = item.alias\n                        ? `[Reference] ${item.type}: ${item.alias} (${item.path})`\n                        : `[Reference] ${item.type}: ${item.path}`;\n\n                    const body = item.summary ?? item.content;\n\n                    return `${title}\\n---\\n${body}\\n---`;\n                }).join('\\n\\n');\n\n                sections.push(`# Background Knowledge (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - High Confidence)\\n${semanticBlock}`);\n            }\n        }\n\n        if (mediumConfidenceItems.length > 0) {\n            // æŒ‰è¯­ä¹‰ç±»å‹è¿›ä¸€æ­¥ç»†åˆ†ä¸­ç½®ä¿¡åº¦é¡¹\n            const semanticGroups: Record<string, typeof mediumConfidenceItems> = {};\n            for (const item of mediumConfidenceItems) {\n                const semantic = item.semantic || 'other';\n                if (!semanticGroups[semantic]) {\n                    semanticGroups[semantic] = [];\n                }\n                semanticGroups[semantic].push(item);\n            }\n\n            for (const [semantic, items] of Object.entries(semanticGroups)) {\n                const semanticBlock = items.map(item => {\n                    const title = item.alias\n                        ? `[Reference] ${item.type}: ${item.alias} (${item.path})`\n                        : `[Reference] ${item.type}: ${item.path}`;\n\n                    const body = item.summary ?? item.content;\n\n                    return `${title}\\n---\\n${body}\\n---`;\n                }).join('\\n\\n');\n\n                sections.push(`# Supporting Information (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - Medium Confidence)\\n${semanticBlock}`);\n            }\n        }\n\n        if (lowConfidenceItems.length > 0) {\n            // æŒ‰è¯­ä¹‰ç±»å‹è¿›ä¸€æ­¥ç»†åˆ†ä½ç½®ä¿¡åº¦é¡¹\n            const semanticGroups: Record<string, typeof lowConfidenceItems> = {};\n            for (const item of lowConfidenceItems) {\n                const semantic = item.semantic || 'other';\n                if (!semanticGroups[semantic]) {\n                    semanticGroups[semantic] = [];\n                }\n                semanticGroups[semantic].push(item);\n            }\n\n            for (const [semantic, items] of Object.entries(semanticGroups)) {\n                const semanticBlock = items.map(item => {\n                    const title = item.alias\n                        ? `[Reference] ${item.type}: ${item.alias} (${item.path})`\n                        : `[Reference] ${item.type}: ${item.path}`;\n\n                    const body = item.summary ?? item.content;\n\n                    return `${title}\\n---\\n${body}\\n---`;\n                }).join('\\n\\n');\n\n                sections.push(`# Archived References (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - Low Confidence)\\n${semanticBlock}`);\n            }\n        }\n\n        const contextBlock = sections.join('\\n\\n');\n\n        return `\n${contextBlock}\n\n# Task Instructions\nBased on the provided context (if any), answer the user's question. If the context contains source code, treat it as your \"source of truth.\"\n\nUser Question:\n${userInput}\n`;\n    }\n\n    /**\n     * ä½¿ç”¨ DSL æŸ¥è¯¢ä¸Šä¸‹æ–‡\n     */\n    async queryDSL(dslQuery: string, contextBank?: import('./contextBank').ContextBank): Promise<ContextItem[]> {\n        const parsedQuery = DSLParser.parse(dslQuery);\n        const engine = new DSLQueryEngine(this.items);\n        const result = engine.execute(parsedQuery);\n\n        let matchingItems = result.items;\n\n        // å¦‚æœæä¾›äº† ContextBankï¼Œä¹ŸæŸ¥è¯¢é“¶è¡Œä¸­çš„é¡¹ç›®\n        if (contextBank) {\n            try {\n                // å°† DSL æŸ¥è¯¢è½¬æ¢ä¸º ContextBank æŸ¥è¯¢é€‰é¡¹\n                const bankQueryOptions: import('./contextBank').BankQueryOptions = {\n                    input: dslQuery,\n                    strategy: 'relevance',\n                    limit: 10 // é™åˆ¶ä»é“¶è¡Œè¿”å›çš„æ•°é‡\n                };\n\n                // æ‰§è¡Œé“¶è¡ŒæŸ¥è¯¢\n                const bankResults = await contextBank.query(bankQueryOptions);\n                matchingItems = [...matchingItems, ...bankResults];\n            } catch (error) {\n                console.warn(`[ContextBuffer] Could not query ContextBank: ${error}`);\n            }\n        }\n\n        return matchingItems;\n    }\n\n    /**\n     * è§£æåŒ…å« DSL çš„ç”¨æˆ·è¾“å…¥å¹¶è·å–ç›¸å…³ä¸Šä¸‹æ–‡\n     */\n    async getDSLContextForInput(input: string, contextBank?: import('./contextBank').ContextBank): Promise<ContextItem[]> {\n        const { dslQueries } = ExtendedContextProtocol.parseUserInput(input);\n        let allMatchingItems: ContextItem[] = [];\n\n        for (const query of dslQueries) {\n            const matchingItems = await this.queryDSL(query, contextBank);\n            allMatchingItems = [...allMatchingItems, ...matchingItems];\n        }\n\n        // å»é‡\n        const uniqueItems = allMatchingItems.filter((item, index, self) =>\n            index === self.findIndex(i => i.path === item.path)\n        );\n\n        return uniqueItems;\n    }\n}\n// Test change for git diff\n// Another test change (unstaged)\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/contextBuffer.ts:1769101059020",
    "tokens": 4259,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/engine.ts",
    "content": "import { Policy, PolicyContext, PolicyResult } from './types';\nimport { RiskLevel } from '../state';\n\nexport class PolicyEngine {\n  private policies: Map<string, Policy> = new Map();\n\n  registerPolicy(policy: Policy): void {\n    this.policies.set(policy.name, policy);\n  }\n\n  unregisterPolicy(name: string): void {\n    this.policies.delete(name);\n  }\n\n  async evaluate(context: PolicyContext): Promise<PolicyResult> {\n    let finalResult: PolicyResult = {\n      allowed: true,\n      reason: 'All policies passed'\n    };\n\n    for (const [name, policy] of this.policies) {\n      const result = await policy.evaluate(context);\n      \n      if (!result.allowed) {\n        return {\n          allowed: false,\n          reason: `Policy \"${name}\" blocked: ${result.reason}`,\n          requiresEscalation: result.requiresEscalation || false,\n          suggestedActions: result.suggestedActions\n        };\n      }\n\n      if (result.requiresEscalation) {\n        finalResult.requiresEscalation = true;\n        finalResult.suggestedActions = result.suggestedActions;\n      }\n    }\n\n    return finalResult;\n  }\n\n  evaluateRisk(action: { type: string; payload: any }): RiskLevel {\n    const { type, payload } = action;\n\n    if (type === 'tool_call') {\n      const toolName = payload.tool_name;\n      \n      const lowRiskTools = ['read_file', 'list_files', 'web_search'];\n      if (lowRiskTools.includes(toolName)) {\n        return 'low';\n      }\n\n      const mediumRiskTools = ['write_file', 'shell'];\n      if (mediumRiskTools.includes(toolName)) {\n        const cmd = payload.parameters?.command || payload.command || '';\n        if (this.containsDangerousCommand(cmd)) {\n          return 'high';\n        }\n        return 'medium';\n      }\n\n      return 'medium';\n    }\n\n    if (type === 'shell_cmd') {\n      const cmd = payload.command || '';\n      if (this.containsDangerousCommand(cmd)) {\n        return 'high';\n      }\n      return 'medium';\n    }\n\n    return 'low';\n  }\n\n  private containsDangerousCommand(cmd: string): boolean {\n    const dangerousPatterns = [\n      /rm\\s+-rf\\s+\\//,\n      /rm\\s+-rf\\s+~/,\n      />\\s*\\/dev\\/null/,\n      /dd\\s+if=/,\n      /mkfs/,\n      /format/,\n      /sudo\\s+rm/\n    ];\n\n    return dangerousPatterns.some(pattern => pattern.test(cmd));\n  }\n}\n\nexport const policyEngine = new PolicyEngine();\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/engine.ts:1769101059020",
    "tokens": 580,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/policies/noDangerousShell.ts",
    "content": "import { Policy, PolicyContext, PolicyResult } from '../types';\nimport { RiskLevel } from '../../state';\n\nexport class NoDangerousShellPolicy implements Policy {\n  name = 'no-dangerous-shell';\n  description = 'Prevents execution of dangerous shell commands';\n\n  evaluate(context: PolicyContext): PolicyResult {\n    const { action } = context;\n\n    if (action.type === 'shell_cmd') {\n      const command = action.payload?.command || '';\n      \n      const dangerousPatterns = [\n        { pattern: /rm\\s+-rf\\s+\\//, name: 'rm -rf /', risk: 'high' },\n        { pattern: /rm\\s+-rf\\s+~/, name: 'rm -rf ~', risk: 'high' },\n        { pattern: />\\s*\\/dev\\/null/, name: 'Redirect to /dev/null', risk: 'medium' },\n        { pattern: /dd\\s+if=/, name: 'dd command', risk: 'high' },\n        { pattern: /mkfs/, name: 'mkfs (filesystem creation)', risk: 'high' },\n        { pattern: /format/, name: 'format command', risk: 'high' },\n        { pattern: /sudo\\s+rm/, name: 'sudo rm', risk: 'high' },\n        { pattern: /chmod\\s+777\\s+\\/(?!dev)/, name: 'chmod 777 on system', risk: 'high' },\n        { pattern: /:\\s*~\\(\\)/, name: 'fork bomb', risk: 'high' }\n      ];\n\n      for (const { pattern, name, risk } of dangerousPatterns) {\n        if (pattern.test(command)) {\n          return {\n            allowed: false,\n            reason: `Dangerous command detected: ${name} (${risk} risk)`,\n            requiresEscalation: risk === 'high',\n            suggestedActions: [\n              `Review the command: \"${command}\"`,\n              'Consider using safer alternatives',\n              'Break down the operation into smaller, safer steps'\n            ]\n          };\n        }\n      }\n    }\n\n    return {\n      allowed: true,\n      reason: 'No dangerous patterns detected'\n    };\n  }\n}\n\nexport const noDangerousShellPolicy = new NoDangerousShellPolicy();\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/policies/noDangerousShell.ts:1769101059020",
    "tokens": 460,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/types.ts",
    "content": "import { RiskLevel } from '../state';\n\nexport interface PolicyContext {\n  action: {\n    type: string;\n    payload: any;\n  };\n  user?: {\n    permissions: string[];\n  };\n  environment?: {\n    isProduction: boolean;\n  };\n}\n\nexport interface PolicyResult {\n  allowed: boolean;\n  reason?: string;\n  requiresEscalation?: boolean;\n  suggestedActions?: string[];\n}\n\nexport interface Policy {\n  name: string;\n  description: string;\n  evaluate(context: PolicyContext): PolicyResult | Promise<PolicyResult>;\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/types.ts:1769101059020",
    "tokens": 125,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/index.ts",
    "content": "export * from './types';\nexport * from './engine';\nexport * from './policies/noDangerousShell';\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/policy/index.ts:1769101059020",
    "tokens": 24,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/agent/replayExplain.ts",
    "content": "import { ExecutionTurn } from './state';\nimport { ExecutionRecorder } from './executionRecorder';\nimport { generateSkillHintsFromContext, formatSkillHints, ContextSkillHint, promoteContextToSkill } from './contextSkillBridge';\nimport { ContextManager } from './contextManager';\nimport { ContextToSkillPromotionRules } from './contextSkillPromotion';\n\nexport function explainExecution(recorder: ExecutionRecorder, contextManager?: ContextManager): string {\n  const turns = recorder.getTurns();\n  const summary = recorder.getSummary();\n\n  const lines: string[] = [];\n\n  lines.push('# Execution Explanation Report');\n  lines.push('');\n  lines.push('## Summary');\n  lines.push(`- Total Turns: ${summary.totalTurns}`);\n  lines.push(`- Added Context Items: ${summary.totalAddedContext}`);\n  lines.push(`- Removed Context Items: ${summary.totalRemovedContext}`);\n  lines.push(`- Changed Context Items: ${summary.totalChangedContext}`);\n  lines.push('');\n\n  // å¦‚æœæä¾›äº†ContextManagerï¼Œç”ŸæˆSkill Hints\n  if (contextManager) {\n    const contextItems = contextManager.getContextBuffer().export();\n    const skillHints = generateSkillHintsFromContext(contextItems);\n\n    if (skillHints.length > 0) {\n      lines.push('## Skill Suggestions from Context');\n      lines.push(formatSkillHints(skillHints));\n      lines.push('');\n    }\n  }\n\n  lines.push('## Detailed Turn-by-Turn Analysis');\n  lines.push('');\n\n  for (const turn of turns) {\n    lines.push(`### Turn ${turn.turnId}`);\n    lines.push('');\n\n    if (turn.startTime) {\n      lines.push(`- Start Time: ${new Date(turn.startTime).toISOString()}`);\n    }\n\n    if (turn.endTime) {\n      lines.push(`- End Time: ${new Date(turn.endTime).toISOString()}`);\n    }\n\n    if (turn.contextDiff) {\n      lines.push('');\n      lines.push('#### Context Changes:');\n\n      if (turn.contextDiff.added.length > 0) {\n        lines.push('- Added:');\n        for (const item of turn.contextDiff.added) {\n          lines.push(`  - ${item}`);\n        }\n      }\n\n      if (turn.contextDiff.removed.length > 0) {\n        lines.push('- Removed:');\n        for (const item of turn.contextDiff.removed) {\n          lines.push(`  - ${item}`);\n        }\n      }\n\n      if (turn.contextDiff.changed.length > 0) {\n        lines.push('- Changed:');\n        for (const item of turn.contextDiff.changed) {\n          lines.push(`  - ${item}`);\n        }\n      }\n    }\n\n    if (turn.proposedAction) {\n      lines.push('');\n      lines.push(`#### Action Type: ${turn.proposedAction.type}`);\n      lines.push(`- Reasoning: ${turn.proposedAction.reasoning}`);\n    }\n\n    if (turn.governance) {\n      lines.push('');\n      lines.push(`#### Governance Decision: ${turn.governance.status}`);\n      if ('reason' in turn.governance) {\n        lines.push(`- Reason: ${turn.governance.reason}`);\n      }\n      lines.push(`- Decided by: ${turn.governance.by}`);\n    }\n\n    if (turn.executionResult) {\n      lines.push('');\n      lines.push(`#### Execution Result: ${turn.executionResult.success ? 'SUCCESS' : 'FAILURE'}`);\n      if (turn.executionResult.error) {\n        lines.push(`- Error: ${turn.executionResult.error}`);\n      }\n    }\n\n    lines.push('');\n  }\n\n  return lines.join('\\n');\n}\n\nexport function replayExecution(recorder: ExecutionRecorder, options: { showContextDiff?: boolean } = {}): string {\n  const { showContextDiff = true } = options;\n  const turns = recorder.getTurns();\n  const lines: string[] = [];\n\n  lines.push('# Execution Replay');\n  lines.push('');\n\n  for (const turn of turns) {\n    lines.push(`## Turn ${turn.turnId}`);\n    \n    if (showContextDiff && turn.contextDiff) {\n      lines.push('');\n      lines.push('### Context Diff:');\n      \n      if (turn.contextDiff.added.length > 0) {\n        lines.push('Added:');\n        for (const item of turn.contextDiff.added) {\n          lines.push(`  + ${item}`);\n        }\n      }\n      \n      if (turn.contextDiff.removed.length > 0) {\n        lines.push('Removed:');\n        for (const item of turn.contextDiff.removed) {\n          lines.push(`  - ${item}`);\n        }\n      }\n      \n      if (turn.contextDiff.changed.length > 0) {\n        lines.push('Changed:');\n        for (const item of turn.contextDiff.changed) {\n          lines.push(`  ~ ${item}`);\n        }\n      }\n      \n      if (!turn.contextDiff.added.length && \n          !turn.contextDiff.removed.length && \n          !turn.contextDiff.changed.length) {\n        lines.push('(No context changes)');\n      }\n    }\n    \n    if (turn.proposedAction) {\n      lines.push('');\n      lines.push(`Action: ${turn.proposedAction.type}`);\n      lines.push(`Reasoning: ${turn.proposedAction.reasoning}`);\n    }\n    \n    if (turn.executionResult) {\n      lines.push('');\n      lines.push(`Result: ${turn.executionResult.success ? 'SUCCESS' : 'FAILURE'}`);\n    }\n    \n    lines.push('');\n  }\n\n  return lines.join('\\n');\n}",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/agent/replayExplain.ts:1769101059020",
    "tokens": 1211,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/ai/prompt.ts",
    "content": "import { OSProfile } from '../core/os';\nimport type { Macro } from '../core/validation';\n\nexport function buildCommandPrompt(\n    userInput: string,\n    os: OSProfile,\n    macros?: Record<string, Macro>,\n    context?: string\n): string {\n    const macroContext = macros && Object.keys(macros).length > 0\n        ? `\nã€å¯å¤ç”¨çš„å¿«æ·æŒ‡ä»¤ (Macros)ã€‘\nä»¥ä¸‹æ˜¯å¯ä»¥ç›´æ¥å¤ç”¨çš„å·²éªŒè¯å‘½ä»¤ã€‚ä¼˜å…ˆå¤ç”¨è¿™äº›æŒ‡ä»¤ï¼Œè€Œä¸æ˜¯ç”Ÿæˆæ–°å‘½ä»¤ï¼š\n\n${Object.entries(macros).map(([name, macro]) => `  - ${name}: ${macro.description || '(æ— æè¿°)'}`).join('\\n')}\n\nå½“ç”¨æˆ·çš„éœ€æ±‚ä¸æŸä¸ª Macro åŒ¹é…æˆ–ç›¸ä¼¼æ—¶ï¼š\n1. ä¼˜å…ˆä½¿ç”¨è¯¥ Macro\n2. åœ¨ JSON è¾“å‡ºä¸­ä½¿ç”¨ \"macro\" å­—æ®µæŒ‡å®š Macro åç§°ï¼Œè€Œä¸æ˜¯ \"command\" å­—æ®µ\n3. ä»…åœ¨æ²¡æœ‰åˆé€‚ Macro æ—¶æ‰ç”Ÿæˆæ–°å‘½ä»¤\n`\n        : '';\n\n    return `\nä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å‘½ä»¤è¡Œä¸“å®¶ã€‚\n\nã€ç³»ç»Ÿç¯å¢ƒã€‘\n- æ“ä½œç³»ç»Ÿ: ${os.name}\n- Shell: ${os.shell}\n- find å®ç°: ${os.find}\n- stat å®ç°: ${os.stat}\n\nã€è§„åˆ™ã€‘\n- å‘½ä»¤å¿…é¡»ä¸å½“å‰ç³»ç»Ÿå…¼å®¹ã€‚\n- å¦‚æœæ˜¯ macOS (BSD):\n  - ä¸å…è®¸ä½¿ç”¨ find -printf\n  - ä¼˜å…ˆä½¿ç”¨ stat -f\n- å¦‚æœæ˜¯ Linux (GNU):\n  - å¯ä½¿ç”¨ find -printf\n- é»˜è®¤ä¸ä½¿ç”¨ sudoã€‚\n- ç¡®ä¿è¾“å‡ºçš„å‘½ä»¤æ˜¯å•è¡Œæˆ–è€…ä½¿ç”¨ && è¿æ¥ã€‚\n- ä¸è¦è§£é‡Šï¼Œåªè¾“å‡ºç¬¦åˆä»¥ä¸‹ JSON ç»“æ„çš„æ–‡æœ¬ã€‚\n- ä¼˜å…ˆå¤ç”¨å·²éªŒè¯çš„å¿«æ·æŒ‡ä»¤ï¼ˆMacrosï¼‰ï¼Œæ¯ä¸ª Macro éƒ½æ˜¯ç»è¿‡äººå·¥éªŒè¯çš„å¯é å‘½ä»¤ã€‚åœ¨ç”Ÿæˆæ–°å‘½ä»¤å‰ï¼Œæ£€æŸ¥æ˜¯å¦å·²æœ‰ Macro å¯ä»¥å®Œæˆä»»åŠ¡ã€‚\n\n${macroContext}\n\nã€è¾“å‡º JSON ç»“æ„ã€‘\n{\n  \"plan\": \"ç®€è¦è¯´æ˜ä½ å‡†å¤‡æ‰§è¡Œçš„æ­¥éª¤\",\n  \"command\": \"å¯ç›´æ¥æ‰§è¡Œçš„ shell å‘½ä»¤ï¼ˆä»…å½“æ²¡æœ‰åˆé€‚ Macro æ—¶æä¾›ï¼‰\",\n  \"macro\": \"è¦å¤ç”¨çš„ Macro åç§°ï¼ˆä¼˜å…ˆä½¿ç”¨ï¼Œä¸ command äºŒé€‰ä¸€ï¼‰\",\n  \"risk\": \"low | medium | high\"\n}\n\nã€ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‘\n${context || 'æ— '}\n\nã€ç”¨æˆ·éœ€æ±‚ã€‘\n${userInput}\n`;\n}\n\nexport function buildFixPrompt(\n    originalCmd: string,\n    stderr: string,\n    os: OSProfile\n): string {\n    return `\nè¯¥å‘½ä»¤åœ¨ ${os.name} ä¸Šæ‰§è¡Œå¤±è´¥ï¼š\n\nå‘½ä»¤ï¼š\n${originalCmd}\n\né”™è¯¯ä¿¡æ¯ï¼š\n${stderr}\n\nè¯·ç”Ÿæˆä¸€ä¸ª **${os.name} å…¼å®¹** çš„ç­‰ä»·å‘½ä»¤ã€‚\nä¾ç„¶åªè¾“å‡º JSON æ ¼å¼ã€‚æ³¨æ„ï¼šè¿™æ˜¯ä¿®å¤å‘½ä»¤ï¼Œä¸éœ€è¦æ£€æŸ¥ Macroã€‚\n\n{\n  \"plan\": \"ä¿®å¤è¯´æ˜\",\n  \"command\": \"ä¿®å¤åçš„å‘½ä»¤\",\n  \"risk\": \"low | medium | high\"\n}\n`;\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/ai/prompt.ts:1769101059020",
    "tokens": 393,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/ai/types.ts",
    "content": "export { AICommandPlan, type AICommandPlan as AICommandPlanType } from '../core/validation';\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/ai/types.ts:1769101059020",
    "tokens": 24,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  },
  {
    "type": "file",
    "path": "/Users/ygs/ygs/vsyuangs/src/engine/ai/client.ts",
    "content": "import axios from 'axios';\nimport fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { DEFAULT_AI_PROXY_URL, DEFAULT_MODEL, DEFAULT_ACCOUNT_TYPE, type UserConfig, type AIRequestMessage } from '../core/validation';\nimport { loadChatHistory, saveChatHistory } from '../agent/chatHistoryStorage';\n\nconst CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');\n\nlet conversationHistory: AIRequestMessage[] = [];\n\n// åˆå§‹åŒ–æ—¶åŠ è½½æŒä¹…åŒ–çš„èŠå¤©å†å²è®°å½•\nloadChatHistory().then(history => {\n    conversationHistory = history;\n});\n\nexport function addToConversationHistory(role: 'system' | 'user' | 'assistant', content: string) {\n    conversationHistory.push({ role, content });\n    if (conversationHistory.length > 20) {\n        conversationHistory = conversationHistory.slice(-20);\n    }\n    // åŒæ—¶ä¿å­˜åˆ°æŒä¹…åŒ–å­˜å‚¨\n    saveChatHistory(conversationHistory);\n}\n\nexport function clearConversationHistory() {\n    conversationHistory = [];\n    // åŒæ—¶æ¸…é™¤æŒä¹…åŒ–å­˜å‚¨\n    saveChatHistory(conversationHistory);\n}\n\nexport function getConversationHistory() {\n    return conversationHistory;\n}\n\nexport function getUserConfig(): UserConfig {\n    if (fs.existsSync(CONFIG_FILE)) {\n        try {\n            const content = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(content) as UserConfig;\n        } catch (e) { }\n    }\n    return {};\n}\n\nexport async function askAI(prompt: string, model?: string): Promise<string> {\n    const config = getUserConfig();\n    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;\n\n    const headers = {\n        'Content-Type': 'application/json',\n        'X-Client-ID': 'vscode',\n        'Origin': 'https://cli.want.biz',\n        'Referer': 'https://cli.want.biz/',\n        'account': config.accountType || DEFAULT_ACCOUNT_TYPE,\n        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',\n        'Accept': 'application/json'\n    };\n\n    const data = {\n        model: model || config.defaultModel || DEFAULT_MODEL,\n        messages: [{ role: 'user', content: prompt }],\n        stream: false\n    };\n\n    try {\n        const response = await axios.post(url, data, { headers });\n        const content = response.data?.choices?.[0]?.message?.content;\n        return content || '';\n    } catch (error: any) {\n        const errorMsg = error.response?.data?.error?.message || error.response?.data?.message || error.message || 'æœªçŸ¥é”™è¯¯';\n        throw new Error(`AI è¯·æ±‚å¤±è´¥: ${errorMsg}`);\n    }\n}\n\nexport async function callAI_Stream(messages: AIRequestMessage[], model: string | undefined, onChunk: (content: string) => void): Promise<void> {\n    const config = getUserConfig();\n    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;\n\n    const response = await axios({\n        method: 'post',\n        url: url,\n        data: {\n            model: model || config.defaultModel || DEFAULT_MODEL,\n            messages: messages,\n            stream: true\n        },\n        responseType: 'stream',\n        headers: {\n            'Content-Type': 'application/json',\n            'X-Client-ID': 'vscode',\n            'Origin': 'https://cli.want.biz',\n            'Referer': 'https://cli.want.biz/',\n            'account': config.accountType || DEFAULT_ACCOUNT_TYPE,\n            'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',\n            'Accept': 'application/json'\n        }\n    });\n\n    return new Promise((resolve, reject) => {\n        let buffer = '';\n        response.data.on('data', (chunk: Buffer) => {\n            buffer += chunk.toString();\n            let lines = buffer.split('\\n');\n            buffer = lines.pop() || '';\n\n            for (const line of lines) {\n                const trimmedLine = line.trim();\n                if (trimmedLine.startsWith('data: ')) {\n                    const data = trimmedLine.slice(6);\n                    if (data === '[DONE]') {\n                        resolve();\n                        return;\n                    }\n                    try {\n                        const parsed = JSON.parse(data);\n                        const content = parsed.choices[0]?.delta?.content || '';\n                        if (content) onChunk(content);\n                    } catch (e) { }\n                }\n            }\n        });\n        response.data.on('error', reject);\n        response.data.on('end', () => {\n            resolve();\n        });\n    });\n}\n",
    "id": "file:/Users/ygs/ygs/vsyuangs/src/engine/ai/client.ts:1769101059020",
    "tokens": 1127,
    "importance": 0.5,
    "lastUsedAt": 1769101059020
  }
]