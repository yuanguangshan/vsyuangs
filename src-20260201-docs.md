# Project Documentation

- **Generated at:** 2026-02-01 22:06:36
- **Root Dir:** `src`
- **File Count:** 115
- **Total Size:** 686.42 KB

<a name="toc"></a>
## ğŸ“‚ æ‰«æç›®å½•
- [core/AutomatedTestScanner.ts](#ğŸ“„-coreautomatedtestscannerts) (546 lines, 15.98 KB)
- [core/SecurityScanCoordinator.ts](#ğŸ“„-coresecurityscancoordinatorts) (610 lines, 17.11 KB)
- [core/diff.ts](#ğŸ“„-corediffts) (1188 lines, 34.26 KB)
- [core/diffApplyTransaction.ts](#ğŸ“„-corediffapplytransactionts) (499 lines, 12.89 KB)
- [core/diffSecurityValidator.ts](#ğŸ“„-corediffsecurityvalidatorts) (379 lines, 10.33 KB)
- [core/diffSource.ts](#ğŸ“„-corediffsourcets) (210 lines, 6.38 KB)
- [core/preferenceMemory.ts](#ğŸ“„-corepreferencememoryts) (388 lines, 9.84 KB)
- [core/quickSecurityScanner.ts](#ğŸ“„-corequicksecurityscannerts) (376 lines, 10.57 KB)
- [core/reviewSchema.ts](#ğŸ“„-corereviewschemats) (321 lines, 7.51 KB)
- [core/semanticReviewContext.ts](#ğŸ“„-coresemanticreviewcontextts) (624 lines, 16.14 KB)
- [core/semanticReviewValidator.ts](#ğŸ“„-coresemanticreviewvalidatorts) (431 lines, 11.15 KB)
- [core/types.ts](#ğŸ“„-coretypests) (50 lines, 0.84 KB)
- [engine/agent/AgentRuntime.ts](#ğŸ“„-engineagentagentruntimets) (589 lines, 19.49 KB)
- [engine/agent/actions.ts](#ğŸ“„-engineagentactionsts) (53 lines, 1.58 KB)
- [engine/agent/chatHistoryStorage.ts](#ğŸ“„-engineagentchathistorystoragets) (51 lines, 1.70 KB)
- [engine/agent/context.ts](#ğŸ“„-engineagentcontextts) (31 lines, 1.22 KB)
- [engine/agent/contextBank.ts](#ğŸ“„-engineagentcontextbankts) (542 lines, 16.67 KB)
- [engine/agent/contextBuffer.ts](#ğŸ“„-engineagentcontextbufferts) (526 lines, 19.26 KB)
- [engine/agent/contextDSL.ts](#ğŸ“„-engineagentcontextdslts) (404 lines, 11.17 KB)
- [engine/agent/contextImportance.ts](#ğŸ“„-engineagentcontextimportancets) (82 lines, 1.89 KB)
- [engine/agent/contextManager.ts](#ğŸ“„-engineagentcontextmanagerts) (255 lines, 7.55 KB)
- [engine/agent/contextProtocol.ts](#ğŸ“„-engineagentcontextprotocolts) (445 lines, 13.83 KB)
- [engine/agent/contextSkillBridge.ts](#ğŸ“„-engineagentcontextskillbridgets) (146 lines, 4.84 KB)
- [engine/agent/contextSkillPromotion.ts](#ğŸ“„-engineagentcontextskillpromotionts) (434 lines, 16.19 KB)
- [engine/agent/contextStorage.ts](#ğŸ“„-engineagentcontextstoragets) (24 lines, 0.69 KB)
- [engine/agent/contextSummary.ts](#ğŸ“„-engineagentcontextsummaryts) (44 lines, 0.90 KB)
- [engine/agent/executionRecorder.ts](#ğŸ“„-engineagentexecutionrecorderts) (43 lines, 1.09 KB)
- [engine/agent/executor.ts](#ğŸ“„-engineagentexecutorts) (94 lines, 2.80 KB)
- [engine/agent/governance.ts](#ğŸ“„-engineagentgovernancets) (70 lines, 2.27 KB)
- [engine/agent/governance/bridge.ts](#ğŸ“„-engineagentgovernancebridgets) (38 lines, 1.27 KB)
- [engine/agent/governance/core.ts](#ğŸ“„-engineagentgovernancecorets) (35 lines, 1.22 KB)
- [engine/agent/governance/ledger.ts](#ğŸ“„-engineagentgovernanceledgerts) (22 lines, 0.48 KB)
- [engine/agent/governance/sandbox/core.as.ts](#ğŸ“„-engineagentgovernancesandboxcoreasts) (33 lines, 1.35 KB)
- [engine/agent/index.ts](#ğŸ“„-engineagentindexts) (14 lines, 0.85 KB)
- [engine/agent/knowledgeGraph.ts](#ğŸ“„-engineagentknowledgegraphts) (49 lines, 1.30 KB)
- [engine/agent/llm.ts](#ğŸ“„-engineagentllmts) (124 lines, 3.54 KB)
- [engine/agent/llmAdapter.ts](#ğŸ“„-engineagentllmadapterts) (248 lines, 9.55 KB)
- [engine/agent/policy/engine.ts](#ğŸ“„-engineagentpolicyenginets) (91 lines, 2.26 KB)
- [engine/agent/policy/index.ts](#ğŸ“„-engineagentpolicyindexts) (3 lines, 0.09 KB)
- [engine/agent/policy/policies/noDangerousShell.ts](#ğŸ“„-engineagentpolicypoliciesnodangerousshellts) (49 lines, 1.79 KB)
- [engine/agent/policy/sampler.ts](#ğŸ“„-engineagentpolicysamplerts) (235 lines, 5.81 KB)
- [engine/agent/policy/types.ts](#ğŸ“„-engineagentpolicytypests) (27 lines, 0.49 KB)
- [engine/agent/prompt.ts](#ğŸ“„-engineagentpromptts) (80 lines, 2.08 KB)
- [engine/agent/replay/events.ts](#ğŸ“„-engineagentreplayeventsts) (30 lines, 0.59 KB)
- [engine/agent/replay/index.ts](#ğŸ“„-engineagentreplayindexts) (3 lines, 0.08 KB)
- [engine/agent/replay/recorder.ts](#ğŸ“„-engineagentreplayrecorderts) (58 lines, 1.38 KB)
- [engine/agent/replay/replayer.ts](#ğŸ“„-engineagentreplayreplayerts) (84 lines, 1.88 KB)
- [engine/agent/replayExplain.ts](#ğŸ“„-engineagentreplayexplaints) (162 lines, 4.74 KB)
- [engine/agent/selectModel.ts](#ğŸ“„-engineagentselectmodelts) (14 lines, 0.33 KB)
- [engine/agent/skills.ts](#ğŸ“„-engineagentskillsts) (225 lines, 6.27 KB)
- [engine/agent/state.ts](#ğŸ“„-engineagentstatets) (102 lines, 2.39 KB)
- [engine/agent/types.ts](#ğŸ“„-engineagenttypests) (76 lines, 1.86 KB)
- [engine/ai/client.ts](#ğŸ“„-engineaiclientts) (140 lines, 4.64 KB)
- [engine/ai/prompt.ts](#ğŸ“„-engineaipromptts) (116 lines, 3.21 KB)
- [engine/ai/types.ts](#ğŸ“„-engineaitypests) (1 lines, 0.09 KB)
- [engine/aiClient.ts](#ğŸ“„-engineaiclientts) (35 lines, 1.12 KB)
- [engine/core/apps.ts](#ğŸ“„-enginecoreappsts) (49 lines, 1.63 KB)
- [engine/core/autofix.ts](#ğŸ“„-enginecoreautofixts) (22 lines, 0.61 KB)
- [engine/core/capabilities.ts](#ğŸ“„-enginecorecapabilitiests) (69 lines, 1.90 KB)
- [engine/core/capabilityInference.ts](#ğŸ“„-enginecorecapabilityinferencets) (25 lines, 0.93 KB)
- [engine/core/capabilitySystem.ts](#ğŸ“„-enginecorecapabilitysystemts) (114 lines, 3.15 KB)
- [engine/core/completion.legacy.ts](#ğŸ“„-enginecorecompletionlegacyts) (225 lines, 5.89 KB)
- [engine/core/completion/builtin.ts](#ğŸ“„-enginecorecompletionbuiltints) (18 lines, 0.84 KB)
- [engine/core/completion/cache.ts](#ğŸ“„-enginecorecompletioncachets) (47 lines, 1.07 KB)
- [engine/core/completion/index.ts](#ğŸ“„-enginecorecompletionindexts) (30 lines, 0.69 KB)
- [engine/core/completion/path.ts](#ğŸ“„-enginecorecompletionpathts) (39 lines, 1.04 KB)
- [engine/core/completion/resolver.ts](#ğŸ“„-enginecorecompletionresolverts) (106 lines, 2.62 KB)
- [engine/core/completion/types.ts](#ğŸ“„-enginecorecompletiontypests) (30 lines, 0.50 KB)
- [engine/core/completion/utils.ts](#ğŸ“„-enginecorecompletionutilsts) (10 lines, 0.26 KB)
- [engine/core/configMerge.ts](#ğŸ“„-enginecoreconfigmergets) (122 lines, 3.09 KB)
- [engine/core/executionRecord.ts](#ğŸ“„-enginecoreexecutionrecordts) (99 lines, 2.50 KB)
- [engine/core/executionStore.ts](#ğŸ“„-enginecoreexecutionstorets) (100 lines, 2.44 KB)
- [engine/core/executor.ts](#ğŸ“„-enginecoreexecutorts) (37 lines, 0.97 KB)
- [engine/core/explain.ts](#ğŸ“„-enginecoreexplaints) (106 lines, 2.99 KB)
- [engine/core/fileReader.ts](#ğŸ“„-enginecorefilereaderts) (72 lines, 2.03 KB)
- [engine/core/macros.ts](#ğŸ“„-enginecoremacrosts) (83 lines, 2.36 KB)
- [engine/core/modelMatcher.ts](#ğŸ“„-enginecoremodelmatcherts) (102 lines, 2.65 KB)
- [engine/core/models.config.json](#ğŸ“„-enginecoremodelsconfigjson) (30 lines, 0.61 KB)
- [engine/core/os.ts](#ğŸ“„-enginecoreosts) (39 lines, 1.00 KB)
- [engine/core/replayDiff.ts](#ğŸ“„-enginecorereplaydiffts) (284 lines, 8.07 KB)
- [engine/core/replayEngine.ts](#ğŸ“„-enginecorereplayenginets) (161 lines, 4.54 KB)
- [engine/core/risk.ts](#ğŸ“„-enginecoreriskts) (18 lines, 0.48 KB)
- [engine/core/validation.ts](#ğŸ“„-enginecorevalidationts) (194 lines, 5.97 KB)
- [engine/diff/applyDiff.ts](#ğŸ“„-enginediffapplydiffts) (14 lines, 0.38 KB)
- [engine/prompt/explain.prompt.ts](#ğŸ“„-enginepromptexplainpromptts) (16 lines, 0.34 KB)
- [engine/prompt/optimize.prompt.ts](#ğŸ“„-enginepromptoptimizepromptts) (24 lines, 0.42 KB)
- [engine/prompt/send.prompt.ts](#ğŸ“„-enginepromptsendpromptts) (10 lines, 0.24 KB)
- [engine/utils/confirm.ts](#ğŸ“„-engineutilsconfirmts) (17 lines, 0.44 KB)
- [engine/utils/history.ts](#ğŸ“„-engineutilshistoryts) (28 lines, 0.89 KB)
- [engine/utils/renderer.ts](#ğŸ“„-engineutilsrendererts) (116 lines, 3.64 KB)
- [runtime/vscode/VSCodeExecutor.ts](#ğŸ“„-runtimevscodevscodeexecutorts) (147 lines, 6.20 KB)
- [utils/git.ts](#ğŸ“„-utilsgitts) (43 lines, 1.03 KB)
- [vscode/codeActions/YuangsCodeActionProvider.ts](#ğŸ“„-vscodecodeactionsyuangscodeactionproviderts) (89 lines, 2.28 KB)
- [vscode/commands/askAI.ts](#ğŸ“„-vscodecommandsaskaits) (78 lines, 2.54 KB)
- [vscode/commands/optimize.ts](#ğŸ“„-vscodecommandsoptimizets) (83 lines, 2.23 KB)
- [vscode/commands/optimizeSelection.ts](#ğŸ“„-vscodecommandsoptimizeselectionts) (63 lines, 2.40 KB)
- [vscode/commands/sendToYuangs.ts](#ğŸ“„-vscodecommandssendtoyuangsts) (32 lines, 1.01 KB)
- [vscode/core/contextAdapter.ts](#ğŸ“„-vscodecorecontextadapterts) (447 lines, 15.97 KB)
- [vscode/core/executorAdapter.ts](#ğŸ“„-vscodecoreexecutoradapterts) (323 lines, 9.47 KB)
- [vscode/decorations/inlineDiff.ts](#ğŸ“„-vscodedecorationsinlinediffts) (108 lines, 3.63 KB)
- [vscode/extension.ts](#ğŸ“„-vscodeextensionts) (98 lines, 3.54 KB)
- [vscode/git/SmartStageSuggester.ts](#ğŸ“„-vscodegitsmartstagesuggesterts) (570 lines, 17.99 KB)
- [vscode/guard/ProactiveGuard.ts](#ğŸ“„-vscodeguardproactiveguardts) (401 lines, 11.74 KB)
- [vscode/guard/VotingFileClassifier.ts](#ğŸ“„-vscodeguardvotingfileclassifierts) (171 lines, 4.77 KB)
- [vscode/guard/explanationProtocol.ts](#ğŸ“„-vscodeguardexplanationprotocolts) (90 lines, 2.31 KB)
- [vscode/guard/preferences.ts](#ğŸ“„-vscodeguardpreferencests) (61 lines, 1.95 KB)
- [vscode/guard/types.ts](#ğŸ“„-vscodeguardtypests) (21 lines, 0.38 KB)
- [vscode/provider/ChatViewProvider.ts](#ğŸ“„-vscodeproviderchatviewproviderts) (1188 lines, 49.26 KB)
- [vscode/provider/ProactiveCodeActionProvider.ts](#ğŸ“„-vscodeproviderproactivecodeactionproviderts) (462 lines, 12.82 KB)
- [vscode/provider/ReviewDiagnosticsProvider.ts](#ğŸ“„-vscodeproviderreviewdiagnosticsproviderts) (335 lines, 9.22 KB)
- [vscode/sidePanel/YuangsPanel.ts](#ğŸ“„-vscodesidepanelyuangspanelts) (295 lines, 7.77 KB)
- [vscode/utils/ignoreFilter.ts](#ğŸ“„-vscodeutilsignorefilterts) (202 lines, 6.41 KB)
- [vscode/webview/context-panel-functions.js](#ğŸ“„-vscodewebviewcontext-panel-functionsjs) (204 lines, 5.94 KB)
- [vscode/webview/sidebar.html](#ğŸ“„-vscodewebviewsidebarhtml) (3562 lines, 101.44 KB)
- [ygs.md](#ğŸ“„-ygsmd) (3 lines, 0.12 KB)

---

## ğŸ“„ core/AutomatedTestScanner.ts

````typescript
/**
 * Automated Test Scanner - è‡ªåŠ¨åŒ–æµ‹è¯•æ‰«æ
 * 
 * åŠŸèƒ½ï¼š
 * - åœ¨ AI ç”Ÿæˆä»£ç åè‡ªåŠ¨è¿è¡Œé™æ€æ‰«æ
 * - æ‰§è¡Œæ¶æ„ Diff é˜²å¾¡æµ‹è¯•
 * - æä¾›å®‰å…¨æ£€æŸ¥æŠ¥å‘Š
 * 
 * ç”¨æˆ·ä½“éªŒï¼š
 * - AI ç”Ÿæˆä»£ç åï¼Œè‡ªåŠ¨è¿è¡Œä¸€å¥—åŸºç¡€çš„é™æ€æ‰«æ
 * - ç¡®ä¿ç”Ÿæˆçš„ä»£ç å®‰å…¨å¯é 
 * 
 * èŒè´£è¾¹ç•Œï¼š
 * - Validator (DiffSecurityValidator) = å†³ç­–å±‚ï¼Œæ˜¯å¦å…è®¸è¿›å…¥ç³»ç»Ÿ
 * - Scanner (AutomatedTestScanner) = å»ºè®®å±‚ï¼Œæ˜¯å¦å­˜åœ¨é£é™©æ¨¡å¼/æ˜¯å¦å»ºè®®ä¼˜åŒ–
 * 
 * åŸåˆ™ï¼š
 * - Validator å¿…é¡»é€šè¿‡ï¼Œç³»ç»Ÿæ‰èƒ½ç»§ç»­
 * - Scanner çš„è­¦å‘Šå’Œå»ºè®®æ˜¯å¯é€‰çš„
 */

import * as vscode from 'vscode';
import { DiffParser } from './diff';
import { DiffSecurityValidator, SecurityValidationResult } from './diffSecurityValidator';
import { ReviewResultV1, ReviewSuggestion } from './reviewSchema';

/**
 * æ‰«æç»“æœ
 */
export interface ScanResult {
  /** æ˜¯å¦é€šè¿‡æ‰«æ */
  passed: boolean;

  /** æ‰«ææ—¶é—´ */
  timestamp: Date;

  /** æ‰«æç±»å‹ */
  scanType: 'security' | 'quality' | 'full';

  /** å®‰å…¨æ£€æŸ¥ç»“æœ */
  securityCheck: SecurityCheckResult;

  /** è´¨é‡æ£€æŸ¥ç»“æœï¼ˆå¯é€‰ï¼‰ */
  qualityCheck?: QualityCheckResult;

  /** æ€»ä½“å»ºè®® */
  recommendations: string[];
}

/**
 * å®‰å…¨æ£€æŸ¥ç»“æœ
 */
export interface SecurityCheckResult {
  /** æ˜¯å¦é€šè¿‡å®‰å…¨æ£€æŸ¥ */
  passed: boolean;

  /** Diff è§£æç»“æœ */
  parseResult: {
    success: boolean;
    fileCount: number;
    hunkCount: number;
  };

  /** å®‰å…¨éªŒè¯ç»“æœ */
  validationResult: SecurityValidationResult;

  /** å‘ç°çš„å®‰å…¨é—®é¢˜ */
  securityIssues: SecurityIssue[];
}

/**
 * è´¨é‡æ£€æŸ¥ç»“æœ
 */
export interface QualityCheckResult {
  /** æ˜¯å¦é€šè¿‡è´¨é‡æ£€æŸ¥ */
  passed: boolean;

  /** ä»£ç å¤æ‚åº¦ï¼ˆå¯é€‰ï¼‰ */
  complexity?: {
    avg: number;
    max: number;
  };

  /** ä»£ç é‡å¤ç‡ï¼ˆå¯é€‰ï¼‰ */
  duplication?: {
    percentage: number;
    duplicatedLines: number;
  };

  /** å…¶ä»–è´¨é‡æŒ‡æ ‡ */
  metrics: {
    [key: string]: number | string;
  };
}

/**
 * å®‰å…¨é—®é¢˜
 */
export interface SecurityIssue {
  /** é—®é¢˜ç±»å‹ */
  type: 
    | 'PATH_TRAVERSAL' 
    | 'ABSOLUTE_PATH' 
    | 'LINE_TOO_LONG' 
    | 'CONTEXT_TOO_LARGE' 
    | 'HUNK_TOO_LARGE' 
    | 'TOO_MANY_HUNKS' 
    | 'TOO_MANY_FILES' 
    | 'EXTENSION_NOT_ALLOWED'
    | 'FORBIDDEN_PATH_PATTERN'
    | 'HUNK_HEADER_FORGERY'
    | 'INVALID_UNIFIED_DIFF';

  /** ä¸¥é‡ç¨‹åº¦ */
  severity: 'low' | 'medium' | 'high' | 'critical';

  /** é—®é¢˜æè¿° */
  message: string;

  /** ç›¸å…³æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰ */
  filePath?: string;

  /** ç›¸å…³ hunk ç´¢å¼•ï¼ˆå¯é€‰ï¼‰ */
  hunkIndex?: number;

  /** å»ºè®®ä¿®å¤ */
  suggestion?: string;
}

/**
 * Automated Test Scanner
 */
export class AutomatedTestScanner {
  private securityValidator: DiffSecurityValidator;
  private outputChannel: vscode.OutputChannel;

  constructor() {
    this.securityValidator = new DiffSecurityValidator();
    this.outputChannel = vscode.window.createOutputChannel('VS Yuangs Security Scanner');
  }

  /**
   * æ‰«æ AI ç”Ÿæˆçš„ä»£ç ï¼ˆDiff æ ¼å¼ï¼‰
   * 
   * æ³¨æ„ï¼šè¿™æ˜¯å»ºè®®å±‚æ‰«æï¼Œä¸æ˜¯å†³ç­–å±‚éªŒè¯
   * å†³ç­–å±‚éªŒè¯åº”è¯¥ä½¿ç”¨ DiffSecurityValidator.validate()
   */
  async scanGeneratedCode(
    diffText: string,
    options?: {
      scanType?: 'security' | 'quality' | 'full';
      runTests?: boolean;
    }
  ): Promise<ScanResult> {
    const scanType = options?.scanType || 'security';
    const timestamp = new Date();

    this.outputChannel.appendLine(`[Scanner] Starting ${scanType} scan at ${timestamp.toISOString()}`);
    this.outputChannel.appendLine(`[Scanner] Diff length: ${diffText.length} bytes`);
    this.outputChannel.appendLine(`[Scanner] Mode: advisory (suggestions only)`);

    // 1. è§£æ Diff
    const parseResult = DiffParser.parse(diffText);
    
    this.outputChannel.appendLine(
      `[Scanner] Parse result: ${parseResult.success ? 'SUCCESS' : 'FAILED'}` +
      (parseResult.success ? ` (${parseResult.files.length} files, ${parseResult.stats.hunkCount} hunks)` : '')
    );

    // 2. å®‰å…¨æ£€æŸ¥ï¼ˆå»ºè®®å±‚ï¼‰
    // æ³¨æ„ï¼šè¿™é‡Œåªæ˜¯æ‰«æå’Œæä¾›å»ºè®®ï¼Œä¸æ˜¯å†³ç­–å±‚éªŒè¯
    // å†³ç­–å±‚éªŒè¯åº”è¯¥ç”± DiffSecurityValidator.validate() å®Œæˆ
    const securityCheck = await this.performSecurityCheck(parseResult, diffText);

    // 3. è´¨é‡æ£€æŸ¥ï¼ˆå¦‚æœéœ€è¦ï¼‰
    let qualityCheck: QualityCheckResult | undefined;
    if (scanType === 'quality' || scanType === 'full') {
      qualityCheck = await this.performQualityCheck(parseResult);
    }

    // 4. ç”Ÿæˆå»ºè®®ï¼ˆè¿™æ˜¯ Scanner çš„æ ¸å¿ƒä»·å€¼ï¼‰
    const recommendations = this.generateRecommendations(securityCheck, qualityCheck);

    // 5. æ„å»ºç»“æœ
    // Scanner çš„ passed è¡¨ç¤º"æ²¡æœ‰ä¸¥é‡è­¦å‘Š"ï¼Œä¸ä»£è¡¨"å¯ä»¥å®‰å…¨æ‰§è¡Œ"
    // å®‰å…¨æ‰§è¡Œéœ€è¦å…ˆé€šè¿‡ DiffSecurityValidator.validate()
    const passed = securityCheck.passed && (!qualityCheck || qualityCheck.passed);

    const result: ScanResult = {
      passed,
      timestamp,
      scanType,
      securityCheck,
      qualityCheck,
      recommendations
    };

    // 6. æ˜¾ç¤ºç»“æœ
    this.displayScanResult(result);

    // 7. è¿è¡Œæµ‹è¯•ï¼ˆå¦‚æœéœ€è¦ï¼‰
    if (options?.runTests) {
      await this.runMaliciousDiffTests();
    }

    return result;
  }

  /**
   * æ‰§è¡Œå®‰å…¨æ£€æŸ¥ï¼ˆå»ºè®®å±‚ï¼‰
   * 
   * é‡è¦ï¼šè¿™æ˜¯ Scanner çš„å®‰å…¨æ£€æŸ¥ï¼Œæä¾›è­¦å‘Šå’Œå»ºè®®
   * å†³ç­–å±‚çš„å®‰å…¨éªŒè¯åº”è¯¥ä½¿ç”¨ DiffSecurityValidator.validate()
   * 
   * åŒºåˆ«ï¼š
   * - DiffSecurityValidator.validate() = å¿…é¡»é€šè¿‡ï¼Œå¦åˆ™é˜»æ–­
   * - Scanner.performSecurityCheck() = å»ºè®®å’Œè­¦å‘Šï¼Œå¯é…ç½®
   */
  private async performSecurityCheck(
    parseResult: import('./diff').DiffResult,
    diffText: string
  ): Promise<SecurityCheckResult> {
    this.outputChannel.appendLine('[Scanner] Performing security check (advisory mode)...');

    // æ³¨æ„ï¼šè¿™é‡Œä½¿ç”¨ validator è¿›è¡Œæ£€æŸ¥ï¼Œä½†è¿™æ˜¯å»ºè®®å±‚çš„æ£€æŸ¥
    // å†³ç­–å±‚çš„éªŒè¯åº”è¯¥åœ¨è°ƒç”¨ Scanner ä¹‹å‰å®Œæˆ
    const textValidation = this.securityValidator.validateDiffText(diffText);
    const structureValidation = parseResult.success 
      ? this.securityValidator.validate(parseResult)
      : { valid: false, errors: [] };

    // åˆå¹¶é”™è¯¯
    const allErrors = [
      ...textValidation.errors,
      ...structureValidation.errors
    ];

    // è½¬æ¢ä¸ºå®‰å…¨é—®é¢˜æè¿°
    const securityIssues = allErrors.map(error => ({
      type: error.type,
      severity: this.mapErrorToSeverity(error.type),
      message: error.message,
      filePath: error.filePath,
      hunkIndex: error.hunkIndex,
      suggestion: this.generateSuggestionForError(error)
    }));

    const passed = parseResult.success && allErrors.length === 0;

    this.outputChannel.appendLine(
      `[Scanner] Security check: ${passed ? 'PASSED' : 'FAILED'} (${allErrors.length} issues)`
    );
    this.outputChannel.appendLine(
      `[Scanner] Note: This is advisory. Use DiffSecurityValidator.validate() for authoritative validation.`
    );

    return {
      passed,
      parseResult: {
        success: parseResult.success,
        fileCount: parseResult.success ? parseResult.files.length : 0,
        hunkCount: parseResult.success ? parseResult.stats.hunkCount : 0
      },
      validationResult: {
        valid: allErrors.length === 0,
        errors: allErrors
      },
      securityIssues
    };
  }

  /**
   * æ‰§è¡Œè´¨é‡æ£€æŸ¥
   */
  private async performQualityCheck(
    parseResult: import('./diff').DiffResult
  ): Promise<QualityCheckResult> {
    this.outputChannel.appendLine('[Scanner] Performing quality check...');

    if (!parseResult.success) {
      return {
        passed: false,
        metrics: {}
      };
    }

    // è®¡ç®—åŸºæœ¬æŒ‡æ ‡
    const totalLines = parseResult.stats.totalAdded + parseResult.stats.totalRemoved;
    const avgLinesPerFile = parseResult.files.length > 0 
      ? totalLines / parseResult.files.length 
      : 0;

    // æ£€æŸ¥ hunk å¤æ‚åº¦
    const totalHunks = parseResult.stats.hunkCount;
    const avgHunksPerFile = parseResult.files.length > 0
      ? totalHunks / parseResult.files.length
      : 0;

    const metrics: Record<string, number | string> = {
      totalFiles: parseResult.files.length,
      totalLines,
      totalHunks,
      avgLinesPerFile: Math.round(avgLinesPerFile * 100) / 100,
      avgHunksPerFile: Math.round(avgHunksPerFile * 100) / 100,
      linesAdded: parseResult.stats.totalAdded,
      linesRemoved: parseResult.stats.totalRemoved
    };

    // ç®€å•çš„è´¨é‡è§„åˆ™
    const passed = 
      avgLinesPerFile < 500 && // æ¯ä¸ªæ–‡ä»¶å¹³å‡ä¸è¶…è¿‡ 500 è¡Œ
      avgHunksPerFile < 20;  // æ¯ä¸ªæ–‡ä»¶å¹³å‡ä¸è¶…è¿‡ 20 ä¸ª hunks

    this.outputChannel.appendLine(
      `[Scanner] Quality check: ${passed ? 'PASSED' : 'FAILED'}`
    );

    return {
      passed,
      metrics
    };
  }

  /**
   * ç”Ÿæˆå»ºè®®
   */
  private generateRecommendations(
    securityCheck: SecurityCheckResult,
    qualityCheck?: QualityCheckResult
  ): string[] {
    const recommendations: string[] = [];

    // å®‰å…¨å»ºè®®
    if (!securityCheck.passed) {
      recommendations.push('Security issues detected. Review and fix before applying.');
      
      const criticalIssues = securityCheck.securityIssues.filter(i => i.severity === 'critical');
      const highIssues = securityCheck.securityIssues.filter(i => i.severity === 'high');
      
      if (criticalIssues.length > 0) {
        recommendations.push(`${criticalIssues.length} critical security issue(s) found.`);
      }
      if (highIssues.length > 0) {
        recommendations.push(`${highIssues.length} high-severity security issue(s) found.`);
      }
    } else {
      recommendations.push('No security issues detected.');
    }

    // è´¨é‡å»ºè®®
    if (qualityCheck && !qualityCheck.passed) {
      recommendations.push('Quality issues detected. Consider refactoring.');
      
      const avgLinesPerFile = typeof qualityCheck.metrics.avgLinesPerFile === 'number' 
        ? qualityCheck.metrics.avgLinesPerFile 
        : 0;
      const avgHunksPerFile = typeof qualityCheck.metrics.avgHunksPerFile === 'number' 
        ? qualityCheck.metrics.avgHunksPerFile 
        : 0;
      
      if (avgLinesPerFile > 500) {
        recommendations.push('Consider splitting large files into smaller modules.');
      }
      if (avgHunksPerFile > 20) {
        recommendations.push('Consider organizing changes into logical groups.');
      }
    } else if (qualityCheck) {
      recommendations.push('Code quality checks passed.');
    }

    return recommendations;
  }

  /**
   * æ˜ å°„é”™è¯¯ç±»å‹åˆ°ä¸¥é‡ç¨‹åº¦
   */
  private mapErrorToSeverity(
    errorType: SecurityIssue['type']
  ): 'low' | 'medium' | 'high' | 'critical' {
    const severityMap: Record<SecurityIssue['type'], 'low' | 'medium' | 'high' | 'critical'> = {
      PATH_TRAVERSAL: 'critical',
      ABSOLUTE_PATH: 'critical',
      FORBIDDEN_PATH_PATTERN: 'critical',
      HUNK_HEADER_FORGERY: 'high',
      INVALID_UNIFIED_DIFF: 'high',
      LINE_TOO_LONG: 'medium',
      CONTEXT_TOO_LARGE: 'low',
      HUNK_TOO_LARGE: 'medium',
      TOO_MANY_HUNKS: 'low',
      TOO_MANY_FILES: 'low',
      EXTENSION_NOT_ALLOWED: 'high'
    };

    return severityMap[errorType] || 'medium';
  }

  /**
   * ä¸ºé”™è¯¯ç”Ÿæˆå»ºè®®
   */
  private generateSuggestionForError(error: import('./diffSecurityValidator').SecurityValidationError): string {
    switch (error.type) {
      case 'PATH_TRAVERSAL':
        return 'Remove ".." from file paths and use relative paths within the workspace.';
      case 'ABSOLUTE_PATH':
        return 'Use relative paths instead of absolute paths.';
      case 'FORBIDDEN_PATH_PATTERN':
        return 'Avoid modifying system files or sensitive directories.';
      case 'HUNK_HEADER_FORGERY':
        return 'Ensure hunk headers match the actual line counts in the diff.';
      case 'LINE_TOO_LONG':
        return 'Break long lines into multiple lines for better readability.';
      case 'CONTEXT_TOO_LARGE':
        return 'Reduce the amount of context lines in the diff.';
      case 'HUNK_TOO_LARGE':
        return 'Split large hunks into smaller, more focused changes.';
      case 'TOO_MANY_HUNKS':
        return 'Consider organizing changes into separate commits.';
      case 'TOO_MANY_FILES':
        return 'Consider splitting changes into multiple logical commits.';
      case 'EXTENSION_NOT_ALLOWED':
        return 'File extension is not allowed in the current security policy.';
      default:
        return 'Review and fix the identified issue.';
    }
  }

  /**
   * æ˜¾ç¤ºæ‰«æç»“æœ
   */
  private displayScanResult(result: ScanResult): void {
    const message = result.passed 
      ? 'âœ… Security and quality checks passed'
      : 'âš ï¸ Security or quality issues detected';

    const details = `
Scan Summary:
- Type: ${result.scanType.toUpperCase()}
- Status: ${result.passed ? 'PASSED' : 'FAILED'}
- Security: ${result.securityCheck.passed ? 'âœ…' : 'âŒ'} (${result.securityCheck.securityIssues.length} issues)
${result.qualityCheck ? `- Quality: ${result.qualityCheck.passed ? 'âœ…' : 'âŒ'}` : ''}

Recommendations:
${result.recommendations.map(r => `â€¢ ${r}`).join('\n')}
    `.trim();

    // æ˜¾ç¤ºåˆ°è¾“å‡ºé¢æ¿
    this.outputChannel.appendLine('\n' + '='.repeat(60));
    this.outputChannel.appendLine(details);
    this.outputChannel.appendLine('='.repeat(60));
    this.outputChannel.show(true);

    // æ˜¾ç¤ºé€šçŸ¥
    if (result.passed) {
      vscode.window.showInformationMessage(message, 'View Details').then(selection => {
        if (selection === 'View Details') {
          this.outputChannel.show(true);
        }
      });
    } else {
      vscode.window.showWarningMessage(message, 'View Details', 'Ignore').then(selection => {
        if (selection === 'View Details') {
          this.outputChannel.show(true);
        }
      });
    }
  }

  /**
   * è¿è¡Œæ¶æ„ Diff é˜²å¾¡æµ‹è¯•
   */
  private async runMaliciousDiffTests(): Promise<void> {
    this.outputChannel.appendLine('\n[Scanner] Running malicious diff defense tests...');

    try {
      // æ³¨æ„ï¼šç”±äº TypeScript çš„ rootDir é™åˆ¶ï¼Œæ— æ³•ç›´æ¥ä» src/ å¯¼å…¥ test/ ç›®å½•
      // è¿™ä¸ªåŠŸèƒ½éœ€è¦é€šè¿‡å¤–éƒ¨å‘½ä»¤æˆ–ç¼–è¯‘åçš„æµ‹è¯•æ¨¡å—æ¥å®ç°
      // è¿™é‡Œæˆ‘ä»¬åªè®°å½•æ—¥å¿—ï¼Œå®é™…æµ‹è¯•åº”è¯¥é€šè¿‡å‘½ä»¤è¡Œè¿è¡Œ
      
      this.outputChannel.appendLine('[Scanner] âš ï¸ Test integration requires external test runner');
      this.outputChannel.appendLine('[Scanner] Tip: Run "npm test" to execute malicious diff defense tests');
      
      // TODO: å¯ä»¥é€šè¿‡ vscode.commands.executeCommand è°ƒç”¨å¤–éƒ¨æµ‹è¯•å‘½ä»¤
      // const testCommand = vscode.commands.executeCommand('vsyuangs.runMaliciousDiffTests');
    } catch (error) {
      this.outputChannel.appendLine(`[Scanner] âŒ Failed to run tests: ${error}`);
    }
  }

  /**
   * æ‰«æ Review å»ºè®®ä¸­çš„ Diff
   */
  async scanReviewSuggestion(suggestion: ReviewSuggestion): Promise<ScanResult> {
    if (!suggestion.diff) {
      vscode.window.showWarningMessage('Suggestion does not contain a diff to scan');
      return {
        passed: false,
        timestamp: new Date(),
        scanType: 'security',
        securityCheck: {
          passed: false,
          parseResult: { success: false, fileCount: 0, hunkCount: 0 },
          validationResult: { valid: false, errors: [] },
          securityIssues: []
        },
        recommendations: ['No diff content to scan']
      };
    }

    return await this.scanGeneratedCode(suggestion.diff.content, {
      scanType: 'security',
      runTests: false
    });
  }

  /**
   * æ¸…ç†èµ„æº
   */
  dispose(): void {
    this.outputChannel.dispose();
  }
}

/**
 * å…¨å±€æ‰«æå™¨å®ä¾‹
 */
let globalScanner: AutomatedTestScanner | null = null;

/**
 * è·å–å…¨å±€æ‰«æå™¨å®ä¾‹
 */
export function getScanner(): AutomatedTestScanner {
  if (!globalScanner) {
    globalScanner = new AutomatedTestScanner();
  }
  return globalScanner;
}

/**
 * æ¸…ç†å…¨å±€æ‰«æå™¨
 */
export function disposeScanner(): void {
  if (globalScanner) {
    globalScanner.dispose();
    globalScanner = null;
  }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/SecurityScanCoordinator.ts

````typescript
/**
 * Security Scan Coordinator - åŒå±‚å®‰å…¨é˜²æŠ¤åè°ƒå™¨
 * 
 * è®¾è®¡åŸåˆ™ï¼š
 * - AI ä»‹å…¥å‰ï¼šè¿è¡Œæœ¬åœ°å¿«é€Ÿæ‰«æ
 * - Diff åº”ç”¨å‰ï¼šè¿è¡Œå®Œæ•´çš„å®‰å…¨éªŒè¯
 * - Diff åº”ç”¨åï¼šè¿è¡Œè¯­ä¹‰çº§åˆ«å®¡æŸ¥
 * - æ±‡æ€»æ‰€æœ‰å®‰å…¨ç»“æœå¹¶å±•ç¤º
 * 
 * åŒå±‚é˜²æŠ¤ä½“ç³»ï¼š
 * - Layer 1: æœ¬åœ°è§„åˆ™æ‰«æï¼ˆ<50msï¼Œæ—  LLMï¼‰
 * - Layer 2: è¯­ä¹‰çº§åˆ«éªŒè¯ï¼ˆéœ€è¦ LLMï¼Œæ›´æ™ºèƒ½ï¼‰
 */

import * as vscode from 'vscode';
import { DiffParseResult } from './diff';
import { DiffSecurityValidator } from './diffSecurityValidator';
import { QuickSecurityScanner } from './quickSecurityScanner';
import { SecuritySeverity, SecurityIssue, IssueType } from './securityTypes';

/**
 * å®‰å…¨æ‰«æé˜¶æ®µ
 */
export enum ScanPhase {
  /** Phase 1: AI ä»‹å…¥å‰çš„æœ¬åœ°æ‰«æ */
  BEFORE_AI = 'before_ai',
  /** Phase 2: Diff åº”ç”¨å‰çš„éªŒè¯ */
  BEFORE_APPLY = 'before_apply',
  /** Phase 3: Diff åº”ç”¨åçš„è¯­ä¹‰å®¡æŸ¥ */
  AFTER_APPLY = 'after_apply'
}

/**
 * å®‰å…¨æ‰«æç»“æœ
 */
export interface SecurityScanResult {
  /** æ‰«æé˜¶æ®µ */
  phase: ScanPhase;
  /** æ˜¯å¦é€šè¿‡ */
  passed: boolean;
  /** å‘ç°çš„é—®é¢˜ */
  issues: SecurityIssue[];
  /** æ‰«æè€—æ—¶ï¼ˆæ¯«ç§’ï¼‰ */
  duration: number;
  /** æ‰«ææ—¶é—´æˆ³ */
  timestamp: number;
}

/**
 * ç»¼åˆå®‰å…¨æŠ¥å‘Š
 */
export interface ComprehensiveSecurityReport {
  /** æ‰€æœ‰æ‰«æç»“æœ */
  scans: SecurityScanResult[];
  /** æ€»ä½“è¯„ä¼° */
  overallStatus: 'passed' | 'warning' | 'failed';
  /** å…³é”®é—®é¢˜æ•°é‡ */
  criticalIssueCount: number;
  /** é”™è¯¯çº§åˆ«é—®é¢˜æ•°é‡ */
  errorIssueCount: number;
  /** è­¦å‘Šçº§åˆ«é—®é¢˜æ•°é‡ */
  warningIssueCount: number;
  /** ä¿¡æ¯çº§åˆ«é—®é¢˜æ•°é‡ */
  infoIssueCount: number;
  /** æ€»è€—æ—¶ */
  totalDuration: number;
}

/**
 * å®‰å…¨æ‰«æåè°ƒå™¨é€‰é¡¹
 */
export interface SecurityScanCoordinatorOptions {
  /** æ˜¯å¦å¯ç”¨ AI ä»‹å…¥å‰æ‰«æï¼ˆé»˜è®¤ trueï¼‰ */
  enableBeforeAiScan?: boolean;
  /** æ˜¯å¦å¯ç”¨ Diff åº”ç”¨å‰éªŒè¯ï¼ˆé»˜è®¤ trueï¼‰ */
  enableBeforeApplyValidation?: boolean;
  /** æ˜¯å¦å¯ç”¨ Diff åº”ç”¨åè¯­ä¹‰å®¡æŸ¥ï¼ˆé»˜è®¤ trueï¼‰ */
  enableAfterApplyReview?: boolean;
  /** æ˜¯å¦è‡ªåŠ¨æ˜¾ç¤ºè¯Šæ–­ä¿¡æ¯ï¼ˆé»˜è®¤ trueï¼‰ */
  autoShowDiagnostics?: boolean;
  /** æ˜¯å¦åœ¨å‘ç°å…³é”®é—®é¢˜æ—¶é˜»æ­¢åº”ç”¨ï¼ˆé»˜è®¤ trueï¼‰ */
  blockOnCritical?: boolean;
}

/**
 * é»˜è®¤é€‰é¡¹
 */
const DEFAULT_OPTIONS: SecurityScanCoordinatorOptions = {
  enableBeforeAiScan: true,
  enableBeforeApplyValidation: true,
  enableAfterApplyReview: true,
  autoShowDiagnostics: true,
  blockOnCritical: true
};

/**
 * å®‰å…¨æ‰«æåè°ƒå™¨
 * 
 * åè°ƒä¸‰å±‚å®‰å…¨æ‰«æï¼Œå½¢æˆå®Œæ•´çš„é˜²æŠ¤ä½“ç³»
 * 
 * ä½¿ç”¨ç¤ºä¾‹ï¼š
 * ```typescript
 * const coordinator = new SecurityScanCoordinator();
 * 
 * // AI ä»‹å…¥å‰æ‰«æ
 * const beforeAiReport = await coordinator.scanBeforeAi(code, filePath);
 * if (!beforeAiReport.passed && coordinator.options.blockOnCritical) {
 *   // é˜»æ­¢ AI ä»‹å…¥
 *   return;
 * }
 * 
 * // Diff åº”ç”¨å‰éªŒè¯
 * const beforeApplyReport = await coordinator.validateBeforeApply(diff);
 * if (!beforeApplyReport.passed) {
 *   // é˜»æ­¢åº”ç”¨
 *   return;
 * }
 * 
 * // Diff åº”ç”¨åå®¡æŸ¥
 * const afterApplyReport = await coordinator.reviewAfterApply(appliedFiles);
 * ```
 */
export class SecurityScanCoordinator {
  private options: SecurityScanCoordinatorOptions;
  private quickScanner: QuickSecurityScanner;
  private securityValidator: DiffSecurityValidator;
  private diagnosticCollection: vscode.DiagnosticCollection;
  private scanHistory: SecurityScanResult[] = [];

  constructor(options: SecurityScanCoordinatorOptions = {}) {
    this.options = { ...DEFAULT_OPTIONS, ...options };
    this.quickScanner = new QuickSecurityScanner();
    this.securityValidator = new DiffSecurityValidator();
    this.diagnosticCollection = vscode.languages.createDiagnosticCollection('yuangs-security');
  }

  /**
   * Phase 1: AI ä»‹å…¥å‰çš„æœ¬åœ°æ‰«æ
   * 
   * åœ¨ AI ç”Ÿæˆä»£ç ä¹‹å‰ï¼Œè¿è¡Œå¿«é€Ÿæœ¬åœ°æ‰«æ
   * 
   * @param code ä»£ç å†…å®¹
   * @param filePath æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰
   * @param document VS Code æ–‡æ¡£å¯¹è±¡ï¼ˆå¯é€‰ï¼Œç”¨äºç²¾ç¡®è®¡ç®—è¡Œåˆ—å·ï¼‰
   * @returns å®‰å…¨æ‰«æç»“æœ
   */
  async scanBeforeAi(
    code: string,
    filePath?: string,
    document?: vscode.TextDocument
  ): Promise<SecurityScanResult> {
    if (!this.options.enableBeforeAiScan) {
      return this.createEmptyResult(ScanPhase.BEFORE_AI);
    }

    console.log(`[SecurityScanCoordinator] Phase 1: Scanning before AI for ${filePath || 'unknown'}`);
    const startTime = Date.now();

    try {
      // ä½¿ç”¨ QuickSecurityScanner è¿›è¡Œå¿«é€Ÿæ‰«æ
      const quickResult = await this.quickScanner.quickScan(code, filePath, document);

      const result: SecurityScanResult = {
        phase: ScanPhase.BEFORE_AI,
        passed: quickResult.valid,
        issues: quickResult.issues,
        duration: Date.now() - startTime,
        timestamp: Date.now()
      };

      this.scanHistory.push(result);
      this.updateDiagnostics(result, document);

      if (result.passed) {
        console.log(`[SecurityScanCoordinator] âœ“ Phase 1 passed (${result.duration}ms)`);
      } else {
        console.warn(`[SecurityScanCoordinator] âœ— Phase 1 failed: found ${result.issues.length} issues`);
      }

      return result;
    } catch (error) {
      console.error('[SecurityScanCoordinator] Phase 1 scan failed:', error);
      return {
        phase: ScanPhase.BEFORE_AI,
        passed: false,
        issues: [],
        duration: Date.now() - startTime,
        timestamp: Date.now()
      };
    }
  }

  /**
   * Phase 2: Diff åº”ç”¨å‰çš„éªŒè¯
   * 
   * åœ¨åº”ç”¨ diff ä¹‹å‰ï¼Œè¿›è¡Œå®Œæ•´çš„å®‰å…¨éªŒè¯
   * 
   * @param diff è§£æåçš„ diff
   * @returns å®‰å…¨æ‰«æç»“æœ
   */
  async validateBeforeApply(diff: DiffParseResult): Promise<SecurityScanResult> {
    if (!this.options.enableBeforeApplyValidation) {
      return this.createEmptyResult(ScanPhase.BEFORE_APPLY);
    }

    console.log('[SecurityScanCoordinator] Phase 2: Validating before apply');
    const startTime = Date.now();

    try {
      // ä½¿ç”¨ DiffSecurityValidator è¿›è¡Œå®Œæ•´éªŒè¯
      const validationResult = this.securityValidator.validate(diff);

      // å°†éªŒè¯é”™è¯¯è½¬æ¢ä¸º SecurityIssue æ ¼å¼
      const issues: SecurityIssue[] = validationResult.errors.map(error => ({
        type: this.mapErrorTypeToIssueType(error.type),
        severity: this.mapErrorTypeToSeverity(error.type),
        message: error.message,
        filePath: error.filePath,
        line: error.line,
        ruleId: `SEC_VALIDATION_${error.type}`
      }));

      const result: SecurityScanResult = {
        phase: ScanPhase.BEFORE_APPLY,
        passed: validationResult.valid,
        issues,
        duration: Date.now() - startTime,
        timestamp: Date.now()
      };

      this.scanHistory.push(result);

      if (result.passed) {
        console.log(`[SecurityScanCoordinator] âœ“ Phase 2 passed (${result.duration}ms)`);
      } else {
        console.warn(`[SecurityScanCoordinator] âœ— Phase 2 failed: found ${result.issues.length} issues`);
      }

      return result;
    } catch (error) {
      console.error('[SecurityScanCoordinator] Phase 2 validation failed:', error);
      return {
        phase: ScanPhase.BEFORE_APPLY,
        passed: false,
        issues: [],
        duration: Date.now() - startTime,
        timestamp: Date.now()
      };
    }
  }

  /**
   * Phase 3: Diff åº”ç”¨åçš„è¯­ä¹‰å®¡æŸ¥
   * 
   * åœ¨åº”ç”¨ diff ä¹‹åï¼Œè¿›è¡Œè¯­ä¹‰çº§åˆ«çš„å®¡æŸ¥
   * 
   * @param appliedFiles å·²åº”ç”¨çš„æ–‡ä»¶åˆ—è¡¨
   * @param diff åŸå§‹ diffï¼ˆå¯é€‰ï¼Œç”¨äºä¸Šä¸‹æ–‡ï¼‰
   * @returns å®‰å…¨æ‰«æç»“æœ
   */
  async reviewAfterApply(
    appliedFiles: string[],
    diff?: DiffParseResult
  ): Promise<SecurityScanResult> {
    if (!this.options.enableAfterApplyReview) {
      return this.createEmptyResult(ScanPhase.AFTER_APPLY);
    }

    console.log(`[SecurityScanCoordinator] Phase 3: Reviewing after apply for ${appliedFiles.length} files`);
    const startTime = Date.now();

    try {
      const issues: SecurityIssue[] = [];

      // å¯¹æ¯ä¸ªæ–‡ä»¶è¿›è¡Œè¯­ä¹‰å®¡æŸ¥
      // æ³¨æ„ï¼šSemanticReviewValidator æ˜¯é™æ€ç±»ï¼Œç›´æ¥è°ƒç”¨æ–¹æ³•
      // è¿™é‡Œæš‚æ—¶è·³è¿‡è¯­ä¹‰å®¡æŸ¥ï¼Œå› ä¸ºéœ€è¦ ReviewResultV1 æ ¼å¼
      // TODO: é›†æˆè¯­ä¹‰å®¡æŸ¥å™¨

      console.log('[SecurityScanCoordinator] Phase 3: Semantic review skipped (integration needed)');

      const result: SecurityScanResult = {
        phase: ScanPhase.AFTER_APPLY,
        passed: !issues.some(i => i.severity === SecuritySeverity.CRITICAL),
        issues,
        duration: Date.now() - startTime,
        timestamp: Date.now()
      };

      this.scanHistory.push(result);
      this.updateDiagnosticsForFiles(result, appliedFiles);

      if (result.passed) {
        console.log(`[SecurityScanCoordinator] âœ“ Phase 3 passed (${result.duration}ms)`);
      } else {
        console.warn(`[SecurityScanCoordinator] âœ— Phase 3 found ${result.issues.length} issues`);
      }

      return result;
    } catch (error) {
      console.error('[SecurityScanCoordinator] Phase 3 review failed:', error);
      return {
        phase: ScanPhase.AFTER_APPLY,
        passed: false,
        issues: [],
        duration: Date.now() - startTime,
        timestamp: Date.now()
      };
    }
  }

  /**
   * è¿è¡Œå®Œæ•´çš„ä¸‰å±‚æ‰«ææµç¨‹
   * 
   * @param code åŸå§‹ä»£ç ï¼ˆPhase 1ï¼‰
   * @param diff è§£æåçš„ diffï¼ˆPhase 2ï¼‰
   * @param appliedFiles å·²åº”ç”¨çš„æ–‡ä»¶ï¼ˆPhase 3ï¼‰
   * @param filePath æ–‡ä»¶è·¯å¾„ï¼ˆPhase 1ï¼‰
   * @param document VS Code æ–‡æ¡£å¯¹è±¡ï¼ˆPhase 1ï¼‰
   * @returns ç»¼åˆå®‰å…¨æŠ¥å‘Š
   */
  async runFullScanPipeline(
    code: string,
    diff: DiffParseResult,
    appliedFiles: string[],
    filePath?: string,
    document?: vscode.TextDocument
  ): Promise<ComprehensiveSecurityReport> {
    console.log('[SecurityScanCoordinator] Running full scan pipeline...');

    const scans: SecurityScanResult[] = [];

    // Phase 1: AI ä»‹å…¥å‰æ‰«æ
    const phase1Result = await this.scanBeforeAi(code, filePath, document);
    scans.push(phase1Result);

    // å¦‚æœ Phase 1 å‘ç°å…³é”®é—®é¢˜ä¸”é…ç½®ä¸ºé˜»æ­¢ï¼Œç›´æ¥è¿”å›
    if (!phase1Result.passed && this.options.blockOnCritical) {
      const criticalIssues = phase1Result.issues.filter(i => i.severity === SecuritySeverity.CRITICAL);
      if (criticalIssues.length > 0) {
        console.warn('[SecurityScanCoordinator] Blocking due to critical issues in Phase 1');
        return this.generateReport(scans);
      }
    }

    // Phase 2: Diff åº”ç”¨å‰éªŒè¯
    const phase2Result = await this.validateBeforeApply(diff);
    scans.push(phase2Result);

    // å¦‚æœ Phase 2 å¤±è´¥ï¼Œç›´æ¥è¿”å›
    if (!phase2Result.passed && this.options.blockOnCritical) {
      console.warn('[SecurityScanCoordinator] Blocking due to validation failures in Phase 2');
      return this.generateReport(scans);
    }

    // Phase 3: Diff åº”ç”¨åå®¡æŸ¥
    const phase3Result = await this.reviewAfterApply(appliedFiles, diff);
    scans.push(phase3Result);

    console.log('[SecurityScanCoordinator] Full scan pipeline completed');
    return this.generateReport(scans);
  }

  /**
   * ç”Ÿæˆç»¼åˆå®‰å…¨æŠ¥å‘Š
   */
  private generateReport(scans: SecurityScanResult[]): ComprehensiveSecurityReport {
    let criticalCount = 0;
    let errorCount = 0;
    let warningCount = 0;
    let infoCount = 0;

    for (const scan of scans) {
      for (const issue of scan.issues) {
        switch (issue.severity) {
          case SecuritySeverity.CRITICAL:
            criticalCount++;
            break;
          case SecuritySeverity.ERROR:
            errorCount++;
            break;
          case SecuritySeverity.WARNING:
            warningCount++;
            break;
          case SecuritySeverity.INFO:
            infoCount++;
            break;
        }
      }
    }

    let overallStatus: 'passed' | 'warning' | 'failed';
    if (criticalCount > 0 || errorCount > 0) {
      overallStatus = 'failed';
    } else if (warningCount > 0) {
      overallStatus = 'warning';
    } else {
      overallStatus = 'passed';
    }

    const totalDuration = scans.reduce((sum, scan) => sum + scan.duration, 0);

    return {
      scans,
      overallStatus,
      criticalIssueCount: criticalCount,
      errorIssueCount: errorCount,
      warningIssueCount: warningCount,
      infoIssueCount: infoCount,
      totalDuration
    };
  }

  /**
   * æ›´æ–°è¯Šæ–­ä¿¡æ¯
   */
  private updateDiagnostics(result: SecurityScanResult, document?: vscode.TextDocument): void {
    if (!this.options.autoShowDiagnostics || !document) return;

    const diagnostics: vscode.Diagnostic[] = [];

    for (const issue of result.issues) {
      if (issue.line !== undefined) {
        const range = new vscode.Range(
          issue.line,
          issue.column || 0,
          issue.line,
          document.lineAt(issue.line).range.end.character
        );

        const severity = this.mapSeverityToDiagnosticSeverity(issue.severity);
        const diagnostic = new vscode.Diagnostic(
          range,
          issue.message,
          severity
        );
        diagnostic.code = issue.ruleId;
        diagnostics.push(diagnostic);
      }
    }

    this.diagnosticCollection.set(document.uri, diagnostics);
  }

  /**
   * æ›´æ–°å¤šä¸ªæ–‡ä»¶çš„è¯Šæ–­ä¿¡æ¯
   */
  private updateDiagnosticsForFiles(result: SecurityScanResult, fileNames: string[]): void {
    if (!this.options.autoShowDiagnostics) return;

    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) return;

    const diagnosticsMap = new Map<string, vscode.Diagnostic[]>();

    for (const issue of result.issues) {
      if (!issue.filePath || issue.line === undefined) continue;

      const fileUri = vscode.Uri.joinPath(workspaceFolder.uri, issue.filePath);
      const diagnostics = diagnosticsMap.get(fileUri.toString()) || [];

      const range = new vscode.Range(
        issue.line,
        issue.column || 0,
        issue.line,
        100 // å‡è®¾è¡Œé•¿ä¸è¶…è¿‡ 100
      );

      const severity = this.mapSeverityToDiagnosticSeverity(issue.severity);
      const diagnostic = new vscode.Diagnostic(
        range,
        issue.message,
        severity
      );
      diagnostic.code = issue.ruleId;
      diagnostics.push(diagnostic);

      diagnosticsMap.set(fileUri.toString(), diagnostics);
    }

    // åº”ç”¨è¯Šæ–­ä¿¡æ¯
    for (const [uriStr, diagnostics] of diagnosticsMap) {
      const uri = vscode.Uri.parse(uriStr);
      this.diagnosticCollection.set(uri, diagnostics);
    }
  }

  /**
   * æ¸…ç©ºè¯Šæ–­ä¿¡æ¯
   */
  clearDiagnostics(): void {
    this.diagnosticCollection.clear();
  }

  /**
   * è·å–æ‰«æå†å²
   */
  getScanHistory(): SecurityScanResult[] {
    return [...this.scanHistory];
  }

  /**
   * æ¸…ç©ºæ‰«æå†å²
   */
  clearHistory(): void {
    this.scanHistory = [];
  }

  /**
   * æ˜ å°„é”™è¯¯ç±»å‹åˆ°é—®é¢˜ç±»å‹
   */
  private mapErrorTypeToIssueType(
    errorType: string
  ): IssueType {
    // ç®€åŒ–æ˜ å°„ï¼Œæ ¹æ®éœ€è¦æ‰©å±•
    if (errorType.includes('PATH') || errorType.includes('FILE')) {
      return IssueType.SECURITY_PATH;
    }
    if (errorType.includes('LINE') || errorType.includes('HUNK')) {
      return IssueType.SECURITY_INJECTION;
    }
    return IssueType.SECURITY_LEAK;
  }

  /**
   * æ˜ å°„é”™è¯¯ç±»å‹åˆ°ä¸¥é‡ç¨‹åº¦
   */
  private mapErrorTypeToSeverity(
    errorType: string
  ): SecuritySeverity {
    // ç®€åŒ–æ˜ å°„ï¼Œæ ¹æ®éœ€è¦æ‰©å±•
    if (errorType.includes('PATH') || errorType.includes('CRITICAL')) {
      return SecuritySeverity.CRITICAL;
    }
    return SecuritySeverity.ERROR;
  }

  /**
   * æ˜ å°„ä¸¥é‡ç¨‹åº¦åˆ°è¯Šæ–­ä¸¥é‡ç¨‹åº¦
   */
  private mapSeverityToDiagnosticSeverity(
    severity: SecuritySeverity
  ): vscode.DiagnosticSeverity {
    switch (severity) {
      case SecuritySeverity.CRITICAL:
        return vscode.DiagnosticSeverity.Error;
      case SecuritySeverity.ERROR:
        return vscode.DiagnosticSeverity.Error;
      case SecuritySeverity.WARNING:
        return vscode.DiagnosticSeverity.Warning;
      case SecuritySeverity.INFO:
        return vscode.DiagnosticSeverity.Information;
      default:
        return vscode.DiagnosticSeverity.Hint;
    }
  }

  /**
   * åˆ›å»ºç©ºç»“æœ
   */
  private createEmptyResult(phase: ScanPhase): SecurityScanResult {
    return {
      phase,
      passed: true,
      issues: [],
      duration: 0,
      timestamp: Date.now()
    };
  }

  /**
   * æ›´æ–°é€‰é¡¹
   */
  updateOptions(options: Partial<SecurityScanCoordinatorOptions>): void {
    this.options = { ...this.options, ...options };
  }

  /**
   * è·å–å½“å‰é€‰é¡¹
   */
  getOptions(): SecurityScanCoordinatorOptions {
    return { ...this.options };
  }

  /**
   * é”€æ¯èµ„æº
   */
  dispose(): void {
    this.diagnosticCollection.dispose();
  }
}

/**
 * å•ä¾‹å®ä¾‹
 */
let coordinatorInstance: SecurityScanCoordinator | null = null;

export function getSecurityScanCoordinator(): SecurityScanCoordinator {
  if (!coordinatorInstance) {
    coordinatorInstance = new SecurityScanCoordinator();
  }
  return coordinatorInstance;
}

export function resetSecurityScanCoordinator(): void {
  if (coordinatorInstance) {
    coordinatorInstance.dispose();
    coordinatorInstance = null;
  }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/diff.ts

````typescript
/**
 * Diff Parser v2 - Unified Diff è§£æå™¨ï¼ˆç±»å‹å®‰å…¨ + æ ¡éªŒï¼‰
 * 
 * è®¾è®¡åŸåˆ™ï¼š
 * - è¯­ä¹‰ä¸å¯å˜ï¼šä¸€ä¸ª block = ä¸€ä¸ª hunk
 * - ä¸ä½¿ç”¨ union ç±»å‹
 * - Parser é˜¶æ®µå®Œæˆæ ¡éªŒ
 * - ä¸º Safe Apply Engine æ‰“åŸºç¡€
 * 
 * æ”¯æŒçš„ diff å½¢æ€ï¼ˆä¸¥æ ¼ unified diff å­é›†ï¼‰ï¼š
 * - --- a/path/to/file.ts
 * - +++ b/path/to/file.ts
 * - @@ -start,count +start,count @@ optional context
 * - - removed line
 * - + added line
 *   unchanged line (context)
 */

import * as vscode from 'vscode';

// ============================================================================
// ç±»å‹å®šä¹‰ï¼ˆv2 æ ¸å¿ƒï¼‰
// ============================================================================

/**
 * Diff è¡Œç±»å‹ï¼ˆå¼ºç±»å‹ï¼Œæ—  unionï¼‰
 */
export interface DiffLine {
  /** è¡Œç±»å‹ */
  type: 'context' | 'add' | 'remove';
  /** å»é™¤ +/- åçš„å†…å®¹ */
  content: string;
  /** åŸå§‹ diff è¡Œï¼ˆä¿ç•™ + / -ï¼‰ */
  raw: string;
  /** åœ¨ diff ä¸­çš„è¡Œå·ï¼ˆä» 0 å¼€å§‹ï¼‰ */
  lineNumber: number;
}

/**
 * Diff Hunkï¼ˆä¸€ä¸ª @@@ å—ï¼‰
 */
export interface DiffHunk {
  /** æ–‡ä»¶è·¯å¾„ï¼ˆå·²è§„èŒƒåŒ–ï¼Œæ—  a/ æˆ– b/ å‰ç¼€ï¼‰ */
  filePath: string;
  /** è¯­è¨€ç±»å‹ï¼ˆæ¨æ–­ï¼‰ */
  language?: string;
  /** Hunk å¤´éƒ¨ï¼š@@ -oldStart,oldCount +newStart,newCount @@ */
  header: string;
  /** æ—§æ–‡ä»¶èµ·å§‹è¡Œå· */
  oldStart: number;
  /** æ—§æ–‡ä»¶è¡Œæ•° */
  oldCount: number;
  /** æ–°æ–‡ä»¶èµ·å§‹è¡Œå· */
  newStart: number;
  /** æ–°æ–‡ä»¶è¡Œæ•° */
  newCount: number;
  /** Hunk å†…çš„æ‰€æœ‰è¡Œ */
  lines: DiffLine[];
  /** ç»Ÿè®¡ä¿¡æ¯ */
  stats: {
    added: number;
    removed: number;
    context: number;
  };
}

/**
 * Diff Fileï¼ˆä¸€ä¸ªæ–‡ä»¶çš„å®Œæ•´ diffï¼‰
 */
export interface DiffFile {
  /** åŸå§‹è·¯å¾„ */
  oldPath: string;
  /** æ–°è·¯å¾„ */
  newPath: string;
  /** è§„èŒƒåŒ–åçš„è·¯å¾„ */
  normalizedPath: string;
  /** è¯¥æ–‡ä»¶çš„æ‰€æœ‰ hunks */
  hunks: DiffHunk[];
  /** è¯¥æ–‡ä»¶çš„ç»Ÿè®¡ */
  stats: {
    added: number;
    removed: number;
    context: number;
    hunkCount: number;
  };
}

/**
 * å®‰å…¨é™åˆ¶é”™è¯¯è¯¦æƒ…
 */
export interface LimitExceededDetail {
  /** é™åˆ¶ç±»å‹ */
  type: 'MAX_LINE_LENGTH' | 'MAX_CONTEXT_LINES' | 'MAX_HUNKS' | 'MAX_FILES';
  /** å®é™…å€¼ */
  actual: number;
  /** æœ€å¤§å…è®¸å€¼ */
  max: number;
}

/**
 * è§£æç»“æœï¼ˆæˆåŠŸï¼‰
 */
export interface DiffParseResult {
  success: true;
  files: DiffFile[];
  stats: {
    fileCount: number;
    hunkCount: number;
    totalAdded: number;
    totalRemoved: number;
  };
}

/**
 * è§£æé”™è¯¯ï¼ˆå¸¦ä¸Šä¸‹æ–‡ï¼‰
 */
export interface DiffParseError {
  success: false;
  error: 'INVALID_FORMAT' | 'HUNK_MISMATCH' | 'INVALID_PATH' | 
          'MISSING_CONTEXT' | 'LINE_COUNT_MISMATCH' | 'LIMIT_EXCEEDED';
  message: string;
  line?: number;
  hunkIndex?: number;
  /** å®‰å…¨é™åˆ¶è¯¦æƒ…ï¼ˆä»…å½“ error === 'LIMIT_EXCEEDED' æ—¶å­˜åœ¨ï¼‰*/
  limit?: LimitExceededDetail;
}

/**
 * è§£æç»“æœç±»å‹
 */
export type DiffResult = DiffParseResult | DiffParseError;

// ============================================================================
// Diff Parser v2ï¼ˆæ ¸å¿ƒå¼•æ“ï¼‰
// ============================================================================

/**
 * Unified Diff Parser v2
 * 
 * ç‰¹æ€§ï¼š
 * - ä¸¥æ ¼æ ¡éªŒï¼ˆcontext è¡Œã€è¡Œæ•°ç»Ÿè®¡ï¼‰
 * - ç±»å‹å®‰å…¨ï¼ˆæ—  unionï¼‰
 * - å¯è¿½æº¯é”™è¯¯ï¼ˆå¸¦è¡Œå·ã€hunk ç´¢å¼•ï¼‰
 * - æ”¯æŒå¤šæ–‡ä»¶ diff
 */
export class DiffParser {
  /**
   * è§£æ unified diff æ–‡æœ¬
   * 
   * @param text unified diff æ–‡æœ¬
   * @returns è§£æç»“æœï¼ˆæˆåŠŸæˆ–é”™è¯¯ï¼‰
   */
  static parse(text: string): DiffResult {
    const lines = text.split('\n');
    const files: DiffFile[] = [];

    let currentFile: DiffFile | null = null;
    let currentHunk: DiffHunk | null = null;
    let oldPath = '';
    let newPath = '';
    let normalizedPath = '';

    // ç»Ÿè®¡å˜é‡
    let totalHunkCount = 0;
    let totalAdded = 0;
    let totalRemoved = 0;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i]; // v2.1ï¼šå®Œå…¨ä¿ç•™åŸå§‹è¡Œï¼ˆåŒ…æ‹¬å³ä¾§ç©ºæ ¼ï¼‰
      const trimmedLine = line.trim();

      // 1. æ£€æµ‹æ–‡ä»¶å¤´ï¼š--- a/file
      if (trimmedLine.startsWith('--- ')) {
        const match = trimmedLine.match(/^---\s+(?:a\/)?(.+?)(?:\s+|$)/);
        if (!match) {
          return this.error('INVALID_FORMAT', 'Invalid old file header', i);
        }
        oldPath = match[1] || '';
        continue;
      }

      // 2. æ£€æµ‹æ–‡ä»¶å¤´ï¼š+++ b/file
      if (trimmedLine.startsWith('+++ ')) {
        const match = trimmedLine.match(/^\+\+\+\s+(?:b\/)?(.+?)(?:\s+|$)/);
        if (!match) {
          return this.error('INVALID_FORMAT', 'Invalid new file header', i);
        }
        newPath = match[1] || '';

        // è§„èŒƒåŒ–è·¯å¾„
        normalizedPath = this.normalizePath(newPath);

        // ä¿å­˜å‰ä¸€ä¸ªæ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (currentFile) {
          // Finalize å‰ä¸€ä¸ª hunkï¼ˆå¦‚æœå­˜åœ¨ï¼‰
          if (currentHunk) {
            this.finalizeHunk(currentFile, currentHunk);
            currentHunk = null;
          }

          files.push(currentFile);
          totalHunkCount += currentFile.stats.hunkCount;
          totalAdded += currentFile.stats.added;
          totalRemoved += currentFile.stats.removed;
        }

        // åˆ›å»ºæ–°æ–‡ä»¶
        currentFile = {
          oldPath,
          newPath,
          normalizedPath,
          hunks: [],
          stats: {
            added: 0,
            removed: 0,
            context: 0,
            hunkCount: 0
          }
        };

        continue;
      }

      // 3. æ£€æµ‹ hunk å¤´ï¼š@@ -a,b +c,d @@
      if (trimmedLine.startsWith('@@')) {
        if (!currentFile) {
          return this.error('INVALID_FORMAT', 'Hunk found before file header', i);
        }

        // ä¿å­˜å‰ä¸€ä¸ª hunkï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (currentHunk) {
          this.finalizeHunk(currentFile, currentHunk);
        }

        // è§£æ hunk å¤´
        const hunkMatch = trimmedLine.match(/^@@\s+-(\d+)(?:,(\d+))?\s+\+(\d+)(?:,(\d+))?\s+@@/);
        if (!hunkMatch) {
          return this.error('INVALID_FORMAT', 'Invalid hunk header', i);
        }

        const oldStart = parseInt(hunkMatch[1], 10);
        const oldCount = hunkMatch[2] ? parseInt(hunkMatch[2], 10) : 1;
        const newStart = parseInt(hunkMatch[3], 10);
        const newCount = hunkMatch[4] ? parseInt(hunkMatch[4], 10) : 1;

        // åˆ›å»ºæ–° hunk
        currentHunk = {
          filePath: normalizedPath,
          language: this.inferLanguage(normalizedPath),
          header: trimmedLine,
          oldStart,
          oldCount,
          newStart,
          newCount,
          lines: [],
          stats: {
            added: 0,
            removed: 0,
            context: 0
          }
        };

        continue;
      }

      // 4. è§£æ diff è¡Œ
      if (currentHunk && currentFile) {
        const lineNumber = i;

        if (line.startsWith('+')) {
          // æ·»åŠ è¡Œï¼ˆæ’é™¤ +++ï¼‰
          if (!trimmedLine.startsWith('+++')) {
            const content = line.substring(1);
            currentHunk.lines.push({
              type: 'add',
              content,
              raw: line,
              lineNumber
            });
            currentHunk.stats.added++;
          }
        } else if (line.startsWith('-')) {
          // åˆ é™¤è¡Œï¼ˆæ’é™¤ ---ï¼‰
          if (!trimmedLine.startsWith('---')) {
            const content = line.substring(1);
            currentHunk.lines.push({
              type: 'remove',
              content,
              raw: line,
              lineNumber
            });
            currentHunk.stats.removed++;
          }
        } else if (line.startsWith(' ')) {
          // ä¸Šä¸‹æ–‡è¡Œ
          const content = line.substring(1);
          currentHunk.lines.push({
            type: 'context',
            content,
            raw: line,
            lineNumber
          });
          currentHunk.stats.context++;
        } else if (line.startsWith('\\')) {
          // è·³è¿‡ diff å…ƒæ•°æ®ï¼ˆå¦‚ \ No newline at end of fileï¼‰
          continue;
        } else if (trimmedLine.length === 0) {
          // ç©ºè¡Œä½œä¸º context
          currentHunk.lines.push({
            type: 'context',
            content: '',
            raw: line,
            lineNumber
          });
          currentHunk.stats.context++;
        }
      }
    }

    // ä¿å­˜æœ€åä¸€ä¸ª hunk å’Œæ–‡ä»¶
    if (currentHunk && currentFile) {
      this.finalizeHunk(currentFile, currentHunk);
    }

    if (currentFile) {
      files.push(currentFile);
      totalHunkCount += currentFile.stats.hunkCount;
      totalAdded += currentFile.stats.added;
      totalRemoved += currentFile.stats.removed;
    }

    // æœ€ç»ˆæ ¡éªŒï¼šè‡³å°‘æœ‰ä¸€ä¸ªæ–‡ä»¶
    if (files.length === 0) {
      return this.error('INVALID_FORMAT', 'No diff files found');
    }

    // æœ€ç»ˆæ ¡éªŒï¼šæ‰€æœ‰æ–‡ä»¶è‡³å°‘æœ‰ä¸€ä¸ª hunk
    if (totalHunkCount === 0) {
      return this.error('INVALID_FORMAT', 'No hunks found in diff');
    }

    return {
      success: true,
      files,
      stats: {
        fileCount: files.length,
        hunkCount: totalHunkCount,
        totalAdded,
        totalRemoved
      }
    };
  }

  /**
   * è§„èŒƒåŒ–æ–‡ä»¶è·¯å¾„
   *
   * @param path åŸå§‹è·¯å¾„
   * @returns è§„èŒƒåŒ–åçš„è·¯å¾„ï¼ˆå»é™¤ a/ æˆ– b/ å‰ç¼€ï¼‰
   */
  private static normalizePath(path: string): string {
    return this.flexibleNormalizePath(path);
  }

  /**
   * çµæ´»çš„è·¯å¾„è§„èŒƒåŒ–å‡½æ•°ï¼Œå®¹å¿å„ç§æ ¼å¼é”™è¯¯
   *
   * @param pathStr åŸå§‹è·¯å¾„å­—ç¬¦ä¸²
   * @returns è§„èŒƒåŒ–åçš„è·¯å¾„
   */
  private static flexibleNormalizePath(pathStr: string): string {
    // 1. å»æ‰å¼•å·
    let cleanPath = pathStr.replace(/^["']|["']$/g, '');

    // 2. ç§»é™¤å¸¸è§çš„ git å‰ç¼€
    if (cleanPath.startsWith('a/') || cleanPath.startsWith('b/')) {
      cleanPath = cleanPath.substring(2);
    }

    // 3. ç§»é™¤å¼€å¤´çš„æ–œæ 
    cleanPath = cleanPath.replace(/^[/\\]+/, '');

    return cleanPath.trim();
  }

  /**
   * æ¨æ–­è¯­è¨€ç±»å‹
   * 
   * @param filePath æ–‡ä»¶è·¯å¾„
   * @returns è¯­è¨€ç±»å‹
   */
  private static inferLanguage(filePath: string): string {
    const ext = filePath.split('.').pop()?.toLowerCase();
    const langMap: Record<string, string> = {
      js: 'javascript',
      ts: 'typescript',
      tsx: 'typescript',
      jsx: 'javascript',
      py: 'python',
      java: 'java',
      go: 'go',
      rs: 'rust',
      cpp: 'cpp',
      c: 'c',
      h: 'c',
      vue: 'vue',
      html: 'html',
      css: 'css',
      json: 'json',
      yaml: 'yaml',
      yml: 'yaml',
      md: 'markdown',
      sh: 'bash',
      bash: 'bash',
      sql: 'sql'
    };
    return langMap[ext || ''] || 'text';
  }

  /**
   * æ ¡éªŒå¹¶ä¿®å¤ hunk çš„è¡Œæ•°ç»Ÿè®¡ï¼ˆv2.1 ä¿®æ­£ï¼šæ­£ç¡®çš„ unified diff è¯­ä¹‰ï¼‰
   *
   * unified diff è¯­ä¹‰ï¼š
   * - oldCount = context + removed
   * - newCount = context + added
   *
   * @param hunk è¦æ ¡éªŒçš„ hunk
   * @returns æ ¡éªŒç»“æœ - ä½¿ç”¨åˆ¤åˆ«è”åˆç±»å‹ç¡®ä¿è°ƒç”¨æ–¹æ­£ç¡®å¤„ç†è¿”å›å€¼
   */
  private static validateAndFixHunkLineCount(hunk: DiffHunk):
    | { status: 'ok'; finalHunk: DiffHunk }
    | { status: 'fixed'; finalHunk: DiffHunk; error: string }
    | { status: 'error'; error: string } {
    // è®¡ç®—å®é™…è§£æåˆ°çš„æ—§ä»£ç è¡Œæ•° (context + remove)
    const actualOldCount = hunk.stats.context + hunk.stats.removed;
    // è®¡ç®—å®é™…è§£æåˆ°çš„æ–°ä»£ç è¡Œæ•° (context + add)
    const actualNewCount = hunk.stats.context + hunk.stats.added;

    // å¦‚æœè¡Œæ•°ä¸ä¸€è‡´ï¼Œè¿›è¡Œè‡ªåŠ¨ä¿®å¤
    if (actualOldCount !== hunk.oldCount || actualNewCount !== hunk.newCount) {
      console.warn(`[Diff Fixer] æ£€æµ‹åˆ°è¡Œæ•°ä¸åŒ¹é…: å£°æ˜(-${hunk.oldCount},+${hunk.newCount}) -> å®é™…(-${actualOldCount},+${actualNewCount})`);

      // åˆ›å»ºæ–°çš„ hunk å¯¹è±¡ï¼Œé¿å…ä¿®æ”¹åŸå¯¹è±¡ï¼ˆå‰¯ä½œç”¨ï¼‰
      const fixedHunk = {
        ...hunk,
        oldCount: actualOldCount,
        newCount: actualNewCount
      };

      return {
        status: 'fixed', // æ ‡è®°ä¸ºå·²ä¿®å¤
        finalHunk: fixedHunk,
        error: "Auto-fixed line count mismatch"
      };
    }

    // æ ¡éªŒ context è¡Œä¸èƒ½ä¸ºç©ºï¼ˆå¯é€‰ï¼‰
    if (hunk.stats.context === 0 && hunk.stats.added > 0 && hunk.stats.removed > 0) {
      // å…è®¸æ—  context çš„ hunkï¼ˆä½†åœ¨åº”ç”¨æ—¶ä¼šæ›´å±é™©ï¼‰
      // è¿™é‡Œåªå‘å‡ºè­¦å‘Šï¼Œä¸è¿”å›é”™è¯¯
      console.warn(`[DiffParser] Hunk at ${hunk.filePath}:${hunk.oldStart} has no context lines`);
    }

    return { status: 'ok', finalHunk: hunk };
  }

  /**
   * å°† hunk æ·»åŠ åˆ°æ–‡ä»¶å¹¶æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
   *
   * @param file æ–‡ä»¶å¯¹è±¡
   * @param hunk è¦æ·»åŠ çš„ hunk
   */
  private static finalizeHunk(file: DiffFile, hunk: DiffHunk) {
    const validateResult = this.validateAndFixHunkLineCount(hunk);

    if (validateResult.status === 'error') {
      // å¦‚æœå‡ºç°é”™è¯¯ï¼Œå¯ä»¥é€‰æ‹©è·³è¿‡æˆ–æŠ›å‡ºå¼‚å¸¸ï¼Œè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨åŸå§‹hunk
      console.error(`[DiffParser] Validation error: ${validateResult.error}`);
      file.hunks.push(hunk);
      file.stats.hunkCount++;
      file.stats.added += hunk.stats.added;
      file.stats.removed += hunk.stats.removed;
      file.stats.context += hunk.stats.context;
    } else {
      // status ä¸º 'ok' æˆ– 'fixed'ï¼Œä¸¤ç§æƒ…å†µä¸‹éƒ½æœ‰ finalHunk
      file.hunks.push(validateResult.finalHunk);
      file.stats.hunkCount++;
      file.stats.added += validateResult.finalHunk.stats.added;
      file.stats.removed += validateResult.finalHunk.stats.removed;
      file.stats.context += validateResult.finalHunk.stats.context;
    }
  }

  /**
   * åˆ›å»ºé”™è¯¯å¯¹è±¡
   *
   * @param error é”™è¯¯ç±»å‹
   * @param message é”™è¯¯æ¶ˆæ¯
   * @param line é”™è¯¯è¡Œå·ï¼ˆå¯é€‰ï¼‰
   * @param hunkIndex é”™è¯¯ hunk ç´¢å¼•ï¼ˆå¯é€‰ï¼‰
   * @returns è§£æé”™è¯¯å¯¹è±¡
   */
  private static error(
    error: DiffParseError['error'],
    message: string,
    line?: number,
    hunkIndex?: number
  ): DiffParseError {
    return {
      success: false,
      error,
      message,
      line,
      hunkIndex
    };
  }
}

// ============================================================================
// Diff Applier v2ï¼ˆSafe Apply Engine - MVPï¼‰
// ============================================================================

/**
 * åº”ç”¨ç»“æœï¼ˆæˆåŠŸï¼‰
 */
export interface DiffApplyResult {
  success: true;
  changedFiles: string[];
  stats: {
    filesChanged: number;
    hunksApplied: number;
    linesAdded: number;
    linesRemoved: number;
  };
}

/**
 * åº”ç”¨é”™è¯¯ï¼ˆå¸¦ä¸Šä¸‹æ–‡ï¼‰
 */
export interface DiffApplyError {
  success: false;
  error: 'FILE_NOT_FOUND' | 'CONTEXT_MISMATCH' | 'REMOVE_MISMATCH' | 'INVALID_DIFF';
  message: string;
  filePath?: string;
  hunkIndex?: number;
  line?: number;
}

/**
 * åº”ç”¨ç»“æœç±»å‹
 */
export type ApplyResult = DiffApplyResult | DiffApplyError;

/**
 * åº”ç”¨é€‰é¡¹
 */
export interface DiffApplyOptions {
  /** å¹²è¿è¡Œï¼ˆä¸å®é™…åº”ç”¨ï¼Œåªæ ¡éªŒï¼‰ */
  dryRun?: boolean;
  /** é‡åˆ°å†²çªæ—¶æ˜¯å¦å¤±è´¥ï¼ˆé»˜è®¤ trueï¼‰ */
  failOnConflict?: boolean;
}

/**
 * Safe Diff Applier
 * 
 * ç‰¹æ€§ï¼š
 * - å¢é‡åº”ç”¨ï¼ˆä¸è¦†ç›–æ•´ä¸ªæ–‡ä»¶ï¼‰
 * - Context æ ¡éªŒï¼ˆé˜²æ­¢è¯¯æ”¹ï¼‰
 * - å¤±è´¥å¿«é€Ÿï¼ˆä¸é™é»˜å¤±è´¥ï¼‰
 * - å¯å›æ»šï¼ˆTODO: æ·»åŠ  undo æ”¯æŒï¼‰
 * 
 * === Apply Engine è¯­ä¹‰ä¸å˜å¼ï¼ˆSemantic Invariantsï¼‰===
 * 
 * ã€å…¨å±€ä¸å˜å¼ã€‘
 * G1. Safety Firstï¼ˆå®‰å…¨ä¼˜å…ˆï¼‰
 *   - å®å¯å¤±è´¥ï¼Œä¹Ÿä¸è¯¯æ”¹
 *   - ä»»ä½•ä¸€ä¸ª hunk apply å¤±è´¥ â†’ æ•´ä¸ª apply å¤±è´¥
 *   - ä¸å…è®¸ partial apply
 *   - ä¸å…è®¸ silent fallback
 * 
 * G2. Determinismï¼ˆç¡®å®šæ€§ï¼‰
 *   - ç›¸åŒè¾“å…¥ â†’ ç›¸åŒè¾“å‡ºï¼ˆæˆ–ç›¸åŒå¤±è´¥ï¼‰
 *   - ä¸èƒ½ä¾èµ–éç¡®å®šæ€§æœç´¢é¡ºåº
 *   - ä¸èƒ½ä¾èµ– runtime çŠ¶æ€
 * 
 * G3. Single Source of Truth
 *   - æ–‡æ¡£å†…å®¹æ˜¯å”¯ä¸€æƒå¨
 *   - è¡Œå·åªæ˜¯ hintï¼ˆéæƒå¨ï¼‰
 *   - Apply å†³ç­–åªèƒ½ç”± Context exact matchã€Remove exact match å†³å®š
 *   - è¡Œå·ä»…ç”¨äº"èµ·å§‹æœç´¢ä½ç½®"
 * 
 * ã€Hunk çº§ä¸å˜å¼ã€‘
 * H1. One Hunk = One Atomic Edit
 *   - ä¸€ä¸ª hunk è¦ä¹ˆå®Œå…¨åº”ç”¨
 *   - ä¸å…è®¸æ‹†åˆ†ã€éƒ¨åˆ†æˆåŠŸ
 * 
 * H2. Line Accounting Invariantï¼ˆè¡Œæ•°å®ˆæ’ï¼‰
 *   - oldCount == contextLines + removedLines
 *   - newCount == contextLines + addedLines
 *   - delta = addedLines - removedLines
 * 
 * H3. Context Authority Invariantï¼ˆä¸Šä¸‹æ–‡æƒå¨ï¼‰
 *   - æ‰€æœ‰ context è¡Œå¿…é¡»é€å­—åŒ¹é…
 *   - åŒ¹é…é¡ºåºå¿…é¡»ä¸€è‡´
 *   - ä¸å…è®¸ skip context
 *   - ä¸å…è®¸ re-order context
 * 
 * H4. Remove Must Match Exactlyï¼ˆåˆ é™¤è¡Œçº¢çº¿ï¼‰ğŸ”´
 *   - æ¯ä¸€æ¡ remove è¡Œå¿…é¡»åœ¨ context ç¡®è®¤çš„ä½ç½®
 *   - å¿…é¡»é€å­—åŒ¹é…ï¼ˆåŒ…æ‹¬ç©ºæ ¼ï¼‰
 *   - ğŸš« fuzzy matching æ°¸è¿œä¸èƒ½ï¼šå¿½ç•¥ remove è¡Œã€æ¨¡ç³Š remove è¡Œ
 * 
 * H5. No Cross-Hunk Interaction
 *   - hunk A çš„åŒ¹é…ç»“æœä¸å¾—å½±å“ hunk B çš„åŒ¹é…é€»è¾‘
 *   - åªèƒ½é€šè¿‡å·²å˜æ›´æ–‡æ¡£çŠ¶æ€äº§ç”Ÿå½±å“
 * 
 * ã€å¤š Hunk åº”ç”¨ä¸å˜å¼ã€‘
 * M1. Sequential Mutation Invariant
 *   - hunk[0] â†’ original document
 *   - hunk[1] â†’ doc after hunk[0]
 *   - ğŸš« ç¦æ­¢ï¼šé¢„è®¡ç®—æ‰€æœ‰ edit rangesã€å¯¹åŸå§‹ snapshot apply æ‰€æœ‰ hunks
 * 
 * M2. Cursor Monotonicityï¼ˆæ¨èï¼‰
 *   - Apply cursor åªèƒ½ï¼šå‘å‰ç§»åŠ¨æˆ–ä¿æŒä¸å˜ï¼ˆå¤±è´¥æ—¶ï¼‰
 *   - é¿å… O(nÂ²) é‡æ‰«
 * 
 * ã€ç©ºè¡Œ/ç©ºç™½è¯­ä¹‰ä¸å˜å¼ã€‘
 * W1. ä¸‰æ€æ¨¡å‹å¿…é¡»ä¿ç•™
 *   - ç©ºè¡Œ content = ""
 *   - ç©ºç™½è¡Œ content = /^\s+$/
 *   - æ™®é€šè¡Œ content = other
 *   - "" åªèƒ½åŒ¹é…çœŸæ­£çš„ç©ºè¡Œ
 *   - ç©ºç™½è¡Œå¿…é¡»é€å­—åŒ¹é…ç©ºç™½
 *   - ğŸš« ä¸å…è®¸ normalize / trim
 * 
 * ã€Error Semantics Invariantã€‘
 * E1. Error Is Precise
 *   - é”™è¯¯å¿…é¡»è¯´æ˜ï¼šhunkIndexã€diff line numberã€mismatch ç±»å‹
 *   - ğŸš« ä¸å…è®¸ï¼š"Apply failed" without reason
 * 
 * === Fuzzy Matching çº¢çº¿çº¦æŸ ===
 * 
 * ğŸš« ç»å¯¹çº¢çº¿ï¼ˆä¸èƒ½ç ´ï¼‰ï¼š
 * - âŒ Remove è¡Œæ¨¡ç³ŠåŒ¹é…
 * - âŒ Cross-Hunk Searchï¼ˆç©¿è¶Š hunk è¾¹ç•Œï¼‰
 * - âŒ "Best match wins"ï¼ˆé€‰"æœ€ç›¸ä¼¼"çš„ï¼‰
 * 
 * âš ï¸ é«˜é£é™©å®ç°ç‚¹ï¼ˆå¸¸è¢«å¿½ç•¥ï¼‰ï¼š
 * - Levenshtein è·ç¦»ï¼šéå•è°ƒã€éç›´è§‰å®‰å…¨ã€ææ˜“äº§ç”Ÿ multiple matches
 * - å¿½ç•¥ç¼©è¿›ï¼šåœ¨ Python/YAML/Makefile ä¸­æ˜¯ç¾éš¾
 * - fuzzy + è¡Œå· hintï¼šå¾ˆå®¹æ˜“å˜æˆ"è¡Œå·ä¸»å¯¼ apply"ï¼Œç›´æ¥è¿å G1/G3
 * 
 * âœ… å®‰å…¨å®ç°æ¨¡å‹ï¼š
 * 1. ç²¾ç¡®åŒ¹é…å¤±è´¥
 * 2. å¦‚æœ fuzzy disabled â†’ fail
 * 3. å¯ç”¨ fuzzyï¼šä»…å¯¹ contextã€åœ¨æœ‰é™çª—å£å†…æœç´¢ï¼ˆÂ±20 è¡Œï¼‰
 * 4. ç»Ÿè®¡å€™é€‰æ•°
 * 5. != 1 â†’ fail
 * 
 * === æ€§èƒ½ä¸ DoS é˜²å¾¡ ===
 * 
 * - Fuzzy search = O(n * window * cost)
 * - Levenshtein = O(mn)
 * - âœ… çª—å£å¿…é¡» hard-limitï¼ˆå¦‚ Â±20 è¡Œï¼‰
 * - âœ… context è¡Œæ•°å¿…é¡»å°ï¼ˆå·²é™åˆ¶ max 200ï¼‰
 * - âœ… fail fastï¼ˆç¬¬ä¸€ä¸ª mismatch å°±é€€å‡ºï¼‰
 * 
 * âš ï¸ å”¯ä¸€çœŸæ­£çš„é£é™©ï¼š
 * ä¸æ˜¯è®¾è®¡ï¼Œè€Œæ˜¯æœªæ¥å®ç°æ—¶çš„"ä¾¿åˆ©æ€§å¦¥å"
 * - "å…ˆè®©å®ƒå·¥ä½œ"
 * - "AI diff æœ‰ç‚¹ä¸å‡†ï¼Œå®½æ¾ç‚¹å§"
 * 
 * ğŸš« ä»»ä½•è¿å remove/context ç²¾ç¡®æ€§çš„ PR éƒ½åº”è¯¥è¢«ç›´æ¥æ‹’ç»
 */
export class DiffApplier {
  /**
   * åº”ç”¨ diff åˆ°å·¥ä½œåŒº
   * 
   * @param diff è§£æåçš„ diff
   * @param options åº”ç”¨é€‰é¡¹
   * @returns åº”ç”¨ç»“æœï¼ˆæˆåŠŸæˆ–é”™è¯¯ï¼‰
   */
  static async apply(diff: DiffParseResult, options: DiffApplyOptions = {}): Promise<ApplyResult> {
    if (!diff.success) {
      return {
        success: false,
        error: 'INVALID_DIFF',
        message: 'Invalid diff result'
      };
    }

    const edit = new vscode.WorkspaceEdit();
    const changedFiles = new Set<string>();
    let hunksApplied = 0;
    let linesAdded = 0;
    let linesRemoved = 0;

    // éå†æ¯ä¸ªæ–‡ä»¶
    for (const file of diff.files) {
      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æ‰“å¼€
      const doc = vscode.workspace.textDocuments.find(d =>
        d.uri.fsPath?.endsWith(file.normalizedPath) || false
      );

      if (!doc) {
        if (options.failOnConflict !== false) {
          return {
            success: false,
            error: 'FILE_NOT_FOUND',
            message: `File not found or not open: ${file.normalizedPath}`,
            filePath: file.normalizedPath
          };
        }
        console.warn(`[DiffApplier] File not found: ${file.normalizedPath}`);
        continue;
      }

      // éå†æ¯ä¸ª hunk
      for (let hunkIndex = 0; hunkIndex < file.hunks.length; hunkIndex++) {
        const hunk = file.hunks[hunkIndex];

        try {
          // åº”ç”¨å•ä¸ª hunk
          const applyResult = await this.applyHunk(doc, hunk, edit, options);

          if (!applyResult.ok) {
            return {
              success: false,
              error: 'CONTEXT_MISMATCH',
              message: applyResult.error || 'Unknown error',
              filePath: file.normalizedPath,
              hunkIndex,
              line: applyResult.line
            };
          }

          hunksApplied++;
          linesAdded += hunk.stats.added;
          linesRemoved += hunk.stats.removed;
          changedFiles.add(file.normalizedPath);

        } catch (error) {
          if (options.failOnConflict !== false) {
            return {
              success: false,
              error: 'CONTEXT_MISMATCH',
              message: error instanceof Error ? error.message : String(error),
              filePath: file.normalizedPath,
              hunkIndex,
              line: undefined
            };
          }
          console.error(`[DiffApplier] Failed to apply hunk:`, error);
        }
      }
    }

    // å¹²è¿è¡Œæ¨¡å¼ï¼šä¸å®é™…åº”ç”¨
    if (options.dryRun) {
      console.log('[DiffApplier] Dry run complete. Would apply:', {
        files: Array.from(changedFiles),
        hunks: hunksApplied,
        linesAdded,
        linesRemoved
      });

      return {
        success: true,
        changedFiles: Array.from(changedFiles),
        stats: {
          filesChanged: changedFiles.size,
          hunksApplied,
          linesAdded,
          linesRemoved
        }
      };
    }

    // å®é™…åº”ç”¨
    const success = await vscode.workspace.applyEdit(edit);

    if (!success) {
      return {
        success: false,
        error: 'INVALID_DIFF',
        message: 'Failed to apply workspace edit'
      };
    }

    return {
      success: true,
      changedFiles: Array.from(changedFiles),
      stats: {
        filesChanged: changedFiles.size,
        hunksApplied,
        linesAdded,
        linesRemoved
      }
    };
  }

  /**
   * åº”ç”¨å®Œæ•´çš„æ–‡ä»¶å†…å®¹ï¼ˆé™çº§æœºåˆ¶ï¼‰
   *
   * @param filePath æ–‡ä»¶è·¯å¾„
   * @param newContent æ–°çš„æ–‡ä»¶å†…å®¹
   * @returns åº”ç”¨ç»“æœ
   */
  static async applyFullContent(filePath: string, newContent: string): Promise<ApplyResult> {
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) {
      return {
        success: false,
        error: 'INVALID_DIFF',
        message: 'No workspace folder found'
      };
    }

    // åŸºæœ¬å†…å®¹æ ¡éªŒï¼Œé˜²æ­¢æ˜æ˜¾é”™è¯¯
    if (!newContent || typeof newContent !== 'string') {
      return {
        success: false,
        error: 'INVALID_DIFF',
        message: 'Invalid content provided for replacement'
      };
    }

    // æ£€æŸ¥æ˜¯å¦åŒ…å«æ˜æ˜¾çš„å¼‚å¸¸å†…å®¹ï¼ˆå¦‚è¿‡å¤šçš„æ¢è¡Œç¬¦æˆ–ç‰¹æ®Šå­—ç¬¦ï¼‰
    if (newContent.length > 0 && newContent.length < 10 && !newContent.trim()) {
      return {
        success: false,
        error: 'INVALID_DIFF',
        message: 'Content appears to be empty or invalid'
      };
    }

    const fullPath = vscode.Uri.joinPath(workspaceFolder.uri, filePath);

    try {
      // è·å–å½“å‰æ–‡æ¡£
      const document = await vscode.workspace.openTextDocument(fullPath);
      const oldContent = document.getText();

      // æ£€æŸ¥æ–°æ—§å†…å®¹æ˜¯å¦å·®å¼‚è¿‡å¤§ï¼ˆå¯é€‰çš„å®‰å…¨æ£€æŸ¥ï¼‰
      const oldLines = oldContent.split('\n').length;
      const newLines = newContent.split('\n').length;
      const lineDiffRatio = Math.abs(newLines - oldLines) / Math.max(oldLines, 1);

      // å¦‚æœå†…å®¹å·®å¼‚å¾ˆå¤§ï¼Œå¯ä»¥è€ƒè™‘æç¤ºç”¨æˆ·ï¼ˆè¿™é‡Œæš‚æ—¶æ³¨é‡Šæ‰ï¼Œå¯æ ¹æ®éœ€è¦å¯ç”¨ï¼‰
      // if (lineDiffRatio > 2.0) { // æ–°å†…å®¹æ˜¯æ—§å†…å®¹çš„2å€ä»¥ä¸Š
      //   console.warn(`[DiffApplier] Large content change detected: ${filePath}`);
      // }

      // åˆ›å»ºå…¨æ–‡ä»¶èŒƒå›´
      const fullRange = new vscode.Range(
        document.lineAt(0).range.start,
        document.lineAt(document.lineCount - 1).range.end
      );

      const edit = new vscode.WorkspaceEdit();
      // æ‰§è¡Œæ›¿æ¢
      edit.replace(fullPath, fullRange, newContent);

      // åº”ç”¨ä¿®æ”¹
      const success = await vscode.workspace.applyEdit(edit);
      if (success) {
        await document.save();
        return {
          success: true,
          changedFiles: [filePath],
          stats: {
            filesChanged: 1,
            hunksApplied: 0,
            linesAdded: newContent.split('\n').length,
            linesRemoved: document.getText().split('\n').length
          }
        };
      } else {
        return {
          success: false,
          error: 'INVALID_DIFF',
          message: 'VS Code rejected the file modification request'
        };
      }
    } catch (error) {
      return {
        success: false,
        error: 'FILE_NOT_FOUND',
        message: `Failed to open or modify file: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * åº”ç”¨å•ä¸ª hunkï¼ˆMVP å®ç°ï¼‰
   * 
   * @param doc æ–‡æ¡£å¯¹è±¡
   * @param hunk è¦åº”ç”¨çš„ hunk
   * @param edit å·¥ä½œåŒºç¼–è¾‘å¯¹è±¡
   * @param options åº”ç”¨é€‰é¡¹
   * @returns åº”ç”¨ç»“æœ
   */
  private static async applyHunk(
    doc: vscode.TextDocument,
    hunk: DiffHunk,
    edit: vscode.WorkspaceEdit,
    options: DiffApplyOptions
  ): Promise<{ ok: boolean; error?: string; line?: number }> {
    // å®šä½ hunk èµ·å§‹ä½ç½®ï¼ˆä½¿ç”¨ context è¡Œï¼‰
    const line = this.locateHunkStart(doc, hunk);

    if (line === -1) {
      return {
        ok: false,
        error: `Cannot locate hunk start at line ${hunk.oldStart}`
      };
    }

    // ä»ä¸‹å¾€ä¸Šåº”ç”¨ï¼ˆé¿å…è¡Œå·åç§»ï¼‰
    let currentLine = line;
    const removeEdits: vscode.Range[] = [];
    const addEdits: Array<{ pos: vscode.Position; text: string }> = [];

    for (const diffLine of hunk.lines) {
      if (diffLine.type === 'context') {
        // æ ¡éªŒ context è¡Œæ˜¯å¦åŒ¹é…
        if (currentLine >= doc.lineCount) {
          return {
            ok: false,
            error: 'Context line out of bounds',
            line: diffLine.lineNumber
          };
        }

        const actualLine = doc.lineAt(currentLine).text;
        if (actualLine !== diffLine.content) {
          return {
            ok: false,
            error: `Context mismatch at line ${currentLine + 1}: expected "${diffLine.content}", got "${actualLine}"`,
            line: diffLine.lineNumber
          };
        }
        currentLine++;
      } else if (diffLine.type === 'remove') {
        // æ ‡è®°åˆ é™¤ï¼ˆç¨åæ‰§è¡Œï¼‰
        if (currentLine >= doc.lineCount) {
          return {
            ok: false,
            error: 'Remove line out of bounds',
            line: diffLine.lineNumber
          };
        }

        const actualLine = doc.lineAt(currentLine).text;
        if (actualLine !== diffLine.content) {
          return {
            ok: false,
            error: `Remove mismatch at line ${currentLine + 1}: expected "${diffLine.content}", got "${actualLine}"`,
            line: diffLine.lineNumber
          };
        }

        removeEdits.push(doc.lineAt(currentLine).range);
        currentLine++;
      } else if (diffLine.type === 'add') {
        // æ ‡è®°æ·»åŠ ï¼ˆç¨åæ‰§è¡Œï¼‰
        // v2.1 æ”¹è¿›ï¼šä½¿ç”¨å®Œæ•´è¡Œå†…å®¹ï¼Œä¿ç•™åŸå§‹ç¼©è¿›å’Œæ¢è¡Œç¬¦
        addEdits.push({
          pos: new vscode.Position(currentLine, 0),
          text: diffLine.raw.substring(1) + '\n' // å»é™¤ + ä½†ä¿ç•™æ‰€æœ‰å…¶ä»–å­—ç¬¦
        });
        // æ·»åŠ è¡Œä¸å¢åŠ  currentLine
      }
    }

    // æ‰§è¡Œåˆ é™¤ï¼ˆä»åå¾€å‰ï¼‰
    for (let i = removeEdits.length - 1; i >= 0; i--) {
      edit.delete(doc.uri, removeEdits[i]);
    }

    // æ‰§è¡Œæ·»åŠ 
    for (const addEdit of addEdits) {
      edit.insert(doc.uri, addEdit.pos, addEdit.text);
    }

    return { ok: true };
  }

  /**
   * å®šä½ hunk èµ·å§‹ä½ç½®
   *
   * @param doc æ–‡æ¡£å¯¹è±¡
   * @param hunk è¦å®šä½çš„ hunk
   * @returns èµ·å§‹è¡Œå·ï¼ˆ0-basedï¼‰ï¼Œæœªæ‰¾åˆ°è¿”å› -1
   */
  private static locateHunkStart(doc: vscode.TextDocument, hunk: DiffHunk): number {
    const targetLine = hunk.oldStart - 1; // è½¬æ¢ä¸º 0-based

    // 1. é¦–å…ˆå°è¯•ç²¾ç¡®è¡Œå·åŒ¹é…
    if (targetLine >= 0 && targetLine < doc.lineCount) {
      // æ£€æŸ¥ä¸Šä¸‹æ–‡è¡Œæ˜¯å¦åŒ¹é…
      const anchors = hunk.lines.filter(l => l.type === 'context' && l.content.trim().length > 0).map(l => l.content.trim());
      if (anchors.length > 0 && this.isLinesMatch(doc.lineAt(targetLine).text, anchors[0])) {
        // å¦‚æœç¬¬ä¸€ä¸ªé”šç‚¹åŒ¹é…ï¼Œæ£€æŸ¥åç»­é”šç‚¹æ˜¯å¦ä¹ŸåŒ¹é…
        let matchCount = 1;
        for (let j = 1; j < Math.min(anchors.length, 3); j++) {
          if (targetLine + j < doc.lineCount && this.isLinesMatch(doc.lineAt(targetLine + j).text, anchors[j])) {
            matchCount++;
          }
        }
        // å¦‚æœåŒ¹é…è¶…è¿‡ 50% çš„é”šç‚¹ï¼Œå°±è®¤ä¸ºæ‰¾åˆ°äº†ä½ç½®
        if (matchCount / Math.min(anchors.length, 3) >= 0.5) {
          return targetLine;
        }
      }
    }

    // 2. å¦‚æœç²¾ç¡®åŒ¹é…å¤±è´¥ï¼Œå¯åŠ¨æ¨¡ç³Šæœç´¢
    console.log(`[Fuzzy] è¡Œå· ${hunk.oldStart} åŒ¹é…å¤±è´¥ï¼Œå¯åŠ¨å†…å®¹å®šä½...`);
    const bestMatchIndex = this.findBestMatchIndex(doc, hunk);

    return bestMatchIndex;
  }

  /**
   * ç®€å•çš„æ¨¡ç³ŠåŒ¹é…å·¥å…·å‡½æ•°
   */
  private static isLinesMatch(fileLine: string, diffLine: string): boolean {
    if (!fileLine || !diffLine) return false;
    // å¿½ç•¥ç¼©è¿›å’Œé¦–å°¾ç©ºæ ¼è¿›è¡Œå¯¹æ¯”
    return fileLine.trim() === diffLine.trim();
  }

  /**
   * åœ¨æ–‡æ¡£ä¸­æŸ¥æ‰¾æœ€ä½³åŒ¹é…ç´¢å¼•
   */
  private static findBestMatchIndex(doc: vscode.TextDocument, hunk: DiffHunk): number {
    const fileLines = doc.getText().split('\n');

    // æå– context ç±»å‹ä¸”ä¸ä¸ºç©ºçš„è¡Œä½œä¸ºæœç´¢é”šç‚¹
    const anchors = hunk.lines
      .filter(l => l.type === 'context' && l.content.trim().length > 5)
      .map(l => l.content.trim());

    if (anchors.length === 0) return -1;

    // é™åˆ¶æœç´¢èŒƒå›´ï¼Œé¿å…å…¨æ–‡ä»¶æ‰«æå¯¼è‡´æ€§èƒ½é—®é¢˜
    // ä»¥æœŸæœ›ä½ç½®ä¸ºä¸­å¿ƒï¼Œå‰åå„æœç´¢50è¡Œï¼Œä½†ä¸è¶…è¿‡æœ€å¤§æœç´¢èŒƒå›´
    const searchRadius = 50;
    const maxSearchAttempts = 200; // é™åˆ¶æœ€å¤§å°è¯•æ¬¡æ•°
    let attempts = 0;

    const expectedStart = Math.max(0, hunk.oldStart - 1 - searchRadius); // è½¬æ¢ä¸º0-basedå¹¶å‡å»æœç´¢åŠå¾„
    const expectedEnd = Math.min(fileLines.length, hunk.oldStart - 1 + searchRadius); // åŠ ä¸Šæœç´¢åŠå¾„

    // æœç´¢æŒ‡å®šèŒƒå›´å†…çš„åŒ¹é…
    for (let i = expectedStart; i < expectedEnd && i < fileLines.length && attempts < maxSearchAttempts; i++, attempts++) {
      if (this.isLinesMatch(fileLines[i], anchors[0])) {
        // å¦‚æœç¬¬ä¸€ä¸ªé”šç‚¹åŒ¹é…ï¼Œæ£€æŸ¥åç»­é”šç‚¹æ˜¯å¦ä¹ŸåŒ¹é…
        let matchCount = 1;
        for (let j = 1; j < Math.min(anchors.length, 3); j++) {
          if (i + j < fileLines.length && this.isLinesMatch(fileLines[i + j], anchors[j])) {
            matchCount++;
          }
        }
        // åªè¦åŒ¹é…è¶…è¿‡ 50% çš„é”šç‚¹ï¼Œå°±è®¤ä¸ºæ‰¾åˆ°äº†ä½ç½®
        if (matchCount / Math.min(anchors.length, 3) >= 0.5) {
          return i;
        }
      }
    }
    return -1;
  }
}

// ============================================================================
// ä»£ç å®¡æŸ¥ç»“æœè§£æï¼ˆä¿ç•™åŸåŠŸèƒ½ï¼‰
// ============================================================================

/**
 * ä»£ç å®¡æŸ¥ç»“æœ
 */
export interface ReviewIssue {
  type: 'error' | 'warning' | 'info';
  message: string;
  suggestion?: string;
  file?: string;
  line?: number;
}

/**
 * DiffApplier ä»£ç å®¡æŸ¥ç»“æœè§£æå™¨
 */
export class ReviewParser {
  /**
   * è§£æä»£ç å®¡æŸ¥ç»“æœ
   * 
   * @param text AI è¿”å›çš„ä»£ç å®¡æŸ¥æ–‡æœ¬
   * @returns ç»“æ„åŒ–çš„å®¡æŸ¥ç»“æœæ•°ç»„
   */
  static parse(text: string): ReviewIssue[] {
    const issues: ReviewIssue[] = [];
    const lines = text.split('\n');
    let currentType: 'error' | 'warning' | 'info' | null = null;
    let currentMessage = '';

    for (const line of lines) {
      // æ£€æµ‹ä¸¥é‡ç¨‹åº¦æ ‡ç­¾
      const errorMatch = line.match(/ğŸ”´\s*(?:Error|error)\s*:?\s*(.+)/i);
      const warningMatch = line.match(/ğŸŸ¡\s*(?:Warning|warning)\s*:?\s*(.+)/i);
      const infoMatch = line.match(/ğŸ”µ\s*(?:Info|info)\s*:?\s*(.+)/i);

      if (errorMatch) {
        // ä¿å­˜å‰ä¸€ä¸ª issueï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (currentType && currentMessage.trim()) {
          issues.push({
            type: currentType,
            message: currentMessage
          });
        }
        // åˆ›å»ºæ–° issue
        currentType = 'error';
        currentMessage = errorMatch[1]?.trim() || '';
      } else if (warningMatch) {
        if (currentType && currentMessage.trim()) {
          issues.push({
            type: currentType,
            message: currentMessage
          });
        }
        currentType = 'warning';
        currentMessage = warningMatch[1]?.trim() || '';
      } else if (infoMatch) {
        if (currentType && currentMessage.trim()) {
          issues.push({
            type: currentType,
            message: currentMessage
          });
        }
        currentType = 'info';
        currentMessage = infoMatch[1]?.trim() || '';
      } else if (line.trim()) {
        // æ™®é€šæ–‡æœ¬è¡Œï¼Œè¿½åŠ åˆ°å½“å‰æ¶ˆæ¯
        if (currentMessage) {
          currentMessage += ' ' + line.trim();
        }
      }
    }

    // ä¿å­˜æœ€åä¸€ä¸ª issue
    if (currentType && currentMessage.trim()) {
      issues.push({
        type: currentType,
        message: currentMessage
      });
    }

    return issues;
  }
}

// ============================================================================
// å·¥å…·å‡½æ•°
// ============================================================================

/**
 * ä» AI æ–‡æœ¬ä¸­æå–ä»£ç å—
 * 
 * @param text åŒ…å«ä»£ç å—çš„æ–‡æœ¬
 * @returns æå–çš„ä»£ç å—æ•°ç»„
 */
export function extractCodeBlocks(text: string): Array<{ language: string; content: string }> {
  const regex = /```(\w+)?\n([\s\S]*?)```/g;
  const blocks: Array<{ language: string; content: string }> = [];
  let match;

  while ((match = regex.exec(text)) !== null) {
    const language = match[1];
    const content = match[2];

    blocks.push({
      language: language || 'text',
      content: content?.trim() || ''
    });
  }

  return blocks;
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/diffApplyTransaction.ts

````typescript
/**
 * Diff Apply Transaction - åŸå­æ€§äº‹åŠ¡æ¨¡å‹
 * 
 * ç›®æ ‡ï¼š
 * - å®ç°çœŸæ­£çš„å¯å›æ»šäº‹åŠ¡ï¼ˆä¸æ˜¯ try/catchï¼‰
 * - æ”¯æŒ tmp â†’ bak â†’ replace æµç¨‹
 * - å¼•å…¥ fsync ä¸ hash æ ¡éªŒ
 * - æ”¯æŒ DIRTY TRANSACTION çŠ¶æ€æ£€æµ‹
 * 
 * åŸåˆ™ï¼š
 * - Apply â‰  Commit
 * - å¤±è´¥è‡ªåŠ¨å›æ»š
 * - å¤šæ–‡ä»¶åŸå­æ€§ä¿è¯
 */

import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';

/**
 * äº‹åŠ¡çŠ¶æ€
 */
export enum TransactionState {
  /** æœªå¼€å§‹ */
  IDLE = 'idle',
  /** å·²å¼€å§‹ï¼Œæœªæäº¤ */
  ACTIVE = 'active',
  /** å·²æäº¤ */
  COMMITTED = 'committed',
  /** å·²å›æ»š */
  ROLLED_BACK = 'rolled_back',
  /** è„çŠ¶æ€ï¼šéƒ¨åˆ†å¤±è´¥ï¼Œéœ€è¦æ‰‹åŠ¨æ¸…ç† */
  DIRTY = 'dirty'
}

/**
 * æ–‡ä»¶æ“ä½œç±»å‹
 */
export enum FileOperationType {
  /** å†™å…¥æ–°æ–‡ä»¶ */
  WRITE = 'write',
  /** æ›¿æ¢æ–‡ä»¶ */
  REPLACE = 'replace',
  /** åˆ é™¤æ–‡ä»¶ */
  DELETE = 'delete'
}

/**
 * æ–‡ä»¶æ“ä½œè®°å½•
 */
export interface FileOperation {
  /** æ“ä½œç±»å‹ */
  type: FileOperationType;
  
  /** æ–‡ä»¶è·¯å¾„ */
  filePath: string;
  
  /** åŸå§‹å†…å®¹ï¼ˆç”¨äºå›æ»šï¼‰ */
  originalContent?: string;
  
  /** æ–°å†…å®¹ï¼ˆç”¨äºæäº¤ï¼‰ */
  newContent?: string;
  
  /** åŸå§‹æ–‡ä»¶ hash */
  originalHash?: string;
  
  /** æ–°æ–‡ä»¶ hash */
  newHash?: string;
  
  /** æ“ä½œæ˜¯å¦æˆåŠŸ */
  success?: boolean;
  
  /** é”™è¯¯ä¿¡æ¯ */
  error?: string;
}

/**
 * äº‹åŠ¡é€‰é¡¹
 */
export interface TransactionOptions {
  /** æ˜¯å¦ä½¿ç”¨ä¸´æ—¶æ–‡ä»¶ï¼ˆé»˜è®¤ trueï¼‰ */
  useTempFile?: boolean;
  
  /** æ˜¯å¦ä½¿ç”¨å¤‡ä»½æ–‡ä»¶ï¼ˆé»˜è®¤ trueï¼‰ */
  useBackupFile?: boolean;
  
  /** æ˜¯å¦è¿›è¡Œ hash æ ¡éªŒï¼ˆé»˜è®¤ trueï¼‰ */
  useHashValidation?: boolean;
  
  /** æ˜¯å¦æ‰§è¡Œ fsyncï¼ˆé»˜è®¤ trueï¼‰ */
  useFsync?: boolean;
  
  /** ä¸´æ—¶æ–‡ä»¶åç¼€ï¼ˆé»˜è®¤ .tmpï¼‰ */
  tempFileSuffix?: string;
  
  /** å¤‡ä»½æ–‡ä»¶åç¼€ï¼ˆé»˜è®¤ .bakï¼‰ */
  backupFileSuffix?: string;
}

/**
 * é»˜è®¤é€‰é¡¹
 */
const DEFAULT_OPTIONS: TransactionOptions = {
  useTempFile: true,
  useBackupFile: true,
  useHashValidation: true,
  useFsync: true,
  tempFileSuffix: '.tmp',
  backupFileSuffix: '.bak'
};

/**
 * Diff Apply Transaction
 * 
 * å®ç°çœŸæ­£çš„åŸå­æ€§äº‹åŠ¡ï¼Œæ”¯æŒï¼š
 * - å¤šæ–‡ä»¶æ“ä½œ
 * - è‡ªåŠ¨å›æ»š
 * - çŠ¶æ€ç®¡ç†
 * - è„çŠ¶æ€æ£€æµ‹
 */
export class DiffApplyTransaction {
  /** äº‹åŠ¡ ID */
  readonly transactionId: string;
  
  /** äº‹åŠ¡çŠ¶æ€ */
  private state: TransactionState = TransactionState.IDLE;
  
  /** æ–‡ä»¶æ“ä½œè®°å½• */
  private operations: FileOperation[] = [];
  
  /** åŸå§‹æ–‡ä»¶å†…å®¹ç¼“å­˜ï¼ˆç”¨äºå›æ»šï¼‰ */
  private originalContents = new Map<string, string>();
  
  /** é€‰é¡¹ */
  private readonly options: TransactionOptions;
  
  /** å·¥ä½œåŒºæ ¹ç›®å½• */
  private readonly workspaceRoot: string;

  constructor(options: TransactionOptions = {}) {
    this.transactionId = crypto.randomBytes(16).toString('hex');
    this.options = { ...DEFAULT_OPTIONS, ...options };
    
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    this.workspaceRoot = workspaceFolder?.uri.fsPath || '';
    
    console.log(`[DiffApplyTransaction] Created transaction ${this.transactionId}`);
  }

  /**
   * å¼€å§‹äº‹åŠ¡
   */
  begin(): void {
    if (this.state !== TransactionState.IDLE) {
      throw new Error(`Cannot begin transaction: state is ${this.state}`);
    }

    this.state = TransactionState.ACTIVE;
    console.log(`[DiffApplyTransaction ${this.transactionId}] Transaction started`);
  }

  /**
   * åº”ç”¨æ–‡ä»¶å†…å®¹
   * 
   * æµç¨‹ï¼š
   * 1. è¯»å–åŸå§‹å†…å®¹
   * 2. è®¡ç®— hash
   * 3. å†™å…¥ä¸´æ—¶æ–‡ä»¶
   * 4. å¤‡ä»½åŸå§‹æ–‡ä»¶
   * 5. æ›¿æ¢åŸæ–‡ä»¶
   * 6. éªŒè¯ hash
   */
  async apply(filePath: string, newContent: string): Promise<void> {
    if (this.state !== TransactionState.ACTIVE) {
      throw new Error(`Cannot apply file: transaction state is ${this.state}`);
    }

    const operation: FileOperation = {
      type: FileOperationType.REPLACE,
      filePath,
      newContent
    };

    try {
      // 1. è¯»å–åŸå§‹å†…å®¹
      const originalContent = await this.readFile(filePath);
      operation.originalContent = originalContent;
      operation.originalHash = this.calculateHash(originalContent);
      operation.newHash = this.calculateHash(newContent);

      // ç¼“å­˜åŸå§‹å†…å®¹ï¼ˆç”¨äºå›æ»šï¼‰
      this.originalContents.set(filePath, originalContent);

      // 2. å¦‚æœå¯ç”¨äº†ä¸´æ—¶æ–‡ä»¶
      if (this.options.useTempFile) {
        const tempFilePath = filePath + (this.options.tempFileSuffix || '.tmp');
        await this.writeFile(tempFilePath, newContent);
        
        // 3. å¦‚æœå¯ç”¨äº†å¤‡ä»½æ–‡ä»¶
        if (this.options.useBackupFile) {
          const backupFilePath = filePath + (this.options.backupFileSuffix || '.bak');
          await this.writeFile(backupFilePath, originalContent);
        }
        
        // 4. æ›¿æ¢åŸæ–‡ä»¶
        await this.replaceFile(tempFilePath, filePath);
      } else {
        // ç›´æ¥å†™å…¥
        await this.writeFile(filePath, newContent);
      }

      // 5. éªŒè¯ hashï¼ˆå¦‚æœå¯ç”¨ï¼‰
      if (this.options.useHashValidation) {
        const actualContent = await this.readFile(filePath);
        const actualHash = this.calculateHash(actualContent);
        
        if (actualHash !== operation.newHash) {
          throw new Error(
            `Hash validation failed for ${filePath}: expected ${operation.newHash}, got ${actualHash}`
          );
        }
      }

      operation.success = true;
      this.operations.push(operation);

      console.log(`[DiffApplyTransaction ${this.transactionId}] Applied ${filePath}`);
    } catch (error) {
      operation.success = false;
      operation.error = error instanceof Error ? error.message : String(error);
      this.operations.push(operation);

      console.error(`[DiffApplyTransaction ${this.transactionId}] Failed to apply ${filePath}:`, error);
      throw error;
    }
  }

  /**
   * æäº¤äº‹åŠ¡
   * 
   * æ¸…ç†ä¸´æ—¶æ–‡ä»¶å’Œå¤‡ä»½æ–‡ä»¶
   */
  async commit(): Promise<void> {
    if (this.state !== TransactionState.ACTIVE) {
      throw new Error(`Cannot commit transaction: state is ${this.state}`);
    }

    try {
      // æ¸…ç†ä¸´æ—¶æ–‡ä»¶å’Œå¤‡ä»½æ–‡ä»¶
      for (const operation of this.operations) {
        if (!operation.success) continue;

        const tempFilePath = operation.filePath + (this.options.tempFileSuffix || '.tmp');
        const backupFilePath = operation.filePath + (this.options.backupFileSuffix || '.bak');

        // åˆ é™¤ä¸´æ—¶æ–‡ä»¶
        if (this.options.useTempFile && await this.fileExists(tempFilePath)) {
          await this.deleteFile(tempFilePath);
        }

        // åˆ é™¤å¤‡ä»½æ–‡ä»¶
        if (this.options.useBackupFile && await this.fileExists(backupFilePath)) {
          await this.deleteFile(backupFilePath);
        }
      }

      this.state = TransactionState.COMMITTED;
      this.originalContents.clear();

      console.log(`[DiffApplyTransaction ${this.transactionId}] Transaction committed`);
    } catch (error) {
      console.error(`[DiffApplyTransaction ${this.transactionId}] Failed to commit:`, error);
      this.state = TransactionState.DIRTY;
      throw error;
    }
  }

  /**
   * å›æ»šäº‹åŠ¡
   * 
   * æ¢å¤æ‰€æœ‰æ–‡ä»¶åˆ°åŸå§‹çŠ¶æ€
   */
  async rollback(): Promise<void> {
    if (this.state !== TransactionState.ACTIVE && this.state !== TransactionState.DIRTY) {
      throw new Error(`Cannot rollback transaction: state is ${this.state}`);
    }

    console.log(`[DiffApplyTransaction ${this.transactionId}] Rolling back transaction`);

    const rollbackErrors: Error[] = [];

    try {
      // æŒ‰ç›¸åé¡ºåºå›æ»š
      for (const operation of [...this.operations].reverse()) {
        if (!operation.success || !operation.originalContent) continue;

        try {
          // å†™å…¥åŸå§‹å†…å®¹
          await this.writeFile(operation.filePath, operation.originalContent);

          // éªŒè¯ hash
          if (this.options.useHashValidation) {
            const actualContent = await this.readFile(operation.filePath);
            const actualHash = this.calculateHash(actualContent);
            const expectedHash = this.calculateHash(operation.originalContent);

            if (actualHash !== expectedHash) {
              throw new Error(
                `Rollback hash validation failed for ${operation.filePath}: expected ${expectedHash}, got ${actualHash}`
              );
            }
          }

          // æ¸…ç†ä¸´æ—¶æ–‡ä»¶å’Œå¤‡ä»½æ–‡ä»¶
          if (this.options.useTempFile) {
            const tempFilePath = operation.filePath + (this.options.tempFileSuffix || '.tmp');
            if (await this.fileExists(tempFilePath)) {
              await this.deleteFile(tempFilePath);
            }
          }

          if (this.options.useBackupFile) {
            const backupFilePath = operation.filePath + (this.options.backupFileSuffix || '.bak');
            if (await this.fileExists(backupFilePath)) {
              await this.deleteFile(backupFilePath);
            }
          }
        } catch (error) {
          rollbackErrors.push(error instanceof Error ? error : new Error(String(error)));
        }
      }

      this.state = TransactionState.ROLLED_BACK;
      this.originalContents.clear();

      console.log(`[DiffApplyTransaction ${this.transactionId}] Transaction rolled back`);

      // å¦‚æœæœ‰å›æ»šé”™è¯¯ï¼ŒæŠ›å‡ºè­¦å‘Š
      if (rollbackErrors.length > 0) {
        console.warn(
          `[DiffApplyTransaction ${this.transactionId}] Rollback completed with ${rollbackErrors.length} errors:`,
          rollbackErrors
        );
      }
    } catch (error) {
      console.error(`[DiffApplyTransaction ${this.transactionId}] Failed to rollback:`, error);
      this.state = TransactionState.DIRTY;
      throw error;
    }
  }

  /**
   * è·å–äº‹åŠ¡çŠ¶æ€
   */
  getState(): TransactionState {
    return this.state;
  }

  /**
   * è·å–äº‹åŠ¡ ID
   */
  getTransactionId(): string {
    return this.transactionId;
  }

  /**
   * è·å–æ‰€æœ‰æ“ä½œè®°å½•
   */
  getOperations(): FileOperation[] {
    return [...this.operations];
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å¤„äºè„çŠ¶æ€
   */
  isDirty(): boolean {
    return this.state === TransactionState.DIRTY;
  }

  /**
   * è·å–å·²ä¿®æ”¹çš„æ–‡ä»¶åˆ—è¡¨
   */
  getModifiedFiles(): string[] {
    return this.operations
      .filter(op => op.success)
      .map(op => op.filePath);
  }

  /**
   * è¯»å–æ–‡ä»¶
   */
  private async readFile(filePath: string): Promise<string> {
    const fullPath = this.resolveFullPath(filePath);
    return fs.promises.readFile(fullPath, 'utf8');
  }

  /**
   * å†™å…¥æ–‡ä»¶
   */
  private async writeFile(filePath: string, content: string): Promise<void> {
    const fullPath = this.resolveFullPath(filePath);
    
    // ç¡®ä¿ç›®å½•å­˜åœ¨
    const dir = path.dirname(fullPath);
    await fs.promises.mkdir(dir, { recursive: true });

    // å†™å…¥æ–‡ä»¶
    await fs.promises.writeFile(fullPath, content, 'utf8');

    // å¦‚æœå¯ç”¨äº† fsync
    if (this.options.useFsync) {
      const handle = await fs.promises.open(fullPath, 'r');
      try {
        await handle.sync();
      } finally {
        await handle.close();
      }
    }
  }

  /**
   * æ›¿æ¢æ–‡ä»¶ï¼ˆåŸå­æ€§æ“ä½œï¼‰
   */
  private async replaceFile(tempPath: string, targetPath: string): Promise<void> {
    const fullTempPath = this.resolveFullPath(tempPath);
    const fullTargetPath = this.resolveFullPath(targetPath);

    // åœ¨æŸäº›ç³»ç»Ÿä¸Šï¼Œé‡å‘½åæ˜¯åŸå­æ“ä½œ
    await fs.promises.rename(fullTempPath, fullTargetPath);
  }

  /**
   * åˆ é™¤æ–‡ä»¶
   */
  private async deleteFile(filePath: string): Promise<void> {
    const fullPath = this.resolveFullPath(filePath);
    await fs.promises.unlink(fullPath);
  }

  /**
   * æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
   */
  private async fileExists(filePath: string): Promise<boolean> {
    const fullPath = this.resolveFullPath(filePath);
    try {
      await fs.promises.access(fullPath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * è®¡ç®— hash
   */
  private calculateHash(content: string): string {
    return crypto.createHash('sha256').update(content).digest('hex');
  }

  /**
   * è§£æå®Œæ•´è·¯å¾„
   */
  private resolveFullPath(filePath: string): string {
    if (path.isAbsolute(filePath)) {
      return filePath;
    }

    return path.join(this.workspaceRoot, filePath);
  }
}

/**
 * å¿«æ·å‡½æ•°ï¼šåˆ›å»ºäº‹åŠ¡
 */
export function createTransaction(options?: TransactionOptions): DiffApplyTransaction {
  return new DiffApplyTransaction(options);
}

/**
 * å¿«æ·å‡½æ•°ï¼šæ‰§è¡Œäº‹åŠ¡ï¼ˆè‡ªåŠ¨å›æ»šï¼‰
 */
export async function executeTransaction<T>(
  callback: (tx: DiffApplyTransaction) => Promise<T>,
  options?: TransactionOptions
): Promise<T> {
  const tx = new DiffApplyTransaction(options);

  tx.begin();

  try {
    const result = await callback(tx);
    await tx.commit();
    return result;
  } catch (error) {
    await tx.rollback();
    throw error;
  }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/diffSecurityValidator.ts

````typescript
/**
 * Diff Security Validator - æ¶æ„ Diff é˜²å¾¡å±‚
 * 
 * ç›®æ ‡ï¼š
 * - é˜²æ­¢è·¯å¾„ç©¿è¶Šæ”»å‡»
 * - é˜²æ­¢ç»å¯¹è·¯å¾„æ”»å‡»
 * - é˜²æ­¢å¤§æ–‡ä»¶ DoS æ”»å‡»
 * - é˜²æ­¢ä¸Šä¸‹æ–‡æ¨¡ç³Šæ”»å‡»
 * - é˜²æ­¢ Hunk Header ä¼ªé€ 
 * 
 * åŸåˆ™ï¼š
 * - å®å¯å¤±è´¥ï¼Œä¹Ÿä¸è¯¯æ”¹
 * - ä»»ä½•ä¸åŒ¹é…ç«‹å³å¤±è´¥
 * - ä¸å…è®¸æ¨¡ç³ŠåŒ¹é…
 * - ä¸è‡ªåŠ¨åç§»è¡Œå·
 */

import { DiffParseResult, DiffFile, DiffHunk } from './diff';

/**
 * å®‰å…¨é™åˆ¶é…ç½®
 */
export interface SecurityLimits {
  /** æœ€å¤§å•è¡Œé•¿åº¦ï¼ˆå­—èŠ‚ï¼‰ */
  maxLineLength: number;
  /** æœ€å¤§ä¸Šä¸‹æ–‡è¡Œæ•° */
  maxContextLines: number;
  /** æ¯ä¸ª hunk çš„æœ€å¤§è¡Œæ•° */
  maxHunkLines: number;
  /** æ¯ä¸ªæ–‡ä»¶çš„æœ€å¤§ hunk æ•° */
  maxHunksPerFile: number;
  /** æ¯ä¸ª diff çš„æœ€å¤§æ–‡ä»¶æ•° */
  maxFilesPerDiff: number;
  /** å…è®¸çš„æ–‡ä»¶æ‰©å±•åï¼ˆç©ºæ•°ç»„è¡¨ç¤ºå…¨éƒ¨å…è®¸ï¼‰ */
  allowedExtensions: string[];
  /** ç¦æ­¢çš„è·¯å¾„æ¨¡å¼ï¼ˆæ­£åˆ™è¡¨è¾¾å¼æ•°ç»„ï¼‰ */
  forbiddenPathPatterns: RegExp[];
}

/**
 * é»˜è®¤å®‰å…¨é™åˆ¶
 */
export const DEFAULT_SECURITY_LIMITS: SecurityLimits = {
  maxLineLength: 4096,        // 4KB
  maxContextLines: 200,       // 200 è¡Œä¸Šä¸‹æ–‡
  maxHunkLines: 1000,         // æ¯ä¸ª hunk æœ€å¤š 1000 è¡Œ
  maxHunksPerFile: 50,        // æ¯ä¸ªæ–‡ä»¶æœ€å¤š 50 ä¸ª hunks
  maxFilesPerDiff: 20,        // æ¯ä¸ª diff æœ€å¤š 20 ä¸ªæ–‡ä»¶
  allowedExtensions: [],      // å…è®¸æ‰€æœ‰æ‰©å±•å
  forbiddenPathPatterns: [
    /\.\./,                   // ç¦æ­¢è·¯å¾„ç©¿è¶Š
    /^\/.*/,                  // ç¦æ­¢ç»å¯¹è·¯å¾„
    /^[A-Za-z]:\\/            // ç¦æ­¢ Windows é©±åŠ¨å™¨è·¯å¾„
  ]
};

/**
 * éªŒè¯ç»“æœ
 */
export interface SecurityValidationResult {
  /** æ˜¯å¦é€šè¿‡éªŒè¯ */
  valid: boolean;
  /** é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœéªŒè¯å¤±è´¥ï¼‰ */
  errors: SecurityValidationError[];
}

/**
 * éªŒè¯é”™è¯¯
 */
export interface SecurityValidationError {
  /** é”™è¯¯ç±»å‹ */
  type: 
    | 'PATH_TRAVERSAL' 
    | 'ABSOLUTE_PATH' 
    | 'LINE_TOO_LONG' 
    | 'CONTEXT_TOO_LARGE' 
    | 'HUNK_TOO_LARGE' 
    | 'TOO_MANY_HUNKS' 
    | 'TOO_MANY_FILES' 
    | 'EXTENSION_NOT_ALLOWED'
    | 'FORBIDDEN_PATH_PATTERN'
    | 'HUNK_HEADER_FORGERY'
    | 'INVALID_UNIFIED_DIFF';
  
  /** é”™è¯¯æ¶ˆæ¯ */
  message: string;
  
  /** ç›¸å…³æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰ */
  filePath?: string;
  
  /** ç›¸å…³ hunk ç´¢å¼•ï¼ˆå¯é€‰ï¼‰ */
  hunkIndex?: number;
  
  /** ç›¸å…³è¡Œå·ï¼ˆå¯é€‰ï¼‰ */
  line?: number;
  
  /** å®é™…å€¼ï¼ˆå¯é€‰ï¼‰ */
  actual?: number;
  
  /** æœ€å¤§å…è®¸å€¼ï¼ˆå¯é€‰ï¼‰ */
  max?: number;
}

/**
 * Diff Security Validator
 */
export class DiffSecurityValidator {
  private limits: SecurityLimits;

  constructor(limits: Partial<SecurityLimits> = {}) {
    this.limits = { ...DEFAULT_SECURITY_LIMITS, ...limits };
  }

  /**
   * éªŒè¯æ•´ä¸ª Diff
   */
  validate(diff: DiffParseResult): SecurityValidationResult {
    const errors: SecurityValidationError[] = [];

    if (!diff.success) {
      return {
        valid: false,
        errors: [{
          type: 'INVALID_UNIFIED_DIFF',
          message: 'Diff parsing failed, cannot validate'
        }]
      };
    }

    // æ£€æŸ¥æ–‡ä»¶æ•°é‡
    if (diff.files.length > this.limits.maxFilesPerDiff) {
      errors.push({
        type: 'TOO_MANY_FILES',
        message: `Too many files in diff: ${diff.files.length} (max: ${this.limits.maxFilesPerDiff})`,
        actual: diff.files.length,
        max: this.limits.maxFilesPerDiff
      });
    }

    // æ£€æŸ¥æ¯ä¸ªæ–‡ä»¶
    for (const file of diff.files) {
      const fileErrors = this.validateFile(file);
      errors.push(...fileErrors);
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  /**
   * éªŒè¯å•ä¸ªæ–‡ä»¶
   */
  private validateFile(file: DiffFile): SecurityValidationError[] {
    const errors: SecurityValidationError[] = [];

    // æ£€æŸ¥è·¯å¾„å®‰å…¨æ€§
    const pathErrors = this.validatePath(file.normalizedPath);
    errors.push(...pathErrors.map(e => ({ ...e, filePath: file.normalizedPath })));

    // æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
    const extErrors = this.validateFileExtension(file.normalizedPath);
    errors.push(...extErrors.map(e => ({ ...e, filePath: file.normalizedPath })));

    // æ£€æŸ¥ hunk æ•°é‡
    if (file.hunks.length > this.limits.maxHunksPerFile) {
      errors.push({
        type: 'TOO_MANY_HUNKS',
        message: `Too many hunks in file ${file.normalizedPath}: ${file.hunks.length} (max: ${this.limits.maxHunksPerFile})`,
        filePath: file.normalizedPath,
        actual: file.hunks.length,
        max: this.limits.maxHunksPerFile
      });
    }

    // æ£€æŸ¥æ¯ä¸ª hunk
    for (let i = 0; i < file.hunks.length; i++) {
      const hunkErrors = this.validateHunk(file.hunks[i], i);
      errors.push(...hunkErrors);
    }

    return errors;
  }

  /**
   * éªŒè¯è·¯å¾„å®‰å…¨æ€§
   */
  private validatePath(path: string): SecurityValidationError[] {
    const errors: SecurityValidationError[] = [];

    // æ£€æŸ¥è·¯å¾„ç©¿è¶Š
    if (path.includes('..')) {
      errors.push({
        type: 'PATH_TRAVERSAL',
        message: `Path traversal detected in ${path}`
      });
    }

    // æ£€æŸ¥ç»å¯¹è·¯å¾„
    if (path.startsWith('/') || /^[A-Za-z]:/.test(path)) {
      errors.push({
        type: 'ABSOLUTE_PATH',
        message: `Absolute path detected: ${path}`
      });
    }

    // æ£€æŸ¥ç¦æ­¢çš„æ¨¡å¼
    for (const pattern of this.limits.forbiddenPathPatterns) {
      if (pattern.test(path)) {
        errors.push({
          type: 'FORBIDDEN_PATH_PATTERN',
          message: `Forbidden path pattern detected in ${path}`
        });
      }
    }

    return errors;
  }

  /**
   * éªŒè¯æ–‡ä»¶æ‰©å±•å
   */
  private validateFileExtension(path: string): SecurityValidationError[] {
    const errors: SecurityValidationError[] = [];

    if (this.limits.allowedExtensions.length > 0) {
      const ext = path.split('.').pop()?.toLowerCase() || '';
      if (!this.limits.allowedExtensions.includes(ext)) {
        errors.push({
          type: 'EXTENSION_NOT_ALLOWED',
          message: `File extension not allowed: .${ext} in ${path}`
        });
      }
    }

    return errors;
  }

  /**
   * éªŒè¯å•ä¸ª Hunk
   */
  private validateHunk(hunk: DiffHunk, hunkIndex: number): SecurityValidationError[] {
    const errors: SecurityValidationError[] = [];

    // æ£€æŸ¥ä¸Šä¸‹æ–‡è¡Œæ•°
    if (hunk.stats.context > this.limits.maxContextLines) {
      errors.push({
        type: 'CONTEXT_TOO_LARGE',
        message: `Too many context lines in hunk at ${hunk.filePath}:${hunk.oldStart}: ${hunk.stats.context} (max: ${this.limits.maxContextLines})`,
        filePath: hunk.filePath,
        hunkIndex,
        actual: hunk.stats.context,
        max: this.limits.maxContextLines
      });
    }

    // æ£€æŸ¥ hunk æ€»è¡Œæ•°
    const totalLines = hunk.lines.length;
    if (totalLines > this.limits.maxHunkLines) {
      errors.push({
        type: 'HUNK_TOO_LARGE',
        message: `Hunk too large at ${hunk.filePath}:${hunk.oldStart}: ${totalLines} lines (max: ${this.limits.maxHunkLines})`,
        filePath: hunk.filePath,
        hunkIndex,
        actual: totalLines,
        max: this.limits.maxHunkLines
      });
    }

    // æ£€æŸ¥æ¯è¡Œé•¿åº¦
    for (let i = 0; i < hunk.lines.length; i++) {
      const line = hunk.lines[i];
      if (line.content.length > this.limits.maxLineLength) {
        errors.push({
          type: 'LINE_TOO_LONG',
          message: `Line too long in ${hunk.filePath} (diff line ${line.lineNumber}): ${line.content.length} bytes (max: ${this.limits.maxLineLength})`,
          filePath: hunk.filePath,
          hunkIndex,
          line: line.lineNumber,
          actual: line.content.length,
          max: this.limits.maxLineLength
        });
      }
    }

    // æ£€æŸ¥ Hunk Header ä¼ªé€ ï¼ˆè¡Œæ•°ç»Ÿè®¡åŒ¹é…ï¼‰
    const headerValidation = this.validateHunkHeader(hunk);
    if (!headerValidation.valid) {
      errors.push({
        type: 'HUNK_HEADER_FORGERY',
        message: headerValidation.error!, // headerValidation.valid ä¸º false æ—¶ error å¿…ç„¶å­˜åœ¨
        filePath: hunk.filePath,
        hunkIndex
      });
    }

    return errors;
  }

  /**
   * éªŒè¯ Hunk Header çš„è¡Œæ•°ç»Ÿè®¡
   */
  private validateHunkHeader(hunk: DiffHunk): { valid: boolean; error?: string } {
    // Unified diff è¯­ä¹‰ï¼š
    // - oldCount = context + removed
    // - newCount = context + added

    const oldLines = hunk.stats.context + hunk.stats.removed;
    const newLines = hunk.stats.context + hunk.stats.added;

    if (oldLines !== hunk.oldCount) {
      return {
        valid: false,
        error: `Hunk header forgery detected at ${hunk.filePath}:${hunk.oldStart}: expected ${hunk.oldCount} old lines (context+removed), found ${oldLines}`
      };
    }

    if (newLines !== hunk.newCount) {
      return {
        valid: false,
        error: `Hunk header forgery detected at ${hunk.filePath}:${hunk.oldStart}: expected ${hunk.newCount} new lines (context+added), found ${newLines}`
      };
    }

    return { valid: true };
  }

  /**
   * éªŒè¯ Diff å†…å®¹ï¼ˆåŸå§‹æ–‡æœ¬ï¼‰
   * 
   * é‡è¦ï¼šæ­¤æ–¹æ³•ä¼šåœ¨å†…éƒ¨è§£æ diff å¹¶åœ¨ DiffParseResult ä¸Šè¿›è¡Œå®Œæ•´çš„å®‰å…¨éªŒè¯
   * è¿™æ ·å¯ä»¥ç¡®ä¿æ‰€æœ‰å®‰å…¨æ£€æŸ¥éƒ½è½åœ¨åŒä¸€ä¸ªæ•°æ®ç»“æ„ä¸Šï¼Œé¿å…"å®‰å…¨ç­–ç•¥åˆ†å‰"
   */
  validateDiffText(diffText: string): SecurityValidationResult {
    // å¯¼å…¥ DiffParserï¼ˆå»¶è¿Ÿå¯¼å…¥é¿å…å¾ªç¯ä¾èµ–ï¼‰
    const { DiffParser } = require('./diff');
    
    // å¿…é¡»å…ˆè§£æ diff
    const parseResult = DiffParser.parse(diffText);
    
    // å¦‚æœè§£æå¤±è´¥ï¼Œç«‹å³è¿”å›æ— æ•ˆ
    if (!parseResult.success) {
      return {
        valid: false,
        errors: [{
          type: 'INVALID_UNIFIED_DIFF',
          message: 'Diff parsing failed: ' + (parseResult.error || 'Unknown error')
        }]
      };
    }
    
    // ç„¶ååœ¨è§£æåçš„ diff ä¸Šè¿›è¡Œå®Œæ•´çš„å®‰å…¨éªŒè¯
    // è¿™æ ·ç¡®ä¿ validateDiffText å’Œ validate çš„å®‰å…¨ç­–ç•¥å®Œå…¨ä¸€è‡´
    return this.validate(parseResult);
  }

  /**
   * æ›´æ–°å®‰å…¨é™åˆ¶
   */
  updateLimits(limits: Partial<SecurityLimits>): void {
    this.limits = { ...this.limits, ...limits };
  }

  /**
   * è·å–å½“å‰å®‰å…¨é™åˆ¶
   */
  getLimits(): SecurityLimits {
    return { ...this.limits };
  }
}

/**
 * å¿«æ·å‡½æ•°ï¼šä½¿ç”¨é»˜è®¤é™åˆ¶éªŒè¯ Diff
 */
export function validateDiffSecurity(diff: DiffParseResult): SecurityValidationResult {
  const validator = new DiffSecurityValidator();
  return validator.validate(diff);
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/diffSource.ts

````typescript
/**
 * Diff Source å®ç°
 * 
 * æä¾›å¤šç§ç­–ç•¥è·å– Diff å†…å®¹ï¼š
 * - GitDiff: ä» Git è·å–å¢é‡ diff
 * - MemoryDiff: ä» VS Code å†…å­˜è·å–ï¼ˆç”¨äºæœªä¿å­˜çš„ä¿®æ”¹ï¼‰
 * - FullFileDiff: å…¨æ–‡ä»¶å†…å®¹ï¼ˆé™çº§ç­–ç•¥ï¼‰
 */

import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { DiffSource } from './securityTypes';

/**
 * Git Diff Source
 * ä» Git è·å–ç›¸å¯¹äº HEAD çš„ diff
 * 
 * è¿”å›å€¼è¯´æ˜ï¼š
 * - null: æ— æ³•è·å– diffï¼ˆé Git ç›®å½•ã€Git æ‰©å±•ä¸å¯ç”¨ï¼‰
 * - "": Git ä»“åº“å¯ç”¨ï¼Œä½†æ²¡æœ‰æœªæäº¤çš„æ›´æ”¹ï¼ˆç©º diffï¼‰
 * - "xxx...": å®é™…çš„ diff å†…å®¹
 */
export class GitDiffSource implements DiffSource {
  constructor(private filePath: string) {}

  async getDiff(): Promise<string | null> {
    try {
      // æ£€æŸ¥æ˜¯å¦åœ¨ Git ä»“åº“ä¸­
      const gitExtension = vscode.extensions.getExtension('vscode.git');
      if (!gitExtension) {
        console.warn('[GitDiffSource] Git extension not available');
        return null;
      }

      const gitApi = await gitExtension.activate();
      if (!gitApi) {
        return null;
      }

      const repository = gitApi.getRepository(vscode.Uri.file(this.filePath));
      if (!repository) {
        console.warn(`[GitDiffSource] No repository found for ${this.filePath}`);
        return null;
      }

      // è·å–ç›¸å¯¹äº HEAD çš„ diff
      const diffText = await repository.diffIndexWithHEAD(this.filePath);
      
      // å…³é”®ä¿®å¤ï¼šç©ºå­—ç¬¦ä¸²è¡¨ç¤º Git å¯ç”¨ä½†æ²¡æœ‰æ›´æ”¹ï¼Œnull è¡¨ç¤º Git ä¸å¯ç”¨
      return diffText !== null ? diffText : null;
    } catch (error) {
      console.error(`[GitDiffSource] Error getting diff for ${this.filePath}:`, error);
      return null;
    }
  }

  getStrategy(): 'git' | 'memory' | 'full' {
    return 'git';
  }
}

/**
 * Memory Diff Source
 * ä» VS Code æ–‡æ¡£å†…å­˜è·å–æœªä¿å­˜çš„ä¿®æ”¹
 * 
 * æ³¨æ„ï¼šæ­¤ Source ä»…ç”¨äºå®‰å…¨æ‰«æï¼Œä¸é€‚ç”¨äºå¢é‡ Code Review
 * å› ä¸ºå®ƒä¼šç”Ÿæˆä¼ªé€ çš„å…¨é‡æ–°å¢ diffï¼Œè€Œä¸æ˜¯çœŸå®çš„å¢é‡
 */
export class MemoryDiffSource implements DiffSource {
  constructor(private document: vscode.TextDocument) {}

  async getDiff(): Promise<string | null> {
    try {
      const content = this.document.getText();
      
      // ç”Ÿæˆä¸€ä¸ªç®€å•çš„ unified diff æ ¼å¼
      // æ³¨æ„ï¼šè¿™åªæ˜¯ä¸€ä¸ªé™çº§ç­–ç•¥ï¼Œä¸æ˜¯çœŸæ­£çš„ diff
      const fileName = path.basename(this.document.fileName);
      const timestamp = new Date().toISOString();
      
      const diffHeader = `diff --git a/${fileName} b/${fileName}
index 0000000..1111111 100644
--- a/${fileName}
+++ b/${fileName}
@@ -0,0 +1,${content.split('\n').length} @@
${content.split('\n').map(line => `+${line}`).join('\n')}
`;

      return diffHeader;
    } catch (error) {
      console.error(`[MemoryDiffSource] Error getting diff:`, error);
      return null;
    }
  }

  getStrategy(): 'git' | 'memory' | 'full' {
    return 'memory';
  }
}

/**
 * Full File Diff Source
 * ç›´æ¥è¿”å›æ–‡ä»¶å®Œæ•´å†…å®¹ï¼ˆæœ€åº•å±‚çš„é™çº§ç­–ç•¥ï¼‰
 * 
 * ä¼˜åŒ–ï¼šå¯¹äºå¤§æ–‡ä»¶ï¼ˆ> 5000 è¡Œï¼‰ï¼Œä»…æ‰«æç¼–è¾‘åŒºåŸŸï¼ˆä¸Šä¸‹ 50 è¡Œï¼‰
 */
export class FullFileDiffSource implements DiffSource {
  constructor(private filePath: string) {}

  async getDiff(): Promise<string | null> {
    try {
      const content = fs.readFileSync(this.filePath, 'utf-8');
      const lines = content.split('\n');
      
      // æ€§èƒ½ä¼˜åŒ–ï¼šå¤§æ–‡ä»¶ä»…è¯»å–éƒ¨åˆ†å†…å®¹
      let contentToScan = content;
      if (lines.length > 5000) {
        // è·å– VS Code æ´»åŠ¨ç¼–è¾‘å™¨çš„é€‰æ‹©èŒƒå›´
        const editor = vscode.window.activeTextEditor;
        if (editor && editor.document.fileName === this.filePath) {
          const selection = editor.selection;
          const startLine = Math.max(0, selection.start.line - 50);
          const endLine = Math.min(lines.length, selection.end.line + 50);
          contentToScan = lines.slice(startLine, endLine).join('\n');
          
          console.log(`[FullFileDiffSource] Large file (${lines.length} lines), scanning window [${startLine}:${endLine}]`);
        } else {
          // å¦‚æœæ²¡æœ‰æ´»åŠ¨ç¼–è¾‘å™¨ï¼Œåªè¯»å–å‰ 1000 è¡Œ
          contentToScan = lines.slice(0, 1000).join('\n');
          console.log(`[FullFileDiffSource] Large file (${lines.length} lines), scanning first 1000 lines`);
        }
      }
      
      // ç”Ÿæˆ unified diff æ ¼å¼
      const fileName = path.basename(this.filePath);
      const timestamp = new Date().toISOString();
      
      const diffHeader = `diff --git a/${fileName} b/${fileName}
index 0000000..1111111 100644
--- a/${fileName}
+++ b/${fileName}
@@ -0,0 +1,${contentToScan.split('\n').length} @@
${contentToScan.split('\n').map(line => `+${line}`).join('\n')}
`;

      return diffHeader;
    } catch (error) {
      console.error(`[FullFileDiffSource] Error reading file ${this.filePath}:`, error);
      return null;
    }
  }

  getStrategy(): 'git' | 'memory' | 'full' {
    return 'full';
  }
}

/**
 * Diff Source Factory
 * æ ¹æ®ä¼˜å…ˆçº§ç­–ç•¥åˆ›å»º Diff Source
 */
export class DiffSourceFactory {
  /**
   * åˆ›å»º Diff Sourceï¼ˆä¼˜å…ˆçº§ï¼šGit -> Memory -> Fullï¼‰
   */
  static create(document: vscode.TextDocument): DiffSource[] {
    const sources: DiffSource[] = [];

    // 1. Git Diff Sourceï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
    sources.push(new GitDiffSource(document.fileName));

    // 2. Memory Diff Sourceï¼ˆé™çº§ç­–ç•¥ï¼‰
    sources.push(new MemoryDiffSource(document));

    // 3. Full File Diff Sourceï¼ˆæœ€åº•å±‚é™çº§ï¼‰
    sources.push(new FullFileDiffSource(document.fileName));

    return sources;
  }

  /**
   * å°è¯•è·å– Diffï¼ˆæŒ‰ä¼˜å…ˆçº§å°è¯•ï¼‰
   * 
   * ç­–ç•¥ä¼˜å…ˆçº§ï¼šGit -> Memory -> Full
   * 
   * è¿”å›å€¼è¯´æ˜ï¼š
   * - null: æ‰€æœ‰ç­–ç•¥éƒ½å¤±è´¥
   * - { diff: "", strategy: "git" }: Git å¯ç”¨ä½†æ— æ›´æ”¹
   * - { diff: "xxx...", strategy: "..." }: è·å–åˆ° diff
   */
  static async tryGetDiff(document: vscode.TextDocument): Promise<{ diff: string; strategy: 'git' | 'memory' | 'full' } | null> {
    const sources = this.create(document);

    for (const source of sources) {
      const diff = await source.getDiff();
      
      // å…³é”®ä¿®å¤ï¼šåªè¦ä¸æ˜¯ nullï¼Œå°±è¯´æ˜è¯¥ç­–ç•¥ç”Ÿæ•ˆäº†
      // diff å¯ä»¥ä¸ºç©ºå­—ç¬¦ä¸²ï¼ˆè¡¨ç¤ºæ²¡æœ‰æ›´æ”¹ï¼‰ï¼Œä½†ç­–ç•¥æ˜¯æˆåŠŸçš„
      if (diff !== null) {
        return {
          diff,
          strategy: source.getStrategy()
        };
      }
    }

    return null;
  }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/preferenceMemory.ts

````typescript
/**
 * Preference Memory - çŸ¥è¯†ç»§æ‰¿æ¨¡å—
 * 
 * è®°å½•ç”¨æˆ·å¯¹ AI å»ºè®®çš„åé¦ˆï¼Œå¹¶åŠ¨æ€è°ƒæ•´ AI çš„è¡Œä¸º
 * 
 * æ ¸å¿ƒåŠŸèƒ½ï¼š
 * 1. è®°å½•ç”¨æˆ·å¯¹å„ç±»å»ºè®®çš„é‡‡çº³/å¿½ç•¥è¡Œä¸º
 * 2. è®¡ç®—ç”¨æˆ·å¯¹å„ç±»é—®é¢˜çš„"åæ„Ÿåº¦"ï¼ˆannoyanceScoreï¼‰
 * 3. ç”Ÿæˆä¸ªæ€§åŒ– Prompt çº¦æŸï¼ˆé»‘åå•/ç™½åå•ï¼‰
 * 4. æ”¯æŒæ—¶é—´è¡°å‡ï¼ˆæ—§åé¦ˆæƒé‡é™ä½ï¼‰
 */

import * as vscode from 'vscode';
import {
  IssueType,
  IssueFeedback,
  IssueFeedbackStats,
  UserPreferenceConstraints,
  DEFAULT_SCAN_CONFIG
} from './securityTypes';

/**
 * åé¦ˆè®°å½•é…ç½®
 */
interface FeedbackConfig {
  /** è®°å½•çš„æœ€å¤§æ•°é‡ */
  maxRecords: number;
  
  /** è®°å½•çš„æœ‰æ•ˆæœŸï¼ˆæ¯«ç§’ï¼‰ */
  recordTTL: number;
  
  /** å¿½ç•¥é˜ˆå€¼ï¼ˆå¿½ç•¥æ¬¡æ•°è¶…è¿‡æ­¤å€¼ä¸”å¿½ç•¥ç‡ > 80% æ‰è®¡å…¥é»‘åå•ï¼‰ */
  ignoreThreshold: number;
  
  /** å¿½ç•¥ç‡é˜ˆå€¼ï¼ˆ0-1ï¼‰ */
  ignoreRateThreshold: number;
  
  /** æ—¶é—´è¡°å‡åŠè¡°æœŸï¼ˆæ¯«ç§’ï¼‰ */
  halfLife: number;
}

/**
 * é»˜è®¤åé¦ˆé…ç½®
 */
const DEFAULT_FEEDBACK_CONFIG: FeedbackConfig = {
  maxRecords: 1000,
  recordTTL: 30 * 24 * 60 * 60 * 1000, // 30å¤©
  ignoreThreshold: 3,
  ignoreRateThreshold: 0.8,
  halfLife: 7 * 24 * 60 * 60 * 1000 // 7å¤©åŠè¡°æœŸ
};

/**
 * Preference Memory
 */
export class PreferenceMemory {
  private context: vscode.ExtensionContext;
  private config: FeedbackConfig;
  private storageKey: string = 'vsyuangs_preference_feedback';

  constructor(context: vscode.ExtensionContext, config?: Partial<FeedbackConfig>) {
    this.context = context;
    this.config = { ...DEFAULT_FEEDBACK_CONFIG, ...config };
  }

  /**
   * è®°å½•ç”¨æˆ·åé¦ˆ
   */
  async recordFeedback(
    issueType: IssueType,
    action: 'applied' | 'ignored' | 'dismissed',
    filePath?: string
  ): Promise<void> {
    const feedback: IssueFeedback = {
      issueType,
      action,
      timestamp: Date.now(),
      filePath
    };

    // è·å–ç°æœ‰è®°å½•
    const records = this.getFeedbackRecords();
    
    // æ·»åŠ æ–°è®°å½•
    records.push(feedback);
    
    // æ¸…ç†è¿‡æœŸè®°å½•
    const validRecords = this.cleanupRecords(records);
    
    // é™åˆ¶è®°å½•æ•°é‡
    const limitedRecords = validRecords.slice(-this.config.maxRecords);
    
    // ä¿å­˜
    await this.context.globalState.update(this.storageKey, limitedRecords);
    
    console.log(`[PreferenceMemory] Recorded feedback: ${issueType} - ${action}`);
  }

  /**
   * è·å–åé¦ˆè®°å½•
   */
  private getFeedbackRecords(): IssueFeedback[] {
    const records = this.context.globalState.get<IssueFeedback[]>(this.storageKey, []);
    return records || [];
  }

  /**
   * æ¸…ç†è¿‡æœŸè®°å½•
   */
  private cleanupRecords(records: IssueFeedback[]): IssueFeedback[] {
    const now = Date.now();
    const cutoff = now - this.config.recordTTL;
    
    return records.filter(r => r.timestamp >= cutoff);
  }

  /**
   * è®¡ç®—ç»Ÿè®¡æ•°æ®
   */
  async getStats(): Promise<IssueFeedbackStats> {
    const records = this.cleanupRecords(this.getFeedbackRecords());
    
    // åˆå§‹åŒ–ç»Ÿè®¡
    const statsMap: Record<IssueType, {
      ignoreCount: number;
      applyCount: number;
      totalCount: number;
      ignoreRate: number;
      lastFeedbackTime: number;
    }> = {} as any;
    
    // åˆå§‹åŒ–æ‰€æœ‰ IssueType
    Object.values(IssueType).forEach(type => {
      statsMap[type] = {
        ignoreCount: 0,
        applyCount: 0,
        totalCount: 0,
        ignoreRate: 0,
        lastFeedbackTime: 0
      };
    });
    
    // ç»Ÿè®¡
    for (const record of records) {
      const type = record.issueType;
      
      if (record.action === 'ignored' || record.action === 'dismissed') {
        statsMap[type].ignoreCount++;
      } else if (record.action === 'applied') {
        statsMap[type].applyCount++;
      }
      
      statsMap[type].totalCount++;
      statsMap[type].lastFeedbackTime = Math.max(
        statsMap[type].lastFeedbackTime,
        record.timestamp
      );
    }
    
    // è®¡ç®—å¿½ç•¥ç‡
    for (const type of Object.values(IssueType)) {
      const stats = statsMap[type];
      if (stats.totalCount > 0) {
        stats.ignoreRate = stats.ignoreCount / stats.totalCount;
      }
    }
    
    // è®¡ç®—èµ·å§‹æ—¶é—´
    const startTime = records.length > 0 
      ? records[0].timestamp 
      : Date.now();
    
    return {
      byType: statsMap,
      totalRecords: records.length,
      startTime
    };
  }

  /**
   * è®¡ç®—æŸä¸ª IssueType çš„åæ„Ÿåº¦ï¼ˆannoyanceScoreï¼‰
   * 
   * è€ƒè™‘å› ç´ ï¼š
   * 1. å¿½ç•¥æ¬¡æ•°ï¼ˆè¶Šå¤šè¶Šåæ„Ÿï¼‰
   * 2. å¿½ç•¥ç‡ï¼ˆè¶Šé«˜è¶Šåæ„Ÿï¼‰
   * 3. æ—¶é—´è¡°å‡ï¼ˆæ—§åé¦ˆæƒé‡é™ä½ï¼‰
   * 
   * è¯„åˆ†æ ‡å‡†ï¼ˆä¼˜åŒ–ç‰ˆï¼‰ï¼š
   * - applied: -1.0 (å¼ºæ­£å‘ï¼Œç”¨æˆ·é‡‡çº³å»ºè®®ï¼‰
   * - dismissed: 0.2 (è½»å¾®è´Ÿå‘ï¼Œç”¨æˆ·åªæ˜¯æš‚æ—¶ä¸æƒ³çœ‹ï¼‰
   * - ignored: 1.0 (å¼ºè´Ÿå‘ï¼Œç”¨æˆ·æ˜ç¡®æ‹’ç»æ­¤ç±»å»ºè®®ï¼‰
   */
  async calculateAnnoyanceScore(issueType: IssueType): Promise<number> {
    const records = this.cleanupRecords(this.getFeedbackRecords());
    const typeRecords = records.filter(r => r.issueType === issueType);
    
    if (typeRecords.length === 0) {
      return 0;
    }
    
    let weightedScore = 0;
    const now = Date.now();
    
    for (const record of typeRecords) {
      // è®¡ç®—æ—¶é—´è¡°å‡å› å­ï¼ˆ0-1ï¼‰
      const age = now - record.timestamp;
      const decay = Math.exp(-age / this.config.halfLife);
      
      // è®¡ç®—å•æ¬¡åé¦ˆçš„åˆ†æ•°ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
      let score: number;
      switch (record.action) {
        case 'applied':
          score = -1.0; // å¼ºæ­£å‘
          break;
        case 'dismissed':
          score = 0.2; // è½»å¾®è´Ÿå‘
          break;
        case 'ignored':
          score = 1.0; // å¼ºè´Ÿå‘
          break;
        default:
          score = 0.5; // é»˜è®¤å€¼
      }
      
      // åŠ æƒç´¯åŠ 
      weightedScore += score * decay;
    }
    
    return Math.max(0, weightedScore);
  }

  /**
   * è·å–é»‘åå•ï¼ˆç”¨æˆ·åæ„Ÿçš„ç±»å‹ï¼‰
   */
  async getBlacklist(): Promise<IssueType[]> {
    const stats = await this.getStats();
    const blacklist: IssueType[] = [];
    
    for (const type of Object.values(IssueType)) {
      const typeStats = stats.byType[type];
      
      // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°é˜ˆå€¼
      if (typeStats.totalCount >= this.config.ignoreThreshold) {
        if (typeStats.ignoreRate >= this.config.ignoreRateThreshold) {
          blacklist.push(type);
        }
      }
    }
    
    return blacklist;
  }

  /**
   * è·å–ç™½åå•ï¼ˆç”¨æˆ·å…³æ³¨çš„ç±»å‹ï¼‰
   * 
   * é€»è¾‘ï¼šç”¨æˆ·ç»å¸¸é‡‡çº³çš„ç±»å‹
   */
  async getWhitelist(): Promise<IssueType[]> {
    const stats = await this.getStats();
    const whitelist: IssueType[] = [];
    
    for (const type of Object.values(IssueType)) {
      const typeStats = stats.byType[type];
      
      // é‡‡çº³ç‡ > 60% ä¸” æ€»åé¦ˆæ¬¡æ•° >= 3
      if (typeStats.totalCount >= 3) {
        const applyRate = typeStats.applyCount / typeStats.totalCount;
        if (applyRate > 0.6) {
          whitelist.push(type);
        }
      }
    }
    
    return whitelist;
  }

  /**
   * ç”Ÿæˆä¸ªæ€§åŒ– Prompt çº¦æŸ
   */
  async getPromptConstraints(): Promise<UserPreferenceConstraints> {
    const [blacklist, whitelist] = await Promise.all([
      this.getBlacklist(),
      this.getWhitelist()
    ]);
    
    return {
      blacklist,
      whitelist,
      generatedAt: Date.now()
    };
  }

  /**
   * ç”Ÿæˆä¸ªæ€§åŒ– Prompt æ–‡æœ¬ï¼ˆç”¨äºæ³¨å…¥åˆ° LLMï¼‰
   */
  async getPromptText(): Promise<string> {
    const constraints = await this.getPromptConstraints();
    
    const parts: string[] = [];
    
    // é»‘åå•
    if (constraints.blacklist.length > 0) {
      const types = constraints.blacklist.map(t => t.replace(/_/g, ' ')).join(', ');
      parts.push(
        `[ç”¨æˆ·åå¥½çº¦æŸ]: è¯·é¿å…æˆ–å¤§å¹…å‡å°‘å…³äºä»¥ä¸‹ç±»å‹çš„å»ºè®®ï¼ˆç”¨æˆ·å·²å¤šæ¬¡æ˜ç¡®å¿½ç•¥ï¼‰ï¼š${types}ã€‚`
      );
    }
    
    // ç™½åå•
    if (constraints.whitelist.length > 0) {
      const types = constraints.whitelist.map(t => t.replace(/_/g, ' ')).join(', ');
      parts.push(
        `[ç”¨æˆ·å…³æ³¨ç‚¹]: è¯·ä¼˜å…ˆå…³æ³¨ä»¥ä¸‹ç±»å‹çš„é—®é¢˜ï¼ˆç”¨æˆ·ç»å¸¸é‡‡çº³å»ºè®®ï¼‰ï¼š${types}ã€‚`
      );
    }
    
    if (parts.length === 0) {
      return '';
    }
    
    return '\n\n' + parts.join('\n');
  }

  /**
   * æ¸…ç©ºæ‰€æœ‰è®°å½•
   */
  async clear(): Promise<void> {
    await this.context.globalState.update(this.storageKey, []);
    console.log('[PreferenceMemory] All records cleared');
  }

  /**
   * è·å–è®°å½•æ•°é‡
   */
  async getRecordCount(): Promise<number> {
    const records = this.cleanupRecords(this.getFeedbackRecords());
    return records.length;
  }

  /**
   * å¯¼å‡ºæ•°æ®ï¼ˆç”¨äºå¤‡ä»½æˆ–åˆ†æï¼‰
   */
  async exportData(): Promise<string> {
    const records = this.getFeedbackRecords();
    return JSON.stringify(records, null, 2);
  }

  /**
   * å¯¼å…¥æ•°æ®
   */
  async importData(jsonData: string): Promise<void> {
    try {
      const records = JSON.parse(jsonData) as IssueFeedback[];
      
      // éªŒè¯æ•°æ®æ ¼å¼
      if (!Array.isArray(records)) {
        throw new Error('Invalid data format: expected array');
      }
      
      // æ¸…ç†å¹¶ä¿å­˜
      const validRecords = this.cleanupRecords(records);
      const limitedRecords = validRecords.slice(-this.config.maxRecords);
      
      await this.context.globalState.update(this.storageKey, limitedRecords);
      
      console.log(`[PreferenceMemory] Imported ${limitedRecords.length} records`);
    } catch (error) {
      console.error('[PreferenceMemory] Failed to import data:', error);
      throw error;
    }
  }
}

/**
 * å•ä¾‹ç®¡ç†å™¨
 */
let memoryInstance: PreferenceMemory | null = null;

export function getPreferenceMemory(context: vscode.ExtensionContext): PreferenceMemory {
  if (!memoryInstance) {
    memoryInstance = new PreferenceMemory(context);
  }
  return memoryInstance;
}

export function resetPreferenceMemory(): void {
  memoryInstance = null;
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/quickSecurityScanner.ts

````typescript
/**
 * å¿«é€Ÿå®‰å…¨æ‰«æå¼•æ“
 * 
 * ç”¨äºåœ¨æ–‡ä»¶ä¿å­˜æ—¶è¿›è¡Œ <50ms çš„å¿«é€Ÿå®‰å…¨æ£€æŸ¥
 * ä»…åŒ…å«æœ¬åœ°è§„åˆ™ï¼Œä¸è°ƒç”¨ LLM
 */

import * as vscode from 'vscode';
import {
  SecurityIssue,
  SecuritySeverity,
  IssueType,
  QuickScanResult,
  ScanMetrics
} from './securityTypes';

/**
 * å®‰å…¨è§„åˆ™å®šä¹‰
 */
interface SecurityRule {
  id: string;
  type: IssueType;
  severity: SecuritySeverity;
  name: string;
  pattern: RegExp;
  description: string;
  suggestion?: string;
}

/**
 * å®‰å…¨è§„åˆ™åº“
 */
const SECURITY_RULES: SecurityRule[] = [
  // ========== CRITICAL: æ•æ„Ÿä¿¡æ¯æ³„éœ² ==========
  {
    id: 'AWS_ACCESS_KEY',
    type: IssueType.SECURITY_LEAK,
    severity: SecuritySeverity.CRITICAL,
    name: 'AWS Access Key',
    pattern: /AKIA[0-9A-Z]{16}/g,
    description: 'æ£€æµ‹åˆ°ç¡¬ç¼–ç çš„ AWS Access Key',
    suggestion: 'ä½¿ç”¨ç¯å¢ƒå˜é‡æˆ–å¯†é’¥ç®¡ç†æœåŠ¡å­˜å‚¨å‡­è¯'
  },
  {
    id: 'AWS_SECRET_KEY',
    type: IssueType.SECURITY_LEAK,
    severity: SecuritySeverity.CRITICAL,
    name: 'AWS Secret Key',
    pattern: /aws_secret_access_key\s*[:=]\s*["']?([A-Za-z0-9+/=]{40})["']?/gi,
    description: 'æ£€æµ‹åˆ°ç¡¬ç¼–ç çš„ AWS Secret Key',
    suggestion: 'ä½¿ç”¨ç¯å¢ƒå˜é‡æˆ–å¯†é’¥ç®¡ç†æœåŠ¡å­˜å‚¨å‡­è¯'
  },
  {
    id: 'GITHUB_TOKEN',
    type: IssueType.SECURITY_LEAK,
    severity: SecuritySeverity.CRITICAL,
    name: 'GitHub Token',
    pattern: /ghp_[a-zA-Z0-9]{36}/g,
    description: 'æ£€æµ‹åˆ°ç¡¬ç¼–ç çš„ GitHub Token',
    suggestion: 'ä½¿ç”¨ GitHub Secrets ç¯å¢ƒå˜é‡å­˜å‚¨å‡­è¯'
  },
  {
    id: 'PRIVATE_KEY',
    type: IssueType.SECURITY_LEAK,
    severity: SecuritySeverity.CRITICAL,
    name: 'Private Key',
    pattern: /-----BEGIN\s+(RSA\s+)?PRIVATE\s+KEY-----/g,
    description: 'æ£€æµ‹åˆ°ç§é’¥å†…å®¹',
    suggestion: 'æ°¸è¿œä¸è¦å°†ç§é’¥æäº¤åˆ°ä»£ç ä»“åº“'
  },
  {
    id: 'API_KEY',
    type: IssueType.SECURITY_LEAK,
    severity: SecuritySeverity.CRITICAL,
    name: 'API Key',
    pattern: /(api[_-]?key|apikey)\s*[:=]\s*["']?[a-zA-Z0-9_-]{20,}["']?/gi,
    description: 'æ£€æµ‹åˆ°å¯èƒ½çš„ API Key',
    suggestion: 'ä½¿ç”¨ç¯å¢ƒå˜é‡æˆ–å¯†é’¥ç®¡ç†æœåŠ¡å­˜å‚¨å‡­è¯'
  },

  // ========== CRITICAL: å±é™©å‡½æ•° ==========
  {
    id: 'EVAL_CALL',
    type: IssueType.DANGEROUS_FUNCTION,
    severity: SecuritySeverity.CRITICAL,
    name: 'eval() è°ƒç”¨',
    pattern: /\beval\s*\(/g,
    description: 'æ£€æµ‹åˆ° eval() å‡½æ•°è°ƒç”¨',
    suggestion: 'é¿å…ä½¿ç”¨ eval()ï¼Œæ”¹ç”¨æ›´å®‰å…¨çš„æ›¿ä»£æ–¹æ¡ˆ'
  },
  {
    id: 'DANGEROUS_SHELL_EXEC',
    type: IssueType.DANGEROUS_FUNCTION,
    severity: SecuritySeverity.CRITICAL,
    name: 'å±é™© Shell æ‰§è¡Œ',
    pattern: /(exec|spawn)\s*\(/g,
    description: 'æ£€æµ‹åˆ°å±é™©çš„ Shell æ‰§è¡Œå‡½æ•°',
    suggestion: 'ç¡®ä¿å¯¹è¾“å…¥è¿›è¡Œä¸¥æ ¼çš„éªŒè¯å’Œè½¬ä¹‰'
  },

  // ========== ERROR: æ³¨å…¥æ”»å‡»é£é™© ==========
  {
    id: 'SQL_INJECTION_RISK',
    type: IssueType.SECURITY_INJECTION,
    severity: SecuritySeverity.ERROR,
    name: 'SQL æ³¨å…¥é£é™©',
    pattern: /SELECT\s+.*\s+FROM\s+.*WHERE\s+.*[+].*/gi,
    description: 'æ£€æµ‹åˆ°å¯èƒ½çš„ SQL æ³¨å…¥é£é™©ï¼ˆå­—ç¬¦ä¸²æ‹¼æ¥ï¼‰',
    suggestion: 'ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢æˆ– ORM æ¡†æ¶'
  },
  {
    id: 'COMMAND_INJECTION_RISK',
    type: IssueType.SECURITY_INJECTION,
    severity: SecuritySeverity.ERROR,
    name: 'å‘½ä»¤æ³¨å…¥é£é™©',
    pattern: /(child_process|exec|spawn)\s*\(\s*`[^`]*\$\{[^}]+\}[^`]*`\)/g,
    description: 'æ£€æµ‹åˆ°å¯èƒ½çš„å‘½ä»¤æ³¨å…¥é£é™©ï¼ˆæ¨¡æ¿å­—ç¬¦ä¸²ï¼‰',
    suggestion: 'å¯¹ç”¨æˆ·è¾“å…¥è¿›è¡Œä¸¥æ ¼çš„éªŒè¯å’Œè½¬ä¹‰'
  },

  // ========== ERROR: è·¯å¾„å®‰å…¨é—®é¢˜ ==========
  {
    id: 'PATH_TRAVERSAL_RISK',
    type: IssueType.SECURITY_PATH,
    severity: SecuritySeverity.ERROR,
    name: 'è·¯å¾„ç©¿è¶Šé£é™©',
    pattern: /\.\.\/|\.\.\\/g,
    description: 'æ£€æµ‹åˆ°å¯èƒ½çš„è·¯å¾„ç©¿è¶Šæ”»å‡»',
    suggestion: 'ä½¿ç”¨ path.resolve() æˆ– path.join() å¹¶éªŒè¯è·¯å¾„'
  },
  {
    id: 'ABSOLUTE_PATH_USER_INPUT',
    type: IssueType.SECURITY_PATH,
    severity: SecuritySeverity.ERROR,
    name: 'ç»å¯¹è·¯å¾„ç”¨æˆ·è¾“å…¥',
    pattern: /(fs\.readFile|fs\.writeFile)\s*\(\s*["']\/[^"']*["']/g,
    description: 'æ£€æµ‹åˆ°ç¡¬ç¼–ç çš„ç»å¯¹è·¯å¾„',
    suggestion: 'ä½¿ç”¨ç›¸å¯¹è·¯å¾„æˆ–é…ç½®æ–‡ä»¶'
  },

  // ========== WARNING: æ€§èƒ½é—®é¢˜ ==========
  {
    id: 'SYNC_FS_OPERATION',
    type: IssueType.PERFORMANCE_IO,
    severity: SecuritySeverity.WARNING,
    name: 'åŒæ­¥æ–‡ä»¶æ“ä½œ',
    pattern: /fs\.(readFileSync|writeFileSync|existsSync)\s*\(/g,
    description: 'æ£€æµ‹åˆ°åŒæ­¥æ–‡ä»¶æ“ä½œ',
    suggestion: 'ä½¿ç”¨å¼‚æ­¥ç‰ˆæœ¬ (readFile, writeFile) é¿å…é˜»å¡äº‹ä»¶å¾ªç¯'
  },
  {
    id: 'HEAVY_SYNC_OPERATION',
    type: IssueType.PERFORMANCE_LOOP,
    severity: SecuritySeverity.WARNING,
    name: 'åŒæ­¥ JSON è§£æ',
    pattern: /JSON\.(parse|stringify)\s*\(\s*(?:fs\.readFileSync|require\()/g,
    description: 'æ£€æµ‹åˆ°åŒæ­¥è¯»å–å¹¶è§£æå¤§æ–‡ä»¶',
    suggestion: 'ä½¿ç”¨æµå¼è§£ææˆ–å¼‚æ­¥æ“ä½œ'
  },

  // ========== INFO: ä»£ç é£æ ¼ ==========
  {
    id: 'TODO_COMMENT',
    type: IssueType.STYLE_COMMENT,
    severity: SecuritySeverity.INFO,
    name: 'TODO æ³¨é‡Š',
    pattern: /TODO|FIXME|HACK|XXX/gi,
    description: 'æ£€æµ‹åˆ° TODO/FIXME æ³¨é‡Š',
    suggestion: 'è€ƒè™‘åˆ›å»º issue è·Ÿè¸ªè¿™äº›å¾…åŠäº‹é¡¹'
  },
  {
    id: 'CONSOLE_LOG',
    type: IssueType.STYLE_COMMENT,
    severity: SecuritySeverity.INFO,
    name: 'console.log',
    pattern: /console\.(log|debug|info|warn|error)\s*\(/g,
    description: 'æ£€æµ‹åˆ° console.log',
    suggestion: 'ç”Ÿäº§ç¯å¢ƒä¸­ç§»é™¤æˆ–ä½¿ç”¨ä¸“ä¸šçš„æ—¥å¿—åº“'
  }
];

/**
 * å¿«é€Ÿå®‰å…¨æ‰«æå™¨
 */
export class QuickSecurityScanner {
  private rules: SecurityRule[];
  private performanceHistory: ScanMetrics[] = [];

  constructor(customRules?: SecurityRule[]) {
    this.rules = customRules || SECURITY_RULES;
  }

  /**
   * å¿«é€Ÿæ‰«æä»£ç å†…å®¹
   * 
   * @param code ä»£ç å†…å®¹
   * @param filePath æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰
   * @param document VS Code æ–‡æ¡£å¯¹è±¡ï¼ˆå¯é€‰ï¼Œç”¨äºç²¾ç¡®è®¡ç®—è¡Œåˆ—å·ï¼‰
   * @returns æ‰«æç»“æœ
   * 
   * æ³¨æ„ï¼šè¡Œåˆ—å·è®¡ç®—å…¼å®¹ CRLF å’Œ LF æ¢è¡Œç¬¦
   * å¦‚æœæä¾›äº† document å‚æ•°ï¼Œä½¿ç”¨ VS Code API ç²¾ç¡®è®¡ç®—
   * å¦åˆ™ä½¿ç”¨æ‰‹åŠ¨è®¡ç®—ï¼ˆå¯èƒ½å¯¹ CRLF æœ‰è½»å¾®åå·®ï¼‰
   */
  async quickScan(code: string, filePath?: string, document?: vscode.TextDocument): Promise<QuickScanResult> {
    const startTime = Date.now();
    const issues: SecurityIssue[] = [];

    // éå†æ‰€æœ‰è§„åˆ™
    for (const rule of this.rules) {
      const matches = code.matchAll(rule.pattern);
      const matchArray = Array.from(matches);

      for (const match of matchArray) {
        const matchIndex = match.index || 0;
        let lineIndex = 0;
        let column = 0;

        // å¦‚æœæä¾›äº†æ–‡æ¡£å¯¹è±¡ï¼Œä½¿ç”¨ VS Code API ç²¾ç¡®è®¡ç®—ï¼ˆæ¨èï¼‰
        if (document) {
          const position = document.positionAt(matchIndex);
          lineIndex = position.line;
          column = position.character;
        } else {
          // æ‰‹åŠ¨è®¡ç®—è¡Œåˆ—å·ï¼ˆå…¼å®¹ CRLF å’Œ LFï¼‰
          const lines = code.split('\n');
          let charCount = 0;
          
          for (let i = 0; i < lines.length; i++) {
            // æ£€æµ‹å½“å‰è¡Œçš„æ¢è¡Œç¬¦ç±»å‹
            const lineWithBreak = lines[i];
            const hasCRLF = i < lines.length - 1 && code[charCount + lineWithBreak.length] === '\r';
            const breakLength = hasCRLF ? 2 : 1;
            
            if (charCount + lineWithBreak.length >= matchIndex) {
              lineIndex = i;
              column = matchIndex - charCount;
              break;
            }
            charCount += lineWithBreak.length + breakLength;
          }
        }

        issues.push({
          type: rule.type,
          severity: rule.severity,
          message: rule.description,
          filePath,
          line: lineIndex,
          column,
          suggestion: rule.suggestion,
          ruleId: rule.id
        });
      }
    }

    const duration = Date.now() - startTime;

    // è®°å½•æ€§èƒ½æŒ‡æ ‡
    this.recordMetrics({
      fileSize: code.length,
      duration,
      rulesExecuted: this.rules.length,
      issuesFound: issues.length,
      timestamp: Date.now(),
      strategy: 'full'
    });

    // æ€§èƒ½è­¦å‘Š
    if (duration > 50) {
      console.warn(`[QuickSecurityScanner] Scan took ${duration}ms (should be < 50ms)`);
    }

    return {
      valid: issues.filter(i => i.severity === SecuritySeverity.CRITICAL).length === 0,
      issues,
      hasCriticalError: issues.some(i => i.severity === SecuritySeverity.CRITICAL),
      duration
    };
  }

  /**
   * è®°å½•æ€§èƒ½æŒ‡æ ‡
   */
  private recordMetrics(metrics: ScanMetrics): void {
    this.performanceHistory.push(metrics);

    // åªä¿ç•™æœ€è¿‘ 100 æ¡è®°å½•
    if (this.performanceHistory.length > 100) {
      this.performanceHistory.shift();
    }
  }

  /**
   * è·å–å¹³å‡æ‰«æè€—æ—¶
   */
  getAverageDuration(): number {
    if (this.performanceHistory.length === 0) return 0;

    const total = this.performanceHistory.reduce((sum, m) => sum + m.duration, 0);
    return total / this.performanceHistory.length;
  }

  /**
   * è·å–æ€§èƒ½ç»Ÿè®¡
   */
  getPerformanceStats(): {
    averageDuration: number;
    maxDuration: number;
    totalScans: number;
    averageIssuesFound: number;
  } {
    if (this.performanceHistory.length === 0) {
      return {
        averageDuration: 0,
        maxDuration: 0,
        totalScans: 0,
        averageIssuesFound: 0
      };
    }

    const durations = this.performanceHistory.map(m => m.duration);
    const totalIssues = this.performanceHistory.reduce((sum, m) => sum + m.issuesFound, 0);

    return {
      averageDuration: durations.reduce((a, b) => a + b, 0) / durations.length,
      maxDuration: Math.max(...durations),
      totalScans: this.performanceHistory.length,
      averageIssuesFound: totalIssues / this.performanceHistory.length
    };
  }

  /**
   * æ·»åŠ è‡ªå®šä¹‰è§„åˆ™
   */
  addRule(rule: SecurityRule): void {
    this.rules.push(rule);
  }

  /**
   * ç§»é™¤è§„åˆ™
   */
  removeRule(ruleId: string): void {
    this.rules = this.rules.filter(r => r.id !== ruleId);
  }

  /**
   * è·å–æ‰€æœ‰è§„åˆ™
   */
  getRules(): SecurityRule[] {
    return [...this.rules];
  }

  /**
   * æ¸…ç©ºæ€§èƒ½å†å²
   */
  clearPerformanceHistory(): void {
    this.performanceHistory = [];
  }
}

/**
 * å•ä¾‹å®ä¾‹
 */
let scannerInstance: QuickSecurityScanner | null = null;

export function getQuickSecurityScanner(): QuickSecurityScanner {
  if (!scannerInstance) {
    scannerInstance = new QuickSecurityScanner();
  }
  return scannerInstance;
}

export function resetQuickSecurityScanner(): void {
  scannerInstance = null;
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/reviewSchema.ts

````typescript
/**
 * Review JSON Schema v1
 * 
 * è®¾è®¡ç›®æ ‡ï¼š
 * - äººç±»å¯è¯»ï¼ˆè°ƒè¯•ã€æ—¥å¿—ï¼‰
 * - æœºå™¨å¯æ‰§è¡Œï¼ˆDiagnostics / CodeActionï¼‰
 * - å®‰å…¨å¯å®¡è®¡ï¼ˆMalicious Diff Defenseï¼‰
 * - å‘å‰å…¼å®¹ v2 / v3
 */

/**
 * Review ç»“æœ v1
 */
export interface ReviewResultV1 {
  /** Schema ç‰ˆæœ¬ */
  schemaVersion: "1.0";

  /** å…ƒæ•°æ® */
  meta: {
    /** æ¨¡å‹åç§° */
    model: string;
    /** ç”Ÿæˆæ—¶é—´ï¼ˆISO Dateï¼‰ */
    generatedAt: string;
    /** å®¡æŸ¥ç±»å‹ */
    reviewType: "commit" | "diff" | "file";
  };

  /** æ‘˜è¦ */
  summary: {
    /** é£é™©çº§åˆ« */
    riskLevel: "low" | "medium" | "high";
    /** é—®é¢˜æ•°é‡ */
    issueCount: number;
    /** å»ºè®®æ•°é‡ */
    suggestionCount: number;
  };

  /** é—®é¢˜åˆ—è¡¨ */
  issues: ReviewIssue[];

  /** å»ºè®®åˆ—è¡¨ï¼ˆå¯é€‰ï¼‰ */
  suggestions?: ReviewSuggestion[];
}

/**
 * Review Issueï¼ˆDiagnostics çš„æ ¸å¿ƒï¼‰
 */
export interface ReviewIssue {
  /** å”¯ä¸€æ ‡è¯†ç¬¦ï¼ˆUUIDï¼‰ */
  id: string;

  /** é—®é¢˜ç±»å‹ */
  type: "bug" | "security" | "performance" | "style" | "logic" | "best_practice";

  /** ä¸¥é‡ç¨‹åº¦ */
  severity: "info" | "warning" | "error";

  /** é—®é¢˜æ¶ˆæ¯ */
  message: string;

  /** ä½ç½®ä¿¡æ¯ï¼ˆå¯é€‰ï¼Œå…è®¸è·¨æ–‡ä»¶/è¯­ä¹‰çº§é—®é¢˜ï¼‰ */
  location?: {
    /** æ–‡ä»¶è·¯å¾„ */
    filePath: string;
    /** ä»£ç èŒƒå›´ */
    range?: {
      /** èµ·å§‹è¡Œå·ï¼ˆ0-basedï¼‰ */
      startLine: number;
      /** èµ·å§‹å­—ç¬¦ä½ç½®ï¼ˆå¯é€‰ï¼‰ */
      startChar?: number;
      /** ç»“æŸè¡Œå·ï¼ˆ0-basedï¼‰ */
      endLine: number;
      /** ç»“æŸå­—ç¬¦ä½ç½®ï¼ˆå¯é€‰ï¼‰ */
      endChar?: number;
    };
  };

  /** è¯¦ç»†è§£é‡Šï¼ˆå¯é€‰ï¼‰ */
  explanation?: string;

  /** ç½®ä¿¡åº¦ï¼ˆ0~1ï¼Œç”¨äº UI é€æ˜åº¦æˆ–è¿‡æ»¤ï¼‰ */
  confidence?: number;

  /** ç›¸å…³ä»£ç ç‰‡æ®µï¼ˆå¯é€‰ï¼‰ */
  codeSnippet?: string;
}

/**
 * Review Suggestionï¼ˆCodeAction çš„æ¡¥æ¢ï¼‰
 */
export interface ReviewSuggestion {
  /** å”¯ä¸€æ ‡è¯†ç¬¦ï¼ˆUUIDï¼‰ */
  id: string;

  /** å»ºè®®æ ‡é¢˜ï¼ˆCodeAction æ ‡é¢˜ï¼‰ */
  title: string;

  /** å»ºè®®æè¿°ï¼ˆå¯é€‰ï¼‰ */
  description?: string;

  /** åº”ç”¨èŒƒå›´ï¼ˆå¯é€‰ï¼‰ */
  appliesTo?: {
    /** æ–‡ä»¶è·¯å¾„ */
    filePath: string;
    /** ä»£ç èŒƒå›´ */
    range?: {
      /** èµ·å§‹è¡Œå·ï¼ˆ0-basedï¼‰ */
      startLine: number;
      /** ç»“æŸè¡Œå·ï¼ˆ0-basedï¼‰ */
      endLine: number;
    };
  };

  /** Diff å†…å®¹ï¼ˆå¯é€‰ï¼‰ */
  diff?: {
    /** Diff ç±»å‹ */
    type: "unified";
    /** Diff å†…å®¹ */
    content: string;
  };

  /** å®‰å…¨ä¿¡æ¯ */
  safety: {
    /** é£é™©çº§åˆ« */
    risk: "low" | "medium" | "high";
    /** æ˜¯å¦éœ€è¦ç”¨æˆ·ç¡®è®¤ */
    requiresConfirmation?: boolean;
  };
}

/**
 * Commit Suggestionï¼ˆæ™ºèƒ½ Stage å»ºè®®ï¼‰
 */
export interface CommitSuggestion {
  /** å”¯ä¸€æ ‡è¯†ç¬¦ */
  id: string;

  /** Commit æ¶ˆæ¯å»ºè®® */
  commitMessage: {
    /** æ ‡é¢˜ */
    title: string;
    /** è¯¦ç»†æè¿°ï¼ˆå¯é€‰ï¼‰ */
    body?: string;
    /** ç±»å‹ï¼ˆå¯é€‰ï¼‰ */
    type?: "feat" | "fix" | "docs" | "style" | "refactor" | "test" | "chore";
  };

  /** æ–‡ä»¶åˆ†ç»„ */
  fileGroups: FileGroup[];

  /** åˆ†ç»„ç†ç”± */
  rationale: string;
}

/**
 * æ–‡ä»¶åˆ†ç»„ï¼ˆç”¨äºæ™ºèƒ½ Stage å»ºè®®ï¼‰
 */
export interface FileGroup {
  /** åˆ†ç»„ ID */
  id: string;

  /** åˆ†ç»„åç§°ï¼ˆå¦‚ "UI Changes", "Logic Updates"ï¼‰ */
  name: string;

  /** åˆ†ç»„ç±»å‹ */
  type: "ui" | "logic" | "docs" | "test" | "config" | "other";

  /** æ–‡ä»¶åˆ—è¡¨ */
  files: string[];

  /** å˜æ›´ç»Ÿè®¡ */
  stats: {
    /** æ·»åŠ è¡Œæ•° */
    added: number;
    /** åˆ é™¤è¡Œæ•° */
    removed: number;
    /** ä¸Šä¸‹æ–‡è¡Œæ•° */
    context: number;
  };

  /** åˆ†ç±»è§£é‡Šï¼ˆå¯é€‰ï¼Œç”¨äºæ™ºèƒ½åˆ†ç±»ï¼‰ */
  explanation?: {
    category: "ui" | "logic" | "docs" | "test" | "chore" | "other";
    confidence: number;
    reasons: string[];
    votes: Array<{
      category: "ui" | "logic" | "docs" | "test" | "chore" | "other";
      weight: number;
      reason: string;
      source: 'path' | 'diff' | 'keyword' | 'ast' | 'history';
    }>;
  };
}

/**
 * Review Schema éªŒè¯å™¨
 */
export class ReviewSchemaValidator {
  /**
   * éªŒè¯ ReviewResultV1 å¯¹è±¡
   */
  static validate(result: any): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!result) {
      return { valid: false, errors: ['Review result is null or undefined'] };
    }

    // éªŒè¯ schemaVersion
    if (result.schemaVersion !== "1.0") {
      errors.push(`Invalid schemaVersion: ${result.schemaVersion}, expected "1.0"`);
    }

    // éªŒè¯ meta
    if (!result.meta) {
      errors.push('Missing meta field');
    } else {
      if (!result.meta.model) {
        errors.push('Missing meta.model field');
      }
      if (!result.meta.generatedAt) {
        errors.push('Missing meta.generatedAt field');
      }
    }

    // éªŒè¯ summary
    if (!result.summary) {
      errors.push('Missing summary field');
    } else {
      const validRiskLevels = ['low', 'medium', 'high'];
      if (!validRiskLevels.includes(result.summary.riskLevel)) {
        errors.push(`Invalid summary.riskLevel: ${result.summary.riskLevel}`);
      }
      if (typeof result.summary.issueCount !== 'number') {
        errors.push('summary.issueCount must be a number');
      }
      if (typeof result.summary.suggestionCount !== 'number') {
        errors.push('summary.suggestionCount must be a number');
      }
    }

    // éªŒè¯ issues
    if (!Array.isArray(result.issues)) {
      errors.push('issues must be an array');
    } else {
      for (let i = 0; i < result.issues.length; i++) {
        const issueErrors = this.validateIssue(result.issues[i]);
        errors.push(...issueErrors.map(e => `issues[${i}]: ${e}`));
      }
    }

    // éªŒè¯ suggestionsï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    if (result.suggestions && !Array.isArray(result.suggestions)) {
      errors.push('suggestions must be an array');
    } else if (result.suggestions) {
      for (let i = 0; i < result.suggestions.length; i++) {
        const suggestionErrors = this.validateSuggestion(result.suggestions[i]);
        errors.push(...suggestionErrors.map(e => `suggestions[${i}]: ${e}`));
      }
    }

    return { valid: errors.length === 0, errors };
  }

  /**
   * éªŒè¯å•ä¸ª Issue
   */
  private static validateIssue(issue: any): string[] {
    const errors: string[] = [];

    if (!issue.id) {
      errors.push('Missing id field');
    }

    const validTypes = ['bug', 'security', 'performance', 'style', 'logic', 'best_practice'];
    if (!validTypes.includes(issue.type)) {
      errors.push(`Invalid type: ${issue.type}`);
    }

    const validSeverities = ['info', 'warning', 'error'];
    if (!validSeverities.includes(issue.severity)) {
      errors.push(`Invalid severity: ${issue.severity}`);
    }

    if (!issue.message) {
      errors.push('Missing message field');
    }

    if (issue.confidence !== undefined && (issue.confidence < 0 || issue.confidence > 1)) {
      errors.push('Confidence must be between 0 and 1');
    }

    return errors;
  }

  /**
   * éªŒè¯å•ä¸ª Suggestion
   */
  private static validateSuggestion(suggestion: any): string[] {
    const errors: string[] = [];

    if (!suggestion.id) {
      errors.push('Missing id field');
    }

    if (!suggestion.title) {
      errors.push('Missing title field');
    }

    if (!suggestion.safety) {
      errors.push('Missing safety field');
    } else {
      const validRisks = ['low', 'medium', 'high'];
      if (!validRisks.includes(suggestion.safety.risk)) {
        errors.push(`Invalid safety.risk: ${suggestion.safety.risk}`);
      }
    }

    return errors;
  }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/semanticReviewContext.ts

````typescript
/**
 * Semantic Review Context - Phase 3 å®Œæ•´ä¸Šä¸‹æ–‡æ„å»ºå™¨
 * 
 * ç›®æ ‡ï¼š
 * - æ„å»ºåŸºäºçœŸå®å¯ç¼–è¯‘ä¸Šä¸‹æ–‡çš„è¯­ä¹‰å®¡æŸ¥
 * - æ”¯æŒ TypeScript Program çš„å†…å­˜æ„å»º
 * - å®ç°é¡¹ç›®æ ¹æŸ¥æ‰¾ï¼ˆtsconfig.json å‘ä¸Šæœç´¢ï¼‰
 * - è¾“å‡ºåˆ†çº§è¯­ä¹‰é£é™©ï¼ˆé pass/failï¼‰
 * 
 * åŸåˆ™ï¼š
 * - åœ¨ diff åº”ç”¨åè¿›è¡Œè¯­ä¹‰å®¡æŸ¥
 * - åŸºäºçœŸå® AST å’Œç±»å‹ç³»ç»Ÿ
 * - åŒºåˆ† criticalã€errorã€warningã€info
 */

import * as vscode from 'vscode';
import * as ts from 'typescript';
import * as path from 'path';

/**
 * è¯­ä¹‰é£é™©çº§åˆ«
 */
export enum SemanticRiskLevel {
  /** å…³é”®ï¼šå¿…é¡»é˜»å¡ */
  CRITICAL = 'critical',
  /** é”™è¯¯ï¼šéœ€è¦ä¿®å¤ */
  ERROR = 'error',
  /** è­¦å‘Šï¼šéœ€è¦æ³¨æ„ */
  WARNING = 'warning',
  /** ä¿¡æ¯ï¼šå¯é€‰æ”¹è¿› */
  INFO = 'info'
}

/**
 * è¯­ä¹‰é£é™©ç±»åˆ«
 */
export enum SemanticRiskCategory {
  /** ç±»å‹å®‰å…¨ */
  TYPE_SAFETY = 'type_safety',
  /** é€»è¾‘é”™è¯¯ */
  LOGIC = 'logic',
  /** å®‰å…¨é—®é¢˜ */
  SECURITY = 'security',
  /** æ€§èƒ½é—®é¢˜ */
  PERFORMANCE = 'performance',
  /** API è¯¯ç”¨ */
  API_MISUSE = 'api_misuse',
  /** ä»£ç è´¨é‡ */
  CODE_QUALITY = 'code_quality'
}

/**
 * è¯­ä¹‰é£é™©
 */
export interface SemanticRisk {
  /** é£é™© ID */
  id: string;
  
  /** é£é™©çº§åˆ« */
  level: SemanticRiskLevel;
  
  /** é£é™©ç±»åˆ« */
  category: SemanticRiskCategory;
  
  /** é£é™©æ¶ˆæ¯ */
  message: string;
  
  /** æ–‡ä»¶è·¯å¾„ */
  filePath: string;
  
  /** ä»£ç ä½ç½® */
  range?: {
    startLine: number;
    startChar: number;
    endLine: number;
    endChar: number;
  };
  
  /** ç›¸å…³ä»£ç ç‰‡æ®µ */
  snippet?: string;
  
  /** ä¿®å¤å»ºè®® */
  suggestion?: string;
  
  /** ç½®ä¿¡åº¦ [0, 1] */
  confidence: number;
}

/**
 * Phase 3 è¯­ä¹‰å®¡æŸ¥ç»“æœ
 */
export interface Phase3ReviewResult {
  /** æ˜¯å¦é€šè¿‡å®¡æŸ¥ */
  passed: boolean;
  
  /** é˜»å¡åŸå› ï¼ˆå¦‚æœæœªé€šè¿‡ï¼‰ */
  blockReason?: string;
  
  /** è¯­ä¹‰é£é™©åˆ—è¡¨ */
  risks: SemanticRisk[];
  
  /** é£é™©ç»Ÿè®¡ */
  stats: {
    critical: number;
    error: number;
    warning: number;
    info: number;
  };
  
  /** å®¡æŸ¥è€—æ—¶ï¼ˆæ¯«ç§’ï¼‰ */
  duration: number;
}

/**
 * è¯­ä¹‰å®¡æŸ¥ä¸Šä¸‹æ–‡
 */
export interface SemanticReviewContext {
  /** TypeScript Program */
  program: ts.Program;
  
  /** TypeScript Compiler API */
  compiler: typeof ts;
  
  /** é¡¹ç›®æ ¹ç›®å½• */
  projectRoot: string;
  
  /** tsconfig.json è·¯å¾„ */
  tsconfigPath: string;
}

/**
 * Phase 3 è¯­ä¹‰å®¡æŸ¥å™¨
 */
export class Phase3SemanticReviewer {
  /**
   * æ„å»ºè¯­ä¹‰å®¡æŸ¥ä¸Šä¸‹æ–‡
   */
  static async buildContext(): Promise<SemanticReviewContext | null> {
    const startTime = Date.now();

    try {
      // 1. æŸ¥æ‰¾é¡¹ç›®æ ¹ç›®å½•ï¼ˆtsconfig.json å‘ä¸Šæœç´¢ï¼‰
      const projectRoot = await this.findProjectRoot();
      if (!projectRoot) {
        console.warn('[Phase3SemanticReviewer] No tsconfig.json found');
        return null;
      }

      const tsconfigPath = path.resolve(projectRoot, 'tsconfig.json');

      if (!ts.sys.fileExists(tsconfigPath)) {
        console.warn('[Phase3SemanticReviewer] Cannot resolve tsconfig.json');
        return null;
      }

      console.log(`[Phase3SemanticReviewer] Found tsconfig.json: ${tsconfigPath}`);

      // 2. è¯»å– tsconfig.json
      const configResult = ts.readConfigFile(tsconfigPath, ts.sys.readFile);
      if (configResult.error) {
        console.error('[Phase3SemanticReviewer] Failed to read tsconfig.json:', configResult.error);
        return null;
      }

      // 3. åˆ›å»º TypeScript Program
      const configParseResult = ts.parseJsonConfigFileContent(
        configResult.config,
        ts.sys,
        projectRoot,
        undefined,
        tsconfigPath
      );

      const program = ts.createProgram({
        rootNames: configParseResult.fileNames,
        options: {
          ...configParseResult.options,
          // ç¡®ä¿ type checking æ˜¯ä¸¥æ ¼çš„
          strict: true,
          noImplicitAny: true,
          strictNullChecks: true,
          noUnusedLocals: true,
          noUnusedParameters: true,
          noImplicitReturns: true,
          noFallthroughCasesInSwitch: true
        }
      });

      const duration = Date.now() - startTime;
      console.log(`[Phase3SemanticReviewer] Context built in ${duration}ms`);

      return {
        program,
        compiler: ts,
        projectRoot,
        tsconfigPath
      };
    } catch (error) {
      console.error('[Phase3SemanticReviewer] Failed to build context:', error);
      return null;
    }
  }

  /**
   * æŸ¥æ‰¾é¡¹ç›®æ ¹ç›®å½•ï¼ˆtsconfig.json å‘ä¸Šæœç´¢ï¼‰
   */
  private static async findProjectRoot(): Promise<string | null> {
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) {
      return null;
    }

    const workspacePath = workspaceFolder.uri.fsPath;

    // ä»å½“å‰ç›®å½•å‘ä¸Šæœç´¢ tsconfig.json
    let currentPath = workspacePath;
    const maxDepth = 10;

    for (let i = 0; i < maxDepth; i++) {
      const tsconfigPath = path.join(currentPath, 'tsconfig.json');
      if (ts.sys.fileExists(tsconfigPath)) {
        return currentPath;
      }

      const parentPath = path.dirname(currentPath);
      if (parentPath === currentPath) {
        // å·²åˆ°è¾¾æ ¹ç›®å½•
        break;
      }

      currentPath = parentPath;
    }

    return null;
  }

  /**
   * æ‰§è¡Œ Phase 3 è¯­ä¹‰å®¡æŸ¥
   */
  static async review(
    filePaths: string[],
    context?: SemanticReviewContext
  ): Promise<Phase3ReviewResult> {
    const startTime = Date.now();
    const risks: SemanticRisk[] = [];

    try {
      // å¦‚æœæ²¡æœ‰æä¾›ä¸Šä¸‹æ–‡ï¼Œå°è¯•æ„å»º
      const reviewContext = context || (await this.buildContext());
      if (!reviewContext) {
        // æ— æ³•æ„å»ºä¸Šä¸‹æ–‡ï¼Œè¿”å›ç©ºç»“æœ
        console.warn('[Phase3SemanticReviewer] No context available, skipping semantic review');
        return {
          passed: true,
          risks: [],
          stats: { critical: 0, error: 0, warning: 0, info: 0 },
          duration: Date.now() - startTime
        };
      }

      // å¯¹æ¯ä¸ªæ–‡ä»¶è¿›è¡Œå®¡æŸ¥
      for (const filePath of filePaths) {
        const fileRisks = await this.reviewFile(filePath, reviewContext);
        risks.push(...fileRisks);
      }

      // ç»Ÿè®¡é£é™©
      const stats = this.calculateRiskStats(risks);

      // åˆ¤æ–­æ˜¯å¦é€šè¿‡å®¡æŸ¥
      const passed = stats.critical === 0 && stats.error === 0;
      const blockReason = !passed
        ? `${stats.critical} critical risks and ${stats.error} errors detected`
        : undefined;

      const duration = Date.now() - startTime;
      console.log(`[Phase3SemanticReviewer] Review completed in ${duration}ms: ${risks.length} risks`);

      return {
        passed,
        blockReason,
        risks,
        stats,
        duration
      };
    } catch (error) {
      console.error('[Phase3SemanticReviewer] Review failed:', error);
      return {
        passed: false,
        blockReason: error instanceof Error ? error.message : String(error),
        risks,
        stats: this.calculateRiskStats(risks),
        duration: Date.now() - startTime
      };
    }
  }

  /**
   * å®¡æŸ¥å•ä¸ªæ–‡ä»¶
   */
  private static async reviewFile(
    filePath: string,
    context: SemanticReviewContext
  ): Promise<SemanticRisk[]> {
    let risks: SemanticRisk[] = [];

    try {
      // è·å– SourceFile
      const sourceFile = context.program.getSourceFile(filePath);
      if (!sourceFile) {
        console.warn(`[Phase3SemanticReviewer] SourceFile not found: ${filePath}`);
        return [];
      }

      // 1. TypeScript è¯Šæ–­ä¿¡æ¯
      const diagnostics = context.program.getSemanticDiagnostics(sourceFile);
      const diagnosticRisks = this.convertDiagnosticsToRisks(diagnostics, filePath);
      
      // 2. è‡ªå®šä¹‰è§„åˆ™æ£€æŸ¥
      const sourceFilePath = sourceFile.fileName;
      const customRisks = this.runCustomRules(sourceFile, sourceFilePath);

      risks = [...diagnosticRisks, ...customRisks];

      return risks;
    } catch (error) {
      console.error(`[Phase3SemanticReviewer] Failed to review file ${filePath}:`, error);
      return [];
    }
  }

  /**
   * å°† TypeScript è¯Šæ–­ä¿¡æ¯è½¬æ¢ä¸ºè¯­ä¹‰é£é™©
   */
  private static convertDiagnosticsToRisks(
    diagnostics: readonly ts.Diagnostic[],
    filePath: string
  ): SemanticRisk[] {
    return diagnostics.map(diagnostic => {
      const level = this.diagnosticCategoryToRiskLevel(diagnostic.category);
      const category = this.diagnosticMessageToCategory(diagnostic.messageText);

      let range;
      if (diagnostic.start !== undefined && diagnostic.length !== undefined) {
        const startLine = diagnostic.start;
        const startChar = 0; // ç®€åŒ–å¤„ç†
        const endLine = diagnostic.start + diagnostic.length;
        const endChar = 0;

        range = { startLine, startChar, endLine, endChar };
      }

      return {
        id: `ts-${diagnostic.code}`,
        level,
        category,
        message: ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n'),
        filePath,
        range,
        confidence: 1.0
      };
    });
  }

  /**
   * è¿è¡Œè‡ªå®šä¹‰è§„åˆ™
   */
  private static runCustomRules(
    sourceFile: ts.SourceFile,
    filePath: string
  ): SemanticRisk[] {
    const risks: SemanticRisk[] = [];

    // 1. ç¦æ­¢ä½¿ç”¨ any ç±»å‹
    this.checkNoAny(sourceFile, filePath, risks);

    // 2. ç¦æ­¢ç©º catch å—
    this.checkNoEmptyCatch(sourceFile, filePath, risks);

    // 3. ç¦æ­¢ console.logï¼ˆåœ¨ç”Ÿäº§ä»£ç ä¸­ï¼‰
    this.checkNoConsoleLog(sourceFile, filePath, risks);

    // 4. ç¦æ­¢ eval
    this.checkNoEval(sourceFile, filePath, risks);

    return risks;
  }

  /**
   * æ£€æŸ¥ç¦æ­¢ä½¿ç”¨ any ç±»å‹
   */
  private static checkNoAny(
    node: ts.Node,
    filePath: string,
    risks: SemanticRisk[]
  ): void {
    if (node.kind === ts.SyntaxKind.AnyKeyword) {
      risks.push({
        id: 'no-any',
        level: SemanticRiskLevel.WARNING,
        category: SemanticRiskCategory.TYPE_SAFETY,
        message: 'Avoid using `any` type, use `unknown` or specific types instead',
        filePath,
        range: this.nodeToRange(node),
        confidence: 0.9,
        suggestion: 'Replace `any` with a specific type or `unknown`'
      });
    }

    ts.forEachChild(node, child => this.checkNoAny(child, filePath, risks));
  }

  /**
   * æ£€æŸ¥ç¦æ­¢ç©º catch å—
   */
  private static checkNoEmptyCatch(
    node: ts.Node,
    filePath: string,
    risks: SemanticRisk[]
  ): void {
    if (ts.isTryStatement(node) && node.catchClause) {
      const catchClause = node.catchClause;
      const hasStatements = catchClause.block.statements.length > 0;

      if (!hasStatements) {
        risks.push({
          id: 'no-empty-catch',
          level: SemanticRiskLevel.ERROR,
          category: SemanticRiskCategory.LOGIC,
          message: 'Empty catch block detected. Either handle the error or rethrow it.',
          filePath,
          range: this.nodeToRange(catchClause),
          confidence: 1.0,
          suggestion: 'Add error handling or rethrow the error'
        });
      }
    }

    ts.forEachChild(node, child => this.checkNoEmptyCatch(child, filePath, risks));
  }

  /**
   * æ£€æŸ¥ç¦æ­¢ console.log
   */
  private static checkNoConsoleLog(
    node: ts.Node,
    filePath: string,
    risks: SemanticRisk[]
  ): void {
    if (ts.isCallExpression(node)) {
      const expression = node.expression;

      // æ£€æŸ¥æ˜¯å¦æ˜¯ console.log
      if (ts.isPropertyAccessExpression(expression)) {
        const objectName = expression.expression.getText();
        const propertyName = expression.name.getText();

        if (objectName === 'console' && propertyName === 'log') {
          // æ’é™¤æµ‹è¯•æ–‡ä»¶
          if (!filePath.includes('.test.') && !filePath.includes('.spec.')) {
            risks.push({
              id: 'no-console-log',
              level: SemanticRiskLevel.WARNING,
              category: SemanticRiskCategory.CODE_QUALITY,
              message: 'Avoid using console.log in production code',
              filePath,
              range: this.nodeToRange(node),
              confidence: 0.8,
              suggestion: 'Use a proper logging library instead'
            });
          }
        }
      }
    }

    ts.forEachChild(node, child => this.checkNoConsoleLog(child, filePath, risks));
  }

  /**
   * æ£€æŸ¥ç¦æ­¢ eval
   */
  private static checkNoEval(
    node: ts.Node,
    filePath: string,
    risks: SemanticRisk[]
  ): void {
    if (ts.isCallExpression(node)) {
      const expression = node.expression;

      // æ£€æŸ¥æ˜¯å¦æ˜¯ eval
      if (ts.isIdentifier(expression) && expression.text === 'eval') {
        risks.push({
          id: 'no-eval',
          level: SemanticRiskLevel.CRITICAL,
          category: SemanticRiskCategory.SECURITY,
          message: 'The use of eval is dangerous and can lead to security vulnerabilities',
          filePath,
          range: this.nodeToRange(node),
          confidence: 1.0,
          suggestion: 'Avoid using eval. Use alternative approaches instead'
        });
      }
    }

    ts.forEachChild(node, child => this.checkNoEval(child, filePath, risks));
  }

  /**
   * å°†è¯Šæ–­ç±»åˆ«è½¬æ¢ä¸ºé£é™©çº§åˆ«
   */
  private static diagnosticCategoryToRiskLevel(
    category: ts.DiagnosticCategory
  ): SemanticRiskLevel {
    switch (category) {
      case ts.DiagnosticCategory.Error:
        return SemanticRiskLevel.ERROR;
      case ts.DiagnosticCategory.Warning:
        return SemanticRiskLevel.WARNING;
      case ts.DiagnosticCategory.Suggestion:
        return SemanticRiskLevel.INFO;
      case ts.DiagnosticCategory.Message:
        return SemanticRiskLevel.INFO;
      default:
        return SemanticRiskLevel.INFO;
    }
  }

  /**
   * æ ¹æ®è¯Šæ–­æ¶ˆæ¯æ¨æ–­é£é™©ç±»åˆ«
   */
  private static diagnosticMessageToCategory(
    messageText: string | ts.DiagnosticMessageChain
  ): SemanticRiskCategory {
    const message = typeof messageText === 'string'
      ? messageText
      : ts.flattenDiagnosticMessageText(messageText, '\n').toLowerCase();

    if (message.includes('security') || message.includes('xss') || message.includes('injection')) {
      return SemanticRiskCategory.SECURITY;
    }

    if (message.includes('performance') || message.includes('loop') || message.includes('o(n)')) {
      return SemanticRiskCategory.PERFORMANCE;
    }

    if (message.includes('type') || message.includes('any') || message.includes('undefined')) {
      return SemanticRiskCategory.TYPE_SAFETY;
    }

    if (message.includes('unused') || message.includes('dead code')) {
      return SemanticRiskCategory.CODE_QUALITY;
    }

    return SemanticRiskCategory.LOGIC;
  }

  /**
   * å°† AST èŠ‚ç‚¹è½¬æ¢ä¸ºèŒƒå›´
   */
  private static nodeToRange(
    node: ts.Node
  ): { startLine: number; startChar: number; endLine: number; endChar: number } {
    const sourceFile = node.getSourceFile();
    const start = ts.getLineAndCharacterOfPosition(sourceFile, node.getStart(sourceFile));
    const end = ts.getLineAndCharacterOfPosition(sourceFile, node.end);

    return {
      startLine: start.line,
      startChar: start.character,
      endLine: end.line,
      endChar: end.character
    };
  }

  /**
   * è®¡ç®—é£é™©ç»Ÿè®¡
   */
  private static calculateRiskStats(
    risks: SemanticRisk[]
  ): { critical: number; error: number; warning: number; info: number } {
    const stats = {
      critical: 0,
      error: 0,
      warning: 0,
      info: 0
    };

    for (const risk of risks) {
      switch (risk.level) {
        case SemanticRiskLevel.CRITICAL:
          stats.critical++;
          break;
        case SemanticRiskLevel.ERROR:
          stats.error++;
          break;
        case SemanticRiskLevel.WARNING:
          stats.warning++;
          break;
        case SemanticRiskLevel.INFO:
          stats.info++;
          break;
      }
    }

    return stats;
  }
}

/**
 * å¿«æ·å‡½æ•°ï¼šæ‰§è¡Œ Phase 3 è¯­ä¹‰å®¡æŸ¥
 */
export async function reviewPhase3(
  filePaths: string[],
  context?: SemanticReviewContext
): Promise<Phase3ReviewResult> {
  return Phase3SemanticReviewer.review(filePaths, context);
}

/**
 * å¿«æ·å‡½æ•°ï¼šæ„å»ºè¯­ä¹‰å®¡æŸ¥ä¸Šä¸‹æ–‡
 */
export async function buildSemanticReviewContext(): Promise<SemanticReviewContext | null> {
  return Phase3SemanticReviewer.buildContext();
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/semanticReviewValidator.ts

````typescript
/**
 * Semantic Review Validator - è¯­ä¹‰æ ¡éªŒå±‚
 * 
 * ç›®æ ‡ï¼š
 * - åœ¨ Schema æ ¡éªŒä¹‹åï¼Œå¢åŠ è¯­ä¹‰å±‚é¢çš„éªŒè¯
 * - ç¡®ä¿ ReviewResult åœ¨è¯­ä¹‰ä¸Šä¹Ÿæ˜¯å®‰å…¨å’Œåˆç†çš„
 * - é˜²æ­¢ AI ç”Ÿæˆçš„å†…å®¹ç»•è¿‡ Schema éªŒè¯ä½†ä»æœ‰è¯­ä¹‰é”™è¯¯
 * 
 * åŸåˆ™ï¼š
 * - Schema æ ¡éªŒ â‰  å®‰å…¨æ ¡éªŒ â‰  è¯­ä¹‰æ ¡éªŒ
 * - å®å¯æ‹’ç»å¯ç–‘è¾“å…¥ï¼Œä¹Ÿä¸è®©ç³»ç»Ÿå´©æºƒ
 */

import * as vscode from 'vscode';
import { ReviewResultV1, ReviewIssue, ReviewSuggestion } from './reviewSchema';
import { DiffParser } from './diff';

/**
 * è¯­ä¹‰æ ¡éªŒç»“æœ
 */
export interface SemanticValidationResult {
  /** æ˜¯å¦é€šè¿‡æ ¡éªŒ */
  valid: boolean;

  /** è¯­ä¹‰é”™è¯¯åˆ—è¡¨ */
  semanticErrors: SemanticValidationError[];

  /** è­¦å‘Šåˆ—è¡¨ï¼ˆä¸å½±å“ä½¿ç”¨ï¼Œä½†éœ€è¦æ³¨æ„ï¼‰ */
  warnings: SemanticValidationWarning[];
}

/**
 * è¯­ä¹‰é”™è¯¯
 */
export interface SemanticValidationError {
  /** é”™è¯¯ç±»å‹ */
  type:
    | 'FILE_NOT_FOUND'
    | 'RANGE_OUT_OF_BOUNDS'
    | 'DIFF_MISMATCH'
    | 'SUMMARY_INCONSISTENCY'
    | 'DUPLICATE_ISSUE_ID'
    | 'DUPLICATE_SUGGESTION_ID'
    | 'INVALID_LOCATION';

  /** é”™è¯¯æ¶ˆæ¯ */
  message: string;

  /** ç›¸å…³çš„ issue IDï¼ˆå¯é€‰ï¼‰ */
  issueId?: string;

  /** ç›¸å…³çš„ suggestion IDï¼ˆå¯é€‰ï¼‰ */
  suggestionId?: string;

  /** ç›¸å…³æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰ */
  filePath?: string;
}

/**
 * è¯­ä¹‰è­¦å‘Š
 */
export interface SemanticValidationWarning {
  /** è­¦å‘Šç±»å‹ */
  type:
    | 'LOW_CONFIDENCE'
    | 'MISSING_EXPLANATION'
    | 'HIGH_RISK_SUGGESTION';

  /** è­¦å‘Šæ¶ˆæ¯ */
  message: string;

  /** ç›¸å…³çš„ issue IDï¼ˆå¯é€‰ï¼‰ */
  issueId?: string;

  /** ç›¸å…³çš„ suggestion IDï¼ˆå¯é€‰ï¼‰ */
  suggestionId?: string;
}

/**
 * Semantic Review Validator
 */
export class SemanticReviewValidator {
  /**
   * éªŒè¯ ReviewResult çš„è¯­ä¹‰
   */
  static async validate(
    reviewResult: ReviewResultV1
  ): Promise<SemanticValidationResult> {
    const semanticErrors: SemanticValidationError[] = [];
    const warnings: SemanticValidationWarning[] = [];

    // 1. æ£€æŸ¥ summary ç»Ÿè®¡æ˜¯å¦è‡ªæ´½
    const summaryErrors = this.validateSummaryConsistency(reviewResult);
    semanticErrors.push(...summaryErrors);

    // 2. æ£€æŸ¥ ID å”¯ä¸€æ€§
    const duplicateErrors = this.validateIdUniqueness(reviewResult);
    semanticErrors.push(...duplicateErrors);

    // 3. éªŒè¯æ‰€æœ‰ issues
    for (const issue of reviewResult.issues) {
      const issueErrors = await this.validateIssue(issue);
      const issueWarnings = this.validateIssueWarnings(issue);
      
      semanticErrors.push(...issueErrors);
      warnings.push(...issueWarnings);
    }

    // 4. éªŒè¯æ‰€æœ‰ suggestions
    if (reviewResult.suggestions) {
      for (const suggestion of reviewResult.suggestions) {
        const suggestionErrors = await this.validateSuggestion(suggestion);
        const suggestionWarnings = this.validateSuggestionWarnings(suggestion);
        
        semanticErrors.push(...suggestionErrors);
        warnings.push(...suggestionWarnings);
      }
    }

    return {
      valid: semanticErrors.length === 0,
      semanticErrors,
      warnings
    };
  }

  /**
   * éªŒè¯ summary ç»Ÿè®¡æ˜¯å¦è‡ªæ´½
   */
  private static validateSummaryConsistency(
    reviewResult: ReviewResultV1
  ): SemanticValidationError[] {
    const errors: SemanticValidationError[] = [];

    // æ£€æŸ¥ issueCount
    if (reviewResult.summary.issueCount !== reviewResult.issues.length) {
      errors.push({
        type: 'SUMMARY_INCONSISTENCY',
        message: `Summary issueCount (${reviewResult.summary.issueCount}) does not match actual issues count (${reviewResult.issues.length})`
      });
    }

    // æ£€æŸ¥ suggestionCount
    const suggestionCount = reviewResult.suggestions?.length || 0;
    if (reviewResult.summary.suggestionCount !== suggestionCount) {
      errors.push({
        type: 'SUMMARY_INCONSISTENCY',
        message: `Summary suggestionCount (${reviewResult.summary.suggestionCount}) does not match actual suggestions count (${suggestionCount})`
      });
    }

    return errors;
  }

  /**
   * éªŒè¯ ID å”¯ä¸€æ€§
   */
  private static validateIdUniqueness(
    reviewResult: ReviewResultV1
  ): SemanticValidationError[] {
    const errors: SemanticValidationError[] = [];

    // æ£€æŸ¥ issue ID å”¯ä¸€æ€§
    const issueIds = new Set<string>();
    for (const issue of reviewResult.issues) {
      if (issueIds.has(issue.id)) {
        errors.push({
          type: 'DUPLICATE_ISSUE_ID',
          message: `Duplicate issue ID: ${issue.id}`,
          issueId: issue.id
        });
      }
      issueIds.add(issue.id);
    }

    // æ£€æŸ¥ suggestion ID å”¯ä¸€æ€§
    if (reviewResult.suggestions) {
      const suggestionIds = new Set<string>();
      for (const suggestion of reviewResult.suggestions) {
        if (suggestionIds.has(suggestion.id)) {
          errors.push({
            type: 'DUPLICATE_SUGGESTION_ID',
            message: `Duplicate suggestion ID: ${suggestion.id}`,
            suggestionId: suggestion.id
          });
        }
        suggestionIds.add(suggestion.id);
      }
    }

    return errors;
  }

  /**
   * éªŒè¯å•ä¸ª issue
   */
  private static async validateIssue(
    issue: ReviewIssue
  ): Promise<SemanticValidationError[]> {
    const errors: SemanticValidationError[] = [];

    // å¦‚æœæ²¡æœ‰ locationï¼Œè·³è¿‡éªŒè¯
    if (!issue.location) {
      return errors;
    }

    // éªŒè¯æ–‡ä»¶è·¯å¾„æ˜¯å¦å­˜åœ¨
    const fileExists = await this.checkFileExists(issue.location.filePath);
    if (!fileExists) {
      errors.push({
        type: 'FILE_NOT_FOUND',
        message: `File not found in workspace: ${issue.location.filePath}`,
        issueId: issue.id,
        filePath: issue.location.filePath
      });
    }

    // éªŒè¯ range æ˜¯å¦æœ‰æ•ˆ
    if (issue.location.range) {
      const rangeValid = await this.validateRange(
        issue.location.filePath,
        issue.location.range
      );

      if (!rangeValid) {
        errors.push({
          type: 'RANGE_OUT_OF_BOUNDS',
          message: `Range out of bounds in ${issue.location.filePath}: lines ${issue.location.range.startLine}-${issue.location.range.endLine}`,
          issueId: issue.id,
          filePath: issue.location.filePath
        });
      }
    }

    return errors;
  }

  /**
   * éªŒè¯å•ä¸ª suggestion
   */
  private static async validateSuggestion(
    suggestion: ReviewSuggestion
  ): Promise<SemanticValidationError[]> {
    const errors: SemanticValidationError[] = [];

    // å¦‚æœæ²¡æœ‰ diffï¼Œè·³è¿‡éªŒè¯
    if (!suggestion.diff) {
      return errors;
    }

    // éªŒè¯ diff å†…å®¹
    const parseResult = DiffParser.parse(suggestion.diff.content);
    if (!parseResult.success) {
      errors.push({
        type: 'DIFF_MISMATCH',
        message: `Failed to parse diff in suggestion ${suggestion.id}: ${parseResult.error}`,
        suggestionId: suggestion.id
      });
      return errors;
    }

    // éªŒè¯ diff æ˜¯å¦åªå½±å“ appliesTo.filePath
    if (suggestion.appliesTo?.filePath) {
      const filesInDiff = new Set(
        parseResult.files.map(f => f.normalizedPath)
      );

      if (!filesInDiff.has(suggestion.appliesTo.filePath)) {
        errors.push({
          type: 'DIFF_MISMATCH',
          message: `Diff in suggestion ${suggestion.id} does not affect file ${suggestion.appliesTo.filePath}`,
          suggestionId: suggestion.id,
          filePath: suggestion.appliesTo.filePath
        });
      }

      // å¦‚æœ diff åŒ…å«å¤šä¸ªæ–‡ä»¶ï¼Œä½† appliesTo åªæŒ‡å®šäº†ä¸€ä¸ªï¼Œè­¦å‘Š
      if (filesInDiff.size > 1) {
        errors.push({
          type: 'DIFF_MISMATCH',
          message: `Diff in suggestion ${suggestion.id} affects ${filesInDiff.size} files, but appliesTo only specifies ${suggestion.appliesTo.filePath}`,
          suggestionId: suggestion.id
        });
      }
    }

    return errors;
  }

  /**
   * éªŒè¯ issue çš„è­¦å‘Š
   */
  private static validateIssueWarnings(issue: ReviewIssue): SemanticValidationWarning[] {
    const warnings: SemanticValidationWarning[] = [];

    // æ£€æŸ¥ä½ç½®ä¿¡åº¦
    if (issue.confidence !== undefined && issue.confidence < 0.5) {
      warnings.push({
        type: 'LOW_CONFIDENCE',
        message: `Issue ${issue.id} has low confidence: ${issue.confidence}`,
        issueId: issue.id
      });
    }

    // æ£€æŸ¥ç¼ºå°‘è§£é‡Š
    if (!issue.explanation && issue.severity === 'error') {
      warnings.push({
        type: 'MISSING_EXPLANATION',
        message: `High severity issue ${issue.id} lacks explanation`,
        issueId: issue.id
      });
    }

    return warnings;
  }

  /**
   * éªŒè¯ suggestion çš„è­¦å‘Š
   */
  private static validateSuggestionWarnings(suggestion: ReviewSuggestion): SemanticValidationWarning[] {
    const warnings: SemanticValidationWarning[] = [];

    // æ£€æŸ¥é«˜é£é™©å»ºè®®
    if (suggestion.safety.risk === 'high') {
      warnings.push({
        type: 'HIGH_RISK_SUGGESTION',
        message: `Suggestion ${suggestion.id} has high risk`,
        suggestionId: suggestion.id
      });
    }

    return warnings;
  }

  /**
   * æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
   */
  private static async checkFileExists(
    filePath: string
  ): Promise<boolean> {
    try {
      const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
      if (!workspaceFolder) {
        // å¦‚æœæ²¡æœ‰ workspaceï¼Œå‡è®¾æ–‡ä»¶ä¸å­˜åœ¨
        return false;
      }

      const uri = vscode.Uri.joinPath(workspaceFolder.uri, filePath);
      
      try {
        await vscode.workspace.fs.stat(uri);
        return true;
      } catch {
        return false;
      }
    } catch {
      return false;
    }
  }

  /**
   * éªŒè¯ range æ˜¯å¦åœ¨æ–‡ä»¶è¡Œæ•°å†…
   */
  private static async validateRange(
    filePath: string,
    range: {
      startLine: number;
      startChar?: number;
      endLine: number;
      endChar?: number;
    }
  ): Promise<boolean> {
    try {
      const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
      if (!workspaceFolder) {
        return false;
      }

      const uri = vscode.Uri.joinPath(workspaceFolder.uri, filePath);
      
      try {
        const document = await vscode.workspace.openTextDocument(uri);
        const lineCount = document.lineCount;

        // range ä½¿ç”¨ 0-based ç´¢å¼•
        if (range.startLine < 0 || range.startLine >= lineCount) {
          return false;
        }

        if (range.endLine < 0 || range.endLine >= lineCount) {
          return false;
        }

        if (range.endLine < range.startLine) {
          return false;
        }

        return true;
      } catch {
        return false;
      }
    } catch {
      return false;
    }
  }

  /**
   * å¿«æ·å‡½æ•°ï¼šéªŒè¯å¹¶æŠ›å‡ºå¼‚å¸¸ï¼ˆå¦‚æœä¸é€šè¿‡ï¼‰
   */
  static async validateOrThrow(
    reviewResult: ReviewResultV1
  ): Promise<void> {
    const result = await this.validate(reviewResult);

    if (!result.valid) {
      const errorMessage = result.semanticErrors
        .map(e => e.message)
        .join('\n');
      throw new Error(`Semantic validation failed:\n${errorMessage}`);
    }
  }
}

/**
 * å¿«æ·å‡½æ•°ï¼šéªŒè¯ ReviewResult
 */
export async function validateSemanticReview(
  reviewResult: ReviewResultV1
): Promise<SemanticValidationResult> {
  return SemanticReviewValidator.validate(reviewResult);
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/types.ts

````typescript
/**
 * Git ç›¸å…³ç±»å‹å®šä¹‰
 */

export interface GitCommitResult {
    success: boolean;
    hash?: string;
    message?: string;
    error?: string;
}

export interface GitReviewResult {
    success: boolean;
    issues: GitReviewIssue[];
    summary?: string;
}

export interface GitReviewIssue {
    type: 'error' | 'warning' | 'info';
    message: string;
    file?: string;
    line?: number;
    suggestion?: string;
}

export interface GitStatus {
    branch: string;
    ahead: number;
    behind: number;
    changed: number;
    staged: number;
}

export interface GitBranch {
    name: string;
    current: boolean;
    remote?: string;
}

export interface GitCommitHistory {
    hash: string;
    message: string;
    author: string;
    date: string;
}

export interface DiffApplyOptions {
    dryRun?: boolean;
    createBackup?: boolean;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/AgentRuntime.ts

````typescript
import chalk from "chalk";
import { randomUUID } from "crypto";
import { LLMAdapter } from "./llmAdapter";
import { GovernanceService } from "./governance";
import { ToolExecutor } from "./executor";
import { ContextManager } from "./contextManager";
import { evaluateProposal } from "./governance/core";
import { ProposedAction, ExecutionTurn } from "./state";
import { ContextBuffer } from "./contextBuffer";
import {
  snapshotFromBuffer,
  diffContext,
  ContextSnapshot,
} from "./contextDiff";
import { ExecutionRecorder } from "./executionRecorder";
import {
  generateReferenceRetrospective,
  analyzeContextLifecycle,
} from "./contextProtocol";
import { ContextToSkillPromotionRules } from "./contextSkillPromotion";
import {
  Skill,
  updateSkillStatus,
  learnSkillFromRecord,
  addSkill,
} from "./skills";

export class AgentRuntime {
  private context: ContextManager;
  private lastContextSnapshot: ContextSnapshot | null = null;
  private executionId: string;
  private executionRecorder: ExecutionRecorder;

  constructor(initialContext: any) {
    this.context = new ContextManager(initialContext);
    this.executionRecorder = new ExecutionRecorder();
    this.executionId = randomUUID();
  }

  /**
   * åˆå§‹åŒ–è¿è¡Œæ—¶ï¼ŒåŒ…æ‹¬ Context Bank
   */
  async initialize(): Promise<void> {
    await this.context.initializeContextBank();
  }

  async run(
    userInput: string,
    mode: "chat" | "command" = "chat",
    onChunk?: (chunk: string) => void,
    model?: string,
    abortSignal?: AbortSignal,
  ) {
    // âœ… ç»ˆæ­¢æ€æ£€æŸ¥ï¼ˆHALTï¼‰- v3.1 æ ¸å¿ƒä¿®å¤
    if (userInput && userInput.trim().toLowerCase() === 'stop') {
      console.log(chalk.blue('\nğŸ›‘ TERMINATION: User requested stop'));
      this.executionRecorder.recordTurn({
        turnId: 0,
        startTime: Date.now(),
        contextSnapshot: {
          inputHash: this.context.getHash(),
          systemPromptVersion: 'v1.0.0',
          toolSetVersion: 'v1.0.0',
          recentMessages: this.context.getRecentMessages(5),
        },
        executionResult: {
          success: true,
          output: 'STOPPED'
        },
        endTime: Date.now()
      } as any);
      return; // âœ… ç›´æ¥ returnï¼Œä¸è¿›å…¥ REACT å¾ªç¯
    }

    // ç¡®ä¿ Context Bank å·²åˆå§‹åŒ–
    await this.initialize();

    let turnCount = 0;
    const maxTurns = 10;

    if (userInput) {
      // æ£€æŸ¥ç”¨æˆ·è¾“å…¥æ˜¯å¦åŒ…å« DSL æŸ¥è¯¢ï¼Œå¦‚æœæœ‰åˆ™è‡ªåŠ¨æ·»åŠ ç›¸å…³ä¸Šä¸‹æ–‡
      const dslContextItems =
        await this.context.getDSLContextForInput(userInput);

      if (dslContextItems.length > 0) {
        console.log(
          chalk.cyan(
            `\n[DSL Query] Found ${dslContextItems.length} matching context items:`,
          ),
        );
        for (const item of dslContextItems) {
          console.log(chalk.cyan(`  - ${item.path} (${item.type})`));
        }
      }

      // ä» Context Bank æŸ¥è¯¢ä¸å½“å‰ä»»åŠ¡ç›¸å…³çš„ä¸Šä¸‹æ–‡
      console.log(chalk.blue("\n[Context Bank] Loading relevant context..."));
      try {
        await this.context.importFromContextBank({
          input: userInput,
          projectScope: process.cwd(), // ä½¿ç”¨å½“å‰å·¥ä½œç›®å½•ä½œä¸ºé¡¹ç›®ä½œç”¨åŸŸ
          strategy: "relevance",
          limit: 5, // æœ€å¤šåŠ è½½5ä¸ªç›¸å…³ä¸Šä¸‹æ–‡
        });
        console.log(chalk.green("[Context Bank] Relevant context loaded"));
      } catch (error) {
        console.log(
          chalk.yellow(`[Context Bank] Could not load context: ${error}`),
        );
      }

      this.context.addMessage("user", userInput);
    }

    while (turnCount < maxTurns) {
      const currentTurn = ++turnCount;
      if (currentTurn > 1) {
        console.log(chalk.blue(`\n--- Turn ${currentTurn} ---`));
      }

      const messages = this.context.getMessages().map((msg) => ({
        role: (msg.role === "tool" ? "system" : msg.role) as
          | "system"
          | "user"
          | "assistant",
        content: msg.content,
      }));

      // === Context Diff ===
      const currentSnapshot = snapshotFromBuffer(
        this.context.getContextBuffer(),
      );
      const contextDiff = diffContext(
        this.lastContextSnapshot,
        currentSnapshot,
      );

      if (
        contextDiff.added.length ||
        contextDiff.removed.length ||
        contextDiff.changed.length
      ) {
        console.log(chalk.cyan("\n[Context Diff]"));
        if (contextDiff.added.length)
          console.log("  + added:", contextDiff.added);
        if (contextDiff.removed.length)
          console.log("  - removed:", contextDiff.removed);
        if (contextDiff.changed.length)
          console.log("  ~ changed:", contextDiff.changed);
      }

      this.lastContextSnapshot = currentSnapshot;

      // è®°å½•æ‰§è¡Œå›åˆ
      const executionTurn: Omit<ExecutionTurn, "turnId"> = {
        startTime: Date.now(),
        contextSnapshot: {
          inputHash: this.context.getHash(),
          systemPromptVersion: "v1.0.0",
          toolSetVersion: "v1.0.0",
          recentMessages: this.context.getRecentMessages(5),
        },
        contextDiff:
          contextDiff.added.length ||
            contextDiff.removed.length ||
            contextDiff.changed.length
            ? contextDiff
            : undefined,
      };

      // ğŸ‘‡ğŸ‘‡ğŸ‘‡ Observation-only Debugï¼ˆæ¨èï¼‰
      if (!onChunk) {
        const observations = this.context.getObservations();
        if (observations.length > 0) {
          console.log(chalk.magenta('\nğŸ” OBSERVATION DEBUG (Agent Perception)'));
          observations.forEach((obs, i) => {
            console.log(
              chalk.magenta(
                `#${i + 1} [${obs.role.toUpperCase()}]\n${obs.content}\n`
              )
            );
          });
        }
      }

      // æ£€æŸ¥æ˜¯å¦è¢«å–æ¶ˆ
      if (abortSignal?.aborted) {
        console.log(chalk.red('\nğŸ›‘ Execution aborted by user'));
        throw new Error('Execution aborted by user');
      }

      const thought = await LLMAdapter.think(
        messages,
        mode as any,
        onChunk,
        model,
        GovernanceService.getPolicyManual(),
        this.context, // ä¼ é€’ContextManagerä»¥ä¾¿è®¿é—®ContextBuffer
        abortSignal // âœ… ä¼ é€’å–æ¶ˆä¿¡å·åˆ° LLMAdapter
      );

      // === Observation Acknowledgement Gate (v3.1 - å®‰å…¨ç‰ˆ) ===
      // âœ… ä½¿ç”¨ getLastAckableObservation() è€Œä¸æ˜¯ getLastObservation()
      // è¿™ä¼šè‡ªåŠ¨æ’é™¤ error ç±»å‹çš„ Observation
      const lastObs = this.context.getLastAckableObservation();
      const ack = (thought.parsedPlan as any)?.acknowledged_observation;

      if (lastObs) {
        // å¦‚æœæœ‰ Observationï¼Œæ£€æŸ¥æ˜¯å¦è¢«æ­£ç¡®ç¡®è®¤
        // æ£€æŸ¥ ack æ˜¯å¦å­˜åœ¨ä¸”ä¸ä¸º NONE
        if (!ack || ack === 'NONE') {
          console.log(chalk.red('\nâŒ OBSERVATION NOT ACKNOWLEDGED'));
          console.log(chalk.red('Expected observation to be restated:'));
          console.log(chalk.red(lastObs.content.substring(0, 100) + '...'));

          // âœ… å…³é”®ä¿®å¤ï¼šä½¿ç”¨ error ç±»å‹ï¼Œè¿™æ ·å®ƒä¸ä¼šè¢«å†æ¬¡ç¡®è®¤
          this.context.addObservation(
            `ERROR: You failed to acknowledge the latest Observation.
You MUST restate it verbatim before continuing.
Latest Observation: ${lastObs.content}`,
            'error'  // â† æ ‡è®°ä¸º error ç±»å‹ï¼Œé˜²æ­¢æ­»å¾ªç¯
          );

          // â—å…³é”®ï¼šä¸è¦æ‰§è¡Œ actionï¼Œç›´æ¥ä¸‹ä¸€è½®
          continue;
        }

        // å®½æ¾æ£€æŸ¥ï¼šåªè¦ ack åŒ…å« Observation çš„ä¸€éƒ¨åˆ†å†…å®¹å³å¯
        if (lastObs.content.length > 30 &&
          !lastObs.content.includes(ack.substring(0, 10)) &&
          !ack.includes(lastObs.content.substring(0, 10))) {
          console.log(chalk.red('\nâŒ OBSERVATION ACK MISMATCH'));
          console.log(chalk.red('Observation:'));
          console.log(chalk.red(lastObs.content.substring(0, 100) + '...'));
          console.log(chalk.red('Your ACK:'));
          console.log(chalk.red(ack.substring(0, 100) + '...'));

          // âœ… ä½¿ç”¨ error ç±»å‹
          this.context.addObservation(
            `ERROR: Your acknowledgment does not match the latest Observation.
Please restate it VERBATIM.
Latest Observation: ${lastObs.content}`,
            'error'  // â† æ ‡è®°ä¸º error ç±»å‹
          );

          continue;
        }
      } else if (ack && ack !== 'NONE') {
        // æ²¡æœ‰éœ€è¦ç¡®è®¤çš„ Observationï¼Œä½† AI ç¡®è®¤äº†æŸä¸ªå†…å®¹
        // è¿™å¯èƒ½æ˜¯è¯¯åˆ¤ï¼Œä½†ä¸æ˜¯è‡´å‘½é”™è¯¯ï¼Œç›´æ¥ç»§ç»­
        console.log(chalk.yellow('\nâš ï¸  ACK provided but no Observation to acknowledge'));
      }

      const action: ProposedAction = {
        id: randomUUID(),
        type: (thought.type as any) || "answer",
        payload: thought.payload || { text: thought.raw },
        riskLevel: "low",
        reasoning: thought.reasoning || "",
      };

      // æ›´æ–°executionTurn
      executionTurn.proposedAction = action;

      if (action.reasoning && !onChunk) {
        console.log(chalk.gray(`\nğŸ¤” Reasoning: ${action.reasoning}`));
      }

      // å¦‚æœ LLM è®¤ä¸ºå·²ç»å®Œæˆæˆ–è€…å½“å‰çš„åŠ¨ä½œå°±æ˜¯å›ç­”
      if (thought.isDone || action.type === "answer") {
        const result = await ToolExecutor.execute(action as any);
        if (!onChunk) {
          console.log(chalk.green(`\n\n\nğŸ¤– AI Action: ${result.output}\n`));
        }

        // âœ… å…³é”®ä¿®å¤ï¼šä¸è¦å°†æœ€ç»ˆç­”æ¡ˆä½œä¸ºObservationæ·»åŠ ï¼Œé¿å…AIé‡å¤å†…å®¹
        // åªæœ‰åœ¨æµå¼ä¼ è¾“æ—¶æ‰ä¸æ·»åŠ ï¼Œéæµå¼ä¼ è¾“ï¼ˆCLIæ¨¡å¼ï¼‰æ·»åŠ ä»¥ä¾¿åç»­åˆ†æ
        if (!onChunk) {
          this.context.addToolResult(action.type, result.output);
        }

        // æ›´æ–°executionTurn
        executionTurn.executionResult = result;
        executionTurn.endTime = Date.now();

        // ä»»åŠ¡æˆåŠŸå®Œæˆï¼Œåªæ›´æ–°è¢«ä½¿ç”¨è¿‡çš„ContextItemçš„é‡è¦æ€§
        for (const item of this.context.getContextBuffer().export()) {
          if (item.importance && item.importance.useCount > 0) {
            // æˆåŠŸå®Œæˆä»»åŠ¡ï¼Œå¢åŠ æˆåŠŸè®¡æ•°
            item.importance.successCount++;
            item.importance.confidence = Math.min(
              1,
              item.importance.confidence + 0.05,
            );
            item.importance.lastUsed = Date.now();
          }
        }

        // è®°å½• ContextBank ä½¿ç”¨æƒ…å†µï¼ˆæˆåŠŸï¼‰
        await this.context.recordBankUsage(true);

        // ç”ŸæˆContextå¼•ç”¨å›æº¯æŠ¥å‘Š
        const retrospectiveReport = generateReferenceRetrospective(
          this.context.getContextBuffer(),
          this.executionId,
          userInput,
          result.output,
        );

        console.log(chalk.magenta("\nğŸ” Context Reference Retrospective:"));
        console.log(retrospectiveReport);

        // åˆ†æContextItemçš„ç”Ÿå‘½å‘¨æœŸ
        const lifecycleAnalysis = analyzeContextLifecycle(
          this.context.getContextBuffer(),
        );
        const recommendations = lifecycleAnalysis.filter(
          (item) => item.recommendation !== "keep",
        );

        if (recommendations.length > 0) {
          console.log(chalk.magenta("\nğŸ’¡ Context Lifecycle Recommendations:"));
          for (const rec of recommendations) {
            console.log(
              chalk.yellow(
                `  ${rec.recommendation.toUpperCase()}: ${rec.path} (quality: ${rec.qualityScore.toFixed(2)}, relevance: ${rec.relevanceScore.toFixed(2)})`,
              ),
            );
          }
        }

        // è®°å½•æ‰§è¡Œå›åˆï¼ˆåªåœ¨è¿™é‡Œè®°å½•ä¸€æ¬¡ï¼‰
        this.executionRecorder.recordTurn({
          ...executionTurn,
          turnId: 0,
        } as any);

        // æ‰§è¡Œå›é¡¾æ€§åˆ†æ
        await this.retrospective({ ...executionTurn, turnId: 0 });

        // âœ… å…³é”®ä¿®å¤ï¼šç›´æ¥ breakï¼Œä¸å†è¿›å…¥ä¸‹ä¸€è½®ï¼Œé¿å…AIé‡å¤è‡ªå·±çš„å›ç­”
        break;
      }

      // === é¢„æ£€ (Pre-flight) ===
      const preCheck = evaluateProposal(
        action,
        GovernanceService.getRules(),
        GovernanceService.getLedgerSnapshot(),
      );
      if (preCheck.effect === "deny") {
        console.log(
          chalk.red(`[PRE-FLIGHT] ğŸ›¡ï¸ Policy Blocked: ${preCheck.reason}`),
        );
        this.context.addMessage(
          "system",
          `POLICY DENIED: ${preCheck.reason}. Find a different way.`,
        );

        // æ›´æ–°executionTurn
        executionTurn.executionResult = {
          success: false,
          output: `POLICY DENIED: ${preCheck.reason}`,
          error: preCheck.reason,
        };
        executionTurn.endTime = Date.now();

        // è®°å½•æ‰§è¡Œå›åˆ
        this.executionRecorder.recordTurn({
          ...executionTurn,
          turnId: 0,
        } as any);

        continue;
      }

      // === æ­£å¼æ²»ç† (WASM + äººå·¥/è‡ªåŠ¨) ===
      const decision = await GovernanceService.adjudicate(action);
      if (decision.status === "rejected") {
        console.log(
          chalk.red(
            `[GOVERNANCE] âŒ Rejected: ${"reason" in decision ? decision.reason : "Unknown reason"}`,
          ),
        );
        this.context.addMessage(
          "system",
          `Rejected by Governance: ${"reason" in decision ? decision.reason : "Unknown reason"}`,
        );

        // æ›´æ–°executionTurn
        executionTurn.governance = decision;
        executionTurn.executionResult = {
          success: false,
          output: `GOVERNANCE REJECTED: ${"reason" in decision ? decision.reason : "Unknown reason"}`,
          error: "reason" in decision ? decision.reason : "Unknown reason",
        };
        executionTurn.endTime = Date.now();

        // ä»»åŠ¡è¢«æ‹’ç»ï¼Œåªæ›´æ–°è¢«ä½¿ç”¨è¿‡çš„ContextItemçš„é‡è¦æ€§ï¼ˆå¤±è´¥æƒ©ç½šï¼‰
        for (const item of this.context.getContextBuffer().export()) {
          if (item.importance && item.importance.useCount > 0) {
            // ä»»åŠ¡å¤±è´¥ï¼Œå¢åŠ å¤±è´¥è®¡æ•°
            item.importance.failureCount++;
            item.importance.confidence = Math.max(
              0,
              item.importance.confidence - 0.1,
            );
            item.importance.lastUsed = Date.now();
          }
        }

        // è®°å½• ContextBank ä½¿ç”¨æƒ…å†µï¼ˆå¤±è´¥ï¼‰
        await this.context.recordBankUsage(false);

        // è®°å½•æ‰§è¡Œå›åˆ
        this.executionRecorder.recordTurn({
          ...executionTurn,
          turnId: 0,
        } as any);

        continue;
      }

      // æ›´æ–°executionTurn
      executionTurn.governance = decision;

      // === æ‰§è¡Œ ===
      console.log(chalk.yellow(`[EXECUTING] âš™ï¸ ${action.type}...`));
      const result = await ToolExecutor.execute(action as any);

      // æ›´æ–°executionTurn
      executionTurn.executionResult = result;
      executionTurn.endTime = Date.now();

      if (result.success) {
        this.context.addToolResult(action.type, result.output);
        const preview =
          result.output.length > 300
            ? result.output.substring(0, 300) + "..."
            : result.output;
        console.log(chalk.green(`[SUCCESS] Result:\n${preview}`));

        // æ›´æ–°ContextBufferä¸­ç›¸å…³é¡¹çš„é‡è¦æ€§ï¼ˆæ ‡è®°ä¸ºè¢«ä½¿ç”¨ï¼‰
        for (const item of this.context.getContextBuffer().export()) {
          if (result.output.includes(item.path)) {
            if (item.importance) {
              item.importance.useCount++;
              item.importance.lastUsed = Date.now();
            }
          }
        }

        // è®°å½• ContextBank ä½¿ç”¨æƒ…å†µï¼ˆæˆåŠŸï¼‰
        await this.context.recordBankUsage(true);
      } else {
        this.context.addToolResult(action.type, `Error: ${result.error}`);
        console.log(chalk.red(`[ERROR] ${result.error}`));

        // è®°å½• ContextBank ä½¿ç”¨æƒ…å†µï¼ˆå¤±è´¥ï¼‰
        await this.context.recordBankUsage(false);
      }

      // è®°å½•æ‰§è¡Œå›åˆ
      this.executionRecorder.recordTurn({ ...executionTurn, turnId: 0 } as any);
    }

    if (turnCount >= maxTurns) {
      console.log(chalk.red(`\nâš ï¸ Max turns (${maxTurns}) reached.`));
    }
  }

  getContextManager(): ContextManager {
    return this.context;
  }

  /**
   * è¯¢é—®ç”¨æˆ·æ˜¯å¦ç¡®è®¤åˆ›å»ºæŠ€èƒ½
   */
  private async confirmSkillCreation(skill: Skill): Promise<boolean> {
    // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œå¯èƒ½ä¼šæœ‰æ›´å¤æ‚çš„ç¡®è®¤é€»è¾‘
    // ç›®å‰è¿”å› true ä»¥è‡ªåŠ¨åˆ›å»ºæŠ€èƒ½
    console.log(chalk.blue(`\nğŸ“ Creating skill: ${skill.name}`));
    return true; // è‡ªåŠ¨ç¡®è®¤ï¼Œå¯æ ¹æ®é…ç½®è°ƒæ•´
  }

  /**
   * ä¿å­˜æŠ€èƒ½
   */
  private async saveSkill(skill: Skill): Promise<void> {
    // å°†æŠ€èƒ½æ·»åŠ åˆ°æŠ€èƒ½åº“
    const now = Date.now();
    const skillToAdd = {
      ...skill,
      successCount: skill.metadata?.promotionCriteria?.successCount || 0,
      failureCount: 0, // æ–°åˆ›å»ºçš„æŠ€èƒ½æ²¡æœ‰å¤±è´¥è®°å½•
      confidence: skill.metadata?.promotionCriteria?.successRate || 0.5,
      lastUsed: now,
      createdAt: now,
      enabled: true,
    };

    // ä½¿ç”¨ addSkill å‡½æ•°æ·»åŠ æŠ€èƒ½
    addSkill(skillToAdd);
  }

  /**
   * æ‰§è¡Œå›åˆå›é¡¾åˆ†æ
   */
  private async retrospective(turn: ExecutionTurn) {
    // å¯¼å‡ºé«˜ä»·å€¼ä¸Šä¸‹æ–‡åˆ° Context Bank
    console.log(chalk.blue("\n[Context Bank] Exporting high-value context..."));
    try {
      await this.context.exportToContextBank(process.cwd()); // ä½¿ç”¨å½“å‰å·¥ä½œç›®å½•ä½œä¸ºé¡¹ç›®ä½œç”¨åŸŸ
      console.log(chalk.green("[Context Bank] High-value context exported"));
    } catch (error) {
      console.log(
        chalk.yellow(`[Context Bank] Could not export context: ${error}`),
      );
    }

    // è¯„ä¼°ä¸Šä¸‹æ–‡æ™‹å‡
    await this.evaluateContextPromotion();
  }

  /**
   * è¯„ä¼°ä¸Šä¸‹æ–‡æ™‹å‡
   */
  private async evaluateContextPromotion() {
    const contextItems = this.context.getContextBuffer().export();
    for (const item of contextItems) {
      const promotedSkill =
        ContextToSkillPromotionRules.evaluatePromotion(item);
      if (promotedSkill) {
        console.log(
          chalk.green(
            `\nğŸš€ PROMOTION: Context "${item.path}" qualifies to be promoted to Skill "${promotedSkill.name}"`,
          ),
        );
        console.log(chalk.gray(`   Description: ${promotedSkill.description}`));

        // è¯¢é—®ç”¨æˆ·æ˜¯å¦ç¡®è®¤åˆ›å»ºæŠ€èƒ½
        const confirmed = await this.confirmSkillCreation(promotedSkill);
        if (confirmed) {
          try {
            // é€šè¿‡æ²»ç†æœåŠ¡å®¡æ‰¹
            const governanceDecision = await GovernanceService.adjudicate({
              id: randomUUID(),
              type: "tool_call",
              payload: {
                tool_name: "skill_create",
                parameters: promotedSkill,
              },
              riskLevel: "low",
              reasoning: "Auto promotion from context",
            });

            if (governanceDecision.status === "approved") {
              // ä¿å­˜æŠ€èƒ½
              await this.saveSkill(promotedSkill);
              // æ ‡è®° ContextItem å·²è¢«æ™‹å‡
              (item as any).metadata = {
                ...(item as any).metadata,
                promotedToSkill: true,
              };
              console.log(
                chalk.green(
                  `âœ… Skill "${promotedSkill.name}" created successfully`,
                ),
              );
            } else {
              console.log(
                chalk.yellow(
                  `âš ï¸  Skill creation rejected by governance: ${"reason" in governanceDecision ? governanceDecision.reason : "Unknown reason"}`,
                ),
              );
            }
          } catch (error) {
            console.log(chalk.red(`âŒ Failed to create skill: ${error}`));
          }
        }
      }
    }
  }

  getExecutionRecorder(): ExecutionRecorder {
    return this.executionRecorder;
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/actions.ts

````typescript
import { AgentAction } from './types';
import { exec } from 'child_process';
import { promisify } from 'util';
import chalk from 'chalk';
import readline from 'readline';

const execAsync = promisify(exec);

export async function executeAction(
    action: AgentAction,
    options?: { autoYes?: boolean }
): Promise<void> {
    if (action.type === 'print') {
        console.log(action.content);
        return;
    }

    if (action.type === 'confirm') {
        const ok = options?.autoYes || await confirm('Execute this action?');
        if (ok) {
            await executeAction(action.next, options);
        }
        return;
    }

    if (action.type === 'execute') {
        try {
            console.log(chalk.cyan(`\nExecuting: ${action.command}\n`));
            const { stdout, stderr } = await execAsync(action.command, {
                shell: typeof process.env.SHELL === 'string' ? process.env.SHELL : undefined
            });
            if (stdout) console.log(stdout);
            if (stderr) console.error(chalk.yellow(stderr));
        } catch (error: any) {
            console.error(chalk.red(`Execution failed: ${error.message}`));
            throw error;
        }
    }
}

async function confirm(message: string): Promise<boolean> {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });

    return new Promise((resolve) => {
        rl.question(chalk.cyan(`${message} (y/N): `), (answer) => {
            rl.close();
            resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');
        });
    });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/chatHistoryStorage.ts

````typescript
import fs from 'fs';
import { promisify } from 'util';
import path from 'path';
import os from 'os';
import { AIRequestMessage } from '../core/validation';

const CHAT_HISTORY_DIR = path.resolve(os.homedir(), '.yuangs_chat_history');
const CHAT_HISTORY_FILE = path.join(CHAT_HISTORY_DIR, 'chat_history.json');

const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);
const mkdirAsync = promisify(fs.mkdir);
const rmAsync = promisify(fs.rm);

export async function loadChatHistory(): Promise<AIRequestMessage[]> {
    if (fs.existsSync(CHAT_HISTORY_FILE)) {
        try {
            const raw = await readFileAsync(CHAT_HISTORY_FILE, 'utf-8');
            const data = JSON.parse(raw);

            // éªŒè¯æ•°æ®ç»“æ„
            if (Array.isArray(data) && data.every(msg =>
                typeof msg === 'object' &&
                ['user', 'assistant', 'system'].includes(msg.role) &&
                typeof msg.content === 'string'
            )) {
                return data as AIRequestMessage[];
            }
        } catch (e) {
            console.warn('è­¦å‘Š: åŠ è½½èŠå¤©å†å²è®°å½•å¤±è´¥ï¼Œä½¿ç”¨ç©ºå†å²è®°å½•');
        }
    }
    return [];
}

export async function saveChatHistory(history: AIRequestMessage[]) {
    try {
        await mkdirAsync(CHAT_HISTORY_DIR, { recursive: true });
        await writeFileAsync(CHAT_HISTORY_FILE, JSON.stringify(history, null, 2));
    } catch (e) {
        console.error('é”™è¯¯: ä¿å­˜èŠå¤©å†å²è®°å½•å¤±è´¥:', e);
    }
}

export async function clearChatHistory() {
    try {
        await rmAsync(CHAT_HISTORY_FILE, { force: true });
    } catch (e) {
        console.error('é”™è¯¯: æ¸…é™¤èŠå¤©å†å²è®°å½•å¤±è´¥:', e);
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/context.ts

````typescript
import { AgentInput, AgentContext } from './types';
import { ContextBuffer } from './contextBuffer';
import { ExtendedContextProtocol } from './contextDSL';
import { computeContextImportance } from './contextImportance';

export function buildContext(input: AgentInput, contextBuffer: ContextBuffer): AgentContext {
    // åŒæ­¥è·å–æ‰€æœ‰ä¸Šä¸‹æ–‡é¡¹
    const items = contextBuffer.export();

    return {
        files: items.map(item => ({
            path: item.path,
            content: item.content,
        })),
        gitDiff: undefined, // Will be enhanced later
        history: [], // Will be populated from conversation history
        contextItems: items,
        totalTokens: items.reduce((sum, item) => sum + item.tokens, 0),
        highConfidenceItems: items.filter(item =>
            item.importance && computeContextImportance(item.importance) > 0.7
        ),
        mediumConfidenceItems: items.filter(item =>
            item.importance &&
            computeContextImportance(item.importance) > 0.3 &&
            computeContextImportance(item.importance) <= 0.7
        ),
        lowConfidenceItems: items.filter(item =>
            !item.importance || computeContextImportance(item.importance) <= 0.3
        )
    };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/contextBank.ts

````typescript
/**
 * Context Bank v1 â€” è·¨ä¼šè¯ä¸Šä¸‹æ–‡é“¶è¡Œ
 * 
 * ä¸€ä¸ªè·¨ä¼šè¯ã€è·¨æ‰§è¡Œå‘¨æœŸçš„é•¿æœŸä¸Šä¸‹æ–‡å­˜å‚¨ç³»ç»Ÿï¼Œ
 * å°†çŸ­æœŸ ContextBuffer ä¸­è¢«è¯æ˜æœ‰ä»·å€¼çš„ä¸Šä¸‹æ–‡æ²‰æ·€ä¸ºå¯å¤ç”¨èµ„äº§ã€‚
 */

import fs from 'fs/promises';
import path from 'path';
import { ContextItem } from './contextBuffer';
import { ContextImportance, computeContextImportance } from './contextImportance';
import { randomUUID } from 'crypto';

export interface BankContextItem extends ContextItem {
  id: string;
  stableId: string;        // ç¨³å®šèº«ä»½
  source: 'project' | 'global' | 'external'; // ä¸Šä¸‹æ–‡æ¥æº
  projectScope?: string;   // é¡¹ç›®ä½œç”¨åŸŸ (repo hash / path)
  tags?: string[];         // æ ‡ç­¾ (e.g. ['build', 'infra', 'ci'])
  frozen?: boolean;        // ç¦æ­¢è‡ªåŠ¨ä¿®æ”¹
  deprecated?: boolean;    // å·²å¼ƒç”¨
  firstSeenAt: number;     // é¦–æ¬¡å‡ºç°æ—¶é—´
  lastUsedAt: number;      // æœ€åä½¿ç”¨æ—¶é—´
}

export interface BankIndexEntry {
  id: string;
  path: string;
  stableId: string;
  type: 'file' | 'directory' | 'runtime';
  confidence: number;      // é‡è¦æ€§è¯„åˆ†
  useCount: number;        // ä½¿ç”¨æ¬¡æ•°
  lastUsed: number;        // æœ€åä½¿ç”¨æ—¶é—´æˆ³
  tags?: string[];         // æ ‡ç­¾
  projectScope?: string;   // é¡¹ç›®ä½œç”¨åŸŸ
  source?: 'project' | 'global' | 'external'; // ä¸Šä¸‹æ–‡æ¥æº
}

export interface BankQueryOptions {
  input?: string;          // ç”¨æˆ·è¾“å…¥ï¼Œç”¨äºç›¸å…³æ€§åŒ¹é…
  projectScope?: string;   // é¡¹ç›®ä½œç”¨åŸŸè¿‡æ»¤
  strategy?: 'ranked' | 'recent' | 'relevance'; // æŸ¥è¯¢ç­–ç•¥
  limit?: number;          // é™åˆ¶è¿”å›æ•°é‡
  tags?: string[];         // æ ‡ç­¾è¿‡æ»¤
}

export interface BankStats {
  totalItems: number;
  totalTokens: number;
  lastUpdated: number;
  usageLogSize: number;
}

export class ContextBank {
  private bankDir: string;
  private indexPath: string;
  private itemsDir: string;
  private snapshotsDir: string;
  private statsDir: string;

  constructor(bankPath?: string) {
    this.bankDir = bankPath || path.join(require('os').homedir(), '.yuangs', 'context-bank');
    this.indexPath = path.join(this.bankDir, 'index.json');
    this.itemsDir = path.join(this.bankDir, 'items');
    this.snapshotsDir = path.join(this.bankDir, 'snapshots');
    this.statsDir = path.join(this.bankDir, 'stats');
  }

  /**
   * åˆå§‹åŒ– Context Bank
   */
  async initialize(): Promise<void> {
    await fs.mkdir(this.bankDir, { recursive: true });
    await fs.mkdir(this.itemsDir, { recursive: true });
    await fs.mkdir(this.snapshotsDir, { recursive: true });
    await fs.mkdir(this.statsDir, { recursive: true });

    // åˆå§‹åŒ–ç´¢å¼•æ–‡ä»¶
    try {
      await fs.access(this.indexPath);
    } catch {
      // å¦‚æœç´¢å¼•æ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªç©ºçš„
      await this.saveIndex([]);
    }
  }

  /**
   * ä» ContextBuffer å¯¼å‡ºé«˜ä»·å€¼ä¸Šä¸‹æ–‡åˆ°é“¶è¡Œ
   */
  async exportFromContextBuffer(contextBuffer: { export(): ContextItem[] }, projectScope?: string): Promise<void> {
    const items = contextBuffer.export();
    const highValueItems = this.filterHighValueItems(items);

    for (const item of highValueItems) {
      // æ·»åŠ é¡¹ç›®ä½œç”¨åŸŸä¿¡æ¯
      const bankItem: BankContextItem = {
        ...item,
        id: `bank_${randomUUID()}`,
        stableId: item.stableId || item.path, // ç¡®ä¿ stableId å­˜åœ¨
        source: projectScope ? 'project' : 'global',
        projectScope,
        firstSeenAt: Date.now(),
        lastUsedAt: Date.now()
      };

      await this.upsertItem(bankItem);
    }
  }

  /**
   * è¿‡æ»¤é«˜ä»·å€¼ ContextItem
   */
  private filterHighValueItems(items: ContextItem[]): ContextItem[] {
    return items.filter(item => {
      if (!item.importance) return false;

      const { useCount, successCount } = item.importance;
      const totalInteractions = useCount + item.importance.failureCount;
      const successRate = totalInteractions > 0 ? successCount / totalInteractions : 0;

      // è§¦å‘æ¡ä»¶ï¼šä½¿ç”¨æ¬¡æ•°â‰¥3 ä¸” æˆåŠŸç‡â‰¥0.6
      return useCount >= 3 && successRate >= 0.6;
    });
  }

  /**
   * æ’å…¥æˆ–æ›´æ–°é“¶è¡Œä¸­çš„é¡¹ç›®
   */
  async upsertItem(item: BankContextItem): Promise<void> {
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒ stableId çš„é¡¹ç›®
    const existingItems = await this.loadIndex();
    const existingIndex = existingItems.findIndex(idx => idx.stableId === item.stableId);

    if (existingIndex !== -1) {
      // æ›´æ–°ç°æœ‰é¡¹ç›®
      const existingItemPath = path.join(this.itemsDir, `${existingItems[existingIndex].id}.json`);
      const existingItem: BankContextItem = JSON.parse(await fs.readFile(existingItemPath, 'utf-8'));

      // åˆå¹¶é‡è¦æ€§ç»Ÿè®¡
      if (item.importance && existingItem.importance) {
        existingItem.importance.useCount += item.importance.useCount;
        existingItem.importance.successCount += item.importance.successCount;
        existingItem.importance.failureCount += item.importance.failureCount;
        existingItem.importance.confidence = Math.max(
          existingItem.importance.confidence,
          item.importance.confidence
        );
      }

      // æ›´æ–°æœ€åä½¿ç”¨æ—¶é—´
      existingItem.lastUsedAt = Math.max(existingItem.lastUsedAt, item.lastUsedAt);
      
      // æ›´æ–°å†…å®¹ï¼ˆå¦‚æœå†…å®¹ä¸åŒï¼‰
      if (item.content !== existingItem.content) {
        existingItem.content = item.content;
        existingItem.tokens = item.tokens;
        existingItem.summary = item.summary;
        existingItem.summarized = item.summarized;
      }

      // ä¿å­˜æ›´æ–°åçš„é¡¹ç›®
      await fs.writeFile(existingItemPath, JSON.stringify(existingItem, null, 2));
      
      // æ›´æ–°ç´¢å¼•
      existingItems[existingIndex] = {
        id: existingItem.id,
        path: existingItem.path,
        stableId: existingItem.stableId,
        type: existingItem.type,
        confidence: computeContextImportance(existingItem.importance!),
        useCount: existingItem.importance?.useCount || 0,
        lastUsed: existingItem.lastUsedAt,
        tags: existingItem.tags,
        projectScope: existingItem.projectScope
      };
    } else {
      // æ·»åŠ æ–°é¡¹ç›®
      const itemId = item.id || `bank_${randomUUID()}`;
      const itemPath = path.join(this.itemsDir, `${itemId}.json`);

      await fs.writeFile(itemPath, JSON.stringify(item, null, 2));

      // æ·»åŠ åˆ°ç´¢å¼•
      const indexEntry: BankIndexEntry = {
        id: itemId,
        path: item.path,
        stableId: item.stableId,
        type: item.type,
        confidence: computeContextImportance(item.importance!),
        useCount: item.importance?.useCount || 0,
        lastUsed: item.lastUsedAt,
        tags: item.tags,
        projectScope: item.projectScope
      };

      existingItems.push(indexEntry);
    }

    await this.saveIndex(existingItems);
  }

  /**
   * æ ¹æ®æŸ¥è¯¢é€‰é¡¹ä»é“¶è¡Œæ£€ç´¢ä¸Šä¸‹æ–‡
   */
  async query(options: BankQueryOptions): Promise<BankContextItem[]> {
    const index = await this.loadIndex();
    let filteredIndex = [...index];

    // è¿‡æ»¤é¡¹ç›®ä½œç”¨åŸŸ
    if (options.projectScope) {
      filteredIndex = filteredIndex.filter(item => 
        item.projectScope === options.projectScope || item.source === 'global'
      );
    }

    // è¿‡æ»¤æ ‡ç­¾
    if (options.tags && options.tags.length > 0) {
      filteredIndex = filteredIndex.filter(item => 
        item.tags && options.tags?.every(tag => item.tags?.includes(tag))
      );
    }

    // æ ¹æ®ç­–ç•¥æ’åº
    switch (options.strategy || 'ranked') {
      case 'ranked':
        filteredIndex.sort((a, b) => b.confidence - a.confidence);
        break;
      case 'recent':
        filteredIndex.sort((a, b) => b.lastUsed - a.lastUsed);
        break;
      case 'relevance':
        // ç®€å•çš„ç›¸å…³æ€§è®¡ç®—ï¼šåŸºäºè·¯å¾„åŒ¹é…
        if (options.input) {
          filteredIndex.sort((a, b) => {
            const aRelevance = this.calculateRelevance(a.path, options.input!);
            const bRelevance = this.calculateRelevance(b.path, options.input!);
            return bRelevance - aRelevance;
          });
        }
        break;
    }

    // é™åˆ¶è¿”å›æ•°é‡
    if (options.limit) {
      filteredIndex = filteredIndex.slice(0, options.limit);
    }

    // åŠ è½½åŒ¹é…çš„é¡¹ç›®
    const results: BankContextItem[] = [];
    for (const entry of filteredIndex) {
      try {
        const itemPath = path.join(this.itemsDir, `${entry.id}.json`);
        const item: BankContextItem = JSON.parse(await fs.readFile(itemPath, 'utf-8'));
        results.push(item);
      } catch (error) {
        console.warn(`[ContextBank] Failed to load item ${entry.id}:`, error);
      }
    }

    return results;
  }

  /**
   * è®¡ç®—è·¯å¾„ä¸è¾“å…¥çš„ç›¸å…³æ€§
   */
  private calculateRelevance(itemPath: string, input: string): number {
    const pathLower = itemPath.toLowerCase();
    const inputLower = input.toLowerCase();
    
    // è®¡ç®—å…³é”®è¯åŒ¹é…åº¦
    const inputWords = inputLower.split(/\W+/).filter(Boolean);
    const matches = inputWords.filter(word => pathLower.includes(word)).length;
    
    return matches / inputWords.length; // è¿”å›åŒ¹é…æ¯”ä¾‹
  }

  /**
   * åŠ è½½ç´¢å¼•
   */
  private async loadIndex(): Promise<BankIndexEntry[]> {
    try {
      const content = await fs.readFile(this.indexPath, 'utf-8');
      const data = JSON.parse(content);

      if (!data || data.version !== '1.0' || !Array.isArray(data.items)) {
        throw new Error('Invalid ContextBank index format');
      }

      return data.items;
    } catch (error) {
      console.warn(`[ContextBank] Failed to load index:`, error);
      return [];
    }
  }

  /**
   * ä¿å­˜ç´¢å¼•
   */
  private async saveIndex(index: BankIndexEntry[]): Promise<void> {
    const data = {
      version: '1.0',
      updatedAt: Date.now(),
      items: index
    };
    await fs.writeFile(this.indexPath, JSON.stringify(data, null, 2));
  }

  /**
   * è·å–é“¶è¡Œç»Ÿè®¡ä¿¡æ¯
   */
  async getStats(): Promise<BankStats> {
    const index = await this.loadIndex();
    let totalTokens = 0;

    for (const entry of index) {
      try {
        const itemPath = path.join(this.itemsDir, `${entry.id}.json`);
        const item: BankContextItem = JSON.parse(await fs.readFile(itemPath, 'utf-8'));
        totalTokens += item.tokens;
      } catch (error) {
        console.warn(`[ContextBank] Failed to load item for stats ${entry.id}:`, error);
      }
    }

    // è·å–ä½¿ç”¨æ—¥å¿—å¤§å°
    let usageLogSize = 0;
    try {
      const usageLogPath = path.join(this.statsDir, 'usage.log');
      const stat = await fs.stat(usageLogPath);
      usageLogSize = stat.size;
    } catch {
      // å¦‚æœæ—¥å¿—æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå¤§å°ä¸º0
    }

    return {
      totalItems: index.length,
      totalTokens,
      lastUpdated: Date.now(), // å®é™…ä¸Šåº”è¯¥æ˜¯ç´¢å¼•æ–‡ä»¶çš„ä¿®æ”¹æ—¶é—´
      usageLogSize
    };
  }

  /**
   * åˆ›å»ºé“¶è¡Œå¿«ç…§
   */
  async createSnapshot(name?: string): Promise<string> {
    const snapshotName = name || `snapshot_${Date.now()}`;
    const snapshotPath = path.join(this.snapshotsDir, `${snapshotName}.json`);
    
    const index = await this.loadIndex();
    const snapshot = {
      name: snapshotName,
      createdAt: Date.now(),
      items: [] as BankContextItem[]
    };

    for (const entry of index) {
      try {
        const itemPath = path.join(this.itemsDir, `${entry.id}.json`);
        const item: BankContextItem = JSON.parse(await fs.readFile(itemPath, 'utf-8'));
        snapshot.items.push(item);
      } catch (error) {
        console.warn(`[ContextBank] Failed to load item for snapshot ${entry.id}:`, error);
      }
    }

    await fs.writeFile(snapshotPath, JSON.stringify(snapshot, null, 2));
    return snapshotPath;
  }

  /**
   * ä»å¿«ç…§æ¢å¤é“¶è¡Œ
   */
  async restoreFromSnapshot(snapshotName: string): Promise<void> {
    const snapshotPath = path.join(this.snapshotsDir, `${snapshotName}.json`);
    const snapshotContent = await fs.readFile(snapshotPath, 'utf-8');
    const snapshot = JSON.parse(snapshotContent);

    // æ¸…ç©ºå½“å‰é¡¹ç›®
    const files = await fs.readdir(this.itemsDir);
    for (const file of files) {
      if (file.endsWith('.json')) {
        await fs.unlink(path.join(this.itemsDir, file));
      }
    }

    // æ¢å¤é¡¹ç›®
    for (const item of snapshot.items) {
      const itemPath = path.join(this.itemsDir, `${item.id}.json`);
      await fs.writeFile(itemPath, JSON.stringify(item, null, 2));
    }

    // é‡å»ºç´¢å¼•
    const newIndex: BankIndexEntry[] = snapshot.items.map((item: BankContextItem) => ({
      id: item.id,
      path: item.path,
      type: item.type,
      confidence: computeContextImportance(item.importance!),
      useCount: item.importance?.useCount || 0,
      lastUsed: item.lastUsedAt,
      tags: item.tags,
      projectScope: item.projectScope
    }));

    await this.saveIndex(newIndex);
  }

  /**
   * è®°å½•ä½¿ç”¨æƒ…å†µ
   */
  async recordUsage(identifier: string, success: boolean): Promise<void> {
    // é¦–å…ˆå°è¯•æŒ‰ ID æŸ¥æ‰¾é¡¹ç›®
    let itemPath = path.join(this.itemsDir, `${identifier}.json`);
    let itemExists = false;
    let actualId = identifier;

    try {
      await fs.access(itemPath);
      itemExists = true;
    } catch {
      // ID ä¸å­˜åœ¨ï¼Œå°è¯•æŒ‰è·¯å¾„æŸ¥æ‰¾
      const index = await this.loadIndex();
      let indexEntry = index.find(entry => entry.path === identifier);

      // å¦‚æœè¿˜æ˜¯æ‰¾ä¸åˆ°ï¼Œå°è¯•æŒ‰ stableId æŸ¥æ‰¾
      if (!indexEntry) {
        indexEntry = index.find(entry => entry.stableId === identifier);
      }

      if (indexEntry) {
        itemPath = path.join(this.itemsDir, `${indexEntry.id}.json`);
        actualId = indexEntry.id; // ä½¿ç”¨å®é™…çš„ ID
        itemExists = true;
      }
    }

    if (!itemExists) {
      console.warn(`[ContextBank] Item with identifier "${identifier}" not found`);
      return;
    }

    try {
      const item: BankContextItem = JSON.parse(await fs.readFile(itemPath, 'utf-8'));

      if (item.importance) {
        item.importance.useCount++;
        if (success) {
          item.importance.successCount++;
          item.importance.confidence = Math.min(1, item.importance.confidence + 0.05);
        } else {
          item.importance.failureCount++;
          item.importance.confidence = Math.max(0, item.importance.confidence - 0.1);
        }
        item.lastUsedAt = Date.now();
      }

      await fs.writeFile(itemPath, JSON.stringify(item, null, 2));

      // æ›´æ–°ç´¢å¼•
      const index = await this.loadIndex();
      const indexEntry = index.find(entry => entry.id === actualId);
      if (indexEntry) {
        indexEntry.useCount = item.importance?.useCount || 0;
        indexEntry.lastUsed = item.lastUsedAt;
        indexEntry.confidence = computeContextImportance(item.importance!);
        await this.saveIndex(index);
      }
    } catch (error) {
      console.warn(`[ContextBank] Failed to update usage for item ${identifier}:`, error);
    }

    // è®°å½•åˆ°ä½¿ç”¨æ—¥å¿—
    const logPath = path.join(this.statsDir, 'usage.log');
    const logEntry = {
      timestamp: Date.now(),
      itemId: actualId,
      success,
      userAgent: 'ContextBank/v1'
    };

    try {
      await fs.appendFile(logPath, JSON.stringify(logEntry) + '\n');
    } catch (error) {
      console.warn('[ContextBank] Failed to write to usage log:', error);
    }
  }

  /**
   * æ¸…ç†è¿‡æœŸæˆ–ä½ä»·å€¼é¡¹ç›®
   */
  async cleanup(options: {
    minConfidence?: number;
    maxAgeDays?: number;
    dryRun?: boolean
  } = {}): Promise<number> {
    const {
      minConfidence = 0.3,
      maxAgeDays = 180,
      dryRun = false
    } = options;

    const index = await this.loadIndex();
    const cutoffTime = Date.now() - (maxAgeDays * 24 * 60 * 60 * 1000);
    let cleanedCount = 0;

    const remainingIndex: BankIndexEntry[] = [];

    for (const entry of index) {
      try {
        const itemPath = path.join(this.itemsDir, `${entry.id}.json`);
        const item: BankContextItem = JSON.parse(await fs.readFile(itemPath, 'utf-8'));

        // æ£€æŸ¥æ˜¯å¦åº”è¯¥ä¿ç•™è¯¥é¡¹ç›®
        const isHighConfidence = entry.confidence >= minConfidence;
        const isRecentlyUsed = entry.lastUsed >= cutoffTime;
        const isFrozen = item.frozen === true;
        const isDeprecated = item.deprecated === true;

        const shouldKeep = isHighConfidence || isRecentlyUsed || isFrozen || isDeprecated;

        if (!shouldKeep && !dryRun) {
          // åˆ é™¤é¡¹ç›®æ–‡ä»¶
          await fs.unlink(itemPath);
          cleanedCount++;
        } else {
          // ä¿ç•™é¡¹ç›®
          remainingIndex.push(entry);
        }
      } catch (error) {
        console.warn(`[ContextBank] Failed to evaluate item for cleanup ${entry.id}:`, error);
        // å¦‚æœæ— æ³•è¯»å–é¡¹ç›®ï¼Œä¿ç•™å®ƒä»¥é˜²ä¸‡ä¸€
        remainingIndex.push(entry);
      }
    }

    if (!dryRun) {
      await this.saveIndex(remainingIndex);
    }

    return cleanedCount;
  }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/contextBuffer.ts

````typescript
import { randomUUID } from 'crypto';
import { ContextImportance, createContextImportance, computeContextImportance } from './contextImportance';
import { summarizeContext } from './contextSummary';
import { ExtendedContextProtocol, DSLQueryEngine, DSLParser } from './contextDSL';
import { recordEdge } from './knowledgeGraph';
import crypto from 'crypto';

function computeStableId(item: {
    path: string;
    semantic?: string;
    content: string;
}) {
    const sig = `${item.path}::${item.semantic ?? ''}::${item.content.slice(0, 512)}`;
    return crypto.createHash('sha256').update(sig).digest('hex');
}

export type ContextItem = {
    schemaVersion?: 1; // Schema ç‰ˆæœ¬
    type: 'file' | 'directory';
    path: string;
    id?: string;
    stableId?: string;   // ç¨³å®šèº«ä»½ï¼ˆè·¨ sessionï¼‰
    importance?: ContextImportance;
    alias?: string;
    content: string;
    summary?: string;
    summarized?: boolean;
    tokens: number;
    // å¼•ç”¨åè®®ç›¸å…³å­—æ®µ
    semantic?: 'source_code' | 'log' | 'config' | 'decision' | 'evidence' | 'documentation' | 'test' | 'requirement';
    summaryQuality?: number; // æ‘˜è¦è´¨é‡è¯„åˆ† (0-1)
    summarySourceHash?: string; // æ‘˜è¦æ¥æºå†…å®¹çš„å“ˆå¸Œå€¼
    referencedBy?: string[]; // å¼•ç”¨æ­¤ContextItemçš„AIå“åº”IDåˆ—è¡¨
    usageStats?: {
        referencedCount: number; // è¢«æ˜¾å¼å¼•ç”¨çš„æ¬¡æ•°
        verifiedUseful: number; // ç»éªŒè¯æœ‰ç”¨çš„å¼•ç”¨æ¬¡æ•°
        verifiedNotUseful: number; // ç»éªŒè¯æ— ç”¨çš„å¼•ç”¨æ¬¡æ•°
    };
    tags?: string[]; // æ ‡ç­¾
    projectScope?: string; // é¡¹ç›®ä½œç”¨åŸŸ
    metadata?: {
        promotedToSkill?: boolean;
        bankItemId?: string;
        source?: string;
    }; // å…ƒæ•°æ®
};

export type InjectionStrategy = 'ranked' | 'recent' | 'all';

export interface BuildPromptOptions {
    maxTokens?: number;
    strategy?: InjectionStrategy;
}

const estimateTokens = (text: string) => Math.ceil(text.length / 4);

export class ContextBuffer {
    private items: ContextItem[] = [];
    private maxTokens = 32000; // çº¦ 12.8 ä¸‡å­—ç¬¦

    async addAsync(item: Omit<ContextItem, 'tokens'>, bypassTokenLimit: boolean = false) {
        const tokens = estimateTokens(item.content);
        this.items.push({
            ...item,
            schemaVersion: item.schemaVersion ?? 1,
            stableId: item.stableId ?? computeStableId(item),
            id: item.id ?? randomUUID(),
            importance: item.importance ?? createContextImportance(item.path, item.type),
            tokens,
            usageStats: item.usageStats ?? {
                referencedCount: 0,
                verifiedUseful: 0,
                verifiedNotUseful: 0
            }
        });
        if (!bypassTokenLimit) {
            await this.trimIfNeeded();
        }
    }

    add(item: Omit<ContextItem, 'tokens'>, bypassTokenLimit: boolean = false) {
        const tokens = estimateTokens(item.content);
        this.items.push({
            ...item,
            schemaVersion: item.schemaVersion ?? 1,
            stableId: item.stableId ?? computeStableId(item),
            id: item.id ?? randomUUID(),
            importance: item.importance ?? createContextImportance(item.path, item.type),
            tokens,
            usageStats: item.usageStats ?? {
                referencedCount: 0,
                verifiedUseful: 0,
                verifiedNotUseful: 0
            }
        });
        if (!bypassTokenLimit) {
            // å¯¹äºåŒæ­¥æ–¹æ³•ï¼Œæˆ‘ä»¬åªåšåŸºæœ¬ä¿®å‰ªï¼ˆä¸è¿›è¡Œæ‘˜è¦ï¼‰
            this.basicTrimIfNeeded();
        }
    }

    private basicTrimIfNeeded() {
        while (this.totalTokens() > this.maxTokens) {
            // æŒ‰é‡è¦æ€§è¯„åˆ†æ’åºï¼Œä½é‡è¦æ€§çš„åœ¨å‰é¢
            this.items.sort((a, b) =>
                computeContextImportance(a.importance!) -
                computeContextImportance(b.importance!)
            );

            const removed = this.items.shift();

            if (removed) {
                console.log(
                    `[Context Trim] removed low-importance: ${removed.path}`
                );
            }
        }
    }

    clear() {
        this.items = [];
    }

    list() {
        return this.items.map((item, i) => ({
            index: i + 1,
            type: item.type,
            path: item.path,
            alias: item.alias,
            tokens: item.tokens,
            summary: item.summary
        }));
    }

    isEmpty() {
        return this.items.length === 0;
    }

    export() {
        return this.items;
    }

    import(items: ContextItem[]) {
        this.items = items;
    }

    private totalTokens() {
        return this.items.reduce((sum, i) => sum + i.tokens, 0);
    }

    private async trimIfNeeded() {
        while (this.totalTokens() > this.maxTokens) {
            // 1. æ‰¾ä¸€ä¸ªã€Œå°šæœª summaryã€ä¸”é‡è¦æ€§æœ€ä½çš„
            const candidates = this.items
                .filter(i => !i.summarized)
                .sort((a, b) =>
                    computeContextImportance(a.importance!) -
                    computeContextImportance(b.importance!)
                );

            if (candidates.length > 0) {
                const candidate = candidates[0];

                // 2. æ‰§è¡Œ summary
                try {
                    const summary = await summarizeContext({
                        type: candidate.type,
                        path: candidate.path,
                        content: candidate.content
                    });

                    candidate.summary = summary;
                    candidate.summarized = true;

                    // 3. ç”¨ summary é‡æ–°è®¡ç®— token
                    candidate.tokens = estimateTokens(summary);

                    // 4. é‡Šæ”¾åŸå§‹å†…å®¹ä»¥èŠ‚çœå†…å­˜ï¼ˆä¿ç•™åŸå§‹å†…å®¹çš„æ ‡è®°ï¼‰
                    const originalContentSize = estimateTokens(candidate.content);
                    candidate.content = `[ARCHIVED: Original content was ${originalContentSize} tokens, summarized to ${candidate.tokens} tokens]`;

                    console.log(
                        `[Context Summary] ${candidate.path} reduced from ${originalContentSize} to ${candidate.tokens} tokens`
                    );

                    continue; // é‡æ–°è¯„ä¼°tokenæ•°é‡
                } catch (error) {
                    console.warn(`[Context Summary] Failed to summarize ${candidate.path}:`, error);
                }
            }

            // å¦‚æœæ²¡æœ‰å¯æ‘˜è¦çš„é¡¹æˆ–æ‘˜è¦å¤±è´¥ï¼Œåˆ™æŒ‰é‡è¦æ€§åˆ é™¤
            this.items.sort((a, b) =>
                computeContextImportance(a.importance!) -
                computeContextImportance(b.importance!)
            );

            const removed = this.items.shift();

            if (removed) {
                console.log(
                    `[Context Trim] removed low-importance: ${removed.path}`
                );
            }
        }
    }

    /**
     * è®°å½•ContextItemè¢«æ˜¾å¼å¼•ç”¨
     * @param path ContextItemçš„è·¯å¾„
     * @param responseId å¼•ç”¨è¯¥ContextItemçš„AIå“åº”ID
     */
    recordExplicitReference(path: string, responseId?: string) {
        const item = this.items.find(i => i.path === path);
        if (item) {
            if (!item.usageStats) {
                item.usageStats = {
                    referencedCount: 0,
                    verifiedUseful: 0,
                    verifiedNotUseful: 0
                };
            }
            item.usageStats.referencedCount++;

            if (responseId) {
                if (!item.referencedBy) {
                    item.referencedBy = [];
                }
                if (!item.referencedBy.includes(responseId)) {
                    item.referencedBy.push(responseId);
                }

                // === C5-B-1: Knowledge Graph Record (Context -> Execution) ===
                if (item.id) {
                    recordEdge({
                        from: item.id,
                        to: responseId, // ä½¿ç”¨ AI å“åº” ID ä½œä¸ºæ‰§è¡ŒèŠ‚ç‚¹çš„ä»£ç† ID
                        type: 'used_in',
                        timestamp: Date.now(),
                        meta: { path: item.path, type: item.type }
                    });
                }
            }

            // åŒæ—¶æ›´æ–°importanceä¸­çš„useCount
            if (item.importance) {
                item.importance.useCount++;
                item.importance.lastUsed = Date.now();
            }
        }
    }

    /**
     * éªŒè¯ContextItemå¼•ç”¨çš„æœ‰æ•ˆæ€§
     * @param path ContextItemçš„è·¯å¾„
     * @param wasUseful å¼•ç”¨æ˜¯å¦è¢«è¯æ˜æœ‰ç”¨
     */
    validateReference(path: string, wasUseful: boolean) {
        const item = this.items.find(i => i.path === path);
        if (item && item.usageStats) {
            if (wasUseful) {
                item.usageStats.verifiedUseful++;
            } else {
                item.usageStats.verifiedNotUseful++;
            }
        }
    }

    /**
     * è®¡ç®—ContextItemçš„ç»¼åˆè¯„åˆ†
     * @param item ContextItem
     * @returns è¯„åˆ†å€¼
     */
    private computeItemScore(item: ContextItem): number {
        if (!item.importance) {
            return 0.5;
        }

        let baseScore = computeContextImportance(item.importance);

        // âœ… æ ¸å¿ƒä¿®å¤ï¼šå¦‚æœæ–‡ä»¶è¢«æ ‡è®°ä¸ºç”¨æˆ·æ˜¾å¼å¼•ç”¨ï¼Œç»™äºˆæé«˜çš„åŸºç¡€åˆ†
        if (item.tags?.includes('user-referenced') || item.tags?.includes('explicit') || item.tags?.includes('user-selected')) {
            baseScore = Math.max(baseScore, 10.0); // å³ä½¿ baseScore å¾ˆä½ï¼Œä¹Ÿå¼ºè¡Œæ‹‰é«˜åˆ° 10.0
        }

        // ä½¿ç”¨æ¬¡æ•°çš„å½±å“
        const useFactor = Math.log(2 + item.importance.useCount);

        // æ–°é²œåº¦è¡°å‡ï¼ˆæœ€è¿‘ä½¿ç”¨çš„é¡¹ç›®è·å¾—æ›´é«˜è¯„åˆ†ï¼‰
        const now = Date.now();
        const daysSinceLastUse = (now - item.importance.lastUsed) / (1000 * 60 * 60 * 24);
        const freshnessFactor = Math.exp(-daysSinceLastUse / 7);

        // æ˜¾å¼å¼•ç”¨çš„å½±å“ (å¢åŠ æƒé‡æ¯”ä¾‹)
        const explicitReferenceFactor = item.usageStats ?
            item.usageStats.referencedCount : 0;

        // âœ… å¢åŠ ä¸€ä¸ªå·¨å¤§çš„å€ç‡ç»™ç”¨æˆ·æ˜¾å¼å¼•ç”¨çš„æ–‡ä»¶
        const userExplicitMultiplier = (item.tags?.includes('user-referenced') || item.tags?.includes('explicit') || item.tags?.includes('user-selected')) ? 100 : 1;

        return baseScore * useFactor * freshnessFactor * (1 + explicitReferenceFactor) * userExplicitMultiplier;
    }

    /**
     * æ ¹æ®ç­–ç•¥å¯¹ContextItemsè¿›è¡Œæ’åº
     * @param items ContextItemæ•°ç»„
     * @param strategy æ’åºç­–ç•¥
     * @returns æ’åºåçš„æ•°ç»„
     */
    private sortItemsByStrategy(items: ContextItem[], strategy: InjectionStrategy): ContextItem[] {
        switch (strategy) {
            case 'ranked':
                // æŒ‰ç»¼åˆè¯„åˆ†é™åºæ’åˆ—
                return [...items].sort((a, b) =>
                    this.computeItemScore(b) - this.computeItemScore(a)
                );
            case 'recent':
                // æŒ‰æœ€è¿‘ä½¿ç”¨æ—¶é—´é™åºæ’åˆ—
                return [...items].sort((a, b) =>
                    (b.importance?.lastUsed || 0) - (a.importance?.lastUsed || 0)
                );
            case 'all':
            default:
                // ä¿æŒåŸæœ‰é¡ºåº
                return [...items];
        }
    }

    buildPrompt(userInput: string, options: BuildPromptOptions = {}): string {
        const { maxTokens, strategy = 'ranked' } = options;

        console.log(`[ContextBuffer] buildPrompt called with:`, {
            userInput: userInput?.substring(0, 50) || '(empty)',
            maxTokens,
            strategy,
            totalItems: this.items.length,
            isEmpty: this.isEmpty()
        });

        if (this.isEmpty()) {
            console.log(`[ContextBuffer] ContextBuffer is EMPTY, returning userInput only`);
            return userInput;
        }

        // æ ¹æ®ç­–ç•¥æ’åºitems
        const sortedItems = this.sortItemsByStrategy([...this.items], strategy);
        console.log(`[ContextBuffer] Items sorted by ${strategy}. Top 5 items:`);
        sortedItems.slice(0, 5).forEach((item, idx) => {
            console.log(`[ContextBuffer]   ${idx + 1}. ${item.alias || item.path}`, {
                confidence: item.importance?.confidence,
                tags: item.tags,
                contentLength: item.content?.length || 0
            });
        });

        // å¦‚æœæŒ‡å®šäº†maxTokensï¼Œæˆ‘ä»¬éœ€è¦æˆªæ–­å†…å®¹ä»¥æ»¡è¶³é™åˆ¶
        let filteredItems = sortedItems;
        if (maxTokens) {
            filteredItems = [];
            let currentTokens = 0;

            for (const item of sortedItems) {
                if (currentTokens + item.tokens > maxTokens) {
                    break;
                }
                filteredItems.push(item);
                currentTokens += item.tokens;
            }
        }

        // æŒ‰é‡è¦æ€§å’Œè¯­ä¹‰ç±»å‹åˆ†ç»„
        const highConfidenceItems = filteredItems.filter(item =>
            item.importance && computeContextImportance(item.importance) > 0.7
        );
        const mediumConfidenceItems = filteredItems.filter(item =>
            item.importance &&
            computeContextImportance(item.importance) > 0.3 &&
            computeContextImportance(item.importance) <= 0.7
        );
        const lowConfidenceItems = filteredItems.filter(item =>
            !item.importance || computeContextImportance(item.importance) <= 0.3
        );

        // æ„å»ºä¸åŒéƒ¨åˆ†çš„ä¸Šä¸‹æ–‡
        const sections = [];

        if (highConfidenceItems.length > 0) {
            // æŒ‰è¯­ä¹‰ç±»å‹è¿›ä¸€æ­¥ç»†åˆ†é«˜ç½®ä¿¡åº¦é¡¹
            const semanticGroups: Record<string, typeof highConfidenceItems> = {};
            for (const item of highConfidenceItems) {
                const semantic = item.semantic || 'other';
                if (!semanticGroups[semantic]) {
                    semanticGroups[semantic] = [];
                }
                semanticGroups[semantic].push(item);
            }

            for (const [semantic, items] of Object.entries(semanticGroups)) {
                const semanticBlock = items.map(item => {
                    const title = item.alias
                        ? `[Reference] ${item.type}: ${item.alias} (${item.path})`
                        : `[Reference] ${item.type}: ${item.path}`;

                    // âœ… æ ¸å¿ƒä¿®å¤ï¼šå¯¹äºé«˜ç½®ä¿¡åº¦æˆ–æ˜¾å¼å¼•ç”¨çš„é¡¹ï¼Œé™¤éå†…å®¹è¢«å½’æ¡£ï¼Œå¦åˆ™ä¼˜å…ˆæ˜¾ç¤ºå®Œæ•´ content
                    // åŸé€»è¾‘æ˜¯ item.summary ?? item.contentï¼Œè¿™ä¼šå¯¼è‡´æœ‰æ‘˜è¦æ—¶ AI çœ‹ä¸åˆ°ç»†èŠ‚
                    const isUserReferenced = item.tags?.includes('user-referenced') || item.tags?.includes('explicit') || item.tags?.includes('user-selected');
                    const isArchived = item.content?.includes('[ARCHIVED:');

                    const body = (isUserReferenced && !isArchived) ? item.content : (item.summary ?? item.content);

                    return `${title}\n---\n${body}\n---`;
                }).join('\n\n');

                sections.push(`# Background Knowledge (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - High Confidence)\n${semanticBlock}`);
            }
        }

        if (mediumConfidenceItems.length > 0) {
            // æŒ‰è¯­ä¹‰ç±»å‹è¿›ä¸€æ­¥ç»†åˆ†ä¸­ç½®ä¿¡åº¦é¡¹
            const semanticGroups: Record<string, typeof mediumConfidenceItems> = {};
            for (const item of mediumConfidenceItems) {
                const semantic = item.semantic || 'other';
                if (!semanticGroups[semantic]) {
                    semanticGroups[semantic] = [];
                }
                semanticGroups[semantic].push(item);
            }

            for (const [semantic, items] of Object.entries(semanticGroups)) {
                const semanticBlock = items.map(item => {
                    const title = item.alias
                        ? `[Reference] ${item.type}: ${item.alias} (${item.path})`
                        : `[Reference] ${item.type}: ${item.path}`;

                    const body = item.summary ?? item.content;

                    return `${title}\n---\n${body}\n---`;
                }).join('\n\n');

                sections.push(`# Supporting Information (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - Medium Confidence)\n${semanticBlock}`);
            }
        }

        if (lowConfidenceItems.length > 0) {
            // æŒ‰è¯­ä¹‰ç±»å‹è¿›ä¸€æ­¥ç»†åˆ†ä½ç½®ä¿¡åº¦é¡¹
            const semanticGroups: Record<string, typeof lowConfidenceItems> = {};
            for (const item of lowConfidenceItems) {
                const semantic = item.semantic || 'other';
                if (!semanticGroups[semantic]) {
                    semanticGroups[semantic] = [];
                }
                semanticGroups[semantic].push(item);
            }

            for (const [semantic, items] of Object.entries(semanticGroups)) {
                const semanticBlock = items.map(item => {
                    const title = item.alias
                        ? `[Reference] ${item.type}: ${item.alias} (${item.path})`
                        : `[Reference] ${item.type}: ${item.path}`;

                    const body = item.summary ?? item.content;

                    return `${title}\n---\n${body}\n---`;
                }).join('\n\n');

                sections.push(`# Archived References (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - Low Confidence)\n${semanticBlock}`);
            }
        }

        const contextBlock = sections.join('\n\n');
        return contextBlock;
    }

    /**
     * ä½¿ç”¨ DSL æŸ¥è¯¢ä¸Šä¸‹æ–‡
     */
    async queryDSL(dslQuery: string, contextBank?: import('./contextBank').ContextBank): Promise<ContextItem[]> {
        const parsedQuery = DSLParser.parse(dslQuery);
        const engine = new DSLQueryEngine(this.items);
        const result = engine.execute(parsedQuery);

        let matchingItems = result.items;

        // å¦‚æœæä¾›äº† ContextBankï¼Œä¹ŸæŸ¥è¯¢é“¶è¡Œä¸­çš„é¡¹ç›®
        if (contextBank) {
            try {
                // å°† DSL æŸ¥è¯¢è½¬æ¢ä¸º ContextBank æŸ¥è¯¢é€‰é¡¹
                const bankQueryOptions: import('./contextBank').BankQueryOptions = {
                    input: dslQuery,
                    strategy: 'relevance',
                    limit: 10 // é™åˆ¶ä»é“¶è¡Œè¿”å›çš„æ•°é‡
                };

                // æ‰§è¡Œé“¶è¡ŒæŸ¥è¯¢
                const bankResults = await contextBank.query(bankQueryOptions);
                matchingItems = [...matchingItems, ...bankResults];
            } catch (error) {
                console.warn(`[ContextBuffer] Could not query ContextBank: ${error}`);
            }
        }

        return matchingItems;
    }

    /**
     * è§£æåŒ…å« DSL çš„ç”¨æˆ·è¾“å…¥å¹¶è·å–ç›¸å…³ä¸Šä¸‹æ–‡
     */
    async getDSLContextForInput(input: string, contextBank?: import('./contextBank').ContextBank): Promise<ContextItem[]> {
        const { dslQueries } = ExtendedContextProtocol.parseUserInput(input);
        let allMatchingItems: ContextItem[] = [];

        for (const query of dslQueries) {
            const matchingItems = await this.queryDSL(query, contextBank);
            allMatchingItems = [...allMatchingItems, ...matchingItems];
        }

        // å»é‡
        const uniqueItems = allMatchingItems.filter((item, index, self) =>
            index === self.findIndex(i => i.path === item.path)
        );

        return uniqueItems;
    }
}
// Test change for git diff
// Another test change (unstaged)

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/contextDSL.ts

````typescript
/**
 * Context å¼•ç”¨ DSL v2
 *
 * åœ¨ v1 åŸºç¡€ä¸Šå¢åŠ äº†æ›´ä¸°å¯Œçš„æŸ¥è¯¢å’Œè¿‡æ»¤åŠŸèƒ½
 */

import { ContextItem } from './contextBuffer';
import { ContextReference } from './contextProtocol';
import { computeContextImportance } from './contextImportance';

export interface DSLQuery {
  /** åŸºç¡€è·¯å¾„åŒ¹é… */
  path?: string;

  /** è·¯å¾„æ¨¡å¼åŒ¹é… (æ”¯æŒ glob) */
  pathPattern?: string;

  /** ä¸Šä¸‹æ–‡ç±»å‹ */
  type?: 'file' | 'directory' | 'runtime' | 'generated';

  /** è¯­ä¹‰ç±»å‹ */
  semantic?: 'source_code' | 'log' | 'config' | 'decision' | 'evidence' | 'documentation' | 'test' | 'requirement';

  /** æœ€å°é‡è¦æ€§é˜ˆå€¼ */
  minImportance?: number;

  /** æ ‡ç­¾è¿‡æ»¤ */
  tags?: string[];

  /** æ—¶é—´èŒƒå›´è¿‡æ»¤ */
  timeRange?: {
    from?: number;
    to?: number;
  };

  /** å†…å®¹å…³é”®è¯æœç´¢ */
  keywords?: string[];

  /** é¡¹ç›®ä½œç”¨åŸŸ */
  projectScope?: string;
}

export interface DSLFilterOptions {
  /** æ’åºæ–¹å¼ */
  sortBy?: 'importance' | 'recency' | 'relevance' | 'path';

  /** æ’åºæ–¹å‘ */
  sortOrder?: 'asc' | 'desc';

  /** é™åˆ¶è¿”å›æ•°é‡ */
  limit?: number;

  /** è·³è¿‡æ•°é‡ */
  offset?: number;
}

export interface DSLResult {
  items: ContextItem[];
  total: number;
  queryTime: number;
}

/**
 * DSL è§£æå™¨
 * å°† DSL å­—ç¬¦ä¸²è§£æä¸ºæŸ¥è¯¢å¯¹è±¡
 */
export class DSLParser {
  /**
   * è§£æ DSL æŸ¥è¯¢å­—ç¬¦ä¸²
   */
  static parse(queryString: string): DSLQuery {
    const query: DSLQuery = {};

    // æŒ‰ç©ºæ ¼åˆ†å‰²æŸ¥è¯¢å­—ç¬¦ä¸²
    const parts = queryString.trim().split(/\s+/);

    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      if (part.startsWith('@') || part.startsWith('#')) {
        // å¤„ç†è·¯å¾„å¼•ç”¨
        if (part.startsWith('@!')) {
          // æ‰§è¡Œå‹å¼•ç”¨ï¼Œæš‚ä¸å¤„ç†
          continue;
        } else if (part.startsWith('#')) {
          // ç›®å½•å¼•ç”¨
          // Check if next part exists and doesn't start with special chars - if so, combine them
          if (i + 1 < parts.length && !parts[i + 1].startsWith('@') && !parts[i + 1].startsWith('#') && !parts[i + 1].includes(':')) {
            query.path = parts[++i]; // Use the next part as the path
          } else {
            query.path = part.substring(1);
          }
          query.type = 'directory';
        } else {
          // æ–‡ä»¶å¼•ç”¨
          // Check if next part exists and doesn't start with special chars - if so, combine them
          if (i + 1 < parts.length && !parts[i + 1].startsWith('@') && !parts[i + 1].startsWith('#') && !parts[i + 1].includes(':')) {
            query.path = parts[++i]; // Use the next part as the path
          } else {
            query.path = part.substring(1);
          }
          query.type = 'file';
        }
      } else if (part.includes(':')) {
        // å¤„ç†é”®å€¼å¯¹
        const [key, value] = part.split(':');

        switch (key.toLowerCase()) {
          case 'type':
            if (value === 'file' || value === 'directory' || value === 'runtime' || value === 'generated') {
              query.type = value;
            }
            break;

          case 'semantic':
            if (value === 'source_code' || value === 'log' || value === 'config' ||
                value === 'decision' || value === 'evidence' || value === 'documentation' ||
                value === 'test' || value === 'requirement') {
              query.semantic = value;
            }
            break;

          case 'importance':
            // è§£æé‡è¦æ€§æ¯”è¾ƒæ“ä½œç¬¦
            const importanceMatch = value.match(/^([<>]=?)(\d+(\.\d+)?)$/);
            if (importanceMatch) {
              const [, op, numStr] = importanceMatch;
              const num = parseFloat(numStr);

              if (op === '>' || op === '>=') {
                query.minImportance = num;
              }
            }
            break;

          case 'tag':
          case 'tags':
            if (!query.tags) query.tags = [];
            query.tags.push(value);
            break;

          case 'path':
            query.pathPattern = value;
            break;

          case 'keyword':
          case 'keywords':
            if (!query.keywords) query.keywords = [];
            query.keywords.push(...value.split(','));
            break;

          case 'project':
            query.projectScope = value;
            break;
        }
      }
    }

    return query;
  }
}

/**
 * DSL æŸ¥è¯¢å¼•æ“
 * æ ¹æ®æŸ¥è¯¢æ¡ä»¶è¿‡æ»¤å’Œæ’åº ContextItem
 */
export class DSLQueryEngine {
  constructor(private contextItems: ContextItem[]) {}

  /**
   * æ‰§è¡Œ DSL æŸ¥è¯¢
   */
  execute(query: DSLQuery, options: DSLFilterOptions = {}): DSLResult {
    const startTime = Date.now();

    // åº”ç”¨è¿‡æ»¤å™¨
    let filteredItems = this.applyFilters(this.contextItems, query);

    // åº”ç”¨æ’åº
    filteredItems = this.applySorting(filteredItems, options);

    // åº”ç”¨åˆ†é¡µ
    const total = filteredItems.length;
    filteredItems = this.applyPagination(filteredItems, options);

    const endTime = Date.now();

    return {
      items: filteredItems,
      total,
      queryTime: endTime - startTime
    };
  }

  private applyFilters(items: ContextItem[], query: DSLQuery): ContextItem[] {
    return items.filter(item => {
      // è·¯å¾„åŒ¹é…ï¼ˆä¿®å¤ç‰ˆï¼‰
      if (query.path) {
        // âœ… å¢å¼ºä¿®å¤ï¼šæ ‡å‡†åŒ–è·¯å¾„åˆ†éš”ç¬¦ (ç»Ÿä¸€è½¬ä¸º /)
        // è§£å†³ Windows ä¸‹ path ä¸ºåæ–œæ è€Œ alias ä¸ºæ­£æ–œæ å¯¼è‡´çš„åŒ¹é…å¤±è´¥
        const normalize = (p: string) => p.replace(/\\/g, '/');
        const qPath = normalize(query.path);
        const iPath = normalize(item.path);

        // 1. å°è¯•ç»å¯¹è·¯å¾„ç²¾ç¡®åŒ¹é…
        const exactMatch = iPath === qPath;

        // 2. å°è¯• Alias åŒ¹é… (ç§»é™¤ @ å‰ç¼€æ¯”è¾ƒ)
        const rawAlias = item.alias || '';
        const normAlias = normalize(rawAlias);
        const cleanAlias = normAlias.replace(/^@/, '');
        
        const aliasMatch = normAlias === qPath || cleanAlias === qPath;

        // 3. å°è¯•ç›¸å¯¹è·¯å¾„/åç¼€åŒ¹é… (æ™ºèƒ½åŒ¹é…)
        // å¦‚æœ query.path æ˜¯ "utils.ts"ï¼Œå®ƒåº”è¯¥åŒ¹é… "/.../src/utils.ts"
        const suffixMatch = qPath && (
          iPath.endsWith(qPath) ||
          iPath.endsWith('/' + qPath)
        ) || false;

        // åªè¦æ»¡è¶³ä»»æ„ä¸€ä¸ªæ¡ä»¶ï¼Œå°±ç®—åŒ¹é…æˆåŠŸ
        if (!exactMatch && !aliasMatch && !suffixMatch) {
          return false;
        }
      }

      // è·¯å¾„æ¨¡å¼åŒ¹é… (ç®€åŒ–ç‰ˆ glob)
      if (query.pathPattern) {
        if (!this.matchesGlob(item.path, query.pathPattern)) {
          return false;
        }
      }

      // ç±»å‹åŒ¹é…
      if (query.type && item.type !== query.type) {
        return false;
      }

      // è¯­ä¹‰ç±»å‹åŒ¹é…
      if (query.semantic && item.semantic !== query.semantic) {
        return false;
      }

      // é‡è¦æ€§è¿‡æ»¤
      if (query.minImportance !== undefined && item.importance) {
        const importance = computeContextImportance(item.importance);
        if (importance < query.minImportance) {
          return false;
        }
      }

      // æ ‡ç­¾è¿‡æ»¤
      if (query.tags && query.tags.length > 0) {
        if (!item.tags || !query.tags.every(tag => item.tags?.includes(tag))) {
          return false;
        }
      }

      // æ—¶é—´èŒƒå›´è¿‡æ»¤
      if (query.timeRange) {
        if (item.importance) {
          const lastUsed = item.importance.lastUsed;

          if (query.timeRange.from && lastUsed < query.timeRange.from) {
            return false;
          }

          if (query.timeRange.to && lastUsed > query.timeRange.to) {
            return false;
          }
        }
      }

      // å…³é”®è¯æœç´¢
      if (query.keywords && query.keywords.length > 0) {
        const contentToSearch = item.content.toLowerCase();
        const hasKeyword = query.keywords.some(keyword =>
          contentToSearch.includes(keyword.toLowerCase())
        );

        if (!hasKeyword) {
          return false;
        }
      }

      // é¡¹ç›®ä½œç”¨åŸŸè¿‡æ»¤
      if (query.projectScope) {
        // è¿™é‡Œå‡è®¾å°†æ¥ ContextItem ä¼šæœ‰ projectScope å­—æ®µ
        // æš‚æ—¶è·³è¿‡
      }

      return true;
    });
  }

  private applySorting(items: ContextItem[], options: DSLFilterOptions): ContextItem[] {
    const { sortBy = 'importance', sortOrder = 'desc' } = options;

    return items.sort((a, b) => {
      let comparison = 0;

      switch (sortBy) {
        case 'importance':
          if (a.importance && b.importance) {
            comparison = computeContextImportance(b.importance) - computeContextImportance(a.importance);
          } else if (a.importance) {
            comparison = -1;
          } else if (b.importance) {
            comparison = 1;
          }
          break;

        case 'recency':
          if (a.importance && b.importance) {
            comparison = b.importance.lastUsed - a.importance.lastUsed;
          } else if (a.importance) {
            comparison = -1;
          } else if (b.importance) {
            comparison = 1;
          }
          break;

        case 'relevance':
          // ä½¿ç”¨ ContextBuffer ä¸­çš„ computeItemScore æ–¹æ³•
          // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œä½¿ç”¨é‡è¦æ€§ä½œä¸ºç›¸å…³æ€§
          if (a.importance && b.importance) {
            comparison = computeContextImportance(b.importance) - computeContextImportance(a.importance);
          }
          break;

        case 'path':
          comparison = a.path.localeCompare(b.path);
          break;
      }

      return sortOrder === 'desc' ? comparison : -comparison;
    });
  }

  private applyPagination(items: ContextItem[], options: DSLFilterOptions): ContextItem[] {
    const { limit, offset = 0 } = options;

    if (limit !== undefined) {
      return items.slice(offset, offset + limit);
    }

    return items;
  }

  /**
   * ç®€åŒ–çš„ glob åŒ¹é…
   */
  private matchesGlob(path: string, pattern: string): boolean {
    // ç®€å•çš„ glob å®ç°ï¼Œæ”¯æŒ * å’Œ **
    const regexPattern = pattern
      .replace(/\./g, '\\.') // è½¬ä¹‰ç‚¹å·
      .replace(/\*/g, '.*')  // * åŒ¹é…ä»»æ„å­—ç¬¦
      .replace(/\*\*/g, '.*'); // ** ä¹ŸåŒ¹é…ä»»æ„å­—ç¬¦ï¼ˆç®€åŒ–å¤„ç†ï¼‰

    const regex = new RegExp(`^${regexPattern}$`);
    return regex.test(path);
  }
}

/**
 * æ‰©å±•çš„ ContextProtocolï¼Œæ”¯æŒ DSL æŸ¥è¯¢
 */
export class ExtendedContextProtocol {
  /**
   * ä½¿ç”¨ DSL æŸ¥è¯¢ä¸Šä¸‹æ–‡
   */
  static async queryContext(dslQuery: string, availableItems: ContextItem[]): Promise<ContextItem[]> {
    const parsedQuery = DSLParser.parse(dslQuery);
    const engine = new DSLQueryEngine(availableItems);
    const result = engine.execute(parsedQuery);

    return result.items;
  }

  /**
   * è§£æåŒ…å« DSL çš„ç”¨æˆ·è¾“å…¥
   */
  static parseUserInput(input: string): { dslQueries: string[]; plainText: string } {
    // æå– DSL æŸ¥è¯¢ï¼ˆä»¥ @ æˆ– # å¼€å¤´çš„éƒ¨åˆ†ï¼‰
    const dslRegex = /[@#][^{}`]+|"[^"]*"|'[^']*'/g;
    const dslMatches: string[] = [];
    let plainText = input;

    let match;
    while ((match = dslRegex.exec(input)) !== null) {
      dslMatches.push(match[0]);
    }

    // ä»åŸæ–‡ä¸­ç§»é™¤ DSL éƒ¨åˆ†ï¼Œå¾—åˆ°çº¯æ–‡æœ¬
    for (const dsl of dslMatches) {
      plainText = plainText.replace(dsl, '').trim();
    }

    return {
      dslQueries: dslMatches,
      plainText
    };
  }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/contextImportance.ts

````typescript
import { randomUUID } from 'crypto';

export interface ContextImportance {
  id: string;              // stable id
  path: string;            // file / dir path
  type: 'file' | 'directory';

  // === Usage stats ===
  useCount: number;
  successCount: number;
  failureCount: number;

  // === Time ===
  lastUsed: number;
  createdAt: number;

  // === Learned weight ===
  confidence: number;      // 0 ~ 1, init 0.5
}

/**
 * è®¡ç®—ä¸Šä¸‹æ–‡é‡è¦æ€§åˆ†æ•°
 * è¯„åˆ†å…¬å¼ä¸Skillç³»ç»Ÿä¿æŒä¸€è‡´
 * @param ctx ContextImportanceå¯¹è±¡
 * @param now å½“å‰æ—¶é—´æˆ³
 * @returns é‡è¦æ€§åˆ†æ•° (0-1)
 */
export function computeContextImportance(
  ctx: ContextImportance,
  now = Date.now()
): number {
  const total = ctx.successCount + ctx.failureCount;
  const successRate = total === 0 ? 0.5 : ctx.successCount / total;

  const idleDays = (now - ctx.lastUsed) / (1000 * 60 * 60 * 24);
  const freshness = Math.exp(-idleDays / 14); // 14 å¤©åŠè¡°

  return (
    0.45 * successRate +
    0.35 * freshness +
    0.20 * ctx.confidence
  );
}

/**
 * åˆ›å»ºæ–°çš„ContextImportanceå¯¹è±¡
 * @param path æ–‡ä»¶æˆ–ç›®å½•è·¯å¾„
 * @param type ç±»å‹
 * @returns ContextImportanceå¯¹è±¡
 */
export function createContextImportance(path: string, type: 'file' | 'directory'): ContextImportance {
  const now = Date.now();
  return {
    id: randomUUID(),
    path,
    type,
    useCount: 0,
    successCount: 0,
    failureCount: 0,
    confidence: 0.5,
    createdAt: now,
    lastUsed: now
  };
}

/**
 * æ›´æ–°ContextImportanceçŠ¶æ€
 * @param ctx ContextImportanceå¯¹è±¡
 * @param success æ˜¯å¦æˆåŠŸ
 */
export function updateContextImportance(ctx: ContextImportance, success: boolean) {
  ctx.useCount++;
  ctx.lastUsed = Date.now();

  if (success) {
    ctx.successCount++;
    ctx.confidence = Math.min(1, ctx.confidence + 0.05);
  } else {
    ctx.failureCount++;
    ctx.confidence = Math.max(0, ctx.confidence - 0.1);
  }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/contextManager.ts

````typescript
import crypto from 'crypto';
import { GovernanceContext } from './state';
import { ContextBuffer } from './contextBuffer';
import { ExtendedContextProtocol } from './contextDSL';
import { ContextBank } from './contextBank';

export class ContextManager {
  private messages: Array<{ role: string; content: string; timestamp: number; metadata?: { kind?: import('./types').ObservationKind } }> = [];
  private contextBuffer: ContextBuffer;
  private contextBank: ContextBank;
  private maxHistorySize = 50;
  
  // âœ… è·Ÿè¸ªæ‰€æœ‰å¼‚æ­¥æ·»åŠ æ“ä½œçš„ Promise
  private pendingAdds: Set<Promise<void>> = new Set();

  constructor(initialContext?: GovernanceContext) {
    this.contextBuffer = new ContextBuffer();
    this.contextBank = new ContextBank();

    if (initialContext?.history) {
      this.messages = initialContext.history.map(msg => ({
        ...msg,
        timestamp: Date.now()
      }));
    }

    if (initialContext?.input) {
      this.addMessage('user', initialContext.input);
    }
  }

  addMessage(role: string, content: string): void {
    this.messages.push({
      role,
      content,
      timestamp: Date.now()
    });

    if (this.messages.length > this.maxHistorySize) {
      this.messages = this.messages.slice(-this.maxHistorySize);
    }
  }

  addToolResult(toolName: string, result: string): void {
    const content = `Tool ${toolName} returned:\n${result}`;
    this.addMessage('tool', content);
  }

  /**
   * æ·»åŠ  Observationï¼Œæ”¯æŒç±»å‹åˆ†çº§ï¼ˆv3.1ï¼‰
   * @param observation è§‚å¯Ÿå†…å®¹
   * @param kind Observation ç±»å‹ï¼štool_result, system_note, error
   */
  addObservation(observation: string, kind: import('./types').ObservationKind = 'system_note'): void {
    this.addMessage('system', observation);
    // ä¸ºæœ€åä¸€æ¡æ¶ˆæ¯æ·»åŠ  kind å…ƒæ•°æ®
    if (this.messages.length > 0) {
      this.messages[this.messages.length - 1].metadata = { kind };
    }
  }

  /**
   * è°ƒè¯•ç”¨ï¼šä»…è·å– Observationï¼ˆTool / System æ³¨å…¥ï¼‰
   * ä¸åŒ…å« user / assistant
   */
  getObservations(): Array<{ role: 'tool' | 'system'; content: string }> {
    return this.messages
      .filter(m => m.role === 'tool' || m.role === 'system')
      .map(m => ({
        role: m.role as 'tool' | 'system',
        content: m.content
      }));
  }

  /**
   * è·å–æœ€æ–°çš„ Observationï¼ˆå‘åå…¼å®¹ï¼‰
   */
  getLastObservation(): { role: 'tool' | 'system'; content: string } | null {
    for (let i = this.messages.length - 1; i >= 0; i--) {
      const m = this.messages[i];
      if (m.role === 'tool' || m.role === 'system') {
        return { role: m.role as any, content: m.content };
      }
    }
    return null;
  }

  /**
   * è·å–éœ€è¦ ACK çš„ Observationï¼ˆæ’é™¤ error ç±»å‹ï¼‰
   * è¿™æ˜¯ v3.1 çš„æ ¸å¿ƒä¿®å¤ï¼šé˜²æ­¢ ERROR è¢«å½“æˆéœ€è¦ç¡®è®¤çš„ Observation
   */
  getLastAckableObservation(): { role: 'tool' | 'system'; content: string } | null {
    for (let i = this.messages.length - 1; i >= 0; i--) {
      const m = this.messages[i];
      if ((m.role === 'tool' || m.role === 'system') && m.metadata?.kind !== 'error') {
        return { role: m.role as any, content: m.content };
      }
    }
    return null;
  }

  getMessages(): Array<{ role: 'system' | 'user' | 'assistant' | 'tool'; content: string }> {
    return this.messages.map(({ role, content }) => ({
      role: role as 'system' | 'user' | 'assistant' | 'tool',
      content
    }));
  }

  getContextBuffer(): ContextBuffer {
    return this.contextBuffer;
  }

  addContextItem(item: Omit<import('./contextBuffer').ContextItem, 'tokens'>) {
    this.contextBuffer.add(item);
  }

  async addContextItemAsync(item: Omit<import('./contextBuffer').ContextItem, 'tokens'>) {
    // âœ… åˆ›å»º Promise å¹¶è·Ÿè¸ªå®ƒ
    const p = this.contextBuffer.addAsync(item);
    this.pendingAdds.add(p);
    
    try {
      await p;
    } finally {
      this.pendingAdds.delete(p);
    }
  }

  buildContextPrompt(userInput: string, options?: import('./contextBuffer').BuildPromptOptions) {
    return this.contextBuffer.buildPrompt(userInput, options);
  }

  /**
   * ä½¿ç”¨ DSL æŸ¥è¯¢ä¸Šä¸‹æ–‡
   */
  async queryDSL(dslQuery: string) {
    return await this.contextBuffer.queryDSL(dslQuery, this.contextBank);
  }

  /**
   * è§£æåŒ…å« DSL çš„ç”¨æˆ·è¾“å…¥å¹¶è·å–ç›¸å…³ä¸Šä¸‹æ–‡
   */
  async getDSLContextForInput(input: string) {
    return await this.contextBuffer.getDSLContextForInput(input, this.contextBank);
  }

  /**
   * åˆå§‹åŒ– Context Bank
   */
  async initializeContextBank(): Promise<void> {
    await this.contextBank.initialize();
  }

  /**
   * ä» ContextBuffer å¯¼å‡ºé«˜ä»·å€¼ä¸Šä¸‹æ–‡åˆ°é“¶è¡Œ
   */
  async exportToContextBank(projectScope?: string): Promise<void> {
    await this.contextBank.exportFromContextBuffer(this.contextBuffer, projectScope);
  }

  /**
   * ä» Context Bank æŸ¥è¯¢ä¸Šä¸‹æ–‡
   */
  async queryContextBank(options: import('./contextBank').BankQueryOptions): Promise<import('./contextBank').BankContextItem[]> {
    return await this.contextBank.query(options);
  }

  /**
   * å°† Context Bank ä¸­çš„é¡¹ç›®æ·»åŠ åˆ°å½“å‰ä¸Šä¸‹æ–‡
   */
  async importFromContextBank(options: import('./contextBank').BankQueryOptions): Promise<void> {
    const bankItems = await this.contextBank.query(options);

    for (const item of bankItems) {
      // å°† BankContextItem è½¬æ¢ä¸º ContextItem å¹¶æ·»åŠ åˆ°ç¼“å†²åŒº
      this.contextBuffer.add({
        type: item.type,
        path: item.path,
        stableId: item.stableId,
        content: item.content,
        summary: item.summary,
        summarized: item.summarized,
        semantic: item.semantic,
        summaryQuality: item.summaryQuality,
        referencedBy: item.referencedBy,
        usageStats: item.usageStats,
        importance: item.importance,
        metadata: {
          source: 'context_bank',
          bankItemId: item.id
        }
      });
    }
  }

  /**
   * è®°å½• ContextBank é¡¹ç›®çš„ä½¿ç”¨æƒ…å†µ
   */
  async recordBankUsage(success: boolean): Promise<void> {
    const contextItems = this.contextBuffer.export();

    for (const item of contextItems) {
      // æ£€æŸ¥é¡¹ç›®æ˜¯å¦æ¥è‡ªé“¶è¡Œï¼ˆæœ‰ bankItemIdï¼‰
      const bankItemId = (item as any).metadata?.bankItemId;
      if (bankItemId) {
        try {
          // ä½¿ç”¨é“¶è¡Œé¡¹ç›® ID è€Œä¸æ˜¯è·¯å¾„è¿›è¡Œè®°å½•
          await this.contextBank.recordUsage(bankItemId, success);
        } catch (error) {
          console.warn(`[ContextManager] Could not record bank usage for ${bankItemId}:`, error);
        }
      }
    }
  }

  getRecentMessages(count: number): Array<{ role: string; content: string; timestamp: number }> {
    return this.messages.slice(-count);
  }

  getHash(): string {
    const content = JSON.stringify(this.messages);
    return crypto.createHash('sha256').update(content).digest('hex');
  }

  getSnapshot() {
    return {
      inputHash: this.getHash(),
      systemPromptVersion: 'v1.0.0',
      toolSetVersion: 'v1.0.0',
      recentMessages: this.getRecentMessages(10)
    };
  }

  clear(): void {
    this.messages = [];
    this.contextBuffer.clear();
  }

  /**
   * ç­‰å¾…æ‰€æœ‰å¼‚æ­¥ä¸Šä¸‹æ–‡é¡¹æ·»åŠ å®Œæˆ
   * 
   * âœ… çœŸæ­£ç­‰å¾…æ‰€æœ‰ pending çš„å¼‚æ­¥æ“ä½œ
   * å³ä½¿æœªæ¥ addAsync() å˜ä¸ºçœŸæ­£çš„å¼‚æ­¥ï¼ˆæ‘˜è¦ã€embeddingç­‰ï¼‰ï¼Œ
   * æ­¤æ–¹æ³•ä¹Ÿèƒ½ç¡®ä¿æ‰€æœ‰æ“ä½œå®Œæˆåå†ç»§ç»­ã€‚
   */
  async flush(): Promise<void> {
    if (this.pendingAdds.size === 0) {
      return;
    }
    
    console.log(`[ContextManager] Flushing ${this.pendingAdds.size} pending add operations...`);
    await Promise.all(Array.from(this.pendingAdds));
    console.log('[ContextManager] All add operations completed');
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/contextProtocol.ts

````typescript
import { ContextBuffer, ContextItem } from './contextBuffer';
import { randomUUID } from 'crypto';
import { ExtendedContextProtocol } from './contextDSL';

/**
 * Contextå¼•ç”¨åè®®v1å®ç°
 * å®šä¹‰äº†ContextItemå¦‚ä½•è¢«æ˜¾å¼å¼•ç”¨ã€ç®¡ç†å’Œæ³¨å…¥çš„åè®®
 */

export interface ContextReference {
  path: string;
  alias?: string;
  lineRange?: { start: number; end?: number };
  timestamp: number;
  responseId?: string;
}

export interface ContextProtocolResult {
  referencedItems: ContextReference[];
  extractedContent: string;
  isValid: boolean;
  errors: string[];
}

/**
 * è§£æAIå“åº”ä¸­çš„Contextå¼•ç”¨
 * @param response AIçš„å“åº”å†…å®¹
 * @returns è§£æå‡ºçš„Contextå¼•ç”¨ä¿¡æ¯
 */
export function parseContextReferences(response: string): ContextProtocolResult {
  const result: ContextProtocolResult = {
    referencedItems: [],
    extractedContent: response,
    isValid: true,
    errors: []
  };

  // åŒ¹é…æ˜¾å¼å¼•ç”¨æ ¼å¼ï¼Œå¦‚ [Reference] file: path/to/file.ts (path/to/file.ts) æˆ–ç±»ä¼¼æ ¼å¼
  const referenceRegex = /\[Reference\]\s+([^:\s]+):\s*([^(]+?)\s*\(([^)]+)\)/g;
  let match;

  while ((match = referenceRegex.exec(response)) !== null) {
    const [, type, description, path] = match;

    const reference: ContextReference = {
      path: path.trim(),
      timestamp: Date.now()
    };

    result.referencedItems.push(reference);
  }

  // åŒ¹é… DSL æŸ¥è¯¢è¯­æ³• (ä¾‹å¦‚: type:file importance:>0.5)
  const dslRegex = /[@#][^{}`]+|"[^"]*"|'[^']*'|[a-z_]+:[^\\s]+/gi;
  let dslMatch;
  while ((dslMatch = dslRegex.exec(response)) !== null) {
    const dslPart = dslMatch[0];

    // æ£€æŸ¥æ˜¯å¦æ˜¯ DSL æŸ¥è¯¢è¯­æ³• (åŒ…å«å†’å·ä¸”ä¸æ˜¯æ–‡ä»¶è·¯å¾„)
    if (dslPart.includes(':') && !dslPart.startsWith('/') && !dslPart.includes('.')) {
      // è¿™å¯èƒ½æ˜¯ DSL æŸ¥è¯¢çš„ä¸€éƒ¨åˆ†ï¼Œæš‚æ—¶è·³è¿‡ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦å®Œæ•´çš„æŸ¥è¯¢
      continue;
    }

    // æ£€æŸ¥æ˜¯å¦æ˜¯è·¯å¾„å¼•ç”¨ (@file æˆ– #dir)
    if (dslPart.startsWith('@') || dslPart.startsWith('#')) {
      const path = dslPart.substring(1);
      if (!result.referencedItems.some(ref => ref.path === path)) {
        result.referencedItems.push({
          path,
          timestamp: Date.now()
        });
      }
    }
  }

  // ä¹Ÿå¯ä»¥åŒ¹é…JSONæ ¼å¼çš„å¼•ç”¨ï¼ˆå¦‚æœAIè¾“å‡ºéµå¾ªç‰¹å®šæ ¼å¼ï¼‰
  try {
    // å°è¯•æŸ¥æ‰¾JSONå—ä¸­çš„å¼•ç”¨ä¿¡æ¯
    const jsonMatch = response.match(/```json\n([\s\S]*?)\n```/);
    if (jsonMatch) {
      const jsonData = JSON.parse(jsonMatch[1]);

      // å¦‚æœJSONä¸­åŒ…å«used_contextå­—æ®µ
      if (jsonData.used_context && Array.isArray(jsonData.used_context)) {
        for (const path of jsonData.used_context) {
          if (!result.referencedItems.some(ref => ref.path === path)) {
            result.referencedItems.push({
              path,
              timestamp: Date.now()
            });
          }
        }
      }
    }
  } catch (e) {
    // å¦‚æœJSONè§£æå¤±è´¥ï¼Œç»§ç»­å¤„ç†
  }

  return result;
}

/**
 * éªŒè¯Contextå¼•ç”¨çš„æœ‰æ•ˆæ€§
 * @param references Contextå¼•ç”¨åˆ—è¡¨
 * @param availableItems å¯ç”¨çš„ContextItemåˆ—è¡¨
 * @returns éªŒè¯ç»“æœ
 */
export function validateContextReferences(references: ContextReference[], availableItems: ContextItem[]): {
  valid: ContextReference[];
  invalid: ContextReference[];
  warnings: string[];
} {
  const valid: ContextReference[] = [];
  const invalid: ContextReference[] = [];
  const warnings: string[] = [];

  for (const ref of references) {
    const foundItem = availableItems.find(item => 
      item.path === ref.path || 
      (item.alias && item.alias === ref.path)
    );

    if (foundItem) {
      valid.push(ref);
    } else {
      invalid.push(ref);
      warnings.push(`Context item not found: ${ref.path}`);
    }
  }

  return { valid, invalid, warnings };
}

/**
 * æ ¹æ®å¼•ç”¨åè®®æ„å»ºä¸Šä¸‹æ–‡æç¤º
 * @param contextBuffer ContextBufferå®ä¾‹
 * @param userInput ç”¨æˆ·è¾“å…¥
 * @param referencedPaths æ˜¾å¼å¼•ç”¨çš„è·¯å¾„åˆ—è¡¨
 * @returns æ„å»ºçš„æç¤ºå­—ç¬¦ä¸²
 */
export async function buildContextPromptWithReferences(
  contextBuffer: ContextBuffer,
  userInput: string,
  referencedPaths?: string[]
): Promise<string> {
  // é¦–å…ˆæ£€æŸ¥ç”¨æˆ·è¾“å…¥æ˜¯å¦åŒ…å« DSL æŸ¥è¯¢
  const dslContextItems = await contextBuffer.getDSLContextForInput(userInput);

  let filteredItems: ContextItem[];

  if (dslContextItems.length > 0) {
    // å¦‚æœæœ‰ DSL æŸ¥è¯¢ç»“æœï¼Œä½¿ç”¨ DSL ç»“æœ
    filteredItems = dslContextItems;
  } else if (referencedPaths && referencedPaths.length > 0) {
    // å¦‚æœæä¾›äº†æ˜¾å¼å¼•ç”¨è·¯å¾„ï¼Œä¼˜å…ˆå¤„ç†è¿™äº›é¡¹
    const allItems = contextBuffer.export();
    filteredItems = allItems.filter(item =>
      referencedPaths.includes(item.path) ||
      (item.alias && referencedPaths.includes(item.alias))
    );
  } else {
    // å¦åˆ™ä½¿ç”¨æ‰€æœ‰å¯ç”¨é¡¹
    filteredItems = contextBuffer.export();
  }

  // æŒ‰é‡è¦æ€§åˆ†ç»„
  const highConfidenceItems = filteredItems.filter(item =>
    item.importance && computeContextImportance(item.importance) > 0.7
  );
  const mediumConfidenceItems = filteredItems.filter(item =>
    item.importance &&
    computeContextImportance(item.importance) > 0.3 &&
    computeContextImportance(item.importance) <= 0.7
  );
  const lowConfidenceItems = filteredItems.filter(item =>
    !item.importance || computeContextImportance(item.importance) <= 0.3
  );

  // æ„å»ºä¸åŒéƒ¨åˆ†çš„ä¸Šä¸‹æ–‡
  const sections = [];

  if (highConfidenceItems.length > 0) {
    // æŒ‰è¯­ä¹‰ç±»å‹è¿›ä¸€æ­¥ç»†åˆ†é«˜ç½®ä¿¡åº¦é¡¹
    const semanticGroups: Record<string, typeof highConfidenceItems> = {};
    for (const item of highConfidenceItems) {
      const semantic = item.semantic || 'other';
      if (!semanticGroups[semantic]) {
        semanticGroups[semantic] = [];
      }
      semanticGroups[semantic].push(item);
    }

    for (const [semantic, items] of Object.entries(semanticGroups)) {
      const semanticBlock = items.map(item => {
        const title = item.alias
          ? `[Reference] ${item.type}: ${item.alias} (${item.path})`
          : `[Reference] ${item.type}: ${item.path}`;

        const body = item.summary ?? item.content;

        return `${title}\n---\n${body}\n---`;
      }).join('\n\n');

      sections.push(`# Background Knowledge (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - High Confidence)\n${semanticBlock}`);
    }
  }

  if (mediumConfidenceItems.length > 0) {
    // æŒ‰è¯­ä¹‰ç±»å‹è¿›ä¸€æ­¥ç»†åˆ†ä¸­ç½®ä¿¡åº¦é¡¹
    const semanticGroups: Record<string, typeof mediumConfidenceItems> = {};
    for (const item of mediumConfidenceItems) {
      const semantic = item.semantic || 'other';
      if (!semanticGroups[semantic]) {
        semanticGroups[semantic] = [];
      }
      semanticGroups[semantic].push(item);
    }

    for (const [semantic, items] of Object.entries(semanticGroups)) {
      const semanticBlock = items.map(item => {
        const title = item.alias
          ? `[Reference] ${item.type}: ${item.alias} (${item.path})`
          : `[Reference] ${item.type}: ${item.path}`;

        const body = item.summary ?? item.content;

        return `${title}\n---\n${body}\n---`;
      }).join('\n\n');

      sections.push(`# Supporting Information (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - Medium Confidence)\n${semanticBlock}`);
    }
  }

  if (lowConfidenceItems.length > 0) {
    // æŒ‰è¯­ä¹‰ç±»å‹è¿›ä¸€æ­¥ç»†åˆ†ä½ç½®ä¿¡åº¦é¡¹
    const semanticGroups: Record<string, typeof lowConfidenceItems> = {};
    for (const item of lowConfidenceItems) {
      const semantic = item.semantic || 'other';
      if (!semanticGroups[semantic]) {
        semanticGroups[semantic] = [];
      }
      semanticGroups[semantic].push(item);
    }

    for (const [semantic, items] of Object.entries(semanticGroups)) {
      const semanticBlock = items.map(item => {
        const title = item.alias
          ? `[Reference] ${item.type}: ${item.alias} (${item.path})`
          : `[Reference] ${item.type}: ${item.path}`;

        const body = item.summary ?? item.content;

        return `${title}\n---\n${body}\n---`;
      }).join('\n\n');

      sections.push(`# Archived References (${semantic.charAt(0).toUpperCase() + semantic.slice(1)} - Low Confidence)\n${semanticBlock}`);
    }
  }

  const contextBlock = sections.join('\n\n');

  return `
${contextBlock}

# Task Instructions
Based on the provided context (if any), answer the user's question. If the context contains source code, treat it as your "source of truth."

User Question:
${userInput}
`;
}

/**
 * éªŒè¯Contextå¼•ç”¨çš„æœ‰æ•ˆæ€§
 * @param responseId å“åº”ID
 * @param expectedPaths æœŸæœ›è¢«å¼•ç”¨çš„è·¯å¾„
 * @param actualReferences å®é™…å¼•ç”¨çš„è·¯å¾„
 * @returns éªŒè¯ç»“æœ
 */
export function validateResponseReferences(
  responseId: string,
  expectedPaths: string[],
  actualReferences: ContextReference[]
): {
  success: boolean;
  matched: string[];
  missing: string[];
  extra: string[];
  accuracy: number; // 0-1, å¼•ç”¨å‡†ç¡®ç‡
} {
  const actualPaths = actualReferences.map(ref => ref.path);
  const matched = expectedPaths.filter(path => actualPaths.includes(path));
  const missing = expectedPaths.filter(path => !actualPaths.includes(path));
  const extra = actualPaths.filter(path => !expectedPaths.includes(path));

  const totalExpected = expectedPaths.length;
  const totalActual = actualReferences.length;
  const correctlyReferenced = matched.length;

  // è®¡ç®—å‡†ç¡®ç‡ï¼šè€ƒè™‘æ­£ç¡®å¼•ç”¨å’Œé¢å¤–å¼•ç”¨çš„å¹³è¡¡
  const accuracy = totalExpected > 0
    ? correctlyReferenced / totalExpected  // æŸ¥å…¨ç‡
    : (totalActual - extra.length) / Math.max(totalActual, 1); // å¦‚æœæ²¡æœ‰é¢„æœŸå¼•ç”¨ï¼Œåˆ™çœ‹æœ‰å¤šå°‘æ˜¯ç›¸å…³çš„

  return {
    success: missing.length === 0 && extra.length <= Math.floor(expectedPaths.length * 0.2), // å…è®¸æœ€å¤š20%çš„é¢å¤–å¼•ç”¨
    matched,
    missing,
    extra,
    accuracy
  };
}

/**
 * ç”ŸæˆContextå¼•ç”¨å›æº¯æŠ¥å‘Š
 * @param contextBuffer ContextBufferå®ä¾‹
 * @param responseId å“åº”ID
 * @param userInput ç”¨æˆ·è¾“å…¥
 * @param response AIå“åº”
 * @returns å›æº¯æŠ¥å‘Š
 */
export async function generateReferenceRetrospective(
  contextBuffer: ContextBuffer,
  responseId: string,
  userInput: string,
  response: string
): Promise<string> {
  const allItems = contextBuffer.export();
  const references = parseContextReferences(response);

  // ç»Ÿè®¡å¼•ç”¨æƒ…å†µ
  const referencedItems = allItems.filter(item =>
    references.referencedItems.some(ref => ref.path === item.path)
  );

  // éªŒè¯å¼•ç”¨çš„æœ‰æ•ˆæ€§
  const validation = validateContextReferences(
    references.referencedItems,
    allItems
  );

  // è®¡ç®—å¼•ç”¨ç»Ÿè®¡
  const stats = {
    totalContextItems: allItems.length,
    referencedItemsCount: referencedItems.length,
    validReferences: validation.valid.length,
    invalidReferences: validation.invalid.length,
    referenceAccuracy: allItems.length > 0
      ? validation.valid.length / (validation.valid.length + validation.invalid.length || 1)
      : 0
  };

  // ç”ŸæˆæŠ¥å‘Š
  const reportLines = [
    '# Context Reference Retrospective Report',
    '',
    '## Query',
    userInput,
    '',
    '## Statistics',
    `- Total Context Items: ${stats.totalContextItems}`,
    `- Referenced Items: ${stats.referencedItemsCount}`,
    `- Valid References: ${stats.validReferences}`,
    `- Invalid References: ${stats.invalidReferences}`,
    `- Reference Accuracy: ${(stats.referenceAccuracy * 100).toFixed(2)}%`,
    '',
    '## Referenced Context Items',
    ...(referencedItems.length > 0
      ? referencedItems.map(item => `- ${item.path} (${item.type})`)
      : ['None']),
    '',
    '## Invalid References',
    ...(validation.invalid.length > 0
      ? validation.invalid.map(ref => `- ${ref.path}`)
      : ['None']),
    '',
    '## Response Excerpt',
    response.length > 200
      ? response.substring(0, 200) + '...'
      : response
  ];

  return reportLines.join('\n');
}

/**
 * åˆ†æContextItemçš„ç”Ÿå‘½å‘¨æœŸå’Œæ¼”å˜
 * @param contextBuffer ContextBufferå®ä¾‹
 * @returns ContextItemç”Ÿå‘½å‘¨æœŸåˆ†æ
 */
export function analyzeContextLifecycle(
  contextBuffer: ContextBuffer
): Array<{
  path: string;
  usageTrend: number; // ä½¿ç”¨è¶‹åŠ¿ (-1 to 1)
  qualityScore: number; // è´¨é‡è¯„åˆ† (0 to 1)
  relevanceScore: number; // ç›¸å…³æ€§è¯„åˆ† (0 to 1)
  recommendation: 'keep' | 'archive' | 'remove' | 'enhance';
}> {
  const items = contextBuffer.export();

  return items.map(item => {
    // è®¡ç®—ä½¿ç”¨è¶‹åŠ¿ (åŸºäºuseCountå’Œæ—¶é—´)
    const now = Date.now();
    const daysSinceCreated = (now - (item.importance?.createdAt || now)) / (1000 * 60 * 60 * 24);
    const avgUsesPerDay = item.importance ? item.importance.useCount / (daysSinceCreated || 1) : 0;

    // ä½¿ç”¨è¶‹åŠ¿ï¼šæ­£å€¼è¡¨ç¤ºä½¿ç”¨é¢‘ç‡å¢åŠ ï¼Œè´Ÿå€¼è¡¨ç¤ºå‡å°‘
    const usageTrend = avgUsesPerDay > 0.5 ? 1 : (avgUsesPerDay > 0.1 ? 0.5 : 0);

    // è´¨é‡è¯„åˆ†ï¼šç»“åˆæ˜¾å¼å¼•ç”¨å’ŒéªŒè¯ç»“æœ
    const qualityScore = item.usageStats
      ? (item.usageStats.verifiedUseful + 1) /
        (item.usageStats.verifiedUseful + item.usageStats.verifiedNotUseful + 2)
      : 0.5; // é»˜è®¤ä¸­ç­‰è¯„åˆ†

    // ç›¸å…³æ€§è¯„åˆ†ï¼šç»“åˆé‡è¦æ€§åˆ†æ•°å’Œæ˜¾å¼å¼•ç”¨æ¬¡æ•°
    const relevanceScore = item.importance
      ? (computeContextImportance(item.importance) +
         (item.usageStats ? Math.min(1, item.usageStats.referencedCount / 10) : 0)) / 2
      : 0.5;

    // ç”Ÿæˆæ¨è
    let recommendation: 'keep' | 'archive' | 'remove' | 'enhance' = 'keep';
    if (relevanceScore < 0.2 && qualityScore < 0.3) {
      recommendation = 'remove';
    } else if (relevanceScore < 0.4 && qualityScore < 0.5) {
      recommendation = 'archive';
    } else if (relevanceScore > 0.7 && qualityScore > 0.8) {
      recommendation = 'enhance'; // é«˜ä»·å€¼ï¼Œå»ºè®®å¢å¼º
    }

    return {
      path: item.path,
      usageTrend,
      qualityScore,
      relevanceScore,
      recommendation
    };
  });
}

// å¯¼å…¥å¿…è¦çš„å‡½æ•°
import { computeContextImportance } from './contextImportance';
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/contextSkillBridge.ts

````typescript
import { ContextItem } from './contextBuffer';
import { Skill } from './skills';
import { ContextToSkillPromotionRules } from './contextSkillPromotion';
import { recordEdge } from './knowledgeGraph';

export interface ContextSkillHint {
  source: 'context';
  path: string;
  suggestedSkillName: string;
  confidence: number; // 0-1, how certain we are this should become a skill
  usageCount: number; // how many times this context was used
  lastUsed: number; // timestamp
  description: string; // description of what this context enables
}

/**
 * åˆ†æContextItemsä»¥ç”ŸæˆSkillHints
 * å½“ContextItemè¢«é¢‘ç¹ä½¿ç”¨ä¸”ä¸æˆåŠŸä»»åŠ¡ç›¸å…³è”æ—¶ï¼Œå»ºè®®å°†å…¶è½¬æ¢ä¸ºSkill
 *
 * @param contextItems ContextItemæ•°ç»„
 * @returns ContextSkillHintæ•°ç»„
 */
export function generateSkillHintsFromContext(contextItems: ContextItem[]): ContextSkillHint[] {
  const hints: ContextSkillHint[] = [];

  for (const item of contextItems) {
    // ä½¿ç”¨æ–°çš„æ™‹å‡è§„åˆ™æ¥è¯„ä¼°æ˜¯å¦åº”è¯¥æ™‹å‡ä¸ºæŠ€èƒ½
    const promotedSkill = ContextToSkillPromotionRules.evaluatePromotion(item);

    if (promotedSkill) {
      // å¦‚æœç¬¦åˆæ™‹å‡æ¡ä»¶ï¼Œç”Ÿæˆæç¤º
      const { useCount, successCount, lastUsed } = item.importance || {
        useCount: 0,
        successCount: 0,
        lastUsed: Date.now()
      };

      hints.push({
        source: 'context',
        path: item.path,
        suggestedSkillName: promotedSkill.name,
        confidence: promotedSkill.metadata?.promotionCriteria?.successRate ||
                   promotedSkill.metadata?.promotionCriteria?.importanceScore ||
                   0.8, // é»˜è®¤é«˜ç½®ä¿¡åº¦
        usageCount: useCount,
        lastUsed,
        description: promotedSkill.description
      });

      // === C5-B-1: Knowledge Graph Record (Context -> Skill Candidate) ===
      if (item.id) {
        recordEdge({
            from: item.id,
            to: `skill_candidate:${promotedSkill.name}`,
            type: 'promoted_to',
            timestamp: Date.now(),
            meta: {
                confidence: promotedSkill.confidence
            }
        });
      }
    } else {
      // ä½¿ç”¨æ—§çš„é€»è¾‘ä½œä¸ºåå¤‡
      if (item.importance) {
        const { useCount, successCount, lastUsed } = item.importance;

        // å¦‚æœä½¿ç”¨æ¬¡æ•°è¶…è¿‡é˜ˆå€¼ï¼Œä¸”æœ‰ä¸€å®šæˆåŠŸç‡ï¼Œç”ŸæˆSkillå»ºè®®
        if (useCount >= 3 && successCount > 0) {
          const successRate = successCount / useCount;
          const daysSinceLastUse = (Date.now() - lastUsed) / (1000 * 60 * 60 * 24);

          // è®¡ç®—å»ºè®®çš„ç½®ä¿¡åº¦
          const confidence = Math.min(1,
            (successRate * 0.6) +  // æˆåŠŸç‡æƒé‡
            (Math.min(1, useCount / 10) * 0.3) +  // ä½¿ç”¨é¢‘ç‡æƒé‡
            (Math.max(0, (7 - daysSinceLastUse) / 7) * 0.1)  // æ–°é²œåº¦æƒé‡
          );

          if (confidence > 0.5) { // åªæœ‰ç½®ä¿¡åº¦è¶…è¿‡0.5æ‰ç”Ÿæˆå»ºè®®
            hints.push({
              source: 'context',
              path: item.path,
              suggestedSkillName: generateSkillNameFromPath(item.path),
              confidence,
              usageCount: useCount,
              lastUsed,
              description: `Frequently used context from ${item.path} that contributed to ${successCount} successful tasks`
            });
          }
        }
      }
    }
  }

  return hints;
}

/**
 * ä»è·¯å¾„ç”ŸæˆSkillåç§°
 * @param path æ–‡ä»¶è·¯å¾„
 * @returns å»ºè®®çš„Skillåç§°
 */
function generateSkillNameFromPath(path: string): string {
  // ç§»é™¤æ–‡ä»¶æ‰©å±•åå¹¶ä½¿ç”¨é©¼å³°å‘½å
  const basename = path.split('/').pop()?.split('.')[0] || path;
  return basename
    .split(/[^a-zA-Z0-9]/)  // æŒ‰éå­—æ¯æ•°å­—å­—ç¬¦åˆ†å‰²
    .map((part, index) =>
      index === 0
        ? part.toLowerCase()
        : part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()
    )
    .join('');
}

/**
 * å°†ContextItemç›´æ¥æ™‹å‡ä¸ºSkill
 * @param contextItem è¦æ™‹å‡çš„ContextItem
 * @returns æ™‹å‡åçš„Skillï¼Œå¦‚æœä¸ç¬¦åˆæ¡ä»¶åˆ™è¿”å›null
 */
export function promoteContextToSkill(contextItem: ContextItem): Skill | null {
  return ContextToSkillPromotionRules.evaluatePromotion(contextItem);
}

/**
 * å°†ContextSkillHintsè½¬æ¢ä¸ºå¯æ˜¾ç¤ºçš„æ–‡æœ¬
 * @param hints ContextSkillHintæ•°ç»„
 * @returns æ ¼å¼åŒ–çš„å­—ç¬¦ä¸²
 */
export function formatSkillHints(hints: ContextSkillHint[]): string {
  if (hints.length === 0) {
    return "No skill suggestions generated from context.";
  }

  const lines: string[] = ["Skill Suggestions from Context:", ""];

  for (const hint of hints) {
    lines.push(`- ${hint.suggestedSkillName} (confidence: ${(hint.confidence * 100).toFixed(1)}%)`);
    lines.push(`  Path: ${hint.path}`);
    lines.push(`  Usage: ${hint.usageCount}, Last used: ${new Date(hint.lastUsed).toLocaleDateString()}`);
    lines.push(`  Description: ${hint.description}`);
    lines.push("");
  }

  return lines.join("\n");
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/contextSkillPromotion.ts

````typescript
/**
 * Context â†” Skill è‡ªåŠ¨æ™‹å‡è§„åˆ™
 * 
 * å®šä¹‰ ContextItem å¦‚ä½•è‡ªåŠ¨è½¬åŒ–ä¸º Skill çš„è§„åˆ™å’Œæ¡ä»¶
 */

import { ContextItem } from './contextBuffer';
import { Skill } from './skills';
import { ContextImportance } from './contextImportance';

export interface ContextToSkillRule {
  id: string;
  name: string;
  description: string;
  condition: (contextItem: ContextItem) => boolean;
  action: (contextItem: ContextItem) => Skill | null;
  priority: number; // æ•°å€¼è¶Šå¤§ï¼Œä¼˜å…ˆçº§è¶Šé«˜
}

export interface SkillToContextRule {
  id: string;
  name: string;
  description: string;
  condition: (skill: Skill) => boolean;
  action: (skill: Skill) => ContextItem | null;
  priority: number;
}

/**
 * Context â†’ Skill æ™‹å‡è§„åˆ™
 */
export class ContextToSkillPromotionRules {
  static readonly RULES: ContextToSkillRule[] = [
    {
      id: 'high-frequency-context',
      name: 'é«˜é¢‘ä½¿ç”¨ä¸Šä¸‹æ–‡æ™‹å‡',
      description: 'å½“ ContextItem è¢«é¢‘ç¹ä½¿ç”¨ä¸”æˆåŠŸç‡é«˜æ—¶ï¼Œæ™‹å‡ä¸º Skill',
      priority: 100,
      condition: (contextItem: ContextItem) => {
        if (!contextItem.importance) return false;

        const { useCount, successCount } = contextItem.importance;
        const successRate = useCount > 0 ? successCount / useCount : 0;

        // ä½¿ç”¨æ¬¡æ•°è¶…è¿‡é˜ˆå€¼ä¸”æˆåŠŸç‡è¾ƒé«˜
        return useCount >= 5 && successRate >= 0.8;
      },
      action: (contextItem: ContextItem) => {
        if (!contextItem.importance) return null;

        const { useCount, successCount } = contextItem.importance;
        const successRate = useCount > 0 ? successCount / useCount : 0;
        const contextPath = contextItem.path; // ä» ContextItem è·å–è·¯å¾„

        // ä»è·¯å¾„ç”ŸæˆæŠ€èƒ½åç§°
        const skillName = contextPath
          .split('/')
          .pop()
          ?.split('.')[0]
          ?.replace(/[^a-zA-Z0-9]/g, '_') || 'unknown_skill';

        return {
          id: `skill_${randomUUID()}`, // ä½¿ç”¨éšæœº UUID è€Œä¸æ˜¯ç›´æ¥å¤åˆ¶ context id
          name: skillName,
          description: `ä»é«˜é¢‘ä½¿ç”¨çš„ä¸Šä¸‹æ–‡ "${contextPath}" æ™‹å‡è€Œæ¥çš„æŠ€èƒ½ã€‚ä½¿ç”¨æ¬¡æ•°: ${useCount}, æˆåŠŸç‡: ${(successRate * 100).toFixed(2)}%`,
          whenToUse: `å½“éœ€è¦è®¿é—® "${contextPath}" çš„å†…å®¹æ—¶`,
          planTemplate: {},
          successCount: successCount,
          failureCount: contextItem.importance.failureCount,
          confidence: successRate,
          lastUsed: contextItem.importance.lastUsed,
          createdAt: contextItem.importance.createdAt,
          enabled: true,
          parameters: {
            contextPath: contextPath
          },
          implementation: `// ä»ä¸Šä¸‹æ–‡ "${contextPath}" æ™‹å‡çš„æŠ€èƒ½å®ç°\nreturn contextItem.content;`,
          metadata: {
            source: 'context_promotion',
            originalContextId: contextItem.id, // ä¿å­˜åŸå§‹ä¸Šä¸‹æ–‡ IDï¼Œè€Œä¸æ˜¯é‡è¦æ€§å¯¹è±¡çš„ ID
            originalContextPath: contextPath,
            originalContextStableId: contextItem.stableId, // ä¿å­˜åŸå§‹ä¸Šä¸‹æ–‡çš„ç¨³å®š ID
            promotionCriteria: {
              useCount,
              successCount,
              successRate
            }
          }
        };
      }
    },
    {
      id: 'high-importance-context',
      name: 'é«˜é‡è¦æ€§ä¸Šä¸‹æ–‡æ™‹å‡',
      description: 'å½“ ContextItem é‡è¦æ€§è¯„åˆ†æŒç»­å¾ˆé«˜æ—¶ï¼Œæ™‹å‡ä¸º Skill',
      priority: 90,
      condition: (contextItem: ContextItem) => {
        if (!contextItem.importance) return false;

        const importanceScore = computeContextImportance(contextItem.importance);

        // é‡è¦æ€§è¯„åˆ†è¶…è¿‡é˜ˆå€¼
        return importanceScore >= 0.9;
      },
      action: (contextItem: ContextItem) => {
        if (!contextItem.importance) return null;

        const importanceScore = computeContextImportance(contextItem.importance);
        const { useCount, successCount, failureCount, lastUsed, createdAt } = contextItem.importance;
        const contextPath = contextItem.path; // ä» ContextItem è·å–è·¯å¾„
        const skillName = `important_${contextPath
          .split('/')
          .pop()
          ?.split('.')[0]
          ?.replace(/[^a-zA-Z0-9]/g, '_') || 'important_skill'}`;

        return {
          id: `skill_${randomUUID()}`, // ä½¿ç”¨éšæœº UUID
          name: skillName,
          description: `ä»é«˜é‡è¦æ€§ä¸Šä¸‹æ–‡ "${contextPath}" æ™‹å‡è€Œæ¥çš„æŠ€èƒ½ã€‚é‡è¦æ€§è¯„åˆ†: ${importanceScore.toFixed(2)}`,
          whenToUse: `å½“éœ€è¦è®¿é—®é«˜é‡è¦æ€§ä¸Šä¸‹æ–‡ "${contextPath}" çš„å†…å®¹æ—¶`,
          planTemplate: {},
          successCount: successCount,
          failureCount: failureCount,
          confidence: importanceScore,
          lastUsed: lastUsed,
          createdAt: createdAt,
          enabled: true,
          parameters: {
            contextPath: contextPath
          },
          implementation: `// ä»é«˜é‡è¦æ€§ä¸Šä¸‹æ–‡æ™‹å‡çš„æŠ€èƒ½å®ç°\nreturn contextItem.content;`,
          metadata: {
            source: 'context_promotion',
            originalContextId: contextItem.id, // ä¿å­˜åŸå§‹ä¸Šä¸‹æ–‡ IDï¼Œè€Œä¸æ˜¯é‡è¦æ€§å¯¹è±¡çš„ ID
            originalContextPath: contextPath,
            originalContextStableId: contextItem.stableId, // ä¿å­˜åŸå§‹ä¸Šä¸‹æ–‡çš„ç¨³å®š ID
            promotionCriteria: {
              importanceScore
            }
          }
        };
      }
    },
    {
      id: 'explicit-reference-context',
      name: 'æ˜¾å¼å¼•ç”¨ä¸Šä¸‹æ–‡æ™‹å‡',
      description: 'å½“ ContextItem è¢«å¤šæ¬¡æ˜¾å¼å¼•ç”¨ä¸”éªŒè¯æœ‰ç”¨æ—¶ï¼Œæ™‹å‡ä¸º Skill',
      priority: 80,
      condition: (contextItem: ContextItem) => {
        // æ£€æŸ¥ä½¿ç”¨ç»Ÿè®¡ä¿¡æ¯
        if (!contextItem.usageStats) return false;

        const { referencedCount, verifiedUseful } = contextItem.usageStats;
        const usefulnessRate = referencedCount > 0 ? verifiedUseful / referencedCount : 0;

        // è¢«æ˜¾å¼å¼•ç”¨æ¬¡æ•°å¤šä¸”æœ‰ç”¨ç‡é«˜
        return referencedCount >= 3 && usefulnessRate >= 0.7;
      },
      action: (contextItem: ContextItem) => {
        if (!contextItem.usageStats || !contextItem.importance) return null;

        const { referencedCount, verifiedUseful } = contextItem.usageStats;
        const usefulnessRate = referencedCount > 0 ? verifiedUseful / referencedCount : 0;
        const { useCount, successCount, failureCount, lastUsed, createdAt } = contextItem.importance;
        const contextPath = contextItem.path; // ä» ContextItem è·å–è·¯å¾„

        const skillName = `referenced_${contextPath
          .split('/')
          .pop()
          ?.split('.')[0]
          ?.replace(/[^a-zA-Z0-9]/g, '_') || 'referenced_skill'}`;

        return {
          id: `skill_${randomUUID()}`, // ä½¿ç”¨éšæœº UUID
          name: skillName,
          description: `ä»è¢«é¢‘ç¹æ˜¾å¼å¼•ç”¨çš„ä¸Šä¸‹æ–‡ "${contextPath}" æ™‹å‡è€Œæ¥çš„æŠ€èƒ½ã€‚å¼•ç”¨æ¬¡æ•°: ${referencedCount}, æœ‰ç”¨ç‡: ${(usefulnessRate * 100).toFixed(2)}%`,
          whenToUse: `å½“éœ€è¦è®¿é—®è¢«é¢‘ç¹å¼•ç”¨çš„ä¸Šä¸‹æ–‡ "${contextPath}" çš„å†…å®¹æ—¶`,
          planTemplate: {},
          successCount: successCount,
          failureCount: failureCount,
          confidence: usefulnessRate,
          lastUsed: lastUsed,
          createdAt: createdAt,
          enabled: true,
          parameters: {
            contextPath: contextPath
          },
          implementation: `// ä»è¢«æ˜¾å¼å¼•ç”¨çš„ä¸Šä¸‹æ–‡æ™‹å‡çš„æŠ€èƒ½å®ç°\nreturn contextItem.content;`,
          metadata: {
            source: 'context_promotion',
            originalContextId: contextItem.id, // ä¿å­˜åŸå§‹ä¸Šä¸‹æ–‡ IDï¼Œè€Œä¸æ˜¯é‡è¦æ€§å¯¹è±¡çš„ ID
            originalContextPath: contextPath,
            originalContextStableId: contextItem.stableId, // ä¿å­˜åŸå§‹ä¸Šä¸‹æ–‡çš„ç¨³å®š ID
            promotionCriteria: {
              referencedCount,
              verifiedUseful,
              usefulnessRate
            }
          }
        };
      }
    },
    {
      id: 'config-or-script-context',
      name: 'é…ç½®æˆ–è„šæœ¬ä¸Šä¸‹æ–‡æ™‹å‡',
      description: 'å½“ ContextItem æ˜¯é…ç½®æ–‡ä»¶æˆ–è„šæœ¬ä¸”è¢«é¢‘ç¹ä½¿ç”¨æ—¶ï¼Œæ™‹å‡ä¸º Skill',
      priority: 70,
      condition: (contextItem: ContextItem) => {
        if (!contextItem.importance) return false;

        // æ£€æŸ¥æ˜¯å¦æ˜¯é…ç½®æ–‡ä»¶æˆ–è„šæœ¬
        const isConfigOrScript = [
          '.json', '.yaml', '.yml', '.toml', '.ini', '.conf',
          '.sh', '.bash', '.zsh', '.ps1', '.cmd', '.bat'
        ].some(ext => contextItem.path.endsWith(ext));

        if (!isConfigOrScript) return false;

        const { useCount, successCount } = contextItem.importance;
        const successRate = useCount > 0 ? successCount / useCount : 0;

        // é…ç½®æˆ–è„šæœ¬è¢«ä½¿ç”¨ä¸”æœ‰ä¸€å®šæˆåŠŸç‡
        return useCount >= 2 && successRate >= 0.6;
      },
      action: (contextItem: ContextItem) => {
        if (!contextItem.importance) return null;

        const { useCount, successCount, failureCount, lastUsed, createdAt } = contextItem.importance;
        const successRate = useCount > 0 ? successCount / useCount : 0;
        const contextPath = contextItem.path; // ä» ContextItem è·å–è·¯å¾„

        // æ ¹æ®æ–‡ä»¶ç±»å‹ç”Ÿæˆä¸åŒçš„æŠ€èƒ½åç§°
        let skillName = contextPath
          .split('/')
          .pop()
          ?.replace(/[^a-zA-Z0-9]/g, '_') || 'config_script_skill';

        if (contextPath.endsWith('.sh') || contextPath.endsWith('.bash')) {
          skillName = `exec_${skillName}`;
        } else if (contextPath.endsWith('.json') || contextPath.endsWith('.yaml') || contextPath.endsWith('.yml')) {
          skillName = `read_${skillName}`;
        }

        return {
          id: `skill_${randomUUID()}`, // ä½¿ç”¨éšæœº UUID
          name: skillName,
          description: `ä»é…ç½®æ–‡ä»¶æˆ–è„šæœ¬ "${contextPath}" æ™‹å‡è€Œæ¥çš„æŠ€èƒ½ã€‚ä½¿ç”¨æ¬¡æ•°: ${useCount}, æˆåŠŸç‡: ${(successRate * 100).toFixed(2)}%`,
          whenToUse: `å½“éœ€è¦è®¿é—®é…ç½®æ–‡ä»¶æˆ–è„šæœ¬ "${contextPath}" çš„å†…å®¹æ—¶`,
          planTemplate: {},
          successCount: successCount,
          failureCount: failureCount,
          confidence: successRate,
          lastUsed: lastUsed,
          createdAt: createdAt,
          enabled: true,
          parameters: {
            contextPath: contextPath
          },
          implementation: `// ä»é…ç½®æ–‡ä»¶æˆ–è„šæœ¬æ™‹å‡çš„æŠ€èƒ½å®ç°\nreturn contextItem.content;`,
          metadata: {
            source: 'context_promotion',
            originalContextId: contextItem.id, // ä¿å­˜åŸå§‹ä¸Šä¸‹æ–‡ IDï¼Œè€Œä¸æ˜¯é‡è¦æ€§å¯¹è±¡çš„ ID
            originalContextPath: contextPath,
            originalContextStableId: contextItem.stableId, // ä¿å­˜åŸå§‹ä¸Šä¸‹æ–‡çš„ç¨³å®š ID
            promotionCriteria: {
              useCount,
              successCount,
              successRate,
              fileType: 'config_or_script'
            }
          }
        };
      }
    }
  ];

  /**
   * è¯„ä¼° ContextItem æ˜¯å¦åº”è¯¥æ™‹å‡ä¸º Skill
   */
  static evaluatePromotion(contextItem: ContextItem): Skill | null {
    // æ£€æŸ¥æ˜¯å¦å·²ç»æ™‹å‡è¿‡
    if ((contextItem as any).metadata?.promotedToSkill) {
      return null;
    }

    // æŒ‰ä¼˜å…ˆçº§æ’åºè§„åˆ™
    const sortedRules = [...this.RULES].sort((a, b) => b.priority - a.priority);

    for (const rule of sortedRules) {
      if (rule.condition(contextItem)) {
        const skill = rule.action(contextItem);
        if (skill) {
          return skill;
        }
      }
    }

    return null;
  }
}

/**
 * Skill â†’ Context é™çº§è§„åˆ™
 */
export class SkillToContextDemotionRules {
  static readonly RULES: SkillToContextRule[] = [
    {
      id: 'low-usage-skill',
      name: 'ä½ä½¿ç”¨ç‡æŠ€èƒ½é™çº§',
      description: 'å½“ Skill é•¿æ—¶é—´æœªè¢«ä½¿ç”¨æ—¶ï¼Œé™çº§ä¸º Context',
      priority: 100,
      condition: (skill: Skill) => {
        // æ£€æŸ¥æŠ€èƒ½å…ƒæ•°æ®ä¸­çš„ä½¿ç”¨ç»Ÿè®¡
        if (!skill.metadata || !skill.metadata.usageStats) return false;
        
        const { lastUsed, useCount } = skill.metadata.usageStats;
        const daysSinceLastUse = (Date.now() - lastUsed) / (1000 * 60 * 60 * 24);
        
        // å¦‚æœé•¿æ—¶é—´æœªä½¿ç”¨ä¸”ä½¿ç”¨æ¬¡æ•°è¾ƒå°‘ï¼Œåˆ™è€ƒè™‘é™çº§
        return daysSinceLastUse > 30 && useCount < 3;
      },
      action: (skill: Skill) => {
        // ä»æŠ€èƒ½çš„å…ƒæ•°æ®ä¸­æ¢å¤åŸå§‹ä¸Šä¸‹æ–‡ä¿¡æ¯
        if (skill.metadata && skill.metadata.originalContextPath) {
          return {
            type: 'file', // å‡è®¾åŸå§‹ä¸Šä¸‹æ–‡æ˜¯æ–‡ä»¶ç±»å‹
            path: skill.metadata.originalContextPath,
            content: skill.implementation || '', // ä½¿ç”¨æŠ€èƒ½å®ç°ä½œä¸ºå†…å®¹
            tokens: Math.ceil((skill.implementation || '').length / 4), // ä¼°ç®—tokenæ•°
            importance: {
              id: skill.id.replace('skill_', 'ctx_'),
              path: skill.metadata.originalContextPath,
              type: 'file',
              useCount: skill.metadata.usageStats?.useCount || 0,
              successCount: skill.metadata.usageStats?.successCount || 0,
              failureCount: skill.metadata.usageStats?.failureCount || 0,
              confidence: skill.metadata.usageStats?.confidence || 0.5,
              createdAt: skill.metadata.createdAt || Date.now(),
              lastUsed: skill.metadata.usageStats?.lastUsed || Date.now()
            },
            summary: skill.description,
            summarized: true,
            semantic: 'decision',
            summaryQuality: 0.8,
            referencedBy: [],
            usageStats: {
              referencedCount: 0,
              verifiedUseful: 0,
              verifiedNotUseful: 0
            },
            tags: [],
            projectScope: undefined,
            metadata: {}
          } as ContextItem;
        }

        return null;
      }
    },
    {
      id: 'failed-skill',
      name: 'å¤±è´¥æŠ€èƒ½é™çº§',
      description: 'å½“ Skill å¤šæ¬¡æ‰§è¡Œå¤±è´¥æ—¶ï¼Œé™çº§ä¸º Context ä¾›äººå·¥å®¡æŸ¥',
      priority: 90,
      condition: (skill: Skill) => {
        // æ£€æŸ¥æŠ€èƒ½å…ƒæ•°æ®ä¸­çš„å¤±è´¥ç»Ÿè®¡
        if (!skill.metadata || !skill.metadata.usageStats) return false;
        
        const { failureCount, successCount } = skill.metadata.usageStats;
        const failureRate = (failureCount || 0) / ((successCount || 0) + (failureCount || 0));
        
        // å¦‚æœå¤±è´¥ç‡è¿‡é«˜ï¼Œåˆ™è€ƒè™‘é™çº§
        return failureRate > 0.7;
      },
      action: (skill: Skill) => {
        // ä»æŠ€èƒ½åˆ›å»ºä¸€ä¸ªä¸Šä¸‹æ–‡é¡¹ï¼Œæ ‡è®°ä¸ºéœ€è¦å®¡æŸ¥
        return {
          type: 'file',
          path: `${skill.name}_failed_skill.txt`,
          content: `æ­¤æŠ€èƒ½ "${skill.name}" å¤šæ¬¡æ‰§è¡Œå¤±è´¥ï¼Œéœ€è¦äººå·¥å®¡æŸ¥å’Œä¿®å¤ã€‚\n\nå¤±è´¥æ¬¡æ•°: ${skill.metadata?.usageStats?.failureCount}\næˆåŠŸæ¬¡æ•°: ${skill.metadata?.usageStats?.successCount}\n\næŠ€èƒ½å®ç°:\n${skill.implementation}`,
          tokens: Math.ceil(`æ­¤æŠ€èƒ½ "${skill.name}" å¤šæ¬¡æ‰§è¡Œå¤±è´¥ï¼Œéœ€è¦äººå·¥å®¡æŸ¥å’Œä¿®å¤ã€‚`.length / 4),
          semantic: 'decision', // æ ‡è®°ä¸ºå†³ç­–ç±»ä¸Šä¸‹æ–‡
          importance: {
            id: skill.id.replace('skill_', 'ctx_'),
            path: `${skill.name}_failed_skill.txt`,
            type: 'file',
            useCount: 0,
            successCount: 0,
            failureCount: 0,
            confidence: 0.5,
            createdAt: Date.now(),
            lastUsed: Date.now()
          },
          summary: `å…³äºæŠ€èƒ½ "${skill.name}" çš„å¤±è´¥åˆ†æ`,
          summarized: true,
          summaryQuality: 0.7,
          referencedBy: [],
          usageStats: {
            referencedCount: 0,
            verifiedUseful: 0,
            verifiedNotUseful: 0
          },
          tags: ['failed-skill', 'review-needed'],
          projectScope: undefined,
          metadata: {}
        } as ContextItem;
      }
    }
  ];

  /**
   * è¯„ä¼° Skill æ˜¯å¦åº”è¯¥é™çº§ä¸º Context
   */
  static evaluateDemotion(skill: Skill): ContextItem | null {
    // æŒ‰ä¼˜å…ˆçº§æ’åºè§„åˆ™
    const sortedRules = [...this.RULES].sort((a, b) => b.priority - a.priority);
    
    for (const rule of sortedRules) {
      if (rule.condition(skill)) {
        const contextItem = rule.action(skill);
        if (contextItem) {
          return contextItem;
        }
      }
    }
    
    return null;
  }
}

// å¯¼å…¥å¿…è¦çš„å‡½æ•°
import { computeContextImportance } from './contextImportance';
import { randomUUID } from 'crypto';
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/contextStorage.ts

````typescript
import fs from 'fs/promises';
import path from 'path';
import { ContextItem } from './contextBuffer';

const CONTEXT_DIR = path.resolve(process.cwd(), '.ai');
const CONTEXT_FILE = path.join(CONTEXT_DIR, 'context.json');

export async function loadContext(): Promise<ContextItem[]> {
    try {
        const raw = await fs.readFile(CONTEXT_FILE, 'utf-8');
        return JSON.parse(raw);
    } catch {
        return [];
    }
}

export async function saveContext(items: ContextItem[]) {
    await fs.mkdir(CONTEXT_DIR, { recursive: true });
    await fs.writeFile(CONTEXT_FILE, JSON.stringify(items, null, 2));
}

export async function clearContextStorage() {
    await fs.rm(CONTEXT_FILE, { force: true });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/contextSummary.ts

````typescript
import { askAI } from '../ai/client';

export function buildContextSummaryPrompt(
  type: 'file' | 'directory',
  path: string,
  content: string
) {
  return `
ä½ æ˜¯ä¸€ä¸ªä»£ç ä¸æ–‡æ¡£å‹ç¼©å™¨ã€‚

ç›®æ ‡ï¼š
- æœ€å¤§é™åº¦ä¿ç•™"ä¹‹åå›ç­”é—®é¢˜æ‰€éœ€çš„ä¿¡æ¯"
- åˆ é™¤å®ç°ç»†èŠ‚ã€é‡å¤å†…å®¹ã€å™ªå£°
- ä¸è¦åŠ å…¥æ¨æµ‹

è¯·å°†ä»¥ä¸‹ ${type} å†…å®¹å‹ç¼©ä¸º **ç»“æ„åŒ–æ‘˜è¦**ï¼š

è·¯å¾„: ${path}

è¦æ±‚æ ¼å¼ï¼š
- ç”¨é¡¹ç›®ç¬¦å·
- ä¿ç•™ï¼šèŒè´£ / æ¥å£ / å…³é”®æ•°æ®ç»“æ„ / å…³é”®è¡Œä¸º
- ä»£ç åªä¿ç•™å‡½æ•°ç­¾åæˆ–æ ¸å¿ƒé€»è¾‘æè¿°
- ä¸è¶…è¿‡åŸå†…å®¹çš„ 20%

å†…å®¹ï¼š
\`\`\`
${content}
\`\`\`
`;
}

export async function summarizeContext(
  item: { type: 'file' | 'directory'; path: string; content: string }
): Promise<string> {
  const prompt = buildContextSummaryPrompt(
    item.type,
    item.path,
    item.content
  );

  const summary = await askAI(prompt);
  return summary.trim();
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/executionRecorder.ts

````typescript
import { ExecutionTurn } from './state';
import { ContextDiff } from './contextDiff';

export class ExecutionRecorder {
  private turns: ExecutionTurn[] = [];
  private turnCounter = 0;

  recordTurn(turn: Omit<ExecutionTurn, 'turnId'>): ExecutionTurn {
    const executionTurn: ExecutionTurn = {
      ...turn,
      turnId: ++this.turnCounter
    };

    this.turns.push(executionTurn);
    return executionTurn;
  }

  getTurns(): ExecutionTurn[] {
    return [...this.turns];
  }

  clear(): void {
    this.turns = [];
    this.turnCounter = 0;
  }

  getSummary(): {
    totalTurns: number;
    totalAddedContext: number;
    totalRemovedContext: number;
    totalChangedContext: number;
  } {
    return {
      totalTurns: this.turns.length,
      totalAddedContext: this.turns.reduce((sum, turn) => 
        sum + (turn.contextDiff?.added.length || 0), 0),
      totalRemovedContext: this.turns.reduce((sum, turn) => 
        sum + (turn.contextDiff?.removed.length || 0), 0),
      totalChangedContext: this.turns.reduce((sum, turn) => 
        sum + (turn.contextDiff?.changed.length || 0), 0)
    };
  }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/executor.ts

````typescript
import { ProposedAction, ToolExecutionResult } from './state';
import { VSCodeExecutor } from '../../runtime/vscode/VSCodeExecutor';
import { addSkill } from './skills';

/**
 * VS Code é€‚é…ç‰ˆçš„ ToolExecutor
 * å°†æ‰€æœ‰æ‰§è¡Œé€»è¾‘é‡å®šå‘åˆ° VS Code API
 */
export class ToolExecutor {
  static async execute(action: ProposedAction): Promise<ToolExecutionResult> {
    const { type, payload } = action;

    try {
      switch (type) {
        case 'tool_call':
          return await this.executeTool(payload);

        case 'shell_cmd':
          const shellResult = await VSCodeExecutor.runCommand(payload.command);
          return { success: true, output: shellResult };

        case 'code_diff':
          const diffResult = await VSCodeExecutor.applyDiff(payload.diff);
          return { success: true, output: diffResult };

        case 'answer':
          return {
            success: true,
            output: payload.content || payload.text || '',
            artifacts: []
          };

        default:
          return {
            success: false,
            error: `Unknown action type: ${type}`,
            output: ''
          };
      }
    } catch (error: any) {
      return {
        success: false,
        error: error.message || String(error),
        output: ''
      };
    }
  }

  private static async executeTool(payload: any): Promise<ToolExecutionResult> {
    const toolName = payload.tool_name;
    const params = payload.parameters || {};

    switch (toolName) {
      case 'read_file':
        try {
          const content = await VSCodeExecutor.readFile(params.path);
          return { success: true, output: content };
        } catch (e: any) {
          return { success: false, error: e.message, output: "" };
        }

      case 'write_file':
        const writeResult = await VSCodeExecutor.writeFile(params.path, params.content);
        return { success: true, output: writeResult };

      case 'list_files':
        try {
          const fileList = await VSCodeExecutor.listFiles(params.path || '.');
          return { success: true, output: fileList };
        } catch (e: any) {
          return { success: false, error: e.message, output: "" };
        }

      case 'skill_create':
          try {
              const success = addSkill(params);
              if (success) {
                  return { success: true, output: `Skill "${params.name}" created successfully.` };
              } else {
          return { success: false, error: `Skill "${params.name}" already exists.`, output: "" };
              }
          } catch (e: any) {
              return { success: false, error: `Failed to create skill: ${e.message}`, output: "" };
          }

      default:
        return {
          success: false,
          error: `Unknown tool: ${toolName}`,
          output: ''
        };
    }
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/governance.ts

````typescript
import { ProposedAction, GovernanceDecision } from './state';
import { evaluateProposal, PolicyRule, RiskEntry } from './governance/core';
import { RiskLedger } from './governance/ledger';
import { WasmGovernanceBridge } from './governance/bridge';
import jsyaml from 'js-yaml';
import fs from 'fs';
import path from 'path';

export class GovernanceService {
  private static rules: PolicyRule[] = [];
  private static ledger = new RiskLedger();
  private static initialized = false;

  static async init(basePath?: string) {
    if (this.initialized) return;
    this.loadPolicy(basePath);
    await WasmGovernanceBridge.init(basePath);
    this.initialized = true;
  }

  private static loadPolicy(basePath?: string) {
    try {
      const root = basePath || process.cwd();
      const policyPath = path.join(root, 'policy.yaml');
      if (fs.existsSync(policyPath)) {
        const content = fs.readFileSync(policyPath, 'utf8');
        const config = jsyaml.load(content) as any;
        this.rules = config.rules || [];
      }
    } catch (e) {
      this.rules = [];
    }
  }

  static getRules(): PolicyRule[] {
    return this.rules;
  }

  static getLedgerSnapshot(): RiskEntry[] {
    return this.ledger.getSnapshot();
  }

  static getPolicyManual(): string {
    return this.rules.map(r => `- ${r.id}: ${r.reason} (${r.effect})`).join('\n');
  }

  static async adjudicate(action: ProposedAction): Promise<GovernanceDecision> {
    await this.init();

    // 1. WASM ç‰©ç†å±‚æ ¸éªŒ
    const wasmResult = WasmGovernanceBridge.evaluate(action, this.rules, this.ledger.getSnapshot());
    if (wasmResult.effect === 'deny') {
      return { status: 'rejected', by: 'policy', reason: wasmResult.reason || 'WASM Denied', timestamp: Date.now() };
    }

    // 2. é€»è¾‘å±‚æ ¸éªŒ
    const logicResult = evaluateProposal(action, this.rules, this.ledger.getSnapshot());
    if (logicResult.effect === 'deny') {
      return { status: 'rejected', by: 'policy', reason: logicResult.reason || 'Policy Denied', timestamp: Date.now() };
    }

    if (logicResult.effect === 'allow') {
      this.ledger.record(action.type);
      return { status: 'approved', by: 'policy', timestamp: Date.now() };
    }

    // 3. äººå·¥å¹²é¢„å…œåº• (æ¨¡æ‹Ÿ)
    return { status: 'approved', by: 'human', timestamp: Date.now() };
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/governance/bridge.ts

````typescript
import fs from 'fs';
import path from 'path';

export class WasmGovernanceBridge {
    private static instance: any = null;

    static async init(basePath?: string): Promise<boolean> {
        try {
            const loader = require('@assemblyscript/loader');
            const wasmPath = path.join(basePath || process.cwd(), 'build', 'release.wasm');

            if (!fs.existsSync(wasmPath)) {
                console.error(`WASM not found at: ${wasmPath}`);
                return false;
            }

            const wasmModule = await loader.instantiate(fs.readFileSync(wasmPath));
            this.instance = wasmModule.exports;
            return true;
        } catch (e) {
            console.error(`WASM init error: ${e}`);
            return false;
        }
    }

    static evaluate(proposal: any, rules: any, ledger: any): any {
        if (!this.instance) return { effect: 'error', reason: 'WASM not initialized' };

        const { __newString, __getString, evaluate } = this.instance;

        const pPtr = __newString(JSON.stringify(proposal));
        const rPtr = __newString(JSON.stringify(rules));
        const lPtr = __newString(JSON.stringify(ledger));

        const resultPtr = evaluate(pPtr, rPtr, lPtr);
        return JSON.parse(__getString(resultPtr));
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/governance/core.ts

````typescript
import { ProposedAction } from '../state';

export interface PolicyRule {
    id: string;
    when: { type?: string; pattern?: string; max_per_minute?: number };
    effect: 'allow' | 'deny' | 'require_approval';
    reason?: string;
}

export interface RiskEntry {
    ts: number;
    actionType: string;
}

export function evaluateProposal(
    action: ProposedAction,
    rules: PolicyRule[],
    ledger: RiskEntry[]
): { effect: string; reason?: string } {
    const now = Date.now();
    for (const rule of rules) {
        const typeMatch = !rule.when.type || rule.when.type === action.type;
        const payloadStr = JSON.stringify(action.payload);
        const patternMatch = !rule.when.pattern || new RegExp(rule.when.pattern, 'i').test(payloadStr);

        if (typeMatch && patternMatch) {
            if (rule.when.max_per_minute) {
                const count = ledger.filter(e => e.ts > now - 60000 && e.actionType === action.type).length;
                if (count >= rule.when.max_per_minute) return { effect: 'deny', reason: `Rate limit: ${rule.id}` };
            }
            return { effect: rule.effect, reason: rule.reason };
        }
    }
    return { effect: 'require_approval', reason: 'Default human review required' };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/governance/ledger.ts

````typescript
import { RiskEntry } from './core';

export class RiskLedger {
    private entries: RiskEntry[] = [];

    record(actionType: string): void {
        this.entries.push({
            ts: Date.now(),
            actionType
        });
        this.cleanup();
    }

    getSnapshot(): RiskEntry[] {
        return [...this.entries];
    }

    private cleanup(): void {
        const oneHourAgo = Date.now() - 3600000;
        this.entries = this.entries.filter(e => e.ts > oneHourAgo);
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/governance/sandbox/core.as.ts

````typescript
/**
 * yuangs Governance WASM Sandbox
 * è¿™é‡Œçš„ä»£ç åœ¨æ‰§è¡Œæ—¶ä¸ Node.js å†…å­˜å®Œå…¨éš”ç¦»
 */

// ç®€å•çš„è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥å­—ç¬¦ä¸²åŒ…å«ï¼ˆWASM å†…éƒ¨å®ç°ï¼‰
function includes(source: string, target: string): boolean {
    return source.indexOf(target) != -1;
}

/**
 * æ ¸å¿ƒè£å†³å¯¼å‡ºå‡½æ•°
 * @param proposal ææ¡ˆå­—ç¬¦ä¸²
 * @param rules è§„åˆ™å­—ç¬¦ä¸²ï¼ˆYAML è½¬æ¢åçš„ JSONï¼‰
 * @param ledger è´¦æœ¬å­—ç¬¦ä¸²
 */
export function evaluate(proposal: string, rules: string, ledger: string): string {
    // 1. æš´åŠ›é˜»æ–­ï¼šæœ€åº•å±‚çš„ç‰©ç†é˜²çº¿ï¼ˆå³ä¾¿å¤–éƒ¨é€»è¾‘è¢«æ±¡æŸ“ï¼Œè¿™é‡Œä¹Ÿæ˜¯æ­»çš„ï¼‰
    if (proposal.includes("rm -rf /") || proposal.includes("sudo rm")) {
        return '{"effect": "deny", "reason": "WASM_SANDBOX: æ£€æµ‹åˆ°æ¯ç­æ€§å‘½ä»¤ï¼Œå¼ºåˆ¶é˜»æ–­"}';
    }

    // 2. æ£€æŸ¥é€Ÿç‡ï¼ˆåŸºäºè´¦æœ¬é•¿åº¦ï¼‰
    // å‡è®¾æˆ‘ä»¬ä¸æƒ³è®© AI åœ¨çŸ­æ—¶é—´å†…è¿ç»­æè®®è¶…è¿‡ 50 æ¬¡
    if (ledger.length > 5000) { // ç®€å•é€šè¿‡å­—ç¬¦ä¸²é•¿åº¦æ¨¡æ‹Ÿå¼‚å¸¸è´¦æœ¬
        return '{"effect": "deny", "reason": "WASM_SANDBOX: è´¦æœ¬å¼‚å¸¸è†¨èƒ€ï¼Œå¯èƒ½é­å—æ‹’ç»æœåŠ¡æ”»å‡»"}';
    }

    // 3. é€»è¾‘é€ä¼ 
    // åœ¨å®é™…ç”Ÿäº§ä¸­ï¼Œæˆ‘ä»¬ä¼šåœ¨è¿™é‡Œè§£æ JSON rulesã€‚
    // ç›®å‰ç‰ˆæœ¬æˆ‘ä»¬å…ˆç¡®ä¿ç‰©ç†é“¾è·¯æ‰“é€šã€‚
    return '{"effect": "allow", "reason": "WASM_SANDBOX: ç‰©ç†éš”ç¦»å±‚éªŒè¯é€šè¿‡"}';
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/index.ts

````typescript
export { AgentRuntime } from './AgentRuntime';
export * from './state';
export { LLMAdapter } from './llmAdapter';
export { GovernanceService } from './governance';
export { ToolExecutor } from './executor';
export { ContextManager } from './contextManager';
export { ContextBuffer } from './contextBuffer';
export { ContextImportance, computeContextImportance, createContextImportance, updateContextImportance } from './contextImportance';
export { buildContextSummaryPrompt, summarizeContext } from './contextSummary';
export { diffContext, snapshotFromBuffer, ContextDiff, ContextSnapshot } from './contextDiff';
export { ExecutionRecorder } from './executionRecorder';
export { explainExecution, replayExecution } from './replayExplain';
export { generateSkillHintsFromContext, formatSkillHints, ContextSkillHint } from './contextSkillBridge';
export * from './skills';

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/knowledgeGraph.ts

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';

export type KGNodeType = 'context' | 'execution' | 'skill';

export type KGEdgeType =
  | 'used_in'        // Context -> Execution
  | 'validated_by'   // Execution -> Skill
  | 'promoted_to'    // Context -> Skill
  | 'derived_from';  // Skill -> Context (optional)

export interface KnowledgeGraphEdge {
  from: string;
  to: string;
  type: KGEdgeType;
  timestamp: number;
  meta?: Record<string, any>;
}

const KG_DIR = path.join(os.homedir(), '.yuangs', 'knowledge');
const KG_FILE = path.join(KG_DIR, 'graph.jsonl');

function ensureDir() {
  if (!fs.existsSync(KG_DIR)) {
    fs.mkdirSync(KG_DIR, { recursive: true });
  }
}

/**
 * è®°å½•ä¸€æ¡ä¸å¯å˜çš„çŸ¥è¯†å›¾è°±è¾¹ (Append-only Fact)
 */
export function recordEdge(edge: KnowledgeGraphEdge) {
  try {
    ensureDir();
    // ç®€å•çš„ JSONL æ ¼å¼ï¼šä¸€è¡Œä¸€ä¸ª JSON å¯¹è±¡
    const line = JSON.stringify({
        ...edge,
        // ç¡®ä¿ timestamp å­˜åœ¨
        timestamp: edge.timestamp || Date.now()
    });
    
    fs.appendFileSync(KG_FILE, line + '\n', 'utf8');
  } catch (error) {
    // å®¹é”™ï¼šKG è®°å½•å¤±è´¥ä¸åº”é˜»æ–­ä¸»æµç¨‹
    console.warn('[KnowledgeGraph] Failed to record edge:', error);
  }
  // NOTE: sync write is acceptable at current scale (<100 edges / run)
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/llm.ts

````typescript
import { AgentPrompt, LLMResult } from './types';
import { callAI_Stream } from '../ai/client';
import axios from 'axios';
import { DEFAULT_AI_PROXY_URL, DEFAULT_MODEL, DEFAULT_ACCOUNT_TYPE, type AIRequestMessage } from '../core/validation';
import fs from 'fs';
import path from 'path';
import os from 'os';
import { safeParseJSON } from '../core/validation';

const CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');

function getUserConfig(): any {
    if (fs.existsSync(CONFIG_FILE)) {
        try {
            const content = fs.readFileSync(CONFIG_FILE, 'utf8');
            return JSON.parse(content);
        } catch (e) { }
    }
    return {};
}

export async function runLLM({
    prompt,
    model,
    stream,
    onChunk,
    abortSignal
}: {
    prompt: AgentPrompt;
    model: string;
    stream: boolean;
    onChunk?: (s: string) => void;
    abortSignal?: AbortSignal;
}): Promise<LLMResult> {
    const start = Date.now();

    // âœ… æ£€æŸ¥å–æ¶ˆä¿¡å·
    if (abortSignal?.aborted) {
        throw new Error('LLM request cancelled');
    }

    // âœ… è®¾ç½®å–æ¶ˆç›‘å¬å™¨
    const cleanup = () => {};
    if (abortSignal) {
        abortSignal.addEventListener('abort', () => {
            console.log('[runLLM] Request aborted');
        });
    }

    if (stream) {
        let raw = '';
        let buffer = '';
        let lastFlush = Date.now();

        await callAI_Stream(prompt.messages, model, (chunk) => {
            // âœ… åœ¨æ¯ä¸ªchunkæ£€æŸ¥å–æ¶ˆä¿¡å·
            if (abortSignal?.aborted) {
                throw new Error('LLM streaming cancelled');
            }

            raw += chunk;
            buffer += chunk;

            // èŠ‚æµï¼šæ¯50msæœ€å¤šè§¦å‘ä¸€æ¬¡onChunkï¼Œçº¦20FPS
            if (Date.now() - lastFlush > 50) {
                onChunk?.(buffer);
                buffer = '';
                lastFlush = Date.now();
            }
        });

        // ç¡®ä¿æœ€åçš„ç¼“å†²åŒºå†…å®¹ä¹Ÿè¢«å‘é€
        if (buffer) {
            onChunk?.(buffer);
        }

        return {
            rawText: raw,
            latencyMs: Date.now() - start,
        };
    }

    // Non-streaming mode with optional schema
    const config = getUserConfig();
    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;

    const headers = {
        'Content-Type': 'application/json',
        'X-Client-ID': 'vscode',
        'Origin': 'https://cli.want.biz',
        'Referer': 'https://cli.want.biz/',
        'account': config.accountType || DEFAULT_ACCOUNT_TYPE,
        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',
        'Accept': 'application/json'
    };

    const data = {
        model: model || config.defaultModel || DEFAULT_MODEL,
        messages: prompt.messages,
        stream: false
    };

    try {
        const response = await axios.post(url, data, { headers });
        const rawText = response.data.choices[0]?.message?.content || '';

        let parsed = undefined;
        if (prompt.outputSchema) {
            const parseResult = safeParseJSON(rawText, prompt.outputSchema, {});
            if (parseResult.success) {
                parsed = parseResult.data;
            }
        }

        return {
            rawText,
            parsed,
            latencyMs: Date.now() - start,
        };
    } catch (error: any) {
        const errorMsg = error.response?.data?.error?.message || error.response?.data?.message || error.message || 'æœªçŸ¥é”™è¯¯';
        throw new Error(`AI è¯·æ±‚å¤±è´¥: ${errorMsg}`);
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/llmAdapter.ts

````typescript
import { AgentThought } from './state';
import { runLLM } from './llm';
import { AgentPrompt } from './types';
import type { AIRequestMessage } from '../core/validation';
import { getUserConfig } from '../ai/client';
import { ContextManager } from './contextManager';
import { ExtendedContextProtocol } from './contextDSL';
import { parseContextReferences, validateContextReferences, buildContextPromptWithReferences } from './contextProtocol';
import { randomUUID } from 'crypto';

export class LLMAdapter {
  static async think(
    messages: AIRequestMessage[],
    mode: 'chat' | 'command' | 'command+exec' = 'chat',
    onChunk?: (chunk: string) => void,
    model?: string,
    customSystemPrompt?: string,
    contextManager?: ContextManager,
    abortSignal?: AbortSignal
  ): Promise<AgentThought> {
    // ç”Ÿæˆå”¯ä¸€çš„å“åº”IDç”¨äºå¼•ç”¨è·Ÿè¸ª
    const responseId = randomUUID();

    // æ„å»ºåŒ…å«ContextBufferå†…å®¹çš„å®Œæ•´ä¸Šä¸‹æ–‡
    let fullMessages = [...messages];

    if (contextManager) {
      const contextBuffer = contextManager.getContextBuffer();
      if (!contextBuffer.isEmpty()) {
        // æ£€æŸ¥ç”¨æˆ·æ¶ˆæ¯ä¸­æ˜¯å¦æœ‰ DSL æŸ¥è¯¢
        const userInput = messages[messages.length - 1]?.content || '';
        const dslContextItems = await contextBuffer.getDSLContextForInput(userInput);

        console.log(`[LLMAdapter] ContextBuffer is NOT EMPTY. Total items: ${contextBuffer.export().length}`);
        console.log(`[LLMAdapter] DSL context items: ${dslContextItems.length}`);

        // æ‰“å°æ‰€æœ‰ä¸Šä¸‹æ–‡é¡¹çš„æ‘˜è¦
        const allItems = contextBuffer.export();
        allItems.forEach((item, idx) => {
          console.log(`[LLMAdapter] Context Item ${idx + 1}:`, {
            path: item.path,
            alias: item.alias,
            type: item.semantic,
            confidence: item.importance?.confidence,
            tags: item.tags,
            contentLength: item.content?.length || 0
          });
        });

        let contextPrompt: string;

        if (dslContextItems.length > 0) {
          // å¦‚æœæœ‰ DSL æŸ¥è¯¢ç»“æœï¼Œä½¿ç”¨ buildContextPromptWithReferences æ¥æ„å»ºæç¤º
          console.log(`[LLMAdapter] Using DSL-based context prompt`);
          contextPrompt = await buildContextPromptWithReferences(contextBuffer, userInput);
        } else {
          // åŒºåˆ†æµå¼ä¼ è¾“å’Œéæµå¼ä¼ è¾“
          // âœ… ä¿®å¤ï¼šæµå¼ä¼ è¾“ä¹Ÿä½¿ç”¨ ranked ç­–ç•¥ï¼Œç¡®ä¿ @references ä¼˜å…ˆçº§æœ€é«˜
          if (onChunk) {
            // æµå¼ä¼ è¾“æ—¶ä½¿ç”¨æ’åç­–ç•¥ï¼Œç¡®ä¿ç”¨æˆ· @ å¼•ç”¨çš„æ–‡ä»¶ä¼˜å…ˆæ˜¾ç¤º
            // é€‚å½“å¢åŠ  token é™åˆ¶ï¼Œé¿å…é‡è¦å†…å®¹è¢«æˆªæ–­
            console.log(`[LLMAdapter] Using RANKED strategy with 12000 tokens (streaming mode)`);
            contextPrompt = contextBuffer.buildPrompt('', {
              strategy: 'ranked',  // ä½¿ç”¨æ’åç­–ç•¥ï¼ŒæŒ‰é‡è¦æ€§æ’åº
              maxTokens: 12000     // å¢åŠ tokené™åˆ¶ï¼Œç¡®ä¿ @references å†…å®¹å®Œæ•´
            });
          } else {
            // éæµå¼ä¼ è¾“æ—¶ä½¿ç”¨å®Œæ•´çš„æ’åç­–ç•¥
            console.log(`[LLMAdapter] Using RANKED strategy with 16000 tokens (non-streaming mode)`);
            contextPrompt = contextBuffer.buildPrompt('', {
              strategy: 'ranked',  // ä½¿ç”¨æ’åç­–ç•¥
              maxTokens: 16000     // è®¾ç½®æœ€å¤§tokené™åˆ¶
            });
          }
        }

        console.log(`[LLMAdapter] Generated context prompt length: ${contextPrompt.length} chars`);

        // å°†ContextBufferå†…å®¹ä½œä¸ºèƒŒæ™¯ä¿¡æ¯æ¶ˆæ¯æ·»åŠ åˆ°æ¶ˆæ¯åˆ—è¡¨å¼€å¤´
        // ä½¿ç”¨æ›´æ˜æ˜¾çš„éš”ç¦»ç¬¦ï¼Œç¡®ä¿ AI ä¸ä¼šæ··æ·†ä¸Šä¸‹æ–‡å’Œå¯¹è¯å†å²
        const contextRoleMessage = {
          role: 'system',
          content: `[CONTEXT DATA STARTED]\n\n${contextPrompt}\n\n[CONTEXT DATA ENDED]\n\nAbove is the project context including files and documentation. Use this information to answer the following questions.`
        };

        fullMessages = [
          contextRoleMessage as any,
          ...fullMessages
        ];
      } else {
        console.log(`[LLMAdapter] ContextBuffer is EMPTY - no context will be sent to AI!`);
      }
    }

    const prompt: AgentPrompt = {
      system: customSystemPrompt || `[SYSTEM PROTOCOL V3.1 - SAFE OBSERVATION ACK - CONTEXT REFERENCE ENABLED]
- ROLE: AUTOMATED EXECUTION AGENT WITH CONTEXT REFERENCE
- OUTPUT: STRICT JSON ONLY
- TALK: FORBIDDEN
- MODE: REACT (THINK -> ACTION -> PERCEIVE)
- CONTEXT REFERENCE: When using information from the provided context, explicitly reference it in your response using [Reference] notation or in the JSON output

OBSERVATION ACKNOWLEDGEMENT (MANDATORY, WITH EXCEPTIONS):
Before proposing any action, you MUST include the field "acknowledged_observation".

RULES:
1. If a valid Tool or System Observation exists, restate it VERBATIM.
2. If NO such Observation exists, output: "acknowledged_observation": "NONE"
3. DO NOT acknowledge:
   - Runtime validation errors
   - ACK-related errors
   - System internal error messages
4. If the user input is "stop" or "halt":
   - Set action_type = "answer"
   - Set acknowledged_observation = "NONE"
   - Do NOT propose further actions

JSON SCHEMA:
{
  "acknowledged_observation": "string | 'NONE'",
  "action_type": "tool_call" | "shell_cmd" | "code_diff" | "answer" | "halt",
  "reasoning": "thought process",
  "tool_name": "read_file" | "write_file" | "list_files",
  "diff": "unified diff string",
  "parameters": {},
  "command": "shell string",
  "content": "final answer string",
  "used_context": ["path/to/file.ts", "path/to/dir"] // OPTIONAL: List paths of context items used
}

AVAILABLE TOOLS:
- read_file: Read file contents (parameter: path)
- write_file: Write or overwrite a file (parameters: path, content)
- list_files: List files and directories (parameter: path, optional, defaults to '.')

EXECUTION RULES:
1. If data is unknown (e.g. file list), use 'shell_cmd' or 'tool_call'.
2. NEVER explain how to do it. JUST EXECUTE.
3. Your output MUST start with '{' and end with '}'.
4. When referencing information from provided context, include the path in "used_context" array or use [Reference] notation.
5. TERMINATION RULE (HIGHEST PRIORITY): If user says "stop", "exit", or "quit", output action_type="answer" with content="STOPPED" and acknowledged_observation="NONE".

Example Task: "count files"
Your Output: {"action_type":"shell_cmd","reasoning":"count files","command":"ls | wc -l","used_context":["/path/to/config.json"]}`,
      messages: fullMessages,
    };

    const config = getUserConfig();
    const finalModel = model || config.defaultModel || 'Assistant';

    const result = await runLLM({
      prompt,
      model: finalModel,
      stream: !!onChunk,
      onChunk,
      abortSignal // âœ… ä¼ é€’å–æ¶ˆä¿¡å·åˆ° runLLM
    });

    // è§£æå“åº”å¹¶å¤„ç†Contextå¼•ç”¨
    const thought = this.parseThought(result.rawText);

    // å¦‚æœæœ‰ContextManagerï¼Œè§£æå¹¶è®°å½•å¼•ç”¨
    if (contextManager) {
      const contextBuffer = contextManager.getContextBuffer();
      const references = parseContextReferences(result.rawText);

      // è®°å½•æ˜¾å¼å¼•ç”¨
      for (const ref of references.referencedItems) {
        contextBuffer.recordExplicitReference(ref.path, responseId);
      }

      // éªŒè¯å¼•ç”¨çš„æœ‰æ•ˆæ€§
      const validation = validateContextReferences(
        references.referencedItems,
        contextBuffer.export()
      );

      // æ›´æ–°å¼•ç”¨çš„æœ‰æ•ˆæ€§
      for (const validRef of validation.valid) {
        contextBuffer.validateReference(validRef.path, true);
      }

      for (const invalidRef of validation.invalid) {
        contextBuffer.validateReference(invalidRef.path, false);
      }
    }

    return thought;
  }

  private static parseThought(raw: string): AgentThought {
    try {
      // æå– JSONï¼šæ”¯æŒ Markdown å—æˆ–çº¯ JSON å­—ç¬¦ä¸²
      const jsonMatch = raw.match(/```json\n([\s\S]*?)\n```/) || raw.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[1] || jsonMatch[0]);

        // å¦‚æœæ˜ç¡®æ ‡è®°ä¸º doneï¼Œæˆ–è€…åŠ¨ä½œä¸º answerï¼Œåˆ™è§†ä¸ºä»»åŠ¡ç»“æŸ
        if (parsed.is_done === true || parsed.action_type === 'answer') {
          return {
            raw,
            parsedPlan: parsed,
            isDone: true,
            type: 'answer',
            payload: {
              content: parsed.final_answer || parsed.content || parsed.text || raw
            }
          };
        }

        // æ™ºèƒ½æ¨æ–­åŠ¨ä½œç±»å‹ï¼šå¦‚æœ AI æ²¡ç»™ action_typeï¼Œæˆ‘ä»¬æ ¹æ®å­—æ®µçŒœæµ‹
        let inferredType = parsed.action_type;
        if (!inferredType) {
          if (parsed.tool_name || parsed.tool) inferredType = 'tool_call';
          else if (parsed.command || parsed.cmd) inferredType = 'shell_cmd';
          else if (parsed.diff || parsed.patch) inferredType = 'code_diff';
          else inferredType = 'answer';
        }

        return {
          raw,
          parsedPlan: parsed,
          isDone: inferredType === 'answer' || parsed.is_done === true,
          type: inferredType,
          payload: {
            tool_name: parsed.tool_name || parsed.tool || '',
            parameters: parsed.parameters || parsed.params || {},
            command: parsed.command || parsed.cmd || '',
            diff: parsed.diff || parsed.patch || '',
            content: parsed.content || parsed.text || ''
          },
          reasoning: parsed.reasoning || ''
        };
      }
    } catch (e) {
      // è§£æå¤±è´¥æ—¶ï¼Œå›é€€åˆ°å°†åŸå§‹å†…å®¹ä½œä¸ºå›ç­”
    }

    return {
      raw,
      parsedPlan: {},
      isDone: true,
      type: 'answer',
      payload: { content: raw },
      reasoning: ''
    };
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/policy/engine.ts

````typescript
import { Policy, PolicyContext, PolicyResult } from './types';
import { RiskLevel } from '../state';

export class PolicyEngine {
  private policies: Map<string, Policy> = new Map();

  registerPolicy(policy: Policy): void {
    this.policies.set(policy.name, policy);
  }

  unregisterPolicy(name: string): void {
    this.policies.delete(name);
  }

  async evaluate(context: PolicyContext): Promise<PolicyResult> {
    let finalResult: PolicyResult = {
      allowed: true,
      reason: 'All policies passed'
    };

    for (const [name, policy] of this.policies) {
      const result = await policy.evaluate(context);
      
      if (!result.allowed) {
        return {
          allowed: false,
          reason: `Policy "${name}" blocked: ${result.reason}`,
          requiresEscalation: result.requiresEscalation || false,
          suggestedActions: result.suggestedActions
        };
      }

      if (result.requiresEscalation) {
        finalResult.requiresEscalation = true;
        finalResult.suggestedActions = result.suggestedActions;
      }
    }

    return finalResult;
  }

  evaluateRisk(action: { type: string; payload: any }): RiskLevel {
    const { type, payload } = action;

    if (type === 'tool_call') {
      const toolName = payload.tool_name;
      
      const lowRiskTools = ['read_file', 'list_files', 'web_search'];
      if (lowRiskTools.includes(toolName)) {
        return 'low';
      }

      const mediumRiskTools = ['write_file', 'shell'];
      if (mediumRiskTools.includes(toolName)) {
        const cmd = payload.parameters?.command || payload.command || '';
        if (this.containsDangerousCommand(cmd)) {
          return 'high';
        }
        return 'medium';
      }

      return 'medium';
    }

    if (type === 'shell_cmd') {
      const cmd = payload.command || '';
      if (this.containsDangerousCommand(cmd)) {
        return 'high';
      }
      return 'medium';
    }

    return 'low';
  }

  private containsDangerousCommand(cmd: string): boolean {
    const dangerousPatterns = [
      /rm\s+-rf\s+\//,
      /rm\s+-rf\s+~/,
      />\s*\/dev\/null/,
      /dd\s+if=/,
      /mkfs/,
      /format/,
      /sudo\s+rm/
    ];

    return dangerousPatterns.some(pattern => pattern.test(cmd));
  }
}

export const policyEngine = new PolicyEngine();

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/policy/index.ts

````typescript
export * from './types';
export * from './engine';
export * from './policies/noDangerousShell';

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/policy/policies/noDangerousShell.ts

````typescript
import { Policy, PolicyContext, PolicyResult } from '../types';
import { RiskLevel } from '../../state';

export class NoDangerousShellPolicy implements Policy {
  name = 'no-dangerous-shell';
  description = 'Prevents execution of dangerous shell commands';

  evaluate(context: PolicyContext): PolicyResult {
    const { action } = context;

    if (action.type === 'shell_cmd') {
      const command = action.payload?.command || '';
      
      const dangerousPatterns = [
        { pattern: /rm\s+-rf\s+\//, name: 'rm -rf /', risk: 'high' },
        { pattern: /rm\s+-rf\s+~/, name: 'rm -rf ~', risk: 'high' },
        { pattern: />\s*\/dev\/null/, name: 'Redirect to /dev/null', risk: 'medium' },
        { pattern: /dd\s+if=/, name: 'dd command', risk: 'high' },
        { pattern: /mkfs/, name: 'mkfs (filesystem creation)', risk: 'high' },
        { pattern: /format/, name: 'format command', risk: 'high' },
        { pattern: /sudo\s+rm/, name: 'sudo rm', risk: 'high' },
        { pattern: /chmod\s+777\s+\/(?!dev)/, name: 'chmod 777 on system', risk: 'high' },
        { pattern: /:\s*~\(\)/, name: 'fork bomb', risk: 'high' }
      ];

      for (const { pattern, name, risk } of dangerousPatterns) {
        if (pattern.test(command)) {
          return {
            allowed: false,
            reason: `Dangerous command detected: ${name} (${risk} risk)`,
            requiresEscalation: risk === 'high',
            suggestedActions: [
              `Review the command: "${command}"`,
              'Consider using safer alternatives',
              'Break down the operation into smaller, safer steps'
            ]
          };
        }
      }
    }

    return {
      allowed: true,
      reason: 'No dangerous patterns detected'
    };
  }
}

export const noDangerousShellPolicy = new NoDangerousShellPolicy();

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/policy/sampler.ts

````typescript
import fs from 'fs';
import path from 'path';

/**
 * Sampling strategies for context content
 */
export type SamplingStrategy = 'head' | 'tail' | 'head_tail' | 'full';

/**
 * Cost profile for estimating token usage
 */
export interface CostProfile {
  tokensPerLine: number;
  maxTokens: number;
}

/**
 * Context item that needs to be sampled
 */
export interface ContextItem {
  id: string;
  type: 'file' | 'directory';
  path: string;
  samplingStrategy: SamplingStrategy;
  estimate(): Promise<{ byteSize: number; lineCount: number }>;
  resolve(): Promise<string>;
}

/**
 * Pending context item with lazy resolution
 */
export class PendingContextItem implements ContextItem {
  constructor(
    public id: string,
    public type: 'file' | 'directory',
    public path: string,
    public samplingStrategy: SamplingStrategy = 'head_tail'
  ) {}

  /**
   * Estimate the size without reading the file content
   */
  async estimate(): Promise<{ byteSize: number; lineCount: number }> {
    try {
      const stats = await fs.promises.stat(this.path);
      const byteSize = stats.size;
      
      // Rough estimate: average line is about 80 characters
      const lineCount = Math.ceil(byteSize / 80);
      
      return { byteSize, lineCount };
    } catch (error) {
      console.error(`Error estimating ${this.path}:`, error);
      return { byteSize: 0, lineCount: 0 };
    }
  }

  /**
   * Read and resolve the file content
   */
  async resolve(): Promise<string> {
    try {
      return await fs.promises.readFile(this.path, 'utf-8');
    } catch (error) {
      console.error(`Error reading ${this.path}:`, error);
      return '';
    }
  }
}

/**
 * Sampler configuration
 */
export interface SamplerConfig {
  maxLines?: number;
  maxBytes?: number;
  maxTokens?: number;
  defaultStrategy?: SamplingStrategy;
}

/**
 * Default configuration
 */
const DEFAULT_CONFIG: Required<SamplerConfig> = {
  maxLines: 1000,
  maxBytes: 1024 * 100, // 100KB
  maxTokens: 4000,
  defaultStrategy: 'head_tail'
};

/**
 * Context Sampler
 * 
 * Responsible for sampling and truncating context content based on
 * sampling strategies and budget constraints.
 */
export class ContextSampler {
  private config: Required<SamplerConfig>;

  constructor(config: SamplerConfig = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Sample a single context item
   */
  async sample(item: ContextItem, config?: Partial<SamplerConfig>): Promise<string> {
    const effectiveConfig = { ...this.config, ...config };
    const strategy = item.samplingStrategy || effectiveConfig.defaultStrategy;

    // Estimate first (cheap operation)
    const { byteSize, lineCount } = await item.estimate();

    // If within limits, just resolve and return
    if (byteSize <= effectiveConfig.maxBytes && lineCount <= effectiveConfig.maxLines) {
      return await item.resolve();
    }

    // Need to sample based on strategy
    const content = await item.resolve();
    return this.applySamplingStrategy(content, strategy, effectiveConfig);
  }

  /**
   * Sample multiple context items with budget allocation
   */
  async sampleMultiple(items: ContextItem[], config?: Partial<SamplerConfig>): Promise<Map<string, string>> {
    const results = new Map<string, string>();

    for (const item of items) {
      try {
        const sampled = await this.sample(item, config);
        results.set(item.id, sampled);
      } catch (error) {
        console.error(`Error sampling item ${item.id}:`, error);
        results.set(item.id, '');
      }
    }

    return results;
  }

  /**
   * Apply sampling strategy to content
   */
  private applySamplingStrategy(
    content: string,
    strategy: SamplingStrategy,
    config: Required<SamplerConfig>
  ): string {
    const lines = content.split('\n');
    const totalLines = lines.length;

    switch (strategy) {
      case 'head':
        return this.sampleHead(lines, config.maxLines);

      case 'tail':
        return this.sampleTail(lines, config.maxLines);

      case 'head_tail':
        return this.sampleHeadTail(lines, config.maxLines);

      case 'full':
        return content;

      default:
        return this.sampleHeadTail(lines, config.maxLines);
    }
  }

  /**
   * Sample from the beginning of the file
   */
  private sampleHead(lines: string[], maxLines: number): string {
    const sampled = lines.slice(0, maxLines);
    return sampled.join('\n');
  }

  /**
   * Sample from the end of the file
   */
  private sampleTail(lines: string[], maxLines: number): string {
    const sampled = lines.slice(-maxLines);
    return sampled.join('\n');
  }

  /**
   * Sample from both beginning and end of the file
   */
  private sampleHeadTail(lines: string[], maxLines: number): string {
    if (lines.length <= maxLines) {
      return lines.join('\n');
    }

    const headLines = Math.floor(maxLines / 2);
    const tailLines = maxLines - headLines;

    const head = lines.slice(0, headLines);
    const tail = lines.slice(-tailLines);

    // Add separator to indicate truncation
    const separator = `\n... [${lines.length - maxLines} lines truncated] ...\n`;
    return [...head, separator, ...tail].join('\n');
  }

  /**
   * Estimate token count for content
   */
  estimateTokens(content: string): number {
    // Rough estimate: 1 token â‰ˆ 4 characters
    return Math.ceil(content.length / 4);
  }

  /**
   * Check if content exceeds token budget
   */
  exceedsTokenBudget(content: string, budget?: number): boolean {
    const effectiveBudget = budget || this.config.maxTokens;
    const estimatedTokens = this.estimateTokens(content);
    return estimatedTokens > effectiveBudget;
  }
}

/**
 * Create a sampler with custom configuration
 */
export function createSampler(config?: SamplerConfig): ContextSampler {
  return new ContextSampler(config);
}

/**
 * Default sampler instance
 */
export const defaultSampler = new ContextSampler();
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/policy/types.ts

````typescript
import { RiskLevel } from '../state';

export interface PolicyContext {
  action: {
    type: string;
    payload: any;
  };
  user?: {
    permissions: string[];
  };
  environment?: {
    isProduction: boolean;
  };
}

export interface PolicyResult {
  allowed: boolean;
  reason?: string;
  requiresEscalation?: boolean;
  suggestedActions?: string[];
}

export interface Policy {
  name: string;
  description: string;
  evaluate(context: PolicyContext): PolicyResult | Promise<PolicyResult>;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/prompt.ts

````typescript
import {
    AgentIntent,
    AgentContext,
    AgentMode,
    AgentPrompt,
} from './types';
import { buildCommandPrompt as buildCommandPromptString } from '../ai/prompt';
import { getOSProfile } from '../core/os';
import { getMacros } from '../core/macros';
import { aiCommandPlanSchema } from '../core/validation';
import { getRelevantSkills } from './skills';

export function buildPrompt(
    intent: AgentIntent,
    context: AgentContext,
    mode: AgentMode,
    input: string
): AgentPrompt {
    if (mode === 'chat') {
        return buildChatPrompt(context, input);
    }

    return buildCommandPromptObject(input, context);
}

function buildChatPrompt(
    context: AgentContext,
    input: string
): AgentPrompt {
    const messages: any[] = [
        ...(context.history ?? []),
    ];

    // Add context files if available
    if (context.files && context.files.length > 0) {
        const contextDesc = context.files.map(f =>
            `File: ${f.path}\n\`\`\`\n${f.content}\n\`\`\``
        ).join('\n\n');

        messages.push({
            role: 'system',
            content: `Context:\n${contextDesc}`,
        });
    }

    messages.push({
        role: 'user',
        content: input,
    });

    return {
        system: 'You are a helpful AI assistant with expertise in software development, system administration, and problem-solving.',
        messages,
    };
}

function buildCommandPromptObject(
    input: string,
    context: AgentContext
): AgentPrompt {
    const os = getOSProfile();
    const macros = getMacros();
    const skills = getRelevantSkills(input);
    let promptText = buildCommandPromptString(input, os, macros);

    if (skills.length > 0) {
        const skillList = skills.map(s => `- ${s.name}: å½“é‡åˆ° "${s.whenToUse}" æ—¶ï¼Œä½ å¯ä»¥å‚è€ƒè®¡åˆ’: ${s.planTemplate.goal}`).join('\n');
        promptText = `ã€å‚è€ƒæŠ€èƒ½åº“ã€‘\n${skillList}\n\n${promptText}`;
    }

    return {
        messages: [
            {
                role: 'user',
                content: promptText,
            },
        ],
        outputSchema: aiCommandPlanSchema,
    };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/replay/events.ts

````typescript
export type EventType = 
  | 'state_transition'
  | 'llm_call'
  | 'tool_execution'
  | 'governance_decision'
  | 'observation_recorded'
  | 'evaluation_result'
  | 'error_occurred';

export interface RuntimeEvent {
  id: string;
  timestamp: number;
  executionId: string;
  type: EventType;
  data: {
    from?: string;
    to?: string;
    action?: any;
    decision?: any;
    result?: any;
    error?: string;
  };
  metadata?: Record<string, any>;
}

export interface EventRecorder {
  record(event: RuntimeEvent): void;
  flush(): Promise<void>;
  getEvents(executionId?: string): RuntimeEvent[];
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/replay/index.ts

````typescript
export * from './events';
export * from './recorder';
export * from './replayer';

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/replay/recorder.ts

````typescript
import { RuntimeEvent, EventRecorder } from './events';
import fs from 'fs/promises';
import path from 'path';
import { randomUUID } from 'crypto';

export class FileEventRecorder implements EventRecorder {
  private events: RuntimeEvent[] = [];
  private logFile: string;
  private flushInterval: number = 1000;

  constructor(logDir: string = '.yuangs_events') {
    this.logFile = path.join(logDir, `events_${Date.now()}.jsonl`);
  }

  async record(event: RuntimeEvent): Promise<void> {
    this.events.push(event);

    if (this.events.length >= this.flushInterval) {
      await this.flush();
    }
  }

  async flush(): Promise<void> {
    if (this.events.length === 0) return;

    const logDir = path.dirname(this.logFile);
    await fs.mkdir(logDir, { recursive: true });

    const content = this.events
      .map(e => JSON.stringify(e))
      .join('\n') + '\n';

    await fs.appendFile(this.logFile, content, 'utf8');
    this.events = [];
  }

  getEvents(executionId?: string): RuntimeEvent[] {
    if (!executionId) {
      return [...this.events];
    }

    return this.events.filter(e => e.executionId === executionId);
  }
}

export const createEvent = (
  executionId: string,
  type: RuntimeEvent['type'],
  data: RuntimeEvent['data'],
  metadata?: RuntimeEvent['metadata']
): RuntimeEvent => ({
  id: randomUUID(),
  timestamp: Date.now(),
  executionId,
  type,
  data,
  metadata
});

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/replay/replayer.ts

````typescript
import { RuntimeEvent } from './events';

export interface ReplayerOptions {
  speed?: number;
  stopOnError?: boolean;
  dryRun?: boolean;
}

export class EventReplayer {
  private events: RuntimeEvent[] = [];
  private currentIndex: number = 0;
  private options: Required<ReplayerOptions>;

  constructor(events: RuntimeEvent[], options: ReplayerOptions = {}) {
    this.events = events;
    this.options = {
      speed: options.speed || 1,
      stopOnError: options.stopOnError !== undefined ? options.stopOnError : true,
      dryRun: options.dryRun || false
    };
  }

  hasNext(): boolean {
    return this.currentIndex < this.events.length;
  }

  next(): RuntimeEvent | null {
    if (!this.hasNext()) {
      return null;
    }

    return this.events[this.currentIndex++];
  }

  reset(): void {
    this.currentIndex = 0;
  }

  async replay(onEvent: (event: RuntimeEvent, options: Required<ReplayerOptions>) => Promise<void>): Promise<void> {
    this.reset();
    let hasError = false;

    while (this.hasNext() && !hasError) {
      const event = this.next();

      if (!event) break;

      try {
        await onEvent(event, this.options);

        if (event.type === 'error_occurred') {
          hasError = true;
          if (this.options.stopOnError) {
            break;
          }
        }

        if (this.options.speed > 1) {
          const delay = 100 / this.options.speed;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      } catch (error: any) {
        console.error(`[Replay] Error at event ${event.id}:`, error.message);
        hasError = true;
      }
    }

    return;
  }

  getSummary(): {
    total: number;
    completed: number;
    errors: number;
  } {
    const errors = this.events.filter(e => e.type === 'error_occurred').length;
    
    return {
      total: this.events.length,
      completed: this.currentIndex,
      errors
    };
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/replayExplain.ts

````typescript
import { ExecutionTurn } from './state';
import { ExecutionRecorder } from './executionRecorder';
import { generateSkillHintsFromContext, formatSkillHints, ContextSkillHint, promoteContextToSkill } from './contextSkillBridge';
import { ContextManager } from './contextManager';
import { ContextToSkillPromotionRules } from './contextSkillPromotion';

export function explainExecution(recorder: ExecutionRecorder, contextManager?: ContextManager): string {
  const turns = recorder.getTurns();
  const summary = recorder.getSummary();

  const lines: string[] = [];

  lines.push('# Execution Explanation Report');
  lines.push('');
  lines.push('## Summary');
  lines.push(`- Total Turns: ${summary.totalTurns}`);
  lines.push(`- Added Context Items: ${summary.totalAddedContext}`);
  lines.push(`- Removed Context Items: ${summary.totalRemovedContext}`);
  lines.push(`- Changed Context Items: ${summary.totalChangedContext}`);
  lines.push('');

  // å¦‚æœæä¾›äº†ContextManagerï¼Œç”ŸæˆSkill Hints
  if (contextManager) {
    const contextItems = contextManager.getContextBuffer().export();
    const skillHints = generateSkillHintsFromContext(contextItems);

    if (skillHints.length > 0) {
      lines.push('## Skill Suggestions from Context');
      lines.push(formatSkillHints(skillHints));
      lines.push('');
    }
  }

  lines.push('## Detailed Turn-by-Turn Analysis');
  lines.push('');

  for (const turn of turns) {
    lines.push(`### Turn ${turn.turnId}`);
    lines.push('');

    if (turn.startTime) {
      lines.push(`- Start Time: ${new Date(turn.startTime).toISOString()}`);
    }

    if (turn.endTime) {
      lines.push(`- End Time: ${new Date(turn.endTime).toISOString()}`);
    }

    if (turn.contextDiff) {
      lines.push('');
      lines.push('#### Context Changes:');

      if (turn.contextDiff.added.length > 0) {
        lines.push('- Added:');
        for (const item of turn.contextDiff.added) {
          lines.push(`  - ${item}`);
        }
      }

      if (turn.contextDiff.removed.length > 0) {
        lines.push('- Removed:');
        for (const item of turn.contextDiff.removed) {
          lines.push(`  - ${item}`);
        }
      }

      if (turn.contextDiff.changed.length > 0) {
        lines.push('- Changed:');
        for (const item of turn.contextDiff.changed) {
          lines.push(`  - ${item}`);
        }
      }
    }

    if (turn.proposedAction) {
      lines.push('');
      lines.push(`#### Action Type: ${turn.proposedAction.type}`);
      lines.push(`- Reasoning: ${turn.proposedAction.reasoning}`);
    }

    if (turn.governance) {
      lines.push('');
      lines.push(`#### Governance Decision: ${turn.governance.status}`);
      if ('reason' in turn.governance) {
        lines.push(`- Reason: ${turn.governance.reason}`);
      }
      lines.push(`- Decided by: ${turn.governance.by}`);
    }

    if (turn.executionResult) {
      lines.push('');
      lines.push(`#### Execution Result: ${turn.executionResult.success ? 'SUCCESS' : 'FAILURE'}`);
      if (turn.executionResult.error) {
        lines.push(`- Error: ${turn.executionResult.error}`);
      }
    }

    lines.push('');
  }

  return lines.join('\n');
}

export function replayExecution(recorder: ExecutionRecorder, options: { showContextDiff?: boolean } = {}): string {
  const { showContextDiff = true } = options;
  const turns = recorder.getTurns();
  const lines: string[] = [];

  lines.push('# Execution Replay');
  lines.push('');

  for (const turn of turns) {
    lines.push(`## Turn ${turn.turnId}`);
    
    if (showContextDiff && turn.contextDiff) {
      lines.push('');
      lines.push('### Context Diff:');
      
      if (turn.contextDiff.added.length > 0) {
        lines.push('Added:');
        for (const item of turn.contextDiff.added) {
          lines.push(`  + ${item}`);
        }
      }
      
      if (turn.contextDiff.removed.length > 0) {
        lines.push('Removed:');
        for (const item of turn.contextDiff.removed) {
          lines.push(`  - ${item}`);
        }
      }
      
      if (turn.contextDiff.changed.length > 0) {
        lines.push('Changed:');
        for (const item of turn.contextDiff.changed) {
          lines.push(`  ~ ${item}`);
        }
      }
      
      if (!turn.contextDiff.added.length && 
          !turn.contextDiff.removed.length && 
          !turn.contextDiff.changed.length) {
        lines.push('(No context changes)');
      }
    }
    
    if (turn.proposedAction) {
      lines.push('');
      lines.push(`Action: ${turn.proposedAction.type}`);
      lines.push(`Reasoning: ${turn.proposedAction.reasoning}`);
    }
    
    if (turn.executionResult) {
      lines.push('');
      lines.push(`Result: ${turn.executionResult.success ? 'SUCCESS' : 'FAILURE'}`);
    }
    
    lines.push('');
  }

  return lines.join('\n');
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/selectModel.ts

````typescript
import { AgentIntent } from './types';
import { getUserConfig } from '../ai/client';

export function selectModel(
    intent: AgentIntent,
    override?: string
): string {
    if (override) return override;

    const config = getUserConfig();
    const defaultModel = config.defaultModel || 'Assistant';

    return defaultModel;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/skills.ts

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import chalk from 'chalk';
import { recordEdge } from './knowledgeGraph';

export interface Skill {
    id: string;
    name: string;
    description: string;
    whenToUse: string; // è§¦å‘åœºæ™¯æè¿°
    planTemplate: any;

    // è¯„ä»·æŒ‡æ ‡
    successCount: number;
    failureCount: number;
    confidence: number; // 0 ~ 1, åˆå§‹ 0.5

    // æ—¶é—´æˆ³
    lastUsed: number;
    createdAt: number;

    // æ˜¯å¦å¯ç”¨
    enabled: boolean;

    // å¯é€‰å±æ€§
    parameters?: any;
    implementation?: string;
    metadata?: {
        source?: string;
        originalContextId?: string;
        originalContextPath?: string;
        originalContextStableId?: string;
        promotionCriteria?: any;
        usageStats?: {
            useCount: number;
            successCount: number;
            failureCount: number;
            confidence: number;
            lastUsed: number;
        };
        createdAt?: number;
    };
}

const SKILLS_FILE = path.join(os.homedir(), '.yuangs_skills.json');
let skillLibrary: Skill[] = [];

// === Persistence Logic ===

function loadSkills() {
    if (fs.existsSync(SKILLS_FILE)) {
        try {
            const data = fs.readFileSync(SKILLS_FILE, 'utf-8');
            skillLibrary = JSON.parse(data);
        } catch (e) {
            console.error(chalk.yellow(`Failed to load skills from ${SKILLS_FILE}, starting empty.`));
            skillLibrary = [];
        }
    }
}

function saveSkills() {
    try {
        fs.writeFileSync(SKILLS_FILE, JSON.stringify(skillLibrary, null, 2));
    } catch (e) {
        console.error(chalk.red(`Failed to save skills to ${SKILLS_FILE}`));
    }
}

// Initialize on load
loadSkills();

// === Existing Logic with Save Hooks ===

/**
 * è®¡ç®—æŠ€èƒ½åˆ† (0 ~ 1)
 */
export function computeSkillScore(skill: Skill, now: number = Date.now()): number {
    const totalUses = skill.successCount + skill.failureCount;
    const successRate = totalUses === 0 ? 0.5 : skill.successCount / totalUses;

    // æ—¶é—´è¡°å‡ (Freshness): åŠè¡°æœŸçº¦ 14 å¤©
    const idleDays = (now - skill.lastUsed) / (1000 * 60 * 60 * 24);
    const freshness = Math.exp(-idleDays / 14);

    // ç»¼åˆå¾—åˆ†: 45% æˆåŠŸç‡ + 35% æ–°é²œåº¦ + 20% ç½®ä¿¡åº¦
    return (0.45 * successRate) + (0.35 * freshness) + (0.20 * skill.confidence);
}

/**
 * æ›´æ–°æŠ€èƒ½çŠ¶æ€ (æ‰§è¡Œåè°ƒç”¨)
 */
export function updateSkillStatus(skillId: string, success: boolean) {
    const skill = skillLibrary.find(s => s.id === skillId);
    if (!skill) return;

    skill.lastUsed = Date.now();
    if (success) {
        skill.successCount++;
        // æˆåŠŸå¥–åŠ±: ç½®ä¿¡åº¦ç¼“æ…¢æå‡
        skill.confidence = Math.min(1, skill.confidence + 0.05);
    } else {
        skill.failureCount++;
        // å¤±è´¥æƒ©ç½š: æƒ©ç½šåŠ›åº¦å¤§äºå¥–åŠ±ï¼Œé˜²æ­¢ç³»ç»Ÿ"è‡ªå—¨"
        skill.confidence = Math.max(0, skill.confidence - 0.1);
    }

    // === C5-B-1: Knowledge Graph Record (Execution -> Skill) ===
    recordEdge({
        from: 'current_execution', // TODO(KG): replace with real executionId (v2)
        to: skill.id,
        type: 'validated_by',
        timestamp: Date.now(),
        meta: { success, skillName: skill.name }
    });

    saveSkills(); // Persist changes
}

/**
 * è‡ªåŠ¨å­¦ä¹ æ–°æŠ€èƒ½
 */
export function learnSkillFromRecord(record: any, success: boolean = true) {
    if (record.mode === 'chat' || !record.llmResult.plan) return;

    const existingSkill = skillLibrary.find(s => s.name === record.llmResult.plan?.goal);

    if (existingSkill) {
        updateSkillStatus(existingSkill.id, success);
        return;
    }

    // åªæœ‰æˆåŠŸçš„è®°å½•æ‰è¢«å­¦ä¸ºæ–°æŠ€èƒ½
    if (!success) return;

    const now = Date.now();
    skillLibrary.push({
        id: record.id,
        name: record.llmResult.plan.goal,
        description: `è‡ªåŠ¨å­¦ä¹ çš„æŠ€èƒ½: ${record.llmResult.plan.goal}`,
        whenToUse: record.input.rawInput,
        planTemplate: record.llmResult.plan,
        successCount: 1,
        failureCount: 0,
        confidence: 0.5,
        lastUsed: now,
        createdAt: now,
        enabled: true
    });

    // æ¯å­¦ä¹ ä¸€æ¬¡ï¼Œå°è¯•æ¸…ç†ä¸€æ¬¡â€œå†·â€æŠ€èƒ½
    reapColdSkills();

    saveSkills(); // Persist changes
}

/**
 * ç­›é€‰å¹¶æ’åºæŠ€èƒ½ (ç”¨äºæ³¨å…¥ Prompt)
 */
export function getRelevantSkills(input: string, limit: number = 3): Skill[] {
    const now = Date.now();

    return skillLibrary
        // 1. åŸºç¡€ç­›é€‰: å‰”é™¤è¯„åˆ†è¿‡ä½çš„æŠ€èƒ½ (ç¡¬æ·˜æ±°é˜ˆå€¼ 0.3)
        .filter(s => computeSkillScore(s, now) >= 0.3)
        // 2. è¿‡æ»¤å·²ç¦ç”¨çš„æŠ€èƒ½
        .filter(s => s.enabled !== false)
        // 3. æ’åº: æŒ‰ç»¼åˆåˆ†æ’åº
        .sort((a, b) => computeSkillScore(b, now) - computeSkillScore(a, now))
        // 4. å–ä¸Šé™
        .slice(0, limit);
}

/**
 * æ¸…ç†è¿‡æœŸæˆ–ä½è´¨æŠ€èƒ½ (Reaper)
 */
export function reapColdSkills() {
    const now = Date.now();
    const initialCount = skillLibrary.length;

    skillLibrary = skillLibrary.filter(skill => {
        const score = computeSkillScore(skill, now);
        const idleDays = (now - skill.lastUsed) / (1000 * 60 * 60 * 24);

        // æ»¡è¶³ä»¥ä¸‹ä»»ä¸€æ¡ä»¶åˆ™æ·˜æ±°:
        // 1. å¾—åˆ†æä½ä¸”é•¿æœŸä¸ç”¨
        if (score < 0.25 && idleDays > 30) return false;
        // 2. å¤±è´¥ç‡æé«˜ä¸”å°è¯•è¿‡ä¸€å®šæ¬¡æ•°
        if (skill.failureCount > 5 && (skill.successCount / (skill.successCount + skill.failureCount)) < 0.2) return false;

        return true;
    });

    // å¼ºåˆ¶ä¿æŒå®¹é‡
    if (skillLibrary.length > 100) {
        // å¦‚æœè¿˜è¶…æ ‡ï¼Œç§»é™¤å¾—åˆ†æœ€ä½çš„é‚£ä¸ª
        skillLibrary.sort((a, b) => computeSkillScore(a, now) - computeSkillScore(b, now));
        skillLibrary.shift();
    }

    if (skillLibrary.length !== initialCount) {
        saveSkills(); // Persist if changes happened
    }
}

export function getAllSkills(): Skill[] {
    return [...skillLibrary];
}

/**
 * æ·»åŠ æ–°æŠ€èƒ½
 */
export function addSkill(skill: Skill) {
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨åŒåæŠ€èƒ½
    const existingSkill = skillLibrary.find(s => s.name === skill.name);
    if (existingSkill) {
        console.log(`Skill with name "${skill.name}" already exists, skipping.`);
        return false;
    }

    skillLibrary.push(skill);
    saveSkills(); // ä¿å­˜æ›´æ”¹
    return true;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/state.ts

````typescript
import { randomUUID } from 'crypto';

export type AgentState = 
  | 'IDLE' 
  | 'THINKING' 
  | 'PROPOSING' 
  | 'GOVERNING' 
  | 'EXECUTING' 
  | 'OBSERVING' 
  | 'EVALUATING' 
  | 'TERMINAL';

export type RiskLevel = 'low' | 'medium' | 'high';

export interface ProposedAction {
  id: string;
  type: 'tool_call' | 'code_diff' | 'shell_cmd' | 'answer';
  payload: any;
  riskLevel: RiskLevel;
  reasoning: string;
}

export type GovernanceDecision = 
  | { status: 'approved'; by: 'policy' | 'human'; timestamp: number }
  | { status: 'rejected'; by: 'policy' | 'human'; reason: string; timestamp: number }
  | { 
      status: 'modified'; 
      by: 'human'; 
      originalActionId: string;
      modifiedAction: ProposedAction;
      modificationReason: string;
      timestamp: number;
    };

export type EvaluationOutcome = 
  | { kind: 'continue'; reason: 'incomplete' | 'failure_retry' }
  | { kind: 'terminate'; reason: 'goal_satisfied' | 'user_abort' | 'max_turns_exceeded' }
  | { kind: 'pause'; reason: 'await_human_input' };

export interface AgentThought {
  raw: string;
  parsedPlan: any;
  isDone: boolean;
  type?: 'tool_call' | 'code_diff' | 'shell_cmd' | 'answer';
  payload?: any;
  reasoning?: string;
}

import { ContextDiff } from './contextDiff';

export interface ExecutionTurn {
  turnId: number;
  startTime: number;
  endTime?: number;
  contextSnapshot: {
    inputHash: string;
    systemPromptVersion: string;
    toolSetVersion: string;
    recentMessages: Array<{ role: string; content: string; timestamp: number }>;
  };
  contextDiff?: ContextDiff;
  thought?: AgentThought;
  proposedAction?: ProposedAction;
  governance?: GovernanceDecision;
  executionResult?: {
    success: boolean;
    output: string;
    error?: string;
    artifacts?: string[];
  };
  observation?: {
    summary: string;
    artifacts: string[];
    truncated?: boolean;
  };
  evaluation?: EvaluationOutcome;
}

export interface GovernanceLoopConfig {
  maxTurns: number;
  autoApproveLowRisk: boolean;
  verbose: boolean;
}

export interface ToolExecutionResult {
  success: boolean;
  output: string;
  error?: string;
  artifacts?: string[];
}

export interface GovernanceContext {
  input: string;
  mode: 'chat' | 'command' | 'command+exec';
  history: AIRequestMessage[];
  files?: Array<{ path: string; content: string }>;
}

interface AIRequestMessage {
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/types.ts

````typescript
import type { AIRequestMessage } from '../core/validation';
// import { AgentPlan } from './plan';

export type AgentMode = 'chat' | 'command' | 'command+exec';

export interface AgentInput {
    rawInput: string;
    stdin?: string;
    context?: AgentContext;
    options?: {
        model?: string;
        stream?: boolean;
        autoYes?: boolean;
        verbose?: boolean;
    };
}

export interface AgentContext {
    files?: Array<{ path: string; content: string }>;
    gitDiff?: string;
    history?: AIRequestMessage[];
    contextItems?: import('./contextBuffer').ContextItem[];
    totalTokens?: number;
    highConfidenceItems?: import('./contextBuffer').ContextItem[];
    mediumConfidenceItems?: import('./contextBuffer').ContextItem[];
    lowConfidenceItems?: import('./contextBuffer').ContextItem[];
}

export interface AgentIntent {
    type: 'chat' | 'shell' | 'analysis';
    capabilities: {
        reasoning?: boolean;
        code?: boolean;
        longContext?: boolean;
        streaming?: boolean;
    };
}

export interface AgentPrompt {
    system?: string;
    messages: AIRequestMessage[];
    outputSchema?: any;
}

export interface LLMResult {
    rawText: string;
    parsed?: any;
    plan?: any;
    latencyMs: number;
    tokens?: {
        prompt: number;
        completion: number;
        total: number;
    };
    costUsd?: number;
}

export type AgentAction =
    | { type: 'print'; content: string }
    | { type: 'confirm'; next: AgentAction }
    | { type: 'execute'; command: string; risk: 'low' | 'medium' | 'high' };

/**
 * Observation ç±»å‹åˆ†çº§ï¼ˆv3.1ï¼‰
 * ç”¨äºåŒºåˆ†å“ªäº› Observation éœ€è¦ç¡®è®¤ï¼Œå“ªäº›ä¸éœ€è¦
 */
export type ObservationKind = 'tool_result' | 'system_note' | 'error' | 'none';

/**
 * å®Œæ•´çš„ Observation æ¥å£
 */
export interface Observation {
    kind: ObservationKind;
    content: string;
    timestamp: number;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/ai/client.ts

````typescript
import axios from 'axios';
import fs from 'fs';
import path from 'path';
import os from 'os';
import { DEFAULT_AI_PROXY_URL, DEFAULT_MODEL, DEFAULT_ACCOUNT_TYPE, type UserConfig, type AIRequestMessage } from '../core/validation';
import { loadChatHistory, saveChatHistory } from '../agent/chatHistoryStorage';

const CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');

let conversationHistory: AIRequestMessage[] = [];

// åˆå§‹åŒ–æ—¶åŠ è½½æŒä¹…åŒ–çš„èŠå¤©å†å²è®°å½•
loadChatHistory().then(history => {
    conversationHistory = history;
});

export function addToConversationHistory(role: 'system' | 'user' | 'assistant', content: string) {
    conversationHistory.push({ role, content });
    if (conversationHistory.length > 20) {
        conversationHistory = conversationHistory.slice(-20);
    }
    // åŒæ—¶ä¿å­˜åˆ°æŒä¹…åŒ–å­˜å‚¨
    saveChatHistory(conversationHistory);
}

export function clearConversationHistory() {
    conversationHistory = [];
    // åŒæ—¶æ¸…é™¤æŒä¹…åŒ–å­˜å‚¨
    saveChatHistory(conversationHistory);
}

export function getConversationHistory() {
    return conversationHistory;
}

export function getUserConfig(): UserConfig {
    if (fs.existsSync(CONFIG_FILE)) {
        try {
            const content = fs.readFileSync(CONFIG_FILE, 'utf8');
            return JSON.parse(content) as UserConfig;
        } catch (e) { }
    }
    return {};
}

export async function askAI(prompt: string, model?: string): Promise<string> {
    const config = getUserConfig();
    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;

    const headers = {
        'Content-Type': 'application/json',
        'X-Client-ID': 'vscode',
        'Origin': 'https://cli.want.biz',
        'Referer': 'https://cli.want.biz/',
        'account': config.accountType || DEFAULT_ACCOUNT_TYPE,
        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',
        'Accept': 'application/json'
    };

    const data = {
        model: model || config.defaultModel || DEFAULT_MODEL,
        messages: [{ role: 'user', content: prompt }],
        stream: false
    };

    try {
        const response = await axios.post(url, data, { headers });
        const content = response.data?.choices?.[0]?.message?.content;
        return content || '';
    } catch (error: any) {
        const errorMsg = error.response?.data?.error?.message || error.response?.data?.message || error.message || 'æœªçŸ¥é”™è¯¯';
        throw new Error(`AI è¯·æ±‚å¤±è´¥: ${errorMsg}`);
    }
}

export async function callAI_Stream(messages: AIRequestMessage[], model: string | undefined, onChunk: (content: string) => void, abortSignal?: AbortSignal): Promise<void> {
    const config = getUserConfig();
    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;

    // âœ… ä½¿ç”¨ä¼ å…¥çš„ AbortSignalï¼Œæˆ–åˆ›å»ºæ–°çš„
    const controller = abortSignal ? { signal: abortSignal, abort: () => {} } : new AbortController();

    const response = await axios({
        method: 'post',
        url: url,
        data: {
            model: model || config.defaultModel || DEFAULT_MODEL,
            messages: messages,
            stream: true
        },
        responseType: 'stream',
        signal: controller.signal,
        headers: {
            'Content-Type': 'application/json',
            'X-Client-ID': 'vscode',
        }
    });

    return new Promise((resolve, reject) => {
        let buffer = '';
        
        const handleChunk = (chunk: Buffer) => {
            // âœ… æ£€æŸ¥å–æ¶ˆä¿¡å·
            if (controller.signal.aborted) {
                reject(new Error('Stream request aborted'));
                return;
            }

            buffer += chunk.toString();
            let lines = buffer.split('\n');
            buffer = lines.pop() || '';

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('data: ')) {
                    const data = trimmedLine.slice(6);
                    if (data === '[DONE]') {
                        resolve();
                        return;
                    }
                    try {
                        const parsed = JSON.parse(data);
                        const content = parsed.choices[0]?.delta?.content || '';
                        if (content) onChunk(content);
                    } catch (e) { }
                }
            }
        };

        response.data.on('data', handleChunk);
        
        response.data.on('error', (error: any) => {
            reject(error);
        });
        
        response.data.on('end', () => {
            resolve();
        });
    });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/ai/prompt.ts

````typescript
import { OSProfile } from '../core/os';
import type { Macro } from '../core/validation';

export function buildCommandPrompt(
    userInput: string,
    os: OSProfile,
    macros?: Record<string, Macro>,
    context?: string
): string {
    const macroContext = macros && Object.keys(macros).length > 0
        ? `
ã€å¯å¤ç”¨çš„å¿«æ·æŒ‡ä»¤ (Macros)ã€‘
ä»¥ä¸‹æ˜¯å¯ä»¥ç›´æ¥å¤ç”¨çš„å·²éªŒè¯å‘½ä»¤ã€‚ä¼˜å…ˆå¤ç”¨è¿™äº›æŒ‡ä»¤ï¼Œè€Œä¸æ˜¯ç”Ÿæˆæ–°å‘½ä»¤ï¼š

${Object.entries(macros).map(([name, macro]) => `  - ${name}: ${macro.description || '(æ— æè¿°)'}`).join('\n')}

å½“ç”¨æˆ·çš„éœ€æ±‚ä¸æŸä¸ª Macro åŒ¹é…æˆ–ç›¸ä¼¼æ—¶ï¼š
1. ä¼˜å…ˆä½¿ç”¨è¯¥ Macro
2. åœ¨ JSON è¾“å‡ºä¸­ä½¿ç”¨ "macro" å­—æ®µæŒ‡å®š Macro åç§°ï¼Œè€Œä¸æ˜¯ "command" å­—æ®µ
3. ä»…åœ¨æ²¡æœ‰åˆé€‚ Macro æ—¶æ‰ç”Ÿæˆæ–°å‘½ä»¤
`
        : '';

    return `
ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å‘½ä»¤è¡Œä¸“å®¶ã€‚

ã€ç³»ç»Ÿç¯å¢ƒã€‘
- æ“ä½œç³»ç»Ÿ: ${os.name}
- Shell: ${os.shell}
- find å®ç°: ${os.find}
- stat å®ç°: ${os.stat}

ã€è§„åˆ™ã€‘
- å‘½ä»¤å¿…é¡»ä¸å½“å‰ç³»ç»Ÿå…¼å®¹ã€‚
- å¦‚æœæ˜¯ macOS (BSD):
  - ä¸å…è®¸ä½¿ç”¨ find -printf
  - ä¼˜å…ˆä½¿ç”¨ stat -f
- å¦‚æœæ˜¯ Linux (GNU):
  - å¯ä½¿ç”¨ find -printf
- é»˜è®¤ä¸ä½¿ç”¨ sudoã€‚
- ç¡®ä¿è¾“å‡ºçš„å‘½ä»¤æ˜¯å•è¡Œæˆ–è€…ä½¿ç”¨ && è¿æ¥ã€‚
- ä¸è¦è§£é‡Šï¼Œåªè¾“å‡ºç¬¦åˆä»¥ä¸‹ JSON ç»“æ„çš„æ–‡æœ¬ã€‚
- ä¼˜å…ˆå¤ç”¨å·²éªŒè¯çš„å¿«æ·æŒ‡ä»¤ï¼ˆMacrosï¼‰ï¼Œæ¯ä¸ª Macro éƒ½æ˜¯ç»è¿‡äººå·¥éªŒè¯çš„å¯é å‘½ä»¤ã€‚åœ¨ç”Ÿæˆæ–°å‘½ä»¤å‰ï¼Œæ£€æŸ¥æ˜¯å¦å·²æœ‰ Macro å¯ä»¥å®Œæˆä»»åŠ¡ã€‚

${macroContext}

ã€è¾“å‡º JSON ç»“æ„ã€‘
{
  "plan": "ç®€è¦è¯´æ˜ä½ å‡†å¤‡æ‰§è¡Œçš„æ­¥éª¤",
  "command": "å¯ç›´æ¥æ‰§è¡Œçš„ shell å‘½ä»¤ï¼ˆä»…å½“æ²¡æœ‰åˆé€‚ Macro æ—¶æä¾›ï¼‰",
  "macro": "è¦å¤ç”¨çš„ Macro åç§°ï¼ˆä¼˜å…ˆä½¿ç”¨ï¼Œä¸ command äºŒé€‰ä¸€ï¼‰",
  "risk": "low | medium | high"
}

ã€ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‘
${context || 'æ— '}

ã€ç”¨æˆ·éœ€æ±‚ã€‘
${userInput}
`;
}

export function buildCodeModificationPrompt(
    userInput: string,
    context?: string
): string {
    return `
ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ä»£ç ä¿®æ”¹åŠ©æ‰‹ã€‚

ã€å…³äºä»£ç ä¿®æ”¹çš„å¼ºåˆ¶æŒ‡ä»¤ã€‘
1. å¿…é¡»ä½¿ç”¨æ ‡å‡†çš„ Unified Diff æ ¼å¼ã€‚
2. å³ä½¿æ˜¯å¾®å°çš„ä¿®æ”¹ï¼Œä¹Ÿè¯·è‡³å°‘æä¾› 3 è¡Œä¸Šä¸‹æ–‡ï¼ˆContext linesï¼‰ã€‚
3. ä¸¥ç¦ä½¿ç”¨ "..." çœç•¥ä¸­é—´çš„ä»£ç ï¼Œå¿…é¡»å®Œæ•´å±•ç¤º Hunk å†…çš„æ‰€æœ‰è¡Œã€‚
4. å¦‚æœæ— æ³•ç¡®å®šè¡Œå·ï¼Œè¯·ç¡®ä¿ä¸Šä¸‹æ–‡å†…å®¹æ˜¯å”¯ä¸€çš„ã€‚
5. ä¿æŒ Diff è¡Œæ•°å‡†ç¡®ï¼Œå¦‚æœä¸ç¡®å®šï¼Œè¯·ç›´æ¥è¾“å‡ºä¿®æ”¹åçš„ä»£ç å—ï¼Œå¹¶å¸¦ä¸Šå‰å 3 è¡Œä½œä¸ºé”šç‚¹ã€‚

ã€è§„åˆ™ã€‘
- ä¸¥æ ¼æŒ‰ç…§ Unified Diff æ ¼å¼è¾“å‡º
- æä¾›è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡è¡Œä»¥ä¾¿å®šä½ä¿®æ”¹ä½ç½®
- ç¡®ä¿è¡Œæ•°ç»Ÿè®¡å‡†ç¡®
- ä¸è¦åœ¨ Diff å¤–æ·»åŠ é¢å¤–è§£é‡Š

ã€ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‘
${context || 'æ— '}

ã€ç”¨æˆ·éœ€æ±‚ã€‘
${userInput}

è¯·ç›´æ¥è¾“å‡ºç¬¦åˆæ ‡å‡† Unified Diff æ ¼å¼çš„ä¿®æ”¹å†…å®¹ã€‚
`;
}

export function buildFixPrompt(
    originalCmd: string,
    stderr: string,
    os: OSProfile
): string {
    return `
è¯¥å‘½ä»¤åœ¨ ${os.name} ä¸Šæ‰§è¡Œå¤±è´¥ï¼š

å‘½ä»¤ï¼š
${originalCmd}

é”™è¯¯ä¿¡æ¯ï¼š
${stderr}

è¯·ç”Ÿæˆä¸€ä¸ª **${os.name} å…¼å®¹** çš„ç­‰ä»·å‘½ä»¤ã€‚
ä¾ç„¶åªè¾“å‡º JSON æ ¼å¼ã€‚æ³¨æ„ï¼šè¿™æ˜¯ä¿®å¤å‘½ä»¤ï¼Œä¸éœ€è¦æ£€æŸ¥ Macroã€‚

{
  "plan": "ä¿®å¤è¯´æ˜",
  "command": "ä¿®å¤åçš„å‘½ä»¤",
  "risk": "low | medium | high"
}
`;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/ai/types.ts

````typescript
export { AICommandPlan, type AICommandPlan as AICommandPlanType } from '../core/validation';

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/aiClient.ts

````typescript
import { askAI, addToConversationHistory, getConversationHistory, clearConversationHistory } from './ai/client';
import { AIRequestMessage } from './core/validation';

export class YuangsEngine {
  async send(options: {
    messages: AIRequestMessage[];
    stream?: boolean;
    onToken?: (token: string) => void;
  }): Promise<string> {
    // For now, we'll use the existing askAI function which takes a single prompt
    // In the future, this could be expanded to handle the full message history

    // Extract the user's message from the options
    const userMessage = options.messages.find(msg => msg.role === 'user');
    if (!userMessage) {
      throw new Error('No user message found in options');
    }

    try {
      // Call the existing AI function
      const result = await askAI(userMessage.content);

      // Add to conversation history
      addToConversationHistory('user', userMessage.content);
      addToConversationHistory('assistant', result);

      return result;
    } catch (error) {
      console.error('Error calling AI:', error);
      throw error;
    }
  }
}

export const yuangsEngine = new YuangsEngine();
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/apps.ts

````typescript
import { exec } from 'child_process';
import fs from 'fs';
import path from 'path';
import yaml from 'js-yaml';
import os from 'os';
import { DEFAULT_APPS, parseAppsConfig } from './validation';

export { DEFAULT_APPS };

export function loadAppsConfig(): Record<string, string> {
    const configPaths = [
        path.join(process.cwd(), 'yuangs.config.json'),
        path.join(process.cwd(), 'yuangs.config.yaml'),
        path.join(process.cwd(), 'yuangs.config.yml'),
        path.join(process.cwd(), '.yuangs.json'),
        path.join(process.cwd(), '.yuangs.yaml'),
        path.join(process.cwd(), '.yuangs.yml'),
        path.join(os.homedir(), '.yuangs.json'),
        path.join(os.homedir(), '.yuangs.yaml'),
        path.join(os.homedir(), '.yuangs.yml'),
    ];

    for (const configPath of configPaths) {
        if (fs.existsSync(configPath)) {
            try {
                const configContent = fs.readFileSync(configPath, 'utf8');
                let config: Record<string, string>;
                if (configPath.endsWith('.yaml') || configPath.endsWith('.yml')) {
                    config = yaml.load(configContent) as Record<string, string>;
                } else {
                    config = parseAppsConfig(configContent);
                }
                return config;
            } catch (error) { }
        }
    }
    return DEFAULT_APPS;
}


export function openUrl(url: string) {
    let command;
    switch (process.platform) {
        case 'darwin': command = `open "${url}"`; break;
        case 'win32': command = `start "${url}"`; break;
        default: command = `xdg-open "${url}"`; break;
    }
    exec(command);
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/autofix.ts

````typescript
import { OSProfile } from './os';
import { buildFixPrompt } from '../ai/prompt';
import { askAI } from '../ai/client';
import { safeParseJSON, AIFixPlan, aiFixPlanSchema } from './validation';

export async function autoFixCommand(
    originalCmd: string,
    stderr: string,
    os: OSProfile,
    model?: string
): Promise<AIFixPlan | null> {
    const prompt = buildFixPrompt(originalCmd, stderr, os);
    const raw = await askAI(prompt, model);

    const parseResult = safeParseJSON(raw, aiFixPlanSchema, {} as AIFixPlan);

    if (!parseResult.success) {
        return null;
    }

    return parseResult.data;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/capabilities.ts

````typescript
export enum AtomicCapability {
  TEXT_GENERATION = 'text_generation',
  CODE_GENERATION = 'code_generation',
  TOOL_CALLING = 'tool_calling',
  LONG_CONTEXT = 'long_context',
  REASONING = 'reasoning',
  STREAMING = 'streaming',
}

export interface CompositeCapability {
  name: string;
  composedOf: AtomicCapability[];
}

export const COMPOSITE_CAPABILITIES: CompositeCapability[] = [
  {
    name: 'interactive_agent',
    composedOf: [AtomicCapability.TOOL_CALLING, AtomicCapability.REASONING],
  },
  {
    name: 'large_repo_analysis',
    composedOf: [AtomicCapability.LONG_CONTEXT, AtomicCapability.REASONING],
  },
  {
    name: 'safe_code_editing',
    composedOf: [AtomicCapability.CODE_GENERATION, AtomicCapability.REASONING],
  },
];

export enum ConstraintCapability {
  PREFER_DETERMINISTIC = 'prefer_deterministic',
  LOW_COST = 'low_cost',
  FAST_RESPONSE = 'fast_response',
}

export const CAPABILITY_VERSION = '1.0';

export function isAtomicCapability(value: string): value is AtomicCapability {
  return Object.values(AtomicCapability).includes(value as AtomicCapability);
}

export function isConstraintCapability(value: string): value is ConstraintCapability {
  return Object.values(ConstraintCapability).includes(value as ConstraintCapability);
}

export function resolveCompositeCapability(name: string): AtomicCapability[] {
  const composite = COMPOSITE_CAPABILITIES.find(c => c.name === name);
  if (!composite) {
    throw new Error(`Unknown composite capability: ${name}`);
  }
  return composite.composedOf;
}

export function expandCapabilities(
  capabilities: Array<AtomicCapability | string>
): Set<AtomicCapability> {
  const result = new Set<AtomicCapability>();

  for (const cap of capabilities) {
    if (isAtomicCapability(cap)) {
      result.add(cap);
    } else {
      const atomicCaps = resolveCompositeCapability(cap);
      atomicCaps.forEach(c => result.add(c));
    }
  }

  return result;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/capabilityInference.ts

````typescript
import { AtomicCapability } from '../core/capabilities';
import type { CapabilityRequirement } from '../core/modelMatcher';

export function inferCapabilityRequirement(userInput: string): CapabilityRequirement {
  const required: AtomicCapability[] = [];

  const input = userInput.toLowerCase();

  if (input.includes('ä»£ç ') || input.includes('script') || input.includes('æ–‡ä»¶') || input.includes('create') || input.includes('write')) {
    required.push(AtomicCapability.CODE_GENERATION);
  }

  if (input.includes('åˆ†æ') || input.includes('ç†è§£') || input.includes('è§£é‡Š') || input.includes('æ¨ç†')) {
    required.push(AtomicCapability.REASONING);
  }

  if (input.includes('é•¿') || input.includes('large') || input.includes('ä»“åº“') || input.includes('ç›®å½•') || input.includes('æ‰€æœ‰æ–‡ä»¶')) {
    required.push(AtomicCapability.LONG_CONTEXT);
  }

  return {
    required: Array.from(new Set(required)),
    preferred: [],
  };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/capabilitySystem.ts

````typescript
import {
  CapabilityRequirement,
  matchModelWithFallback,
  ModelCapabilities,
  CapabilityMatchResult,
} from './modelMatcher';
import {
  mergeConfigs,
  loadConfigAt,
  dumpConfigSnapshot,
  getConfigFilePaths,
  MergedConfig,
} from './configMerge';
import {
  createExecutionRecord,
  ExecutionRecord,
} from './executionRecord';
import {
  saveExecutionRecord,
  loadExecutionRecord,
  listExecutionRecords,
} from './executionStore';
import { replayEngine, ReplayOptions, ReplayResult } from './replayEngine';

export class CapabilitySystem {
  private primaryModels: ModelCapabilities[] = [];
  private fallbackModels: ModelCapabilities[] = [];

  constructor() {
    this.initializeDefaultModels();
  }

  private initializeDefaultModels(): void {
    // åˆå§‹åŒ–ä¸ºç©ºæ•°ç»„ï¼Œè®©é…ç½®æ–‡ä»¶æˆä¸ºä¸»è¦æ¥æº
    this.primaryModels = [];
    this.fallbackModels = [];
  }

  matchCapability(requirement: CapabilityRequirement): CapabilityMatchResult {
    const allModels = this.getAllModels();
    const primaryModels = [...this.primaryModels, ...this.loadCustomModels()];
    return matchModelWithFallback(
      primaryModels,
      this.fallbackModels,
      requirement
    );
  }

  loadMergedConfig(): MergedConfig {
    const builtin = {
      aiProxyUrl: 'https://api.openai.com/v1/chat/completions',
      defaultModel: 'gpt-4o-mini',
      accountType: 'free',
    };

    const filePaths = getConfigFilePaths();
    const projectConfig = filePaths.project ? loadConfigAt(filePaths.project) : null;
    const userGlobal = loadConfigAt(filePaths.userGlobal);

    return mergeConfigs(builtin, userGlobal, projectConfig, null);
  }

  loadCustomModels(): ModelCapabilities[] {
    const filePaths = getConfigFilePaths();
    const projectConfig = filePaths.project ? loadConfigAt(filePaths.project) : null;
    const userGlobal = loadConfigAt(filePaths.userGlobal);

    const customModelsArray = [];
    if (userGlobal?.models && Array.isArray(userGlobal.models)) {
      customModelsArray.push(...userGlobal.models as ModelCapabilities[]);
    }
    if (projectConfig?.models && Array.isArray(projectConfig.models)) {
      customModelsArray.push(...projectConfig.models as ModelCapabilities[]);
    }

    return customModelsArray;
  }

  getAllModels(): ModelCapabilities[] {
    const customModels = this.loadCustomModels();
    return [...this.primaryModels, ...this.fallbackModels, ...customModels];
  }

  createAndSaveExecutionRecord(
    commandName: string,
    requirement: CapabilityRequirement,
    matchResult: CapabilityMatchResult,
    command?: string
  ): string {
    const config = this.loadMergedConfig();
    const record = createExecutionRecord(
      commandName,
      requirement,
      config,
      matchResult,
      { success: matchResult.selected !== null },
      command
    );

    const filePath = saveExecutionRecord(record);
    return record.id;
  }

  replayExecution(recordId: string, options: ReplayOptions): Promise<ReplayResult> {
    return replayEngine.replay(recordId, options);
  }

  explainConfig(): string {
    const config = this.loadMergedConfig();
    return dumpConfigSnapshot(config);
  }
}

export const capabilitySystem = new CapabilitySystem();

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/completion.legacy.ts

````typescript
import fs from 'fs';
import path from 'path';
import { Command } from 'commander';
import { loadAppsConfig } from './apps';
import { getMacros } from './macros';
export function getAllCommands(program: Command): string[] {
    const commands: string[] = [];

    program.commands.forEach(cmd => {
        if (cmd.name()) {
            commands.push(cmd.name());
        }
        if (cmd.aliases()) {
            commands.push(...cmd.aliases());
        }
    });

    try {
        const apps = loadAppsConfig();
        Object.keys(apps).forEach(app => {
            if (!commands.includes(app)) {
                commands.push(app);
            }
        });
    } catch {
    }

    try {
        const macros = getMacros();
        Object.keys(macros).forEach(macro => {
            if (!commands.includes(macro)) {
                commands.push(macro);
            }
        });
    } catch {
    }

    return [...new Set(commands)].sort();
}

/**
 * è·å–å‘½ä»¤çš„å­å‘½ä»¤æˆ–å‚æ•°
 */
export function getCommandSubcommands(program: Command, commandName: string): string[] {
    const command = program.commands.find(cmd => cmd.name() === commandName);
    if (!command) return [];

    const subcommands: string[] = [];

    command.commands.forEach(cmd => {
        if (cmd.name()) {
            subcommands.push(cmd.name());
        }
    });

    command.options.forEach(opt => {
        opt.flags.split(/[, ]+/).forEach(flag => {
            if (flag.startsWith('--')) {
                subcommands.push(flag);
            } else if (flag.startsWith('-')) {
                subcommands.push(flag);
            }
        });
    });

    return [...new Set(subcommands)].sort();
}

/**
 * ç”Ÿæˆ Bash è¡¥å…¨è„šæœ¬
 */
export function generateBashCompletion(program: Command): string {
    const commands = getAllCommands(program);

    return `#!/bin/bash
# yuangs bash completion

_yuangs_completion() {
    local cur prev words cword
    _init_completion || return

    # è¡¥å…¨å‘½ä»¤å
    if [[ \${COMP_CWORD} -eq 1 ]]; then
        COMPREPLY=($(compgen -W '${commands.join(' ')}' -- "\${cur}"))
        return
    fi

    # è¡¥å…¨å­å‘½ä»¤å’Œå‚æ•°
    local cmd="\${words[1]}"
    case "\${cmd}" in
        ${commands.map(cmd => `
        ${cmd})
            case "\${prev}" in
                -m|--model)
                    COMPREPLY=($(compgen -W "gemini-2.5-flash-lite gemini-2.5-pro" -- "\${cur}"))
                    ;;
                *)
                    COMPREPLY=($(compgen -W "$(yuangs _complete_subcommand ${cmd})" -- "\${cur}"))
                    ;;
            esac
            ;;
        `).join('\n')}

        *)
            ;;
    esac
}

complete -F _yuangs_completion yuangs
`;
}

/**
 * ç”Ÿæˆ Zsh è¡¥å…¨è„šæœ¬
 */
export function generateZshCompletion(program: Command): string {
    const commands = getAllCommands(program);

    return `#compdef yuangs
# yuangs zsh completion

_yuangs() {
    local -a commands
    commands=(
${commands.map(cmd => `        '${cmd}:$(yuangs _describe ${cmd})'`).join('\n')}
    )

    if (( CURRENT == 2 )); then
        _describe 'command' commands
    else
        local cmd="\${words[2]}"
        case "\${cmd}" in
${commands.map(cmd => `
            ${cmd})
                _values 'options' $(yuangs _complete_subcommand ${cmd})
                ;;
`).join('\n')}
            *)
                ;;
        esac
    fi
}

_yuangs
`;
}

export async function installBashCompletion(program: Command): Promise<boolean> {
    const bashrcPath = path.join(process.env.HOME || '', '.bashrc');
    const bashCompletionDir = path.join(process.env.HOME || '', '.bash_completion.d');

    try {
        if (!fs.existsSync(bashCompletionDir)) {
            fs.mkdirSync(bashCompletionDir, { recursive: true });
        }

        const completionPath = path.join(bashCompletionDir, 'yuangs-completion.bash');
        const completionScript = generateBashCompletion(program);

        fs.writeFileSync(completionPath, completionScript, { mode: 0o644 });
        const sourceLine = `# yuangs completion
if [ -f ~/.bash_completion.d/yuangs-completion.bash ]; then
    source ~/.bash_completion.d/yuangs-completion.bash
fi
`;

        let bashrc = '';
        if (fs.existsSync(bashrcPath)) {
            bashrc = fs.readFileSync(bashrcPath, 'utf-8');
        }

        if (!bashrc.includes('yuangs-completion.bash')) {
            fs.appendFileSync(bashrcPath, `\n${sourceLine}`);
        }

        return true;
    } catch (error) {
        console.error('å®‰è£… Bash è¡¥å…¨å¤±è´¥:', error);
        return false;
    }
}

export async function installZshCompletion(program: Command): Promise<boolean> {
    const zshrcPath = path.join(process.env.HOME || '', '.zshrc');
    const zfuncDir = path.join(process.env.HOME || '', '.zfunctions');

    try {
        if (!fs.existsSync(zfuncDir)) {
            fs.mkdirSync(zfuncDir, { recursive: true });
        }

        const completionPath = path.join(zfuncDir, '_yuangs');
        const completionScript = generateZshCompletion(program);

        fs.writeFileSync(completionPath, completionScript, { mode: 0o644 });
        let zshrc = '';
        if (fs.existsSync(zshrcPath)) {
            zshrc = fs.readFileSync(zshrcPath, 'utf-8');
        }

        const fpathLine = 'fpath=(~/.zfunctions $fpath)';
        const autoloadLine = 'autoload -U compinit && compinit';

        if (!zshrc.includes('fpath=')) {
            fs.appendFileSync(zshrcPath, `\n${fpathLine}`);
        }

        if (!zshrc.includes('autoload -U compinit')) {
            fs.appendFileSync(zshrcPath, `\n${autoloadLine}`);
        }

        return true;
    } catch (error) {
        console.error('å®‰è£… Zsh è¡¥å…¨å¤±è´¥:', error);
        return false;
    }
}

/**
 * è·å–å‘½ä»¤æè¿°ï¼ˆç”¨äºè¡¥å…¨æç¤ºï¼‰
 */
export function getCommandDescription(program: Command, commandName: string): string {
    const command = program.commands.find(cmd => cmd.name() === commandName);
    return command?.description() || '';
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/completion/builtin.ts

````typescript
import type { CompletionItem } from './types';

export function getBuiltinCommands(): Array<{ name: string; description: string }> {
  return [
    { name: 'ai', description: 'å‘ AI æé—®' },
    { name: 'list', description: 'åˆ—å‡ºæ‰€æœ‰åº”ç”¨' },
    { name: 'history', description: 'æŸ¥çœ‹åŠæ‰§è¡Œå‘½ä»¤å†å²' },
    { name: 'config', description: 'ç®¡ç†æœ¬åœ°é…ç½®' },
    { name: 'macros', description: 'æŸ¥çœ‹æ‰€æœ‰å¿«æ·æŒ‡ä»¤' },
    { name: 'save', description: 'ä¿å­˜å¿«æ·æŒ‡ä»¤' },
    { name: 'run', description: 'æ‰§è¡Œå¿«æ·æŒ‡ä»¤' },
    { name: 'help', description: 'æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯' },
    { name: 'completion', description: 'å®‰è£… Shell è¡¥å…¨' },
    { name: 'shici', description: 'æ‰“å¼€å¤è¯—è¯ PWA' },
    { name: 'dict', description: 'æ‰“å¼€è‹±è¯­è¯å…¸' },
    { name: 'pong', description: 'æ‰“å¼€ Pong æ¸¸æˆ' }
  ];
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/completion/cache.ts

````typescript
import type { CompletionItem } from './types';

export class CompletionCache {
  private static instance: CompletionCache;
  private cache: Map<string, CompletionItem[]>;
  private timestamp: number;
  private readonly ttl: number = 5000;

  private constructor() {
    this.cache = new Map();
    this.timestamp = Date.now();
  }

  static getInstance(): CompletionCache {
    if (!CompletionCache.instance) {
      CompletionCache.instance = new CompletionCache();
    }
    return CompletionCache.instance;
  }

  get(key: string): CompletionItem[] | null {
    const now = Date.now();
    if (now - this.timestamp > this.ttl) {
      this.cache.clear();
      this.timestamp = now;
      return null;
    }
    return this.cache.get(key) || null;
  }

  set(key: string, items: CompletionItem[]): void {
    this.cache.set(key, items);
  }

  invalidate(): void {
    this.cache.clear();
    this.timestamp = 0;
  }

  invalidatePattern(pattern: RegExp): void {
    for (const key of this.cache.keys()) {
      if (pattern.test(key)) {
        this.cache.delete(key);
      }
    }
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/completion/index.ts

````typescript
import { CompletionRequest, CompletionResponse } from './types';
import { resolveCompletion } from './resolver';

export async function complete(
  req: CompletionRequest
): Promise<CompletionResponse> {
  if (!Array.isArray(req.words)) {
    return { items: [], isPartial: false };
  }

  if (
    typeof req.currentIndex !== 'number' ||
    req.currentIndex < 0 ||
    req.currentIndex >= req.words.length
  ) {
    return { items: [], isPartial: false };
  }

  return resolveCompletion(req);
}

export { setProgramInstance } from './resolver';

export {
  getAllCommands,
  getCommandSubcommands,
  getCommandDescription,
  installBashCompletion,
  installZshCompletion
} from '../completion.legacy';

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/completion/path.ts

````typescript
import fs from 'fs';
import path from 'path';

export type PathKind = 'file' | 'dir';

export function resolvePathSuggestions(
  input: string,
  kind: PathKind
): string[] {
  const cwd = process.cwd();
  const normalized = input.replace(/^~(?=$|\/)/, process.env.HOME || '');
  const isDirInput = normalized.endsWith(path.sep);

  const baseDir = isDirInput
    ? path.resolve(cwd, normalized)
    : path.resolve(cwd, path.dirname(normalized));

  const prefix = isDirInput ? '' : path.basename(normalized);

  try {
    const entries = fs.readdirSync(baseDir, { withFileTypes: true });
    return entries
      .filter(e => !e.name.startsWith('.'))
      .filter(e => {
        if (kind === 'file') return e.isFile();
        return e.isDirectory();
      })
      .filter(e => e.name.startsWith(prefix))
      .map(e => {
        const fullPath = path.join(baseDir, e.name);
        const suggestion = e.isDirectory()
          ? fullPath + path.sep
          : fullPath;
        return suggestion.replace(/^\\/g, '');
      });
  } catch {
    return [];
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/completion/resolver.ts

````typescript
import { CompletionRequest, CompletionResponse, CompletionItem } from './types';
import { unique } from './utils';
import { getBuiltinCommands } from './builtin';
import { loadAppsConfig } from '../apps';
import { getMacros } from '../macros';
import { Command } from 'commander';

let programInstance: Command | null = null;

export function setProgramInstance(program: Command): void {
  programInstance = program;
}

function getProgramInstance(): Command {
  return programInstance || ({} as Command);
}

export async function resolveCompletion(
  req: CompletionRequest
): Promise<CompletionResponse> {
  const { words, currentIndex } = req;

  const currentWord = words[currentIndex] ?? '';
  const previousWord = words[currentIndex - 1] ?? '';

  if (currentIndex === 1) {
    return completeTopLevel(currentWord);
  }

  return completeSubcommand(words.slice(1, currentIndex), currentWord, previousWord);
}

function completeTopLevel(prefix: string): CompletionResponse {
  const items: CompletionItem[] = [];

  const commands = getBuiltinCommands();
  commands.forEach(cmd => {
    items.push({ label: cmd.name });
  });

  try {
    const apps = loadAppsConfig();
    Object.keys(apps).forEach(name => {
      if (!items.find(i => i.label === name)) {
        items.push({ label: name });
      }
    });
  } catch {}

  try {
    const macros = getMacros();
    Object.keys(macros).forEach(name => {
      if (!items.find(i => i.label === name)) {
        items.push({ label: name });
      }
    });
  } catch {}

  const filtered = items.filter(item => item.label.startsWith(prefix));

  return {
    items: unique(filtered),
    isPartial: true
  };
}

function completeSubcommand(
  path: string[],
  prefix: string,
  prev: string
): CompletionResponse {
  const items: CompletionItem[] = [];

  if (prev === '--model' || prev === '-m') {
    items.push(
      { label: 'gemini-2.5-flash-lite' },
      { label: 'gemini-2.5-pro' },
      { label: 'Assistant' },
      { label: 'GPT-4o-mini' }
    );
  } else if (path.length > 0) {
    const baseCommand = path[0];
    const cmd = getProgramInstance().commands.find((c: any) => c.name() === baseCommand);

    if (cmd) {
      cmd.options.forEach((opt: any) => {
        opt.flags.split(/[, ]+/).forEach((flag: string) => {
          if (flag.startsWith('-') && !flag.startsWith('--')) {
            items.push({ label: flag });
          }
        });
      });

      cmd.commands.forEach((subcmd: any) => {
        items.push({ label: subcmd.name() });
      });
    }
  }

  const filtered = items.filter(item => item.label.startsWith(prefix));

  return {
    items: unique(filtered),
    isPartial: true
  };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/completion/types.ts

````typescript
// core/completion/types.ts

/**
 * yuangs Completion Protocol v1.1
 * ç»ˆæ€è¡¥å…¨åè®® - å”¯ä¸€ã€å¼ºçº¦æŸ
 */

export interface CompletionRequest {
  /**
   * å®Œæ•´ argvï¼Œä¸åŒ…å« node
   * e.g. ['yuangs', 'ai', 'chat', '--m']
   */
  words: string[];

  /**
   * cursor æ‰€åœ¨ index
   */
  currentIndex: number;
}

export interface CompletionItem {
  label: string;
  insertText?: string;
  detail?: string;
}

export interface CompletionResponse {
  items: CompletionItem[];
  isPartial: boolean;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/completion/utils.ts

````typescript
import { CompletionItem } from './types';

export function unique(items: CompletionItem[]): CompletionItem[] {
  const seen = new Set<string>();
  return items.filter(i => {
    if (seen.has(i.label)) return false;
    seen.add(i.label);
    return true;
  });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/configMerge.ts

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import yaml from 'js-yaml';

export type ConfigSource = 'built-in' | 'user-global' | 'project' | 'command-override';

export interface ConfigFieldSource<T = unknown> {
  value: T;
  source: ConfigSource;
  filePath?: string;
}

export interface MergedConfig {
  aiProxyUrl: ConfigFieldSource<string>;
  defaultModel: ConfigFieldSource<string>;
  accountType: ConfigFieldSource<'free' | 'pro'>;
  [key: string]: ConfigFieldSource<unknown>;
}

export function loadConfigAt(filePath: string): Record<string, unknown> | null {
  if (!fs.existsSync(filePath)) {
    return null;
  }

  try {
    const content = fs.readFileSync(filePath, 'utf8');
    if (filePath.endsWith('.yaml') || filePath.endsWith('.yml')) {
      return yaml.load(content) as Record<string, unknown>;
    }
    return JSON.parse(content);
  } catch (error) {
    console.warn(`Failed to load config from ${filePath}:`, error);
    return null;
  }
}

export function mergeConfigs(
  builtin: Record<string, unknown>,
  userGlobal: Record<string, unknown> | null,
  project: Record<string, unknown> | null,
  commandOverride: Record<string, unknown> | null
): MergedConfig {
  const merged: MergedConfig = {} as MergedConfig;

  const addField = (key: string, value: unknown, source: ConfigSource, filePath?: string) => {
    merged[key] = { value, source, filePath };
  };

  Object.entries(builtin).forEach(([key, value]) => {
    addField(key, value, 'built-in');
  });

  if (userGlobal) {
    Object.entries(userGlobal).forEach(([key, value]) => {
      addField(key, value, 'user-global', path.join(os.homedir(), '.yuangs.json'));
    });
  }

  if (project) {
    Object.entries(project).forEach(([key, value]) => {
      addField(key, value, 'project');
    });
  }

  if (commandOverride) {
    Object.entries(commandOverride).forEach(([key, value]) => {
      addField(key, value, 'command-override');
    });
  }

  return merged;
}

export function dumpConfigSnapshot(config: MergedConfig): string {
  const output: Record<string, any> = {};

  Object.entries(config).forEach(([key, field]) => {
    output[key] = {
      value: field.value,
      source: field.source,
      filePath: field.filePath,
    };
  });

  return JSON.stringify(output, null, 2);
}

function findProjectConfig(cwd = process.cwd()): string | null {
  let dir = cwd;
  const configFiles = ['.yuangs.json', '.yuangs.yaml', '.yuangs.yml', 'yuangs.config.json'];

  while (dir && dir !== path.dirname(dir)) {
    for (const filename of configFiles) {
      const candidate = path.join(dir, filename);
      if (fs.existsSync(candidate)) {
        return candidate;
      }
    }
    dir = path.dirname(dir);
  }

  const root = path.parse(cwd).root;
  for (const filename of configFiles) {
    const rootCandidate = path.join(root, filename);
    if (fs.existsSync(rootCandidate)) {
      return rootCandidate;
    }
  }

  return null;
}

export function getConfigFilePaths(): {
  userGlobal: string;
  project: string | null;
} {
  return {
    userGlobal: path.join(os.homedir(), '.yuangs.json'),
    project: findProjectConfig(),
  };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/executionRecord.ts

````typescript
import { MergedConfig } from './configMerge';
import { ModelCapabilities, CapabilityMatchExplanation } from './modelMatcher';
import { CapabilityRequirement } from './modelMatcher';
import { Skill } from '../agent/skills';

export interface ExecutionMeta {
  commandName: string;
  timestamp: string;
  toolVersion: string;
  projectPath: string;
  args?: any;
  rawInput?: string;
  replayable?: boolean;
  version?: string;
}

export interface CapabilityIntent {
  required: string[];
  preferred: string[];
  capabilityVersion: string;
}

export interface ModelDecision {
  candidateModels: CapabilityMatchExplanation[];
  selectedModel: ModelCapabilities | null;
  usedFallback: boolean;
  fallbackReason?: string;
  strategy?: string;
  reason?: string;
  skills?: Skill[];
}

export interface ExecutionOutcome {
  success: boolean;
  failureReason?: 'capability-mismatch' | 'provider-error' | 'user-abort' | 'timeout' | 'other';
  tokenCount?: number;
  latencyMs?: number;
}

export interface ExecutionRecord {
  id: string;
  meta: ExecutionMeta;
  intent: CapabilityIntent;
  configSnapshot: MergedConfig;
  decision: ModelDecision;
  outcome: ExecutionOutcome;
  command?: string;
}

export function createExecutionId(): string {
  return `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

export function createExecutionRecord(
  commandName: string,
  requirement: CapabilityRequirement,
  config: MergedConfig,
  matchResult: any,
  outcome: Partial<ExecutionOutcome> = {},
  command?: string
): ExecutionRecord {
  const version = require('../../package.json').version;

  return {
    id: createExecutionId(),
    meta: {
      commandName,
      timestamp: new Date().toISOString(),
      toolVersion: version,
      projectPath: process.cwd(),
      version,
      replayable: true,
    },
    intent: {
      required: requirement.required.map(String),
      preferred: requirement.preferred.map(String),
      capabilityVersion: require('./capabilities').CAPABILITY_VERSION,
    },
    configSnapshot: config,
    decision: {
      candidateModels: matchResult.candidates || [],
      selectedModel: matchResult.selected,
      usedFallback: matchResult.fallbackOccurred,
    },
    outcome: {
      success: outcome.success ?? false,
      ...outcome,
    },
    command,
  };
}

export function serializeExecutionRecord(record: ExecutionRecord): string {
  return JSON.stringify(record, null, 2);
}

export function deserializeExecutionRecord(json: string): ExecutionRecord {
  return JSON.parse(json) as ExecutionRecord;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/executionStore.ts

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import { ExecutionRecord, serializeExecutionRecord, deserializeExecutionRecord } from './executionRecord';

const RECORD_DIR = path.join(os.homedir(), '.yuangs', 'executions');

export function ensureRecordDir(): void {
  if (!fs.existsSync(RECORD_DIR)) {
    fs.mkdirSync(RECORD_DIR, { recursive: true });
  }
}

export function saveExecutionRecord(record: ExecutionRecord): string {
  ensureRecordDir();

  const filename = `${record.id}.json`;
  const filepath = path.join(RECORD_DIR, filename);

  fs.writeFileSync(filepath, serializeExecutionRecord(record), 'utf8');

  return filepath;
}

export function loadExecutionRecord(id: string): ExecutionRecord | null {
  ensureRecordDir();

  const filename = `${id}.json`;
  const filepath = path.join(RECORD_DIR, filename);

  if (!fs.existsSync(filepath)) {
    return null;
  }

  try {
    const content = fs.readFileSync(filepath, 'utf8');
    return deserializeExecutionRecord(content);
  } catch (error) {
    console.error(`Failed to load execution record ${id}:`, error);
    return null;
  }
}

export function listExecutionRecords(limit: number = 50): ExecutionRecord[] {
  ensureRecordDir();

  const files = fs.readdirSync(RECORD_DIR)
    .filter(f => f.endsWith('.json'))
    .sort((a, b) => {
      const statA = fs.statSync(path.join(RECORD_DIR, a));
      const statB = fs.statSync(path.join(RECORD_DIR, b));
      return statB.mtimeMs - statA.mtimeMs;
    })
    .slice(0, limit);

  const records: ExecutionRecord[] = [];

  for (const file of files) {
    const record = loadExecutionRecord(file.replace('.json', ''));
    if (record) {
      records.push(record);
    }
  }

  return records;
}

export function deleteExecutionRecord(id: string): boolean {
  ensureRecordDir();

  const filename = `${id}.json`;
  const filepath = path.join(RECORD_DIR, filename);

  if (!fs.existsSync(filepath)) {
    return false;
  }

  try {
    fs.unlinkSync(filepath);
    return true;
  } catch (error) {
    console.error(`Failed to delete execution record ${id}:`, error);
    return false;
  }
}

export function clearAllExecutionRecords(): void {
  ensureRecordDir();

  const files = fs.readdirSync(RECORD_DIR).filter(f => f.endsWith('.json'));

  for (const file of files) {
    const filepath = path.join(RECORD_DIR, file);
    try {
      fs.unlinkSync(filepath);
    } catch (error) {
      console.error(`Failed to delete ${filepath}:`, error);
    }
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/executor.ts

````typescript
import { spawn } from 'child_process';

export type ExecResult = {
    stdout: string;
    stderr: string;
    code: number | null;
};

export async function exec(command: string): Promise<ExecResult> {
    return new Promise((resolve) => {
        let stdout = '';
        let stderr = '';

        // Use user's preferred shell back with full support for their environment
        const shell = process.env.SHELL || true;
        const child = spawn(command, [], { shell });

        child.stdout.on('data', (data) => {
            stdout += data.toString();
            process.stdout.write(data);
        });

        child.stderr.on('data', (data) => {
            stderr += data.toString();
            process.stderr.write(data);
        });

        child.on('close', (code) => {
            resolve({ stdout, stderr, code });
        });

        child.on('error', (err) => {
            stderr += err.message;
            resolve({ stdout, stderr, code: 1 });
        });
    });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/explain.ts

````typescript
import { ExecutionRecord } from './executionRecord';
import { computeSkillScore, Skill } from '../agent/skills';

/**
 * Explain Output Spec v1
 * - Stable, human-readable, diff-friendly
 * - No side effects
 * - Do NOT change without bumping spec version
 */
export function explainExecution(record: ExecutionRecord): string {
  const lines: string[] = [];

  lines.push('=== Execution Explanation ===');

  /* =========================
   * [1] Command
   * ========================= */
  lines.push('[1] Command');
  lines.push(`- Name: ${record.meta.commandName ?? 'N/A'}`);

  if (record.command) {
    lines.push(`- Args: ${record.command}`);
  }

  if (record.meta.rawInput) {
    lines.push(`- Raw: ${record.meta.rawInput}`);
  }
  lines.push('');

  /* =========================
   * [2] Decision
   * ========================= */
  const decision = record.decision ?? {};

  lines.push('[2] Decision');
  lines.push(`- Strategy: ${decision.strategy ?? 'capability-match'}`);
  lines.push(
    `- Selected Model: ${decision.selectedModel?.name ?? 'N/A'}`
  );
  lines.push(
    `- Reason: ${decision.reason ?? 'Capability-based selection with fallback support'}`
  );
  lines.push('');

  /* =========================
   * [3] Model
   * ========================= */
  const model = decision.selectedModel;

  lines.push('[3] Model');
  lines.push(`- Name: ${model?.name ?? 'N/A'}`);
  lines.push(`- Provider: ${model?.provider ?? 'N/A'}`);
  lines.push(`- Context Window: ${model?.contextWindow ?? 'default'}`);
  lines.push(`- Cost Profile: ${model?.costProfile ?? 'default'}`);
  lines.push('');

  /* =========================
   * [4] Skills
   * ========================= */
  lines.push('[4] Skills');

  const skills: Skill[] = decision.skills ?? [];
  const now = Date.now();

  if (skills.length === 0) {
    lines.push('- (none)');
  } else {
    const scored = skills
      .map(skill => ({
        skill,
        score: computeSkillScore(skill, now),
      }))
      .sort((a, b) => b.score - a.score);

    for (const { skill, score } of scored) {
      const totalUses = skill.successCount + skill.failureCount;
      const successRate =
        totalUses === 0 ? 0.5 : skill.successCount / totalUses;

      lines.push(`- ${skill.name}`);
      lines.push(`    score: ${score.toFixed(3)}`);
      lines.push(`    confidence: ${skill.confidence.toFixed(3)}`);
      lines.push(`    successRate: ${successRate.toFixed(3)}`);
      lines.push(`    enabled: ${skill.enabled}`);
      lines.push(
        `    lastUsed: ${new Date(skill.lastUsed).toISOString()}`
      );
    }
  }
  lines.push('');

  /* =========================
   * [5] Meta
   * ========================= */
  lines.push('[5] Meta');
  lines.push(`- Execution ID: ${record.id}`);
  lines.push(
    `- Timestamp: ${new Date(record.meta.timestamp).toISOString()}`
  );
  lines.push(`- Replayable: ${record.meta.replayable ?? true}`);
  lines.push(`- Version: ${record.meta.version ?? 'unknown'}`);

  lines.push('=============================');

  return lines.join('\n');
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/fileReader.ts

````typescript
import fs from 'fs';
import path from 'path';

export function parseFilePathsFromLsOutput(output: string): string[] {
    const lines = output.trim().split('\n');
    const filePaths: string[] = [];

    for (const line of lines) {
        const parts = line.trim().split(/\s+/);
        const lastPart = parts[parts.length - 1];
        
        if (lastPart && !lastPart.startsWith('-') && lastPart !== '.' && lastPart !== '..') {
            filePaths.push(lastPart);
        }
    }

    return filePaths;
}

export function readFilesContent(filePaths: string[]): Map<string, string> {
    const contentMap = new Map<string, string>();

    for (const filePath of filePaths) {
        try {
            const fullPath = path.resolve(filePath);
            if (fs.existsSync(fullPath) && fs.statSync(fullPath).isFile()) {
                const content = fs.readFileSync(fullPath, 'utf-8');
                contentMap.set(filePath, content);
            }
        } catch (error) {
            console.error(`æ— æ³•è¯»å–æ–‡ä»¶: ${filePath}`);
        }
    }

    return contentMap;
}

export function buildPromptWithFileContent(
    originalOutput: string,
    filePaths: string[],
    contentMap: Map<string, string>,
    question?: string
): string {
    let prompt = '';

    prompt += '## æ–‡ä»¶åˆ—è¡¨\n';
    prompt += '```\n';
    prompt += originalOutput;
    prompt += '```\n\n';

    if (contentMap.size > 0) {
        prompt += '## æ–‡ä»¶å†…å®¹\n\n';
        for (const [filePath, content] of contentMap) {
            prompt += `### ${filePath}\n`;
            prompt += '```\n';
            const maxChars = 5000;
            const truncated = content.length > maxChars 
                ? content.substring(0, maxChars) + '\n... (å†…å®¹è¿‡é•¿å·²æˆªæ–­)'
                : content;
            prompt += truncated;
            prompt += '\n```\n\n';
        }
    }

    if (question) {
        prompt += `\n## æˆ‘çš„é—®é¢˜\n${question}`;
    } else {
        prompt += '\n## æˆ‘çš„é—®é¢˜\nè¯·åˆ†æä»¥ä¸Šæ–‡ä»¶åˆ—è¡¨å’Œæ–‡ä»¶å†…å®¹';
    }

    return prompt;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/macros.ts

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import { parseMacros, type Macro } from './validation';

const USER_MACROS_FILE = path.join(os.homedir(), '.yuangs_macros.json');

export type { Macro };

function loadMacrosFromFile(filePath: string): Record<string, Macro> {
    if (fs.existsSync(filePath)) {
        try {
            return parseMacros(fs.readFileSync(filePath, 'utf8'));
        } catch (e) { }
    }
    return {};
}

function findProjectMacros(cwd = process.cwd()): string | null {
    let dir = cwd;
    while (dir && dir !== path.dirname(dir)) {
        const candidate = path.join(dir, 'yuangs_macros.json');
        if (fs.existsSync(candidate)) {
            return candidate;
        }
        dir = path.dirname(dir);
    }
    // Check root one last time
    const rootCandidate = path.join(targetRoot(dir), 'yuangs_macros.json');
    if (fs.existsSync(rootCandidate)) return rootCandidate;
    
    return null;
}

// Helper to reliably stop at root (dirname('/') is '/')
function targetRoot(dir: string) {
    return path.parse(dir).root;
}

export function getMacros(): Record<string, Macro> {
    const userMacros = loadMacrosFromFile(USER_MACROS_FILE);
    
    const projectMacrosPath = findProjectMacros();
    const projectMacros = projectMacrosPath ? loadMacrosFromFile(projectMacrosPath) : {};

    return {
        ...userMacros,
        ...projectMacros // Project overrides User
    };
}

export function saveMacro(name: string, commands: string, description: string = '') {
    // Only load USER macros for saving
    const macros = loadMacrosFromFile(USER_MACROS_FILE);
    macros[name] = {
        commands,
        description,
        createdAt: new Date().toISOString()
    };
    fs.writeFileSync(USER_MACROS_FILE, JSON.stringify(macros, null, 2));
    return true;
}

export function deleteMacro(name: string) {
    // Only delete from USER macros
    const macros = loadMacrosFromFile(USER_MACROS_FILE);
    if (macros[name]) {
        delete macros[name];
        fs.writeFileSync(USER_MACROS_FILE, JSON.stringify(macros, null, 2));
        return true;
    }
    return false;
}

export function runMacro(name: string) {
    const macros = getMacros();
    const macro = macros[name];
    if (!macro) return false;

    const { spawn } = require('child_process');
    spawn(macro.commands, [], { shell: true, stdio: 'inherit' });
    return true;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/modelMatcher.ts

````typescript
import { AtomicCapability, ConstraintCapability, expandCapabilities } from './capabilities';

export interface ModelCapabilities {
  name: string;
  provider: string;
  atomicCapabilities: AtomicCapability[];
  contextWindow?: number;
  costProfile?: 'low' | 'medium' | 'high';
}

export interface CapabilityRequirement {
  required: AtomicCapability[];
  preferred: AtomicCapability[];
  constraints?: ConstraintCapability[];
}

export interface CapabilityMatchExplanation {
  modelName: string;
  provider: string;
  hasRequired: boolean;
  hasPreferred: AtomicCapability[];
  missingRequired: AtomicCapability[];
  reason: string;
}

export interface CapabilityMatchResult {
  selected: ModelCapabilities | null;
  candidates: CapabilityMatchExplanation[];
  fallbackOccurred: boolean;
}

export function matchModel(
  models: ModelCapabilities[],
  requirement: CapabilityRequirement
): CapabilityMatchResult {
  const explanations: CapabilityMatchExplanation[] = [];

  for (const model of models) {
    const hasRequired = requirement.required.every(cap =>
      model.atomicCapabilities.includes(cap)
    );

    const missingRequired = requirement.required.filter(cap =>
      !model.atomicCapabilities.includes(cap)
    );

    const hasPreferred = requirement.preferred.filter(cap =>
      model.atomicCapabilities.includes(cap)
    );

    const explanation: CapabilityMatchExplanation = {
      modelName: model.name,
      provider: model.provider,
      hasRequired,
      hasPreferred,
      missingRequired,
      reason: hasRequired
        ? `Has all required capabilities. Matches ${hasPreferred.length}/${requirement.preferred.length} preferred.`
        : `Missing required capabilities: ${missingRequired.map(c => String(c)).join(', ')}`,
    };

    explanations.push(explanation);
  }

  const matchingModels = explanations.filter(e => e.hasRequired);

  if (matchingModels.length === 0) {
    return {
      selected: null,
      candidates: explanations,
      fallbackOccurred: false,
    };
  }

  const bestMatch = matchingModels[0];
  const selectedModel = models.find(m => m.name === bestMatch.modelName);

  return {
    selected: selectedModel || null,
    candidates: explanations,
    fallbackOccurred: false,
  };
}

export function matchModelWithFallback(
  models: ModelCapabilities[],
  fallbackModels: ModelCapabilities[],
  requirement: CapabilityRequirement
): CapabilityMatchResult {
  const primaryResult = matchModel(models, requirement);

  if (primaryResult.selected) {
    return primaryResult;
  }

  const fallbackResult = matchModel(fallbackModels, requirement);

  return {
    ...fallbackResult,
    fallbackOccurred: fallbackResult.selected !== null,
  };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/models.config.json

````json
{
  "availableModels": [
    {
      "id": "gpt-4o-mini",
      "name": "GPT-4o Mini",
      "description": "å¿«é€Ÿä¸”é«˜æ•ˆ"
    },
    {
      "id": "glm4.7",
      "name": "glm4.7",
      "description": "å¹³è¡¡æ€§èƒ½"
    },
    {
      "id": "gemini-flash-lite-latest",
      "name": "Gemini Flash Lite Latest",
      "description": "æè‡´é€Ÿåº¦"
    },
    {
      "id": "gemini-3-flash-preview",
      "name": "Gemini 3 Flash Preview",
      "description": "å¿«é€Ÿä¸”é«˜æ•ˆ"
    },
    {
      "id": "Assistant",
      "name": "Assistant",
      "description": "åŠ©æ‰‹"
    }
  ],
  "defaultModel": "Assistant"
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/os.ts

````typescript
export type OSProfile = {
    name: string;
    shell: string;
    find: 'bsd' | 'gnu';
    stat: 'bsd' | 'gnu';
};

export function getOSProfile(): OSProfile {
    switch (process.platform) {
        case 'darwin':
            return {
                name: 'macOS',
                shell: 'zsh',
                find: 'bsd',
                stat: 'bsd',
            };
        case 'linux':
            return {
                name: 'Linux',
                shell: 'bash',
                find: 'gnu',
                stat: 'gnu',
            };
        case 'win32':
            return {
                name: 'Windows',
                shell: 'cmd',
                find: 'gnu', // Win32 find is different, but for AI context let's assume GNU style tools if they are there, or just label it.
                stat: 'gnu',
            };
        default:
            return {
                name: process.platform,
                shell: 'sh',
                find: 'gnu',
                stat: 'gnu',
            };
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/replayDiff.ts

````typescript
import { ExecutionRecord } from './executionRecord';
import { computeSkillScore } from '../agent/skills';

export interface ReplayDiffResult {
  decisionDiff: DecisionDiff;
  modelDiff: ModelDiff;
  skillsDiff: SkillsDiff;
}

interface DecisionDiff {
  changed: boolean;
  strategyChanged: boolean;
  modelChanged: boolean;
  reasonChanged: boolean;
  before?: {
    strategy: string;
    selectedModel: string;
    reason: string;
  };
  after?: {
    strategy: string;
    selectedModel: string;
    reason: string;
  };
}

interface ModelDiff {
  changed: boolean;
  nameChanged: boolean;
  providerChanged: boolean;
  before?: {
    name: string;
    provider: string;
    contextWindow: number | string;
    costProfile: string;
  };
  after?: {
    name: string;
    provider: string;
    contextWindow: number | string;
    costProfile: string;
  };
}

interface SkillsDiff {
  added: SkillChange[];
  removed: SkillChange[];
  changed: SkillChange[];
}

interface SkillChange {
  name: string;
  score?: number;
  enabled?: boolean;
  confidence?: number;
  successRate?: number;
  lastUsed?: string;
}

export function diffExecution(
  original: ExecutionRecord,
  current: ExecutionRecord
): ReplayDiffResult {
  return {
    decisionDiff: diffDecision(original, current),
    modelDiff: diffModel(original, current),
    skillsDiff: diffSkills(original, current),
  };
}

function diffDecision(original: ExecutionRecord, current: ExecutionRecord): DecisionDiff {
  const origDecision = original.decision;
  const currDecision = current.decision;

  const strategyChanged = origDecision?.strategy !== currDecision?.strategy;
  const modelChanged = origDecision?.selectedModel?.name !== currDecision?.selectedModel?.name;
  const reasonChanged = origDecision?.reason !== currDecision?.reason;

  return {
    changed: strategyChanged || modelChanged || reasonChanged,
    strategyChanged,
    modelChanged,
    reasonChanged,
    before: {
      strategy: origDecision?.strategy ?? 'N/A',
      selectedModel: origDecision?.selectedModel?.name ?? 'N/A',
      reason: origDecision?.reason ?? 'N/A',
    },
    after: {
      strategy: currDecision?.strategy ?? 'N/A',
      selectedModel: currDecision?.selectedModel?.name ?? 'N/A',
      reason: currDecision?.reason ?? 'N/A',
    },
  };
}

function diffModel(original: ExecutionRecord, current: ExecutionRecord): ModelDiff {
  const origModel = original.decision.selectedModel;
  const currModel = current.decision.selectedModel;

  if (!origModel || !currModel) {
    return {
      changed: true,
      nameChanged: true,
      providerChanged: true,
      before: origModel ? {
        name: origModel.name,
        provider: origModel.provider,
        contextWindow: origModel.contextWindow ?? 'default',
        costProfile: origModel.costProfile ?? 'default',
      } : undefined,
      after: currModel ? {
        name: currModel.name,
        provider: currModel.provider,
        contextWindow: currModel.contextWindow ?? 'default',
        costProfile: currModel.costProfile ?? 'default',
      } : undefined,
    };
  }

  const nameChanged = origModel.name !== currModel.name;
  const providerChanged = origModel.provider !== currModel.provider;

  return {
    changed: nameChanged || providerChanged,
    nameChanged,
    providerChanged,
    before: {
      name: origModel.name,
      provider: origModel.provider,
      contextWindow: origModel.contextWindow ?? 'default',
      costProfile: origModel.costProfile ?? 'default',
    },
    after: {
      name: currModel.name,
      provider: currModel.provider,
      contextWindow: currModel.contextWindow ?? 'default',
      costProfile: currModel.costProfile ?? 'default',
    },
  };
}

function diffSkills(original: ExecutionRecord, current: ExecutionRecord): SkillsDiff {
  const origSkills = original.decision.skills ?? [];
  const currSkills = current.decision.skills ?? [];

  const origSkillMap = new Map(origSkills.map(s => [s.name, s]));
  const currSkillMap = new Map(currSkills.map(s => [s.name, s]));

  const added: SkillChange[] = [];
  const removed: SkillChange[] = [];
  const changed: SkillChange[] = [];

  const now = Date.now();

  // Find added and changed skills
  for (const skill of currSkills) {
    const origSkill = origSkillMap.get(skill.name);

    if (!origSkill) {
      // Added
      const score = computeSkillScore(skill, now);
      const totalUses = skill.successCount + skill.failureCount;
      const successRate = totalUses === 0 ? 0.5 : skill.successCount / totalUses;

      added.push({
        name: skill.name,
        score,
        enabled: skill.enabled,
        confidence: skill.confidence,
        successRate,
        lastUsed: new Date(skill.lastUsed).toISOString(),
      });
    } else {
      // Check if changed
      const origScore = computeSkillScore(origSkill, now);
      const currScore = computeSkillScore(skill, now);
      const origTotalUses = origSkill.successCount + origSkill.failureCount;
      const currTotalUses = skill.successCount + skill.failureCount;
      const origSuccessRate = origTotalUses === 0 ? 0.5 : origSkill.successCount / origTotalUses;
      const currSuccessRate = currTotalUses === 0 ? 0.5 : skill.successCount / currTotalUses;

      if (
        Math.abs(origScore - currScore) > 0.001 ||
        origSkill.enabled !== skill.enabled ||
        Math.abs(origSuccessRate - currSuccessRate) > 0.001
      ) {
        changed.push({
          name: skill.name,
          score: currScore,
          enabled: skill.enabled,
          confidence: skill.confidence,
          successRate: currSuccessRate,
          lastUsed: new Date(skill.lastUsed).toISOString(),
        });
      }
    }
  }

  // Find removed skills
  for (const skill of origSkills) {
    if (!currSkillMap.has(skill.name)) {
      const score = computeSkillScore(skill, now);
      const totalUses = skill.successCount + skill.failureCount;
      const successRate = totalUses === 0 ? 0.5 : skill.successCount / totalUses;

      removed.push({
        name: skill.name,
        score,
        enabled: skill.enabled,
        confidence: skill.confidence,
        successRate,
        lastUsed: new Date(skill.lastUsed).toISOString(),
      });
    }
  }

  return {
    added,
    removed,
    changed,
  };
}

export function formatReplayDiff(diff: ReplayDiffResult): string {
  const lines: string[] = [];

  lines.push('=== Replay Diff ===');

  // [Decision]
  lines.push('[Decision]');
  if (!diff.decisionDiff.changed) {
    lines.push('- no change');
  } else {
    if (diff.decisionDiff.strategyChanged) {
      lines.push(`- strategy: ${diff.decisionDiff.before?.strategy} â†’ ${diff.decisionDiff.after?.strategy}`);
    }
    if (diff.decisionDiff.modelChanged) {
      lines.push(`- selectedModel: ${diff.decisionDiff.before?.selectedModel} â†’ ${diff.decisionDiff.after?.selectedModel}`);
    }
    if (diff.decisionDiff.reasonChanged) {
      lines.push(`- reason:`);
      lines.push(`    before: "${diff.decisionDiff.before?.reason}"`);
      lines.push(`    after: "${diff.decisionDiff.after?.reason}"`);
    }
  }
  lines.push('');

  // [Model]
  lines.push('[Model]');
  if (!diff.modelDiff.changed) {
    lines.push('- no change');
  } else {
    if (diff.modelDiff.nameChanged) {
      lines.push(`- name: ${diff.modelDiff.before?.name} â†’ ${diff.modelDiff.after?.name}`);
    }
    if (diff.modelDiff.providerChanged) {
      lines.push(`- provider: ${diff.modelDiff.before?.provider} â†’ ${diff.modelDiff.after?.provider}`);
    }
  }
  lines.push('');

  // [Skills]
  lines.push('[Skills]');
  if (diff.skillsDiff.added.length === 0 &&
      diff.skillsDiff.removed.length === 0 &&
      diff.skillsDiff.changed.length === 0) {
    lines.push('- no change');
  } else {
    for (const skill of diff.skillsDiff.added) {
      lines.push(`+ added: ${skill.name} (score=${skill.score?.toFixed(3)})`);
    }
    for (const skill of diff.skillsDiff.removed) {
      lines.push(`- removed: ${skill.name}`);
    }
    for (const skill of diff.skillsDiff.changed) {
      lines.push(`~ changed: ${skill.name} (score=${skill.score?.toFixed(3)}, enabled=${skill.enabled})`);
    }
  }

  lines.push('===================');

  return lines.join('\n');
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/replayEngine.ts

````typescript
import chalk from 'chalk';
import { ExecutionRecord } from './executionRecord';
import { loadExecutionRecord } from './executionStore';
import { explainExecution } from './explain';

export type ReplayMode = 'strict' | 'compatible' | 're-evaluate';

export interface ReplayOptions {
  mode: ReplayMode;
  skipAI?: boolean;
  verbose?: boolean;
  dry?: boolean;
  explain?: boolean;
  diff?: boolean;
}

export interface ReplayResult {
  success: boolean;
  message: string;
  executedModel?: string;
  deviationReason?: string;
}

export class ReplayEngine {
  async replay(recordId: string, options: ReplayOptions = { mode: 'strict' }): Promise<ReplayResult> {
    const record = loadExecutionRecord(recordId);

    if (!record) {
      return {
        success: false,
        message: `Execution record ${recordId} not found`,
      };
    }

    // NOTE: --diff implicitly enables --explain
    if (options.diff) {
      options.explain = true;
    }

    if (options.explain) {
      console.log(explainExecution(record));
      console.log('');

      if (options.dry) {
        return {
          success: true,
          message: '[Explain + Dry] Explanation shown, no execution',
        };
      }
    }

    if (options.mode === 'strict') {
      return this.strictReplay(record, options);
    }

    if (options.mode === 'compatible') {
      return this.compatibleReplay(record, options);
    }

    return this.reEvaluate(record, options);
  }

  private async strictReplay(
    record: ExecutionRecord,
    options: ReplayOptions
  ): Promise<ReplayResult> {
    const selectedModel = record.decision.selectedModel;

    if (options.verbose || options.dry) {
      console.log(chalk.cyan('[Strict Replay]'));
      console.log(chalk.gray(`  Original Model: ${selectedModel?.name || 'N/A'}`));
      console.log(chalk.gray(`  Original Provider: ${selectedModel?.provider || 'N/A'}`));
      console.log(chalk.gray(`  Original Timestamp: ${record.meta.timestamp}`));
      console.log(chalk.gray(`  Original Command: ${record.meta.commandName}`));
    }

    if (options.dry) {
      return {
        success: true,
        message: '[Dry Replay] Command not executed',
        executedModel: selectedModel?.name ?? undefined,
      };
    }

    if (options.skipAI) {
      return {
        success: true,
        message: 'Strict replay prepared (AI execution skipped)',
        executedModel: selectedModel?.name ?? undefined,
      };
    }

    if (!record.command) {
      return {
        success: false,
        message: 'Strict replay: No command to execute (command not stored in record)',
        executedModel: selectedModel?.name ?? undefined,
      };
    }

    const { exec } = require('./executor');

    try {
      console.log(chalk.gray('[Strict Replay] Executing with original parameters...'));
      const result = await exec(record.command);

      return {
        success: result.code === 0 || result.code === null,
        message: result.code === 0 || result.code === null
          ? 'Strict replay completed successfully'
          : `Strict replay failed with code ${result.code}`,
        executedModel: selectedModel?.name ?? undefined,
      };
    } catch (error: unknown) {
      const message = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        message: `Strict replay error: ${message}`,
        executedModel: selectedModel?.name ?? undefined,
      };
    }
  }

  private async compatibleReplay(
    record: ExecutionRecord,
    options: ReplayOptions
  ): Promise<ReplayResult> {
    const originalModel = record.decision.selectedModel;

    if (options.verbose) {
      console.log(chalk.cyan('[Compatible Replay]'));
      console.log(chalk.gray(`  Original Model: ${originalModel?.name || 'N/A'}`));
      console.log(chalk.gray(`  Will attempt fallback if original unavailable`));
    }

    return {
      success: false,
      message: 'Compatible replay not yet implemented in Phase 1',
      executedModel: originalModel?.name,
      deviationReason: 'Phase 1 only supports strict replay',
    };
  }

  private async reEvaluate(
    record: ExecutionRecord,
    options: ReplayOptions
  ): Promise<ReplayResult> {
    if (options.verbose) {
      console.log(chalk.cyan('[Re-evaluate]'));
      console.log(chalk.gray(`  Will re-run capability matching with current config`));
      console.log(chalk.gray(`  Original Intent: ${record.intent.required.join(', ')}`));
    }

    return {
      success: false,
      message: 'Re-evaluate not yet implemented in Phase 1',
    };
  }
}

export const replayEngine = new ReplayEngine();

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/risk.ts

````typescript
export function assessRisk(command: string, aiRisk: 'low' | 'medium' | 'high'): 'low' | 'medium' | 'high' {
    const HIGH_RISK_PATTERNS = [
        /\brm\b/i,
        /\bsudo\b/i,
        /\bmv\b/i,
        /\bdd\b/i,
        /\bchmod\b/i,
        /\bchown\b/i,
        />\s*\/dev\//,
        /:\(\)\s*\{.*\}/, // Fork bomb
        /\bmkfs\b/i,
    ];

    const hasHighRisk = HIGH_RISK_PATTERNS.some(pattern => pattern.test(command));

    if (hasHighRisk) return 'high';
    return aiRisk;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/core/validation.ts

````typescript
import { z } from 'zod';
import * as fs from 'fs';
import * as path from 'path';

export type UserConfig = {
    defaultModel?: string;
    aiProxyUrl?: string;
    accountType?: 'free' | 'pro' | 'paid';
    contextWindow?: number;
    maxFileTokens?: number;
    maxTotalTokens?: number;
    [key: string]: any;
};

export type AppsConfig = Record<string, string>;

export type AIRequestMessage = {
    role: 'system' | 'user' | 'assistant' | 'tool';
    content: string;
};

export type AIResponse = {
    choices?: Array<{
        message?: {
            content?: string;
        };
        delta?: {
            content?: string;
        };
    }>;
};

export const DEFAULT_AI_PROXY_URL = 'https://api.openai.com/v1/chat/completions';
export const DEFAULT_ACCOUNT_TYPE = 'free' as const;

// é»˜è®¤å€¼ï¼ˆå¦‚æœé…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼‰
export const DEFAULT_MODEL_FALLBACK = 'gpt-4o-mini';

// ä»é…ç½®æ–‡ä»¶è¯»å–é»˜è®¤æ¨¡å‹
function loadDefaultModelFromConfig(): string {
    try {
        // å°è¯•ä» __dirname æŸ¥æ‰¾é…ç½®æ–‡ä»¶
        const possiblePaths = [
            path.join(__dirname, 'models.config.json'),
            path.join(process.cwd(), 'src', 'engine', 'core', 'models.config.json')
        ];

        for (const configPath of possiblePaths) {
            if (fs.existsSync(configPath)) {
                const content = fs.readFileSync(configPath, 'utf-8');
                const config = JSON.parse(content);
                const model = config.defaultModel || DEFAULT_MODEL_FALLBACK;
                console.log(`[validation] Loaded default model from config: ${model}`);
                return model;
            }
        }

        console.warn('[validation] Models config file not found, using fallback');
        return DEFAULT_MODEL_FALLBACK;
    } catch (error) {
        console.error('[validation] Failed to read models config:', error);
        return DEFAULT_MODEL_FALLBACK;
    }
}

// åˆå§‹åŒ–æ—¶åŠ è½½é»˜è®¤æ¨¡å‹å¹¶å¯¼å‡º
export const DEFAULT_MODEL: string = loadDefaultModelFromConfig();

export const DEFAULT_APPS = {
    shici: 'https://wealth.want.biz/shici/index.html',
    dict: 'https://wealth.want.biz/pages/dict.html',
    pong: 'https://wealth.want.biz/pages/pong.html'
} as const;

export const aiCommandPlanSchema = z.object({
    plan: z.string().describe('Explanation of the command'),
    command: z.string().optional().describe('The shell command to execute'),
    macro: z.string().optional().describe('Name of an existing macro to reuse'),
    risk: z.enum(['low', 'medium', 'high']).describe('Risk level assessment')
}).refine(data => data.command || data.macro, {
    message: 'Either command or macro must be provided'
});

export type AICommandPlan = z.infer<typeof aiCommandPlanSchema>;

export const aiFixPlanSchema = z.object({
    plan: z.string().describe('Fix explanation'),
    command: z.string().describe('The fixed shell command (always required for fixes)'),
    risk: z.enum(['low', 'medium', 'high']).describe('Risk level assessment')
});

export type AIFixPlan = z.infer<typeof aiFixPlanSchema>;

export const userConfigSchema = z.object({
    defaultModel: z.string().optional(),
    aiProxyUrl: z.string().url().optional(),
    accountType: z.enum(['free', 'pro', 'paid']).optional(),
    contextWindow: z.number().optional(),
    maxFileTokens: z.number().optional(),
    maxTotalTokens: z.number().optional()
}).passthrough();

export const appsConfigSchema = z.record(z.string(), z.string());

export const macroSchema = z.object({
    commands: z.string(),
    description: z.string(),
    createdAt: z.string()
});

export type Macro = z.infer<typeof macroSchema>;

export const historyEntrySchema = z.object({
    question: z.string(),
    command: z.string(),
    time: z.string()
});

export type HistoryEntry = z.infer<typeof historyEntrySchema>;

export function extractJSON(raw: string): string {
    let jsonContent = raw.trim();

    if (jsonContent.includes('```json')) {
        jsonContent = jsonContent.split('```json')[1].split('```')[0].trim();
    }
    else if (jsonContent.includes('```')) {
        jsonContent = jsonContent.split('```')[1].split('```')[0].trim();
    }

    const firstBrace = jsonContent.indexOf('{');
    const lastBrace = jsonContent.lastIndexOf('}');

    if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
        jsonContent = jsonContent.substring(firstBrace, lastBrace + 1);
    }

    return jsonContent;
}

export function safeParseJSON<T>(
    raw: string,
    schema: z.ZodSchema<T>,
    fallback: T
): { success: true; data: T } | { success: false; error: z.ZodError } {
    try {
        const jsonContent = extractJSON(raw);
        const result = schema.safeParse(JSON.parse(jsonContent));

        if (result.success) {
            return { success: true, data: result.data };
        } else {
            return { success: false, error: result.error };
        }
    } catch (error) {
        if (error instanceof z.ZodError) {
            return { success: false, error };
        }
        return {
            success: false,
            error: new z.ZodError([
                {
                    code: z.ZodIssueCode.custom,
                    message: `Failed to parse JSON: ${error instanceof Error ? error.message : String(error)}`,
                    path: []
                }
            ])
        };
    }
}

export function parseUserConfig(content: string): UserConfig {
    return userConfigSchema.parse(JSON.parse(content));
}

export function parseAppsConfig(content: string): AppsConfig {
    return appsConfigSchema.parse(JSON.parse(content)) as AppsConfig;
}

export function parseMacros(content: string): Record<string, Macro> {
    const parsed = JSON.parse(content);
    const macros: Record<string, Macro> = {};

    for (const [name, value] of Object.entries(parsed)) {
        macros[name] = macroSchema.parse(value);
    }

    return macros;
}

export function parseCommandHistory(content: string): HistoryEntry[] {
    const parsed = JSON.parse(content);
    return z.array(historyEntrySchema).parse(parsed);
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/diff/applyDiff.ts

````typescript
import * as vscode from 'vscode';

export async function applyDiff(editor: vscode.TextEditor, optimizedCode: string) {
  const edit = new vscode.WorkspaceEdit();
  edit.replace(
    editor.document.uri,
    editor.selection,
    optimizedCode
  );
  await vscode.workspace.applyEdit(edit);
  
  // Show confirmation
  vscode.window.showInformationMessage('âœ… ä¼˜åŒ–åçš„ä»£ç å·²åº”ç”¨');
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/prompt/explain.prompt.ts

````typescript
export function explainPrompt(code: string, language: string) {
  return {
    system: `ä½ æ˜¯ä¸€ä½èµ„æ·± ${language} å·¥ç¨‹å¸ˆã€‚

è¯·ç”¨ã€ç®€æ´ã€ç»“æ„åŒ–ã€‘çš„æ–¹å¼è§£é‡Šä»¥ä¸‹ä»£ç ï¼š

- æ ¸å¿ƒä½œç”¨
- å…³é”®é€»è¾‘
- å¯èƒ½çš„è¾¹ç•Œæƒ…å†µ
- æ˜¯å¦å­˜åœ¨é£é™©æˆ–æ”¹è¿›ç‚¹`,
    user: `ä»£ç ï¼š
\`\`\`${language}
${code}
\`\`\``
  };
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/prompt/optimize.prompt.ts

````typescript
export function optimizePrompt(code: string, language: string) {
  return {
    system: `ä½ æ˜¯ä¸€ä½èµ„æ·± ${language} æ¶æ„å¸ˆã€‚

è¯·åœ¨ã€ä¸æ”¹å˜åŸæœ‰è¡Œä¸ºã€‘çš„å‰æä¸‹ä¼˜åŒ–ä»¥ä¸‹ä»£ç ã€‚

è¦æ±‚ï¼š
- å¯è¯»æ€§æ›´å¥½
- æ€§èƒ½æˆ–å¥å£®æ€§æå‡
- ä¿æŒè¯­ä¹‰ä¸€è‡´

è¿”å›æ ¼å¼å¿…é¡»æ˜¯ï¼š

---original
<åŸå§‹ä»£ç >

---optimized
<ä¼˜åŒ–åçš„ä»£ç >`,
    user: `ä»£ç ï¼š
\`\`\`${language}
${code}
\`\`\``
  };
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/prompt/send.prompt.ts

````typescript
export function sendPrompt(code: string, language: string) {
  return {
    system: `ä½ æ˜¯ Yuangs AI ç¼–ç¨‹åŠ©æ‰‹ã€‚`,
    user: `ä»¥ä¸‹æ˜¯ç”¨æˆ·é€‰ä¸­çš„ä»£ç ï¼Œè¯·è¿›è¡Œåˆ†ææˆ–ç­‰å¾…è¿›ä¸€æ­¥æŒ‡ä»¤ï¼š

\`\`\`${language}
${code}
\`\`\``
  };
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/utils/confirm.ts

````typescript
import * as readline from 'node:readline/promises';
import chalk from 'chalk';

export async function confirm(message: string): Promise<boolean> {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });

    try {
        const answer = await rl.question(chalk.yellow(`\nâš ï¸  ${message} (y/N) `));
        return answer.toLowerCase() === 'y';
    } finally {
        rl.close();
    }
}


````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/utils/history.ts

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import { parseCommandHistory, type HistoryEntry } from '../core/validation';

const HISTORY_FILE = path.join(os.homedir(), '.yuangs_cmd_history.json');

export type { HistoryEntry };

export function getCommandHistory(): HistoryEntry[] {
    if (fs.existsSync(HISTORY_FILE)) {
        try {
            return parseCommandHistory(fs.readFileSync(HISTORY_FILE, 'utf8'));
        } catch (e) { }
    }
    return [];
}

export function saveHistory(entry: { question: string; command: string }) {
    let history = getCommandHistory();
    const newEntry: HistoryEntry = {
        ...entry,
        time: new Date().toLocaleString()
    };
    // Keep last 1000, unique commands
    history = [newEntry, ...history.filter(item => item.command !== entry.command)].slice(0, 1000);
    fs.writeFileSync(HISTORY_FILE, JSON.stringify(history, null, 2));
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/utils/renderer.ts

````typescript
import chalk from 'chalk';
import { marked } from 'marked';
import TerminalRenderer from 'marked-terminal';
import ora, { Ora } from 'ora';

// åˆå§‹åŒ– marked é…ç½®
marked.setOptions({
    renderer: new TerminalRenderer({
        tab: 2,
        width: process.stdout.columns || 80,
        showSectionPrefix: false
    }) as any
});

export class StreamMarkdownRenderer {
    private fullResponse: string = '';
    private prefix: string;
    private isFirstOutput: boolean = true;
    private spinner: Ora | null = null;
    private startTime: number;

    constructor(prefix: string = chalk.bold.cyan('ğŸ¤– AIï¼š'), spinner?: Ora) {
        this.prefix = prefix;
        this.spinner = spinner || null;
        this.startTime = Date.now();
    }

    /**
     * å¤„ç†æµå¼æ•°æ®å—
     */
    public onChunk(chunk: string) {
        if (this.spinner && this.spinner.isSpinning) {
            this.spinner.stop();
        }

        if (this.isFirstOutput) {
            process.stdout.write(this.prefix);
            this.isFirstOutput = false;
        }

        this.fullResponse += chunk;
        process.stdout.write(chunk);
    }

    /**
     * æµç»“æŸï¼Œæ‰§è¡Œå›æ»šå¹¶æ¸²æŸ“ Markdown
     */
    public finish(): string {
        // å¦‚æœ Spinner è¿˜åœ¨è½¬ï¼ˆè¯´æ˜æ²¡æœ‰ä»»ä½•è¾“å‡ºï¼‰ï¼Œå…ˆåœæ‰
        if (this.spinner && this.spinner.isSpinning) {
            this.spinner.stop();
        }

        const formatted = (marked.parse(this.fullResponse, { async: false }) as string).trim();

        if (process.stdout.isTTY && this.fullResponse.trim()) {
            const screenWidth = process.stdout.columns || 80;
            const totalContent = this.prefix + this.fullResponse;

            // è®¡ç®—åŸå§‹æ–‡æœ¬å ç”¨çš„å¯è§†è¡Œæ•°
            const lineCount = this.getVisualLineCount(totalContent, screenWidth);

            // 1. æ¸…é™¤å½“å‰è¡Œå‰©ä½™å†…å®¹
            process.stdout.write('\r\x1b[K');
            // 2. å‘ä¸Šå›æ»šå¹¶æ¸…é™¤ä¹‹å‰çš„è¡Œ
            for (let i = 0; i < lineCount - 1; i++) {
                process.stdout.write('\x1b[A\x1b[K');
            }

            // 3. è¾“å‡ºæ ¼å¼åŒ–åçš„ Markdown
            process.stdout.write(this.prefix + formatted + '\n');
        } else {
            // é TTY æ¨¡å¼æˆ–æ— å†…å®¹ï¼Œç›´æ¥è¡¥å……æ¢è¡Œï¼ˆå¦‚æœä¹‹å‰è¾“å‡ºäº†å†…å®¹ï¼‰
            if (this.fullResponse.trim()) {
                process.stdout.write('\n');
            }
        }

        // è¾“å‡ºè€—æ—¶ç»Ÿè®¡
        const elapsed = (Date.now() - this.startTime) / 1000;
        process.stdout.write('\n' + chalk.gray(`â”€`.repeat(20) + ` (è€—æ—¶: ${elapsed.toFixed(2)}s) ` + `â”€`.repeat(20) + '\n\n'));

        return this.fullResponse;
    }

    /**
     * è®¡ç®—æ–‡æœ¬åœ¨ç»ˆç«¯çš„å¯è§†è¡Œæ•°
     */
    private getVisualLineCount(text: string, screenWidth: number): number {
        const stripAnsi = (str: string) => str.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');

        const lines = text.split('\n');
        let totalLines = 0;

        for (const line of lines) {
            // Expand tabs
            const expandedLine = line.replace(/\t/g, '        ');
            const cleanLine = stripAnsi(expandedLine);

            let lineWidth = 0;
            for (const char of cleanLine) {
                const code = char.codePointAt(0) || 0;
                // å¤§éƒ¨åˆ†å®½å­—ç¬¦ï¼ˆå¦‚ä¸­æ–‡ï¼‰å  2 æ ¼
                lineWidth += code > 255 ? 2 : 1;
            }

            if (lineWidth === 0) {
                totalLines += 1;
            } else {
                totalLines += Math.ceil(lineWidth / screenWidth);
            }
        }

        return totalLines;
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ runtime/vscode/VSCodeExecutor.ts

````typescript
import * as vscode from 'vscode';
import * as path from 'path';
import { createIgnoreFilter } from '../../vscode/utils/ignoreFilter';

export class VSCodeExecutor {
    private static ignoreFilter = createIgnoreFilter();
    // å¤„ç†æ–‡ä»¶æ¸²æŸ“/é¢„è§ˆ
    static async previewFile(filePath: string) {
        const fullPath = path.isAbsolute(filePath)
            ? filePath
            : path.join(vscode.workspace.workspaceFolders?.[0].uri.fsPath || '', filePath);
        const uri = vscode.Uri.file(fullPath);
        await vscode.commands.executeCommand('vscode.open', uri);
    }

    // æ‰§è¡Œç»ˆç«¯å‘½ä»¤
    static async runCommand(command: string): Promise<string> {
        return new Promise((resolve) => {
            const terminal = vscode.window.activeTerminal || vscode.window.createTerminal('Yuangs Agent');
            terminal.show();
            terminal.sendText(command);
            // VS Code ç»ˆç«¯ä¸å®¹æ˜“ç›´æ¥è·å–è¾“å‡ºï¼Œé€šå¸¸æˆ‘ä»¬ä¼šè¿”å›ä¸€ä¸ªçŠ¶æ€
            resolve("Command sent to VS Code terminal.");
        });
    }

    // åº”ç”¨æ–‡ä»¶ä¿®æ”¹
    static async writeFile(filePath: string, content: string): Promise<string> {
        const fullPath = this.getAbsolutePath(filePath);
        const uri = vscode.Uri.file(fullPath);
        await vscode.workspace.fs.writeFile(uri, Buffer.from(content));
        return `File saved: ${filePath}`;
    }

    // è¯»å–æ–‡ä»¶å†…å®¹
    static async readFile(filePath: string): Promise<string> {
        const fullPath = this.getAbsolutePath(filePath);
        const uri = vscode.Uri.file(fullPath);
        const content = await vscode.workspace.fs.readFile(uri);
        return Buffer.from(content).toString('utf8');
    }

    // åˆ—å‡ºç›®å½•æ–‡ä»¶
    static async listFiles(dirPath: string = '.'): Promise<string> {
        const fullPath = this.getAbsolutePath(dirPath);
        const uri = vscode.Uri.file(fullPath);
        const entries = await vscode.workspace.fs.readDirectory(uri);
        
        // Apply ignore filter if available
        let filteredEntries = entries;
        if (this.ignoreFilter) {
            const workspaceRoot = vscode.workspace.workspaceFolders?.[0].uri.fsPath;
            if (workspaceRoot) {
                filteredEntries = entries.filter(([name, type]) => {
                    const entryPath = path.join(fullPath, name);
                    return !this.ignoreFilter!.shouldIgnore(entryPath, workspaceRoot);
                });
            }
        }
        
        return filteredEntries.map(([name, type]) => `${name}${type === vscode.FileType.Directory ? '/' : ''}`).join('\n');
    }

    // è·å–ç»å¯¹è·¯å¾„è¾…åŠ©æ–¹æ³•
    private static getAbsolutePath(filePath: string): string {
        if (path.isAbsolute(filePath)) {
            return filePath;
        }
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0].uri.fsPath;
        if (!workspaceFolder) {
            throw new Error("No workspace folder open.");
        }
        return path.join(workspaceFolder, filePath);
    }

    // å¤„ç† Diff åº”ç”¨ (ä¸‰é˜¶æ®µæ‰§è¡Œï¼šPre-Exec / Exec / Post-Exec)
    static async applyDiff(diff: string): Promise<string> {
        const workspaceRoot = vscode.workspace.workspaceFolders?.[0].uri.fsPath;
        if (!workspaceRoot) {
            throw new Error("No workspace opened.");
        }

        try {
            // --- Phase 1: Pre-Exec (Snapshot/Validation) ---
            const status = await this.execCommand("git status --porcelain", workspaceRoot);
            if (status.trim().length > 0) {
                const choice = await vscode.window.showWarningMessage(
                    "Working tree is dirty. Apply diff anyway?",
                    { modal: true },
                    "Stash and Continue", "Abort"
                );
                if (choice === "Stash and Continue") {
                    await this.execCommand("git stash", workspaceRoot);
                } else {
                    throw new Error("Execution aborted due to dirty working tree.");
                }
            }

            const preHash = (await this.execCommand("git rev-parse HEAD", workspaceRoot)).trim();

            // --- Phase 2: Exec (Application) ---
            await this.execCommandWithInput("git apply --index", diff, workspaceRoot);

            // --- Phase 3: Post-Exec (Validation & Commit) ---
            const changedFiles = (await this.execCommand("git diff --name-only HEAD", workspaceRoot))
                .trim()
                .split("\n")
                .filter(f => f.length > 0);

            const commitMessage = `Agent: Applied semantic code change\n\n- Files: ${changedFiles.join(", ")}`;
            await this.execCommand(`git commit -m "${commitMessage}"`, workspaceRoot);

            const postHash = (await this.execCommand("git rev-parse HEAD", workspaceRoot)).trim();

            vscode.window.showInformationMessage(`Successfully applied change: ${postHash.substring(0, 7)}`);

            return `[SUCCESS] Applied 3-phase execution.\n- Snapshot: ${preHash.substring(0, 7)}\n- Commit: ${postHash.substring(0, 7)}\n- Files: ${changedFiles.length}`;

        } catch (error: any) {
            vscode.window.showErrorMessage(`Diff failed: ${error.message}`);
            // Rollback if possible (git reset --hard)
            return `[FAILED] ${error.message}`;
        }
    }

    private static async execCommand(command: string, cwd: string): Promise<string> {
        const { exec } = require('child_process');
        return new Promise((resolve, reject) => {
            exec(command, { cwd }, (error: any, stdout: string, stderr: string) => {
                if (error) reject(new Error(stderr || error.message));
                else resolve(stdout);
            });
        });
    }

    private static async execCommandWithInput(command: string, input: string, cwd: string): Promise<string> {
        const { exec } = require('child_process');
        return new Promise((resolve, reject) => {
            const child = exec(command, { cwd }, (error: any, stdout: string, stderr: string) => {
                if (error) reject(new Error(stderr || error.message));
                else resolve(stdout);
            });
            child.stdin.write(input);
            child.stdin.end();
        });
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ utils/git.ts

````typescript
/**
 * Git é€‚é…å™¨ - æ‰©å±•ç‰ˆæœ¬
 *
 * åŸºäº GitManager.ts çš„åŠŸèƒ½è¿›è¡Œå¢å¼º
 * ä½¿ç”¨ VS Code Git Extension API æ›¿ä»£å‘½ä»¤è¡Œ
 */

import * as vscode from 'vscode';
import { GitManager } from '../vscode/git/GitManager';
import type {
    GitCommitResult,
    GitReviewResult,
    GitReviewIssue,
    GitStatus,
    GitBranch,
    GitCommitHistory,
    DiffApplyOptions
} from '../core/types';

export class GitAdapter {
    /**
     * æäº¤æ›´æ”¹
     * 
     * @param message æäº¤æ¶ˆæ¯
     * @returns Promise<GitCommitResult> æäº¤ç»“æœ
     */
    async commit(message: string): Promise<GitCommitResult> {
        try {
            await GitManager.commit(message);
            
            return {
                success: true,
                message: 'Commit successful'
            };
        } catch (error: any) {
            console.error('[GitAdapter] Commit failed:', error);
            return {
                success: false,
                error: error.message || 'Unknown git error'
            };
        }
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/codeActions/YuangsCodeActionProvider.ts

````typescript
import * as vscode from 'vscode';

export class YuangsCodeActionProvider implements vscode.CodeActionProvider {

  static readonly providedCodeActionKinds = [
    vscode.CodeActionKind.QuickFix,
    vscode.CodeActionKind.Refactor
  ];

  provideCodeActions(
    document: vscode.TextDocument,
    range: vscode.Range,
    context: vscode.CodeActionContext,
    token: vscode.CancellationToken
  ): vscode.ProviderResult<vscode.CodeAction[]> {

    // Only show actions when text is selected
    if (range.isEmpty) return [];

    const selectedText = document.getText(range);
    if (!selectedText.trim()) return [];

    const actions: vscode.CodeAction[] = [];

    // Filter actions based on the requested kind if specified
    const only = context.only;
    const shouldIncludeQuickFix = !only || only.contains(vscode.CodeActionKind.QuickFix);
    const shouldIncludeRefactor = !only || only.contains(vscode.CodeActionKind.Refactor);

    // 1. å‘é€åˆ° Yuangs
    if (shouldIncludeQuickFix) {
      const action = this.createAction(
        'ğŸ“¤ å‘é€åˆ° Yuangsã€è‹‘å¹¿å±±ã€‘',
        'yuangs.sendSelection',
        selectedText,
        document,
        range,
        vscode.CodeActionKind.QuickFix
      );
      action.isPreferred = true; // è®¾ä¸ºé¦–é€‰ï¼Œè¿™æ ·åœ¨ç¯æ³¡é‡Œä¼šé å‰
      actions.push(action);
    }

    // 2. è§£é‡Šè¿™æ®µä»£ç 
    if (shouldIncludeQuickFix) {
      actions.push(this.createAction(
        'ğŸ§  è§£é‡Šè¿™æ®µä»£ç ã€è‹‘å¹¿å±±ã€‘',
        'yuangs.explainSelection',
        selectedText,
        document,
        range,
        vscode.CodeActionKind.QuickFix
      ));
    }

    // 3. ä¼˜åŒ–è¿™æ®µä»£ç 
    if (shouldIncludeRefactor) {
      actions.push(this.createAction(
        'âš¡ ä¼˜åŒ–è¿™æ®µä»£ç ã€è‹‘å¹¿å±±ã€‘',
        'yuangs.optimizeSelection',
        selectedText,
        document,
        range,
        vscode.CodeActionKind.Refactor
      ));
    }

    return actions;
  }

  private createAction(
    title: string,
    command: string,
    code: string,
    document: vscode.TextDocument,
    range: vscode.Range,
    kind: vscode.CodeActionKind
  ): vscode.CodeAction {
    const action = new vscode.CodeAction(title, kind);

    action.command = {
      command,
      title,
      arguments: [code, document, range]
    };

    return action;
  }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/commands/askAI.ts

````typescript
import * as vscode from 'vscode';
import { VSCodeAgentRuntime } from '../core/runtime';

/**
 * Ask AI å‘½ä»¤å¤„ç†å™¨
 * 
 * èŒè´£ï¼š
 * - æ˜¾ç¤ºè¾“å…¥æ¡†è·å–ç”¨æˆ·é—®é¢˜
 * - åˆ›å»º VSCodeAgentRuntime å®ä¾‹
 * - è°ƒç”¨ runChat æ‰§è¡Œ AI ä»»åŠ¡
 * - é€šè¿‡ Progress/Notification å±•ç¤ºç»“æœ
 * 
 * æ³¨æ„ï¼šè¿™æ˜¯ä¸€ä¸ªç‹¬ç«‹å…¥å£ï¼Œä¸ç›´æ¥æ“ä½œ ChatView
 * ChatView åº”è¯¥é€šè¿‡ä¾§è¾¹æ è®¿é—®
 */
export async function askAICommand() {
    console.log('[AskAI] Command triggered');
    
    try {
        // è·å–ç”¨æˆ·è¾“å…¥
        const userInput = await vscode.window.showInputBox({
            prompt: 'Ask Yuangs AI anything...',
            placeHolder: 'Type your question here...'
        });

        if (!userInput) {
            console.log('[AskAI] User cancelled input');
            return;
        }

        console.log('[AskAI] User input received, starting execution...');

        // åˆ›å»º VSCode Agent Runtime å®ä¾‹
        const runtime = new VSCodeAgentRuntime();

        // ä½¿ç”¨è¿›åº¦æŒ‡ç¤ºå™¨æ‰§è¡Œä»»åŠ¡
        await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: 'Yuangs AI is thinking...',
            cancellable: true
        }, async (progress, token) => {
            // ç›‘å¬å–æ¶ˆæ“ä½œ
            token.onCancellationRequested(() => {
                console.log('[AskAI] Task cancelled by user');
            });

            let fullResponse = '';

            // è¿è¡ŒAIä»»åŠ¡ï¼Œæ”¶é›†å®Œæ•´å“åº”
            await runtime.runChat(userInput, (chunk) => {
                fullResponse += chunk;
                // æ›´æ–°è¿›åº¦æ¶ˆæ¯
                progress.report({ 
                    message: `Processing: ${chunk.substring(0, 50)}${chunk.length > 50 ? '...' : ''}` 
                });
            });

            console.log('[AskAI] Task completed successfully');

            // å¯é€‰ï¼šå°†å®Œæ•´å“åº”æ˜¾ç¤ºåˆ°æ–°æ–‡æ¡£æˆ–è¾“å‡ºé¢æ¿
            // è¿™æ ·ç”¨æˆ·å¯ä»¥çœ‹åˆ°å®Œæ•´çš„ AI å›å¤
            if (fullResponse.trim()) {
                const doc = await vscode.workspace.openTextDocument({
                    content: fullResponse,
                    language: 'markdown'
                });
                await vscode.window.showTextDocument(doc, { 
                    preview: true, 
                    viewColumn: vscode.ViewColumn.Beside 
                });
            }
        });

    } catch (error) {
        console.error('[AskAI] Error:', error);
        vscode.window.showErrorMessage(`Error running AI command: ${error}`);
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/commands/optimize.ts

````typescript
import * as vscode from 'vscode';
import { YuangsPanel } from '../sidePanel/YuangsPanel';

/**
 * ä¼˜åŒ–ä»£ç å‘½ä»¤å¤„ç†
 */
export async function optimizeCode(
  document: vscode.TextDocument,
  range: vscode.Range | vscode.Selection
): Promise<void> {
  const editor = vscode.window.activeTextEditor;
  if (!editor || editor.document !== document) {
    vscode.window.showErrorMessage('Active editor does not match document');
    return;
  }

  // 1. è·å–åŸå§‹ä»£ç 
  const originalCode = document.getText(range);
  if (!originalCode) {
    return;
  }

  // 2. è°ƒç”¨ AI å¼•æ“ (æ¨¡æ‹Ÿ)
  // TODO: æ¥å…¥çœŸå®çš„ YuangsEngine
  const { optimizedCode, explanation } = await callAiOptimization(originalCode);

  // 3. ç”Ÿæˆ Markdown æ ¼å¼çš„è¾“å‡º
  const markdownContent = generateMarkdown(originalCode, optimizedCode, explanation);

  // 4. åœ¨ä¾§è¾¹æ æ˜¾ç¤º Markdown å†…å®¹
  YuangsPanel.show(markdownContent, 'Yuangs AI - ä»£ç ä¼˜åŒ–');
}

/**
 * ç”Ÿæˆ Markdown æ ¼å¼çš„è¾“å‡º
 */
function generateMarkdown(originalCode: string, optimizedCode: string, explanation: string): string {
  return `# ä»£ç ä¼˜åŒ–å»ºè®®

${explanation}

## åŸå§‹ä»£ç 

\`\`\`
${originalCode}
\`\`\`

## ä¼˜åŒ–åçš„ä»£ç 

\`\`\`
${optimizedCode}
\`\`\`

---

[åº”ç”¨ä¼˜åŒ–](yuangs.applyOptimization?args=${encodeURIComponent(JSON.stringify({
  documentUri: vscode.window.activeTextEditor?.document.uri.toString(),
  range: vscode.window.activeTextEditor?.selection,
  optimizedCode: optimizedCode
}))})
`;
}

/**
 * æ¨¡æ‹Ÿ AI è°ƒç”¨å‡½æ•°
 */
async function callAiOptimization(code: string): Promise<{ optimizedCode: string; explanation: string }> {
  // è¿™é‡Œæ˜¯ä½ è°ƒç”¨ YuangsEngine çš„åœ°æ–¹
  // const result = await YuangsEngine.optimize(code);
  
  // æ¨¡æ‹Ÿè¿”å›ä¼˜åŒ–åçš„ä»£ç å’Œè§£é‡Š
  const optimizedCode = code.replace(/const/g, 'let');
  const explanation = `### ä¼˜åŒ–è¯´æ˜

æœ¬æ¬¡ä¼˜åŒ–å¯¹ä»£ç è¿›è¡Œäº†ä»¥ä¸‹æ”¹è¿›ï¼š

1. **å˜é‡å£°æ˜ä¼˜åŒ–**ï¼šå°† \`const\` æ”¹ä¸º \`let\`ï¼Œå…è®¸å˜é‡é‡æ–°èµ‹å€¼
2. **ä»£ç å¯è¯»æ€§**ï¼šä¿æŒåŸæœ‰é€»è¾‘ä¸å˜ï¼Œä»…è°ƒæ•´å˜é‡å£°æ˜æ–¹å¼

**å»ºè®®**ï¼šå¦‚æœå˜é‡åœ¨åç»­éœ€è¦é‡æ–°èµ‹å€¼ï¼Œä½¿ç”¨ \`let\ï¼›å¦‚æœä¸éœ€è¦ï¼Œç»§ç»­ä½¿ç”¨ \`const\` æ›´å®‰å…¨ã€‚`;
  
  return { optimizedCode, explanation };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/commands/optimizeSelection.ts

````typescript
import * as vscode from 'vscode';
import { optimizePrompt } from '../../engine/prompt/optimize.prompt';
import { yuangsEngine } from '../../engine/aiClient';
import { YuangsPanel } from '../sidePanel/YuangsPanel';
import { applyDiff } from '../../engine/diff/applyDiff';

export async function optimizeSelection(code: string, document: vscode.TextDocument, range: vscode.Range) {
  try {
    const language = document.languageId;
    const prompt = optimizePrompt(code, language);

    // Show loading indicator
    vscode.window.showInformationMessage('âš¡ æ­£åœ¨ä¼˜åŒ–ä»£ç ...');

    // Send to AI engine
    const result = await yuangsEngine.send({
      messages: [
        { role: 'system', content: prompt.system },
        { role: 'user', content: prompt.user }
      ],
      stream: false
    });

    // Display result in side panel with apply option
    if (result) {
      // Parse the optimized code from AI response
      const optimizedCode = extractOptimizedCode(result);
      
      if (optimizedCode) {
        // Show diff in side panel with apply option
        const diffContent = `## ä¼˜åŒ–ç»“æœ\n\n### åŸå§‹ä»£ç :\n\`\`\`${language}\n${code}\n\`\`\`\n\n### ä¼˜åŒ–å:\n\`\`\`${language}\n${optimizedCode}\n\`\`\`\n\n[åº”ç”¨ä¼˜åŒ–](command:yuangs.applyOptimization?${encodeURIComponent(JSON.stringify({documentUri: document.uri.toString(), range, optimizedCode}))})`;
        
        YuangsPanel.show(diffContent, 'ä»£ç ä¼˜åŒ–');
      } else {
        // If couldn't parse optimized code, just show the raw result
        YuangsPanel.show(result, 'ä»£ç ä¼˜åŒ–');
      }
    }

  } catch (error) {
    console.error('Error optimizing code:', error);
    vscode.window.showErrorMessage('ä¼˜åŒ–ä»£ç æ—¶å‘ç”Ÿé”™è¯¯: ' + (error as Error).message);
  }
}

function extractOptimizedCode(aiResponse: string): string | null {
  // Look for the optimized code section in the AI response
  const optimizedMatch = aiResponse.match(/---optimized\s*\n([\s\S]*?)\n---/i);
  if (optimizedMatch && optimizedMatch[1]) {
    return optimizedMatch[1].trim();
  }
  
  // Alternative pattern: look for code blocks after "ä¼˜åŒ–å" or "optimized"
  const afterOptimized = aiResponse.split(/ä¼˜åŒ–å[:ï¼š]|optimized[:ï¼š]/i)[1];
  if (afterOptimized) {
    const codeBlockMatch = afterOptimized.match(/```(?:\w+)?\n([\s\S]*?)```/);
    if (codeBlockMatch && codeBlockMatch[1]) {
      return codeBlockMatch[1].trim();
    }
  }
  
  return null;
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/commands/sendToYuangs.ts

````typescript
import * as vscode from 'vscode';
import { sendPrompt } from '../../engine/prompt/send.prompt';
import { yuangsEngine } from '../../engine/aiClient';
import { YuangsPanel } from '../sidePanel/YuangsPanel';

export async function sendToYuangs(code: string, document: vscode.TextDocument, range: vscode.Range) {
  try {
    const language = document.languageId;
    const prompt = sendPrompt(code, language);

    // Show loading indicator
    vscode.window.showInformationMessage('ğŸ“¤ æ­£åœ¨å‘é€åˆ° Yuangs...');

    // Send to AI engine
    const result = await yuangsEngine.send({
      messages: [
        { role: 'system', content: prompt.system },
        { role: 'user', content: prompt.user }
      ],
      stream: false
    });

    // Display result in side panel
    if (result) {
      YuangsPanel.show(result, 'Yuangs åˆ†æ');
    }

  } catch (error) {
    console.error('Error sending to Yuangs:', error);
    vscode.window.showErrorMessage('å‘é€åˆ° Yuangs æ—¶å‘ç”Ÿé”™è¯¯: ' + (error as Error).message);
  }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/core/contextAdapter.ts

````typescript
import * as vscode from 'vscode';
import { ContextManager } from '../../engine/agent/contextManager';
import { ContextItem } from '../../engine/agent/contextBuffer';
import * as path from 'path';

/**
 * VS Code â†’ ContextBuffer é€‚é…å™¨
 * å°† VS Code ç¯å¢ƒä¸­çš„ä¸Šä¸‹æ–‡ä¿¡æ¯æ”¶é›†å¹¶æ³¨å…¥åˆ° ContextBuffer ä¸­
 * 
 * èŒè´£ï¼š
 * - æ”¶é›† VS Code ç¯å¢ƒä¸Šä¸‹æ–‡ï¼ˆç¼–è¾‘å™¨ã€é€‰æ‹©ã€Git diffã€è¯Šæ–­ç­‰ï¼‰
 * - å°†ä¸Šä¸‹æ–‡æ³¨å…¥åˆ° ContextManager
 * - è®¾ç½® VS Code äº‹ä»¶ç›‘å¬å™¨
 */
export class VSCodeContextAdapter {
  private contextManager: ContextManager;
  private onFileLoadedCallback?: (fileName: string) => void;

  constructor(contextManager: ContextManager, onFileLoadedCallback?: (fileName: string) => void) {
    console.log('[ContextAdapter] Initializing...');
    this.contextManager = contextManager;
    this.onFileLoadedCallback = onFileLoadedCallback;
  }

  /**
   * è®¾ç½®æ–‡ä»¶åŠ è½½å›è°ƒ
   */
  setOnFileLoadedCallback(callback: (fileName: string) => void): void {
    this.onFileLoadedCallback = callback;
  }

  /**
   * æ¸…ç†æ–‡ä»¶åŠ è½½å›è°ƒï¼ˆç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼‰
   */
  clearFileLoadedCallback(): void {
    this.onFileLoadedCallback = undefined;
    console.log('[ContextAdapter] File loaded callback cleared');
  }

  /**
   * è§£æç”¨æˆ·è¾“å…¥ä¸­çš„å¼•ç”¨ (@filename) å¹¶åŠ è½½åˆ°ä¸Šä¸‹æ–‡
   * âœ… æ”¹è¿›ç‰ˆï¼šæ·»åŠ å»é‡ã€æ€§èƒ½ä¼˜åŒ–å’Œæ›´å¥½çš„ç”¨æˆ·åé¦ˆ
   */
  async resolveUserReferences(userInput: string): Promise<void> {
    console.log(`[ContextAdapter] ğŸ” Parsing user input for @ references: "${userInput.substring(0, 100)}"`);
    
    // æ”¹è¿›æ­£åˆ™è¡¨è¾¾å¼ï¼šæ”¯æŒè·¯å¾„ä¸­çš„ç‰¹æ®Šå­—ç¬¦ï¼Œå¦‚ . / - _
    const references = userInput.match(/@[a-zA-Z0-9_\-./\\]+/g);
    
    if (!references) {
      console.log(`[ContextAdapter] âŒ No @ references found in input`);
      return;
    }

    // âœ… å»é‡ï¼šé˜²æ­¢åŒä¸€æ–‡ä»¶è¢«å¤šæ¬¡å¼•ç”¨
    const uniqueRefs = [...new Set(references)];
    
    console.log(`[ContextAdapter] âœ… Found ${references.length} references (${uniqueRefs.length} unique): ${uniqueRefs.join(', ')}`);
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) {
      vscode.window.showWarningMessage('Yuangs AI: No workspace folder open');
      return;
    }

    // âœ… è·Ÿè¸ªå·²è§£æçš„æ–‡ä»¶è·¯å¾„ï¼Œé˜²æ­¢é‡å¤åŠ è½½
    const resolvedPaths = new Set<string>();
    const loadedFiles: string[] = [];
    const failedFiles: string[] = [];

    for (const ref of uniqueRefs) {
      // ç§»é™¤ @ å‰ç¼€
      const relPath = ref.substring(1);
      console.log(`[ContextAdapter] ğŸ“„ Processing reference: "${relPath}"`);
      
      // âœ… æ€§èƒ½ä¼˜åŒ–ï¼šåªåœ¨æ–‡ä»¶åä¸å«è·¯å¾„åˆ†éš”ç¬¦æ—¶æ‰è¿›è¡Œæ¨¡ç³Šæœç´¢
      const useFuzzySearch = !relPath.includes('/') && !relPath.includes('\\');
      
      // å°è¯•æ‰¾åˆ°æ–‡ä»¶
      let fileUri: vscode.Uri | null = null;
      
      // 1. å…ˆå°è¯•ç›´æ¥è·¯å¾„åŒ¹é…
      try {
        fileUri = vscode.Uri.joinPath(workspaceFolder.uri, relPath);
        const stat = await vscode.workspace.fs.stat(fileUri);
        console.log(`[ContextAdapter] âœ… Direct path match found: ${fileUri.fsPath}`);
      } catch (directPathError) {
        console.log(`[ContextAdapter] âš ï¸ Direct path failed for "${relPath}": ${directPathError}`);
        
        // 2. åªåœ¨æ–‡ä»¶åæ—¶æ‰è¿›è¡Œæ¨¡ç³Šæœç´¢ï¼ˆé¿å…æ‰«ææ•´ä¸ª workspaceï¼‰
        if (useFuzzySearch) {
          try {
            const files = await vscode.workspace.findFiles(`**/${relPath}`, '**/node_modules/**', 5);
            if (files.length > 0) {
              fileUri = files[0];
              console.log(`[ContextAdapter] ğŸ” Fuzzy search found ${files.length} match(es) for "${relPath}", using: ${fileUri.fsPath}`);
            } else {
              console.log(`[ContextAdapter] âŒ Fuzzy search found 0 matches for "${relPath}"`);
            }
          } catch (searchError) {
            console.warn(`[ContextAdapter] âš ï¸ Fuzzy search failed for "${relPath}":`, searchError);
          }
        }
      }

      if (fileUri) {
        // âœ… å»é‡æ£€æŸ¥ï¼šé˜²æ­¢åŒä¸€æ–‡ä»¶è¢«å¤šæ¬¡åŠ è½½
        const fileFsPath = fileUri.fsPath;
        if (resolvedPaths.has(fileFsPath)) {
          console.log(`[ContextAdapter] âš ï¸ Skipping duplicate file: ${fileFsPath}`);
          continue;
        }
        resolvedPaths.add(fileFsPath);

        try {
          const document = await vscode.workspace.openTextDocument(fileUri);
          const content = document.getText();
          
          // âœ… å…³é”®ä¿®å¤ï¼šä½¿ç”¨å·¥ä½œåŒºç›¸å¯¹è·¯å¾„ä½œä¸º aliasï¼Œè€Œä¸æ˜¯ç®€å•çš„æ–‡ä»¶å
          // è¿™æ · @src/engine/aiClient.ts æ‰èƒ½æ­£ç¡®åŒ¹é…åˆ° alias
          const relativePath = vscode.workspace.asRelativePath(fileUri);
          
          await this.contextManager.addContextItemAsync({
             type: 'file',
             path: fileUri.fsPath,
             content: content,
             semantic: 'source_code',
             summary: `User referenced file: ${path.basename(fileUri.fsPath)}`,
             summarized: true,
             summaryQuality: 1.0, 
             alias: relativePath, // ç»Ÿä¸€ä½¿ç”¨ç›¸å¯¹è·¯å¾„ (ä¾‹å¦‚ "src/engine/aiClient.ts")
             tags: ['user-referenced', 'explicit'],
             importance: {
                 id: fileUri.fsPath,
                 path: fileUri.fsPath,
                 type: 'file',
                 useCount: 1,
                 successCount: 1,
                 failureCount: 0,
                 lastUsed: Date.now(),
                 createdAt: Date.now(),
                 confidence: 1.0 
             }
          });
          
          loadedFiles.push(path.basename(fileUri.fsPath));
          console.log(`[ContextAdapter] âœ… Added referenced file to context: ${fileUri.fsPath} (${content.length} chars)`);
          
          // âœ… è§¦å‘ UI å›è°ƒï¼Œé€šçŸ¥å‰ç«¯æ–‡ä»¶åŠ è½½æˆåŠŸ
          if (this.onFileLoadedCallback) {
            try {
              this.onFileLoadedCallback(path.basename(fileUri.fsPath));
            } catch (callbackError) {
              // éš”ç¦» UI å±‚å¼‚å¸¸ï¼Œé¿å…å½±å“æ ¸å¿ƒæ–‡ä»¶åŠ è½½æµç¨‹
              console.warn(`[ContextAdapter] âš ï¸ File loaded callback failed: ${callbackError}`);
            }
          }
          
        } catch (e) {
          console.warn(`[ContextAdapter] âš ï¸ Failed to read referenced file ${relPath}: ${e}`);
          failedFiles.push(relPath);
        }
      } else {
        console.warn(`[ContextAdapter] âš ï¸ Referenced file not found: ${relPath}`);
        failedFiles.push(relPath);
      }
    }

    // âœ… æ‰¹é‡åé¦ˆåŠ è½½ç»“æœï¼ˆé¿å…å¤šä¸ªå¼¹çª—æ‰“æ‰°ç”¨æˆ·ï¼‰
    if (loadedFiles.length > 0) {
      const msg = loadedFiles.length === 1 
        ? `Loaded file: ${loadedFiles[0]}`
        : `Loaded ${loadedFiles.length} files: ${loadedFiles.join(', ')}`;
      vscode.window.setStatusBarMessage(`Yuangs AI: ${msg}`, 5000);
      console.log(`[ContextAdapter] âœ… Successfully loaded: ${msg}`);
    }
    
    if (failedFiles.length > 0) {
      const errorMsg = failedFiles.length === 1
        ? `Could not load: "${failedFiles[0]}"`
        : `Could not load ${failedFiles.length} files: ${failedFiles.map(f => `"${f}"`).join(', ')}`;
      // âœ… ä½¿ç”¨é modal çš„ toastï¼Œä¸æ‰“æ–­ç”¨æˆ·è¾“å…¥æµ
      vscode.window.showWarningMessage(`Yuangs AI: ${errorMsg}`, { modal: false });
    }
  }

  /**
   * æ”¶é›†å½“å‰ VS Code ç¯å¢ƒä¸­çš„ä¸Šä¸‹æ–‡ä¿¡æ¯
   */
  async collectContext(): Promise<void> {
    console.log('[ContextAdapter] Collecting VS Code context...');
    // æ”¶é›†æ´»åŠ¨ç¼–è¾‘å™¨å†…å®¹
    await this.collectActiveEditor();
    
    // æ”¶é›†é€‰ä¸­æ–‡æœ¬
    await this.collectSelection();
    
    // æ”¶é›† Git å·®å¼‚
    await this.collectGitDiff();
    
    // æ”¶é›†å·¥ä½œåŒºè¯Šæ–­ä¿¡æ¯
    await this.collectDiagnostics();
    
    // æ”¶é›†å·¥ä½œåŒºæ–‡ä»¶ç»“æ„
    await this.collectWorkspaceStructure();
  }

  /**
   * æ”¶é›†æ´»åŠ¨ç¼–è¾‘å™¨å†…å®¹
   */
  private async collectActiveEditor(): Promise<void> {
    const editor = vscode.window.activeTextEditor;
    if (!editor) return;

    const document = editor.document;
    const content = document.getText();
    const filePath = document.uri.fsPath;

    const contextItem: Omit<ContextItem, 'tokens'> = {
      type: 'file',
      path: filePath,
      content,
      semantic: 'source_code',
      summary: `Current active file: ${path.basename(filePath)}`,
      summarized: true,
      summaryQuality: 0.8,
      alias: path.basename(filePath),
      tags: ['active', 'current'],
      projectScope: vscode.workspace.getWorkspaceFolder(document.uri)?.uri.fsPath || process.cwd(),
      // å¢åŠ  active editor çš„é‡è¦æ€§
      importance: {
          id: filePath,
          path: filePath,
          type: 'file',
          useCount: 1,
          successCount: 1,
          failureCount: 0,
          confidence: 0.9,
          lastUsed: Date.now(),
          createdAt: Date.now()
      }
    };

    try {
      await this.contextManager.addContextItem(contextItem);
      console.log(`[ContextAdapter] âœ… Added active editor: ${filePath}`);
    } catch (error) {
      console.warn(`[ContextAdapter] âš ï¸ Failed to add active editor: ${error}`);
    }
  }

  /**
   * æ”¶é›†é€‰ä¸­æ–‡æœ¬
   */
  private async collectSelection(): Promise<void> {
    const editor = vscode.window.activeTextEditor;
    if (!editor || editor.selection.isEmpty) return;

    const selection = editor.document.getText(editor.selection);
    const filePath = editor.document.uri.fsPath;
    const selectionStart = editor.selection.start.line + 1;
    const selectionEnd = editor.selection.end.line + 1;

    const contextItem: Omit<ContextItem, 'tokens'> = {
      type: 'file',
      path: filePath,
      content: selection,
      semantic: 'source_code',
      summary: `Selected code from ${path.basename(filePath)} (lines ${selectionStart}-${selectionEnd})`,
      summarized: true,
      summaryQuality: 0.9,
      alias: `selection-${path.basename(filePath)}-${selectionStart}-${selectionEnd}`,
      tags: ['selection', 'highlighted'],
      projectScope: vscode.workspace.getWorkspaceFolder(editor.document.uri)?.uri.fsPath || process.cwd(),
      // å¼ºåˆ¶ Selection ä¸ºæœ€é«˜é‡è¦æ€§
      importance: {
          id: `selection-${filePath}`,
          path: filePath,
          type: 'file',
          useCount: 1,
          successCount: 1,
          failureCount: 0,
          confidence: 1.0,
          lastUsed: Date.now(),
          createdAt: Date.now()
      }
    };

    try {
      await this.contextManager.addContextItem(contextItem);
      console.log(`[ContextAdapter] âœ… Added selection: ${filePath} (lines ${selectionStart}-${selectionEnd})`);
    } catch (error) {
      console.warn(`[ContextAdapter] âš ï¸ Failed to add selection: ${error}`);
    }
  }

  /**
   * æ”¶é›† Git å·®å¼‚
   */
  private async collectGitDiff(): Promise<void> {
    try {
      // æ£€æŸ¥æ˜¯å¦å®‰è£…äº† Git æ‰©å±•
      const gitExtension = vscode.extensions.getExtension('vscode.git');
      if (!gitExtension) {
        console.log('[ContextAdapter] âš ï¸ Git extension not found, skipping git diff');
        return;
      }

      // è·å– Git API
      const git = gitExtension.exports.getAPI(1);
      if (!git.repositories.length) {
        console.log('[ContextAdapter] âš ï¸ No Git repositories found, skipping git diff');
        return;
      }

      const repository = git.repositories[0]; // ä½¿ç”¨ç¬¬ä¸€ä¸ªä»“åº“
      const diff = await repository.diff(true); // è·å–æš‚å­˜å’Œæœªæš‚å­˜çš„æ›´æ”¹

      if (diff && diff.length > 0) {
        const contextItem: Omit<ContextItem, 'tokens'> = {
          type: 'file',
          path: `${repository.rootUri.fsPath}/git-diff`,
          content: diff,
          semantic: 'evidence',
          summary: 'Current Git diff showing changes in repository',
          summarized: true,
          summaryQuality: 0.8,
          alias: 'git-diff',
          tags: ['git', 'diff', 'changes'],
          projectScope: repository.rootUri.fsPath
        };

        try {
          await this.contextManager.addContextItem(contextItem);
          console.log(`[ContextAdapter] âœ… Added git diff: ${repository.rootUri.fsPath}`);
        } catch (error) {
          console.warn(`[ContextAdapter] âš ï¸ Failed to add git diff: ${error}`);
        }
      }
    } catch (error) {
      console.warn(`[ContextAdapter] âš ï¸ Failed to collect git diff: ${error}`);
    }
  }

  /**
   * æ”¶é›†å·¥ä½œåŒºè¯Šæ–­ä¿¡æ¯
   */
  private async collectDiagnostics(): Promise<void> {
    const activeEditor = vscode.window.activeTextEditor;
    if (!activeEditor) return;

    const documentUri = activeEditor.document.uri;
    const diagnostics = vscode.languages.getDiagnostics(documentUri);

    if (diagnostics.length > 0) {
      const diagnosticText = diagnostics.map(diag => 
        `[${diag.severity}] Line ${diag.range.start.line + 1}: ${diag.message}`
      ).join('\n');

      const contextItem: Omit<ContextItem, 'tokens'> = {
        type: 'file',
        path: `${documentUri.fsPath}.diagnostics`,
        content: diagnosticText,
        semantic: 'log',
        summary: `Diagnostics for ${path.basename(documentUri.fsPath)}`,
        summarized: true,
        summaryQuality: 0.7,
        alias: `diagnostics-${path.basename(documentUri.fsPath)}`,
        tags: ['diagnostics', 'errors', 'warnings'],
        projectScope: vscode.workspace.getWorkspaceFolder(documentUri)?.uri.fsPath || process.cwd()
      };

    try {
      await this.contextManager.addContextItem(contextItem);
      console.log(`[ContextAdapter] âœ… Added diagnostics: ${documentUri.fsPath}`);
    } catch (error) {
      console.warn(`[ContextAdapter] âš ï¸ Failed to add diagnostics: ${error}`);
    }
    }
  }

  /**
   * æ”¶é›†å·¥ä½œåŒºæ–‡ä»¶ç»“æ„
   */
  private async collectWorkspaceStructure(): Promise<void> {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders || workspaceFolders.length === 0) return;

    const rootFolder = workspaceFolders[0]; // ä½¿ç”¨ç¬¬ä¸€ä¸ªå·¥ä½œåŒºæ–‡ä»¶å¤¹
    const files = await vscode.workspace.findFiles('**/*', '**/node_modules/**', 1000); // é™åˆ¶æ•°é‡

    const structure = files
      .map(uri => {
        const relativePath = path.relative(rootFolder.uri.fsPath, uri.fsPath);
        return relativePath;
      })
      .sort()
      .join('\n');

    const contextItem: Omit<ContextItem, 'tokens'> = {
      type: 'file',
      path: `${rootFolder.uri.fsPath}/workspace-structure`,
      content: structure,
      semantic: 'documentation',
      summary: 'Project structure showing all files in the workspace',
      summarized: true,
      summaryQuality: 0.6,
      alias: 'workspace-structure',
      tags: ['structure', 'files', 'project'],
      projectScope: rootFolder.uri.fsPath
    };

    try {
      await this.contextManager.addContextItem(contextItem);
      console.log(`[ContextAdapter] âœ… Added workspace structure: ${rootFolder.uri.fsPath}`);
    } catch (error) {
      console.warn(`[ContextAdapter] âš ï¸ Failed to add workspace structure: ${error}`);
    }
  }

  /**
   * ç›‘å¬ VS Code äº‹ä»¶ä»¥åŠ¨æ€æ›´æ–°ä¸Šä¸‹æ–‡
   */
  setupEventListeners(): void {
    console.log('[ContextAdapter] Setting up event listeners...');
    
    // ç›‘å¬æ–‡æ¡£æ›´æ”¹
    vscode.workspace.onDidChangeTextDocument(async (event) => {
      // å¯ä»¥åœ¨æ­¤å¤„æ·»åŠ é€»è¾‘æ¥å¤„ç†æ–‡æ¡£æ›´æ”¹
      // ä¾‹å¦‚ï¼Œæ›´æ–°ç›¸å…³ä¸Šä¸‹æ–‡é¡¹æˆ–æ ‡è®°ä¸ºå·²æ›´æ”¹
      console.log(`[ContextAdapter] ğŸ“ Document changed: ${event.document.fileName}`);
    });

    // ç›‘å¬ç¼–è¾‘å™¨æ›´æ”¹
    vscode.window.onDidChangeActiveTextEditor(async (editor) => {
      if (editor) {
        // å½“ç¼–è¾‘å™¨æ”¹å˜æ—¶ï¼Œå¯ä»¥è€ƒè™‘é‡æ–°æ”¶é›†ä¸Šä¸‹æ–‡
        console.log(`[ContextAdapter] âœï¸ Active editor changed: ${editor.document.fileName}`);
      }
    });

    // ç›‘å¬é€‰æ‹©æ›´æ”¹
    vscode.window.onDidChangeTextEditorSelection(async (event) => {
      // å½“é€‰æ‹©æ”¹å˜æ—¶ï¼Œå¯ä»¥è€ƒè™‘é‡æ–°æ”¶é›†é€‰æ‹©ä¸Šä¸‹æ–‡
      console.log(`[ContextAdapter] âœ‚ï¸ Selection changed in: ${event.textEditor.document.fileName}`);
    });
  }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/core/executorAdapter.ts

````typescript
import * as vscode from 'vscode';
import { ProposedAction } from '../../engine/agent/state';
import { createIgnoreFilter } from '../utils/ignoreFilter';

/**
 * Agent Action â†’ VS Code API é€‚é…å™¨
 * å°† Agent æå‡ºçš„åŠ¨ä½œæ˜ å°„åˆ° VS Code API
 * 
 * èŒè´£ï¼š
 * - æ‰§è¡Œ code_diff â†’ Webview diff é¢„è§ˆ + åº”ç”¨
 * - æ‰§è¡Œ shell_cmd â†’ VS Code Terminal
 * - æ‰§è¡Œ tool_call â†’ open/read/list/search æ–‡ä»¶æ“ä½œ
 * - æ‰§è¡Œ answer â†’ ä¿¡æ¯æç¤º
 */
export class VSCodeExecutorAdapter {
  private static ignoreFilter = createIgnoreFilter();
  /**
   * æ‰§è¡Œ Agent æå‡ºçš„åŠ¨ä½œ
   */
  static async execute(action: ProposedAction) {
    console.log(`[Executor] Executing action: ${action.type}`);
    switch (action.type) {
      case 'code_diff':
        return await this.executeCodeDiff(action.payload.diff || action.payload.content);
      case 'shell_cmd':
        return await this.executeShellCommand(action.payload.command || action.payload.content);
      case 'answer':
        return await this.showMessage(action.payload.content);
      case 'tool_call':
        return await this.executeToolCall(action.payload.tool_name, action.payload.parameters);
      default:
        console.warn(`[Executor] Unknown action type: ${action.type}`);
        return await this.showMessage(`Unknown action type: ${action.type}\nContent: ${action.payload.content || JSON.stringify(action.payload)}`);
    }
  }

  /**
   * æ‰§è¡Œä»£ç å·®å¼‚
   */
  private static async executeCodeDiff(diff: string) {
    try {
      console.log('[Executor] Opening diff preview...');
      // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„diffé¢„è§ˆ
      const panel = vscode.window.createWebviewPanel(
        'diffPreview',
        'AI Generated Diff',
        vscode.ViewColumn.One,
        { enableScripts: true }
      );

      panel.webview.html = `
        <html>
          <body>
            <h3>AI Generated Diff</h3>
            <pre>${diff}</pre>
            <button onclick="applyDiff()">Apply Changes</button>
            <script>
              function applyDiff() {
                vscode.postMessage({ command: 'applyDiff', diff: \`${diff}\` });
              }
              
              const vscode = acquireVsCodeApi();
            </script>
          </body>
        </html>
      `;

      // ç›‘å¬æ¥è‡ªwebviewçš„æ¶ˆæ¯
      panel.webview.onDidReceiveMessage(async (message) => {
        if (message.command === 'applyDiff') {
          // åœ¨è¿™é‡Œåº”ç”¨diffåˆ°å½“å‰æ–‡æ¡£
          const editor = vscode.window.activeTextEditor;
          if (editor) {
            const edit = new vscode.WorkspaceEdit();
            // è¿™é‡Œéœ€è¦è§£ædiffå¹¶åº”ç”¨æ›´æ”¹
            // ç®€åŒ–ç‰ˆæœ¬ï¼šç›´æ¥æ›¿æ¢æ•´ä¸ªæ–‡æ¡£å†…å®¹
            const doc = editor.document;
            const fullRange = new vscode.Range(
              doc.positionAt(0),
              doc.positionAt(doc.getText().length)
            );
            
            edit.replace(doc.uri, fullRange, message.diff);
            await vscode.workspace.applyEdit(edit);
            await doc.save();
            
            vscode.window.showInformationMessage('Changes applied successfully!');
            panel.dispose();
          }
        }
      });

      return {
        success: true,
        output: 'Diff preview opened in new tab'
      };
    } catch (error) {
      console.error('[Executor] Failed to execute code diff:', error);
      return {
        success: false,
        output: '',
        error: `Failed to execute code diff: ${error}`
      };
    }
  }

  /**
   * æ‰§è¡ŒShellå‘½ä»¤
   */
  private static async executeShellCommand(command: string) {
    try {
      console.log(`[Executor] Executing shell command: ${command}`);
      // åˆ›å»ºä¸€ä¸ªæ–°çš„ç»ˆç«¯å¹¶æ‰§è¡Œå‘½ä»¤
      const terminal = vscode.window.createTerminal('AI Terminal');
      terminal.show();
      terminal.sendText(command);
      
      return {
        success: true,
        output: `Command sent to terminal: ${command}`
      };
    } catch (error) {
      console.error('[Executor] Failed to execute shell command:', error);
      return {
        success: false,
        output: '',
        error: `Failed to execute shell command: ${error}`
      };
    }
  }

  /**
   * æ˜¾ç¤ºæ¶ˆæ¯
   */
  private static async showMessage(content: string) {
    try {
      console.log('[Executor] Showing message to user');
      vscode.window.showInformationMessage(content.substring(0, 100) + (content.length > 100 ? '...' : ''));
      return {
        success: true,
        output: content
      };
    } catch (error) {
      console.error('[Executor] Failed to show message:', error);
      return {
        success: false,
        output: '',
        error: `Failed to show message: ${error}`
      };
    }
  }

  /**
   * æ‰§è¡Œå·¥å…·è°ƒç”¨
   */
  private static async executeToolCall(toolName: string, parameters: any) {
    try {
      console.log(`[Executor] Executing tool: ${toolName}`);
      // æ ¹æ®å·¥å…·åç§°æ‰§è¡Œç›¸åº”çš„VS Codeæ“ä½œ
      switch (toolName) {
        case 'open_file':
          return await this.openFile(parameters.path);
        case 'create_file':
          return await this.createFile(parameters.path, parameters.content);
        case 'read_file':
          return await this.readFile(parameters.path);
        case 'list_files':
          return await this.listFiles(parameters.directory);
        case 'search_in_workspace':
          return await this.searchInWorkspace(parameters.query);
        default:
          console.warn(`[Executor] Unknown tool: ${toolName}`);
          return {
            success: false,
            output: '',
            error: `Unknown tool: ${toolName}`
          };
      }
    } catch (error) {
      console.error('[Executor] Failed to execute tool call:', error);
      return {
        success: false,
        output: '',
        error: `Failed to execute tool call: ${error}`
      };
    }
  }

  /**
   * æ‰“å¼€æ–‡ä»¶
   */
  private static async openFile(filePath: string) {
    try {
      console.log(`[Executor] Opening file: ${filePath}`);
      const uri = vscode.Uri.file(filePath);
      const document = await vscode.workspace.openTextDocument(uri);
      await vscode.window.showTextDocument(document);
      
      return {
        success: true,
        output: `File opened: ${filePath}`
      };
    } catch (error) {
      console.error('[Executor] Failed to open file:', error);
      return {
        success: false,
        output: '',
        error: `Failed to open file: ${error}`
      };
    }
  }

  /**
   * åˆ›å»ºæ–‡ä»¶
   */
  private static async createFile(filePath: string, content: string) {
    try {
      console.log(`[Executor] Creating file: ${filePath}`);
      const uri = vscode.Uri.file(filePath);
      const edit = new vscode.WorkspaceEdit();
      edit.createFile(uri, { overwrite: false });
      await vscode.workspace.applyEdit(edit);
      
      // å†™å…¥å†…å®¹
      await vscode.workspace.fs.writeFile(uri, new TextEncoder().encode(content));
      
      return {
        success: true,
        output: `File created: ${filePath}`
      };
    } catch (error) {
      console.error('[Executor] Failed to create file:', error);
      return {
        success: false,
        output: '',
        error: `Failed to create file: ${error}`
      };
    }
  }

  /**
   * è¯»å–æ–‡ä»¶
   */
  private static async readFile(filePath: string) {
    try {
      console.log(`[Executor] Reading file: ${filePath}`);
      const uri = vscode.Uri.file(filePath);
      const content = new TextDecoder().decode(await vscode.workspace.fs.readFile(uri));
      
      return {
        success: true,
        output: content
      };
    } catch (error) {
      console.error('[Executor] Failed to read file:', error);
      return {
        success: false,
        output: '',
        error: `Failed to read file: ${error}`
      };
    }
  }

  /**
   * åˆ—å‡ºæ–‡ä»¶
   */
  private static async listFiles(directory?: string) {
    try {
      console.log(`[Executor] Listing files in: ${directory || 'workspace'}`);
      const folder = directory || vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
      if (!folder) {
        return {
          success: false,
          output: '',
          error: 'No workspace folder found'
        };
      }

      const uri = vscode.Uri.file(folder);
      const files = await vscode.workspace.fs.readDirectory(uri);
      const fileList = files.map(([name, type]) => 
        `${name}${type === vscode.FileType.Directory ? '/' : ''}`
      ).join('\n');
      
      return {
        success: true,
        output: fileList
      };
    } catch (error) {
      console.error('[Executor] Failed to list files:', error);
      return {
        success: false,
        output: '',
        error: `Failed to list files: ${error}`
      };
    }
  }

  /**
   * åœ¨å·¥ä½œåŒºä¸­æœç´¢
   */
  private static async searchInWorkspace(query: string) {
    try {
      console.log(`[Executor] Searching workspace for: ${query}`);
      // ä½¿ç”¨VS Codeçš„æœç´¢åŠŸèƒ½ï¼Œåº”ç”¨å¿½ç•¥è§„åˆ™
      const excludePattern = this.ignoreFilter?.getExcludePattern() || '**/node_modules/**';
      const results = await vscode.workspace.findFiles(`**/${query}**`, excludePattern, 100);
      const resultPaths = results.map(uri => uri.fsPath).join('\n');
      
      return {
        success: true,
        output: resultPaths
      };
    } catch (error) {
      console.error('[Executor] Failed to search workspace:', error);
      return {
        success: false,
        output: '',
        error: `Failed to search in workspace: ${error}`
      };
    }
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/decorations/inlineDiff.ts

````typescript
import * as vscode from 'vscode';

/**
 * Cursor é£æ ¼çš„ Inline Diff è£…é¥°å™¨
 * çº¢è‰²èƒŒæ™¯ + åˆ é™¤çº¿ï¼šè¡¨ç¤ºè¢«åˆ é™¤çš„æ—§ä»£ç 
 * ç»¿è‰²èƒŒæ™¯ï¼šè¡¨ç¤ºæ–°å¢çš„ä»£ç 
 */
export class InlineDiffRenderer {
    
    private static addedDecoration: vscode.TextEditorDecorationType | undefined;
    private static removedDecoration: vscode.TextEditorDecorationType | undefined;

    /**
     * åˆå§‹åŒ–è£…é¥°å™¨ç±»å‹
     */
    public static init(context: vscode.ExtensionContext): void {
        if (this.addedDecoration) {
            return; // å·²ç»åˆå§‹åŒ–è¿‡äº†
        }

        // åˆ›å»ºæ–°å¢ä»£ç çš„è£…é¥°å™¨ï¼ˆç»¿è‰²èƒŒæ™¯ï¼‰
        this.addedDecoration = vscode.window.createTextEditorDecorationType({
            backgroundColor: 'rgba(46, 160, 67, 0.25)', // ç»¿è‰²èƒŒæ™¯ï¼Œä½é€æ˜åº¦
            isWholeLine: true,
            after: {
                contentText: '  âŸµ AI suggestion', // è¡Œå°¾æç¤º
                color: '#00c853',
            },
        });

        // åˆ›å»ºåˆ é™¤ä»£ç çš„è£…é¥°å™¨ï¼ˆçº¢è‰²èƒŒæ™¯ + åˆ é™¤çº¿ï¼‰
        this.removedDecoration = vscode.window.createTextEditorDecorationType({
            backgroundColor: 'rgba(248, 81, 73, 0.25)', // çº¢è‰²èƒŒæ™¯ï¼Œä½é€æ˜åº¦
            textDecoration: 'line-through',
            isWholeLine: true,
        });

        // æ³¨å†Œè£…é¥°å™¨åˆ°ä¸Šä¸‹æ–‡
        context.subscriptions.push(this.addedDecoration);
        context.subscriptions.push(this.removedDecoration);
    }

    /**
     * åœ¨ç¼–è¾‘å™¨ä¸­æ˜¾ç¤º Inline Diff
     * @param editor å½“å‰æ¿€æ´»çš„æ–‡æœ¬ç¼–è¾‘å™¨
     * @param selection é€‰ä¸­çš„èŒƒå›´
     * @param original åŸå§‹ä»£ç 
     * @param optimized ä¼˜åŒ–åçš„ä»£ç 
     */
    public static show(
        editor: vscode.TextEditor,
        selection: vscode.Selection,
        original: string,
        optimized: string
    ): void {
        if (!this.addedDecoration || !this.removedDecoration) {
            console.warn('[InlineDiffRenderer] Decoration types not initialized. Call init() first.');
            return;
        }

        // è®¡ç®—è¡Œçº§å·®å¼‚ï¼ˆç®€åŒ–ç‰ˆï¼‰
        const oldLines = original.split('\n');
        const newLines = optimized.split('\n');

        const addedRanges: vscode.DecorationOptions[] = [];
        const removedRanges: vscode.DecorationOptions[] = [];

        let line = selection.start.line;

        for (let i = 0; i < Math.max(oldLines.length, newLines.length); i++) {
            const oldLine = oldLines[i];
            const newLine = newLines[i];

            if (oldLine !== newLine) {
                // å¦‚æœæ—§è¡Œå­˜åœ¨ä½†æ–°è¡Œä¸åŒ -> è§†ä¸ºåˆ é™¤
                if (oldLine && i < oldLines.length) {
                    removedRanges.push({
                        range: new vscode.Range(line + i, 0, line + i, 999), // è¦†ç›–æ•´è¡Œ
                    });
                }

                // å¦‚æœæ–°è¡Œå­˜åœ¨ä½†æ—§è¡Œä¸åŒ -> è§†ä¸ºæ–°å¢
                if (newLine && i < newLines.length) {
                    addedRanges.push({
                        range: new vscode.Range(line + i, 0, line + i, 999),
                    });
                }
            }
        }

        // åº”ç”¨è£…é¥°å™¨
        editor.setDecorations(this.removedDecoration, removedRanges);
        editor.setDecorations(this.addedDecoration, addedRanges);
    }

    /**
     * æ¸…é™¤æ‰€æœ‰è£…é¥°å™¨
     * @param editor æ–‡æœ¬ç¼–è¾‘å™¨
     */
    public static clear(editor: vscode.TextEditor): void {
        if (!this.addedDecoration || !this.removedDecoration) {
            return;
        }

        editor.setDecorations(this.removedDecoration, []);
        editor.setDecorations(this.addedDecoration, []);
    }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/extension.ts

````typescript
import * as vscode from 'vscode';
import { YuangsCodeActionProvider } from './codeActions/YuangsCodeActionProvider';
import { InlineDiffRenderer } from './decorations/inlineDiff';
import { optimizeCode } from './commands/optimize';
import { explainSelection } from './commands/explainSelection';
import { optimizeSelection } from './commands/optimizeSelection';
import { sendToYuangs } from './commands/sendToYuangs';
import { ChatViewProvider } from './provider/ChatViewProvider';

export function activate(context: vscode.ExtensionContext) {
    console.log('Yuangs AI Assistant is now active!');

    // 1. åˆå§‹åŒ– Diff æ¸²æŸ“å™¨
    InlineDiffRenderer.init(context);

    // 2. æ³¨å†Œ Code Action Provider
    const codeActionProvider = new YuangsCodeActionProvider();
    const providerDisposable = vscode.languages.registerCodeActionsProvider(
        { scheme: 'file', language: '*' },
        codeActionProvider,
        {
            providedCodeActionKinds: YuangsCodeActionProvider.providedCodeActionKinds
        }
    );
    context.subscriptions.push(providerDisposable);

    // 3. æ³¨å†Œ ChatViewProviderï¼ˆä¾§è¾¹æ èŠå¤©è§†å›¾ï¼‰
    const chatViewProvider = new ChatViewProvider(context);
    const chatViewDisposable = vscode.window.registerWebviewViewProvider(
        ChatViewProvider.viewType,
        chatViewProvider
    );
    context.subscriptions.push(chatViewDisposable);

    // 4. æ³¨å†Œå‘½ä»¤å¤„ç†å‡½æ•°
    const optimizeCommandHandler = (uri: vscode.Uri, range: vscode.Range) => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active editor');
            return;
        }

        if (!editor.document) {
            vscode.window.showErrorMessage('No active document');
            return;
        }

        if (range) {
            optimizeCode(editor.document, range);
        } else {
            // If no range (e.g., called from palette), use the current selection
            optimizeCode(editor.document, editor.selection);
        }
    };

    const selectionCommandHandler = async (
        callback: (code: string, document: vscode.TextDocument, range: vscode.Range) => Promise<void>
    ) => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active editor');
            return;
        }

        if (!editor.document) {
            vscode.window.showErrorMessage('No active document');
            return;
        }

        const code = editor.document.getText(editor.selection);
        if (!code) {
            vscode.window.showWarningMessage('è¯·å…ˆé€‰ä¸­ä»£ç ');
            return;
        }

        await callback(code, editor.document, editor.selection);
    };

    // 5. æ³¨å†Œå‘½ä»¤
    context.subscriptions.push(
        vscode.commands.registerCommand('yuangs.optimizeCode', optimizeCommandHandler),
        vscode.commands.registerCommand('yuangs.explainSelection', () => 
            selectionCommandHandler(explainSelection)
        ),
        vscode.commands.registerCommand('yuangs.optimizeSelection', () => 
            selectionCommandHandler(optimizeSelection)
        ),
        vscode.commands.registerCommand('yuangs.sendSelection', () => 
            selectionCommandHandler(sendToYuangs)
        ),
        vscode.commands.registerCommand('yuangs.askAI', async () => {
            // Ask AI å‘½ä»¤ï¼šæ‰“å¼€ä¾§è¾¹æ å¹¶èšç„¦åˆ°è¾“å…¥æ¡†
            await vscode.commands.executeCommand('workbench.view.extension.yuangs-sidebar');
        })
    );
}

export function deactivate() {}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/git/SmartStageSuggester.ts

````typescript
/**
 * Smart Stage Suggester - æ™ºèƒ½ Stage å»ºè®®
 * 
 * åŠŸèƒ½ï¼š
 * - åˆ†ææš‚å­˜åŒºçš„æ–‡ä»¶å˜æ›´
 * - æŒ‰ç…§é€»è¾‘åˆ†ç»„ï¼ˆUIã€é€»è¾‘ã€æ–‡æ¡£ã€æµ‹è¯•ç­‰ï¼‰
 * - æä¾›åˆ†ç»„å»ºè®®å’Œ Commit æ¶ˆæ¯
 * 
 * ç”¨æˆ·ä½“éªŒï¼š
 * - AI åˆ†æ 10 ä¸ªæ–‡ä»¶ï¼Œå»ºè®®åˆ† 2 æ¬¡ Commit
 * - è®© Git æäº¤è®°å½•åƒè‰ºæœ¯å“ä¸€æ ·æ•´æ´
 */

import * as vscode from 'vscode';
import { GitManager } from './GitManager';
import { DiffParser } from '../../core/diff';
import { CommitSuggestion, FileGroup } from '../../core/reviewSchema';
import { VotingFileClassifier } from '../guard/VotingFileClassifier';
import { GroupExplanation, CommitGroup } from '../guard/types';
import { PreferenceMemory, DisagreementRecord } from '../guard/preferences';

/**
 * æ–‡ä»¶ç±»å‹
 */
type FileType = 'ui' | 'logic' | 'docs' | 'test' | 'config' | 'other';

/**
 * æ–‡ä»¶åˆ†ç±»è§„åˆ™
 */
const FILE_TYPE_RULES: Record<FileType, RegExp[]> = {
  ui: [
    /\.css$/, /\.scss$/, /\.less$/,
    /\.html$/, /\.vue$/, /\.svelte$/,
    /\.(png|jpg|jpeg|gif|svg|ico)$/i,
    /components\//i, /styles\//i, /assets\//i
  ],
  logic: [
    /\.ts$/, /\.js$/,
    /\.tsx$/, /\.jsx$/,
    /\.go$/, /\.rs$/, /\.java$/, /\.cpp$/, /\.c$/,
    /src\//, /lib\//, /app\//
  ],
  docs: [
    /\.md$/, /\.txt$/,
    /docs\//i, /readme/i, /changelog/i
  ],
  test: [
    /\.test\.(ts|js)$/, /\.spec\.(ts|js)$/,
    /test\//i, /tests\//i, /__tests__\//i
  ],
  config: [
    /\.json$/, /\.yaml$/, /\.yml$/,
    /package\.json$/, /tsconfig\.json$/,
    /\.eslintrc$/, /\.prettierrc$/,
    /config\//i, /\.env/
  ],
  other: []
};

/**
 * åˆ†ç»„å»ºè®®
 */
export interface GroupingSuggestion {
  /** åˆ†ç»„åˆ—è¡¨ */
  groups: FileGroup[];

  /** åˆ†ç»„ç†ç”± */
  rationale: string;

  /** æ¯ä¸ªåˆ†ç»„çš„ Commit æ¶ˆæ¯å»ºè®® */
  commitMessages: Array<{
    /** åˆ†ç»„ ID */
    groupId: string;
    /** Commit æ¶ˆæ¯ */
    message: {
      title: string;
      body?: string;
      type?: "feat" | "fix" | "docs" | "style" | "refactor" | "test" | "chore";
    };
  }>;
}

/**
 * Smart Stage Suggester
 */
export class SmartStageSuggester {
  private static readonly CONFIDENCE_THRESHOLD_HIGH = 0.6;
  private static readonly CONFIDENCE_THRESHOLD_MEDIUM = 0.3;
  private static preferenceMemory = new PreferenceMemory();
  private static classifier = new VotingFileClassifier(SmartStageSuggester.preferenceMemory);
  /**
   * åˆ†ææš‚å­˜åŒºå¹¶ç”Ÿæˆåˆ†ç»„å»ºè®®
   */
  static async analyzeStagedFiles(): Promise<GroupingSuggestion | null> {
    // è·å–æš‚å­˜åŒº diff
    const diffText = await GitManager.getStagedDiff();
    if (!diffText) {
      return null;
    }

    // è§£æ diff
    const parseResult = DiffParser.parse(diffText);
    if (!parseResult.success) {
      console.error('[SmartStageSuggester] Failed to parse staged diff');
      return null;
    }

    // åˆ†ææ¯ä¸ªæ–‡ä»¶
    const fileGroups = this.groupFiles(parseResult.files);

    // å¦‚æœåªæœ‰ä¸€ä¸ªåˆ†ç»„ï¼Œä¸éœ€è¦åˆ†å¤šæ¬¡ commit
    if (fileGroups.length <= 1) {
      return {
        groups: fileGroups,
        rationale: 'All changes are logically related and can be committed together.',
        commitMessages: this.generateCommitMessages(fileGroups)
      };
    }

    // ç”Ÿæˆå»ºè®®
    return {
      groups: fileGroups,
      rationale: this.generateRationale(fileGroups),
      commitMessages: this.generateCommitMessages(fileGroups)
    };
  }

  /**
   * å°†æ–‡ä»¶åˆ†ç»„
   */
  private static groupFiles(files: import('../../core/diff').DiffFile[]): FileGroup[] {
    const groups = new Map<string, FileGroup>();

    // ä½¿ç”¨æ–°çš„æŠ•ç¥¨åˆ†ç±»å™¨å¯¹æ¯ä¸ªæ–‡ä»¶è¿›è¡Œåˆ†ç±»
    for (const file of files) {
      // Extract diff content from hunks to pass to classifier
      const diffContent = this.extractDiffContent(file);
      const explanation = this.classifier.classify(file.normalizedPath, diffContent);

      // æ ¹æ®ç½®ä¿¡åº¦å†³å®šå¤„ç†æ–¹å¼
      let groupId: string;
      let groupName: string;
      let fileType: FileType;

      if (explanation.confidence < this.CONFIDENCE_THRESHOLD_MEDIUM) {
        // ä½ç½®ä¿¡åº¦ï¼Œæ”¾å…¥éœ€è¦ç¡®è®¤çš„åˆ†ç»„
        groupId = 'group-needs-confirmation';
        groupName = 'Needs Confirmation';
        fileType = 'other';
      } else {
        // é«˜ç½®ä¿¡åº¦ï¼Œä½¿ç”¨é¢„æµ‹çš„ç±»åˆ«
        groupId = `group-${explanation.category}`;
        groupName = this.getGroupDisplayName(explanation.category as FileType);
        fileType = explanation.category as FileType;
      }

      // è·å–æˆ–åˆ›å»ºåˆ†ç»„
      if (!groups.has(groupId)) {
        groups.set(groupId, {
          id: groupId,
          name: groupName,
          type: fileType,
          files: [],
          stats: { added: 0, removed: 0, context: 0 },
          explanation: explanation // æ·»åŠ è§£é‡Šä¿¡æ¯
        });
      }

      const group = groups.get(groupId)!;
      group.files.push(file.normalizedPath);
      group.stats.added += file.stats.added;
      group.stats.removed += file.stats.removed;
      group.stats.context += file.stats.context;
    }

    // è¿‡æ»¤ç©ºåˆ†ç»„
    const nonEmptyGroups = Array.from(groups.values()).filter(g => g.files.length > 0);

    // å¦‚æœæœ‰å¤šä¸ªéç©ºåˆ†ç»„ï¼Œå°è¯•è¿›ä¸€æ­¥åˆå¹¶å°åˆ†ç»„
    return this.mergeSmallGroups(nonEmptyGroups);
  }

  /**
   * ä» DiffFile ä¸­æå– diff å†…å®¹
   */
  private static extractDiffContent(file: import('../../core/diff').DiffFile): string {
    const contentParts: string[] = [];

    for (const hunk of file.hunks) {
      for (const line of hunk.lines) {
        contentParts.push(line.content); // ä½¿ç”¨å†…å®¹è€ŒéåŸå§‹è¡Œï¼Œé¿å…é‡å¤ç¬¦å·
      }
    }

    return contentParts.join('\n');
  }

  /**
   * åˆ†ç±»æ–‡ä»¶ç±»å‹
   */
  private static classifyFile(filePath: string): FileType {
    for (const [type, patterns] of Object.entries(FILE_TYPE_RULES)) {
      for (const pattern of patterns) {
        if (pattern.test(filePath)) {
          return type as FileType;
        }
      }
    }
    return 'other';
  }

  /**
   * è·å–åˆ†ç»„æ˜¾ç¤ºåç§°
   */
  private static getGroupDisplayName(type: FileType | CommitGroup): string {
    const names: Record<FileType | CommitGroup, string> = {
      ui: 'UI Changes',
      logic: 'Logic Updates',
      docs: 'Documentation',
      test: 'Tests',
      config: 'Configuration',
      chore: 'Chore',
      other: 'Other Changes'
    };
    return names[type];
  }

  /**
   * åˆå¹¶å°åˆ†ç»„ï¼ˆæ–‡ä»¶æ•° < 3 çš„åˆ†ç»„ï¼‰
   */
  private static mergeSmallGroups(groups: FileGroup[]): FileGroup[] {
    const smallGroups: FileGroup[] = [];
    const largeGroups: FileGroup[] = [];

    // åˆ†ç¦»å¤§å°åˆ†ç»„
    for (const group of groups) {
      if (group.files.length < 3) {
        smallGroups.push(group);
      } else {
        largeGroups.push(group);
      }
    }

    // å¦‚æœæ²¡æœ‰å°åˆ†ç»„ï¼Œç›´æ¥è¿”å›
    if (smallGroups.length === 0) {
      return groups;
    }

    // åˆå¹¶æ‰€æœ‰å°åˆ†ç»„åˆ° "other" åˆ†ç»„
    const mergedOther: FileGroup = {
      id: 'group-other-merged',
      name: 'Miscellaneous Changes',
      type: 'other',
      files: [],
      stats: { added: 0, removed: 0, context: 0 }
    };

    for (const group of smallGroups) {
      mergedOther.files.push(...group.files);
      mergedOther.stats.added += group.stats.added;
      mergedOther.stats.removed += group.stats.removed;
      mergedOther.stats.context += group.stats.context;
    }

    return [...largeGroups, mergedOther].filter(g => g.files.length > 0);
  }

  /**
   * ç”Ÿæˆåˆ†ç»„ç†ç”±
   */
  private static generateRationale(groups: FileGroup[]): string {
    const parts: string[] = [];

    if (groups.length === 1) {
      return `All changes (${groups[0].files.length} files) are related to ${groups[0].name.toLowerCase()} and can be committed together.`;
    }

    parts.push(`I found ${groups.length} distinct change groups:`);

    for (const group of groups) {
      const changeSummary = this.getChangeSummary(group.stats);
      parts.push(`\n  â€¢ ${group.name}: ${group.files.length} files (${changeSummary})`);
    }

    parts.push('\n\nThese changes are logically independent and should be committed separately for better history organization.');

    return parts.join('');
  }

  /**
   * è·å–å˜æ›´æ‘˜è¦
   */
  private static getChangeSummary(stats: FileGroup['stats']): string {
    const parts: string[] = [];
    if (stats.added > 0) parts.push(`+${stats.added}`);
    if (stats.removed > 0) parts.push(`-${stats.removed}`);
    return parts.join(' ') || 'no changes';
  }

  /**
   * ç”Ÿæˆ Commit æ¶ˆæ¯
   */
  private static generateCommitMessages(groups: FileGroup[]): Array<{
    groupId: string;
    message: {
      title: string;
      body?: string;
      type?: "feat" | "fix" | "docs" | "style" | "refactor" | "test" | "chore";
    };
  }> {
    return groups.map(group => ({
      groupId: group.id,
      message: this.generateCommitMessageForGroup(group)
    }));
  }

  /**
   * ä¸ºå•ä¸ªåˆ†ç»„ç”Ÿæˆ Commit æ¶ˆæ¯
   */
  private static generateCommitMessageForGroup(group: FileGroup): {
    title: string;
    body?: string;
    type?: "feat" | "fix" | "docs" | "style" | "refactor" | "test" | "chore";
  } {
    const commitType = this.getCommitType(group.type);
    const fileCount = group.files.length;
    const changeSummary = this.getChangeSummary(group.stats);

    let title: string;
    let body: string | undefined;

    switch (group.type) {
      case 'ui':
        title = fileCount === 1 
          ? `Update ${this.getFileName(group.files[0])}` 
          : `Update ${group.name.toLowerCase()}`;
        body = `Updated ${fileCount} UI-related ${fileCount === 1 ? 'file' : 'files'} (${changeSummary})`;
        break;

      case 'logic':
        title = fileCount === 1
          ? `Update ${this.getFileName(group.files[0])}`
          : `Update ${group.name.toLowerCase()}`;
        body = `Updated ${fileCount} logic ${fileCount === 1 ? 'file' : 'files'} (${changeSummary})`;
        break;

      case 'docs':
        title = 'Update documentation';
        body = `Updated ${fileCount} documentation ${fileCount === 1 ? 'file' : 'files'} (${changeSummary})`;
        break;

      case 'test':
        title = 'Update tests';
        body = `Updated ${fileCount} test ${fileCount === 1 ? 'file' : 'files'} (${changeSummary})`;
        break;

      case 'config':
        title = 'Update configuration';
        body = `Updated ${fileCount} configuration ${fileCount === 1 ? 'file' : 'files'} (${changeSummary})`;
        break;

      case 'other':
        title = 'Update miscellaneous files';
        body = `Updated ${fileCount} ${fileCount === 1 ? 'file' : 'files'} (${changeSummary})`;
        break;
    }

    return { title, body, type: commitType };
  }

  /**
   * è·å– Commit ç±»å‹
   */
  private static getCommitType(fileType: FileType): "feat" | "fix" | "docs" | "style" | "refactor" | "test" | "chore" {
    const typeMap: Record<FileType, "feat" | "fix" | "docs" | "style" | "refactor" | "test" | "chore"> = {
      ui: 'feat',
      logic: 'feat',
      docs: 'docs',
      test: 'test',
      config: 'chore',
      other: 'chore'
    };
    return typeMap[fileType];
  }

  /**
   * ä»è·¯å¾„è·å–æ–‡ä»¶å
   */
  private static getFileName(filePath: string): string {
    const parts = filePath.split('/');
    return parts[parts.length - 1];
  }

  /**
   * æ˜¾ç¤ºåˆ†ç»„å»ºè®®
   */
  static async showGroupingSuggestion(suggestion: GroupingSuggestion): Promise<void> {
    const message = `
${suggestion.rationale}

Suggested commits:
${suggestion.commitMessages.map(cm => `â€¢ ${cm.message.type}: ${cm.message.title}`).join('\n')}
    `.trim();

    const result = await vscode.window.showInformationMessage(
      'Smart Stage Suggestion: Split changes into ' + suggestion.groups.length + ' commits?',
      { modal: true },
      'View Details',
      'Apply Suggestions',
      'Dismiss'
    );

    if (result === 'View Details') {
      await this.showDetailedSuggestion(suggestion);
    } else if (result === 'Apply Suggestions') {
      // TODO: å®ç°åº”ç”¨å»ºè®®çš„é€»è¾‘
      vscode.window.showInformationMessage('Apply suggestions feature coming soon!');
    }
  }

  /**
   * æ˜¾ç¤ºè¯¦ç»†å»ºè®®
   */
  private static async showDetailedSuggestion(suggestion: GroupingSuggestion): Promise<void> {
    const panel = vscode.window.createWebviewPanel(
      'smartStageSuggestion',
      'Smart Stage Suggestion',
      vscode.ViewColumn.Two,
      { enableScripts: true }
    );

    panel.webview.html = this.getWebviewContent(suggestion);

    // Handle messages from the webview
    panel.webview.onDidReceiveMessage(async (message) => {
      switch (message.command) {
        case 'correction-request':
          // Get the group that was corrected
          const group = suggestion.groups.find(g => g.id === message.groupId);
          if (group && group.explanation) {
            // Validate the new category
            const validCategories = ['ui', 'logic', 'docs', 'test', 'chore', 'other'];
            if (validCategories.includes(message.newCategory)) {
              // Record the correction
              for (const file of group.files) {
                this.recordUserCorrection(
                  message.groupId,
                  file,
                  group.explanation!.category as CommitGroup,
                  message.newCategory as CommitGroup,
                  group.explanation!.confidence
                );
              }

              // Show confirmation
              vscode.window.showInformationMessage(
                `Correction recorded: ${group.name} -> ${message.newCategory}. This will improve future suggestions.`
              );
            } else {
              vscode.window.showErrorMessage(
                `Invalid category: ${message.newCategory}. Valid categories are: ${validCategories.join(', ')}`
              );
            }
          }
          break;
      }
    }, undefined);
  }

  /**
   * ç”Ÿæˆ Webview å†…å®¹
   */
  private static getWebviewContent(suggestion: GroupingSuggestion): string {
    const groupsHtml = suggestion.groups.map(group => {
      // Add explanation if available
      let explanationHtml = '';
      if (group.explanation) {
        const confidencePercentage = Math.round(group.explanation.confidence * 100);
        explanationHtml = `
          <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 3px; border-left: 3px solid #007acc;">
            <strong>Classification:</strong> ${group.explanation.category} (${confidencePercentage}% confidence)<br/>
            <strong>Reasons:</strong> ${group.explanation.reasons.join(', ')}<br/>
            <button onclick="requestCorrection('${group.id}', '${group.name}')" style="margin-top: 5px; padding: 5px 10px; background: #ff6b6b; color: white; border: none; border-radius: 3px; cursor: pointer;">Wrong? Correct it</button>
          </div>
        `;
      }

      return `
        <div class="group" style="margin: 10px 0; padding: 15px; border: 1px solid #ddd; border-radius: 4px;" id="group-${group.id}">
          <h3 style="margin: 0 0 10px 0; color: #333;">${group.name} (${group.files.length} files)</h3>
          <p style="margin: 0 0 10px 0; color: #666;">${this.getChangeSummary(group.stats)}</p>
          <ul style="margin: 0; padding-left: 20px;">
            ${group.files.map(file => `<li style="margin: 2px 0;">${file}</li>`).join('')}
          </ul>
          <div style="margin-top: 10px; padding: 10px; background: #f5f5f5; border-radius: 3px;">
            <strong>Suggested commit:</strong><br/>
            <code>${suggestion.commitMessages.find(cm => cm.groupId === group.id)?.message.title}</code>
          </div>
          ${explanationHtml}
        </div>
      `;
    }).join('');

    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Smart Stage Suggestion</title>
      </head>
      <body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 20px;">
        <h1 style="color: #333; border-bottom: 2px solid #007acc; padding-bottom: 10px;">Smart Stage Suggestion</h1>

        <div style="background: #f9f9f9; padding: 15px; border-radius: 4px; margin: 20px 0;">
          <h2 style="margin: 0 0 10px 0; color: #333;">Rationale</h2>
          <p style="margin: 0; color: #666; white-space: pre-wrap;">${suggestion.rationale}</p>
        </div>

        <h2 style="color: #333; border-bottom: 1px solid #ddd; padding-bottom: 5px;">Grouped Changes</h2>
        ${groupsHtml}

        <div style="margin-top: 20px; padding: 15px; background: #e7f3ff; border-radius: 4px; border-left: 4px solid #007acc;">
          <strong>Tip:</strong> You can apply these commits one by one using the Git Source Control panel.
        </div>

        <script>
          function requestCorrection(groupId, currentGroupName) {
            const newCategory = prompt('What category should this group belong to? (ui, logic, docs, test, chore, other)');
            if (newCategory) {
              // Send message back to extension
              const message = {
                command: 'correction-request',
                groupId: groupId,
                newCategory: newCategory
              };
              vscode.postMessage(message);
            }
          }

          // Handle messages from the extension
          window.addEventListener('message', event => {
            const message = event.data;
            switch (message.command) {
              case 'update-group':
                document.getElementById('group-' + message.groupId).innerHTML = message.updatedHtml;
                break;
            }
          });
        </script>
      </body>
      </html>
    `;
  }

  /**
   * è®°å½•ç”¨æˆ·å¯¹åˆ†ç±»çš„çº æ­£
   */
  static recordUserCorrection(groupId: string, file: string, predictedCategory: CommitGroup, userSelectedCategory: CommitGroup, confidence: number): void {
    const record: DisagreementRecord = {
      file,
      predicted: predictedCategory,
      confidence,
      userChoice: userSelectedCategory as CommitGroup,
      timestamp: Date.now()
    };

    this.preferenceMemory.recordDisagreement(record);
  }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/guard/ProactiveGuard.ts

````typescript
/**
 * Proactive Guard - ä¸»åŠ¨é˜²å¾¡æ¨¡å—
 * 
 * åœ¨æ–‡ä»¶ä¿å­˜æ—¶è‡ªåŠ¨è¿›è¡Œå®‰å…¨æ‰«æï¼Œæä¾›å®æ—¶é˜²æŠ¤
 */

import * as vscode from 'vscode';
import { getQuickSecurityScanner, QuickSecurityScanner } from '../../core/quickSecurityScanner';
import { ScanConfig, DEFAULT_SCAN_CONFIG, SecurityIssue, toDiagnosticSeverity } from '../../core/securityTypes';
import { DiffSourceFactory } from '../../core/diffSource';

/**
 * Proactive Guard é…ç½®
 */
interface ProactiveGuardConfig extends ScanConfig {
  /** æ˜¯å¦å¯ç”¨ Modal å¼¹çª—ï¼ˆç”¨äº Critical é”™è¯¯ï¼‰ */
  enableModalForCritical: boolean;
  
  /** æ˜¯å¦åœ¨çŠ¶æ€æ æ˜¾ç¤ºæ‰«æçŠ¶æ€ */
  showStatusInStatusBar: boolean;
}

/**
 * Proactive Guard çŠ¶æ€
 */
interface GuardState {
  /** æ‰«æè¿›è¡Œä¸­çš„æ–‡ä»¶ */
  scanningFiles: Set<string>;
  
  /** ä¸Šæ¬¡æ‰«æç»“æœ */
  lastScanResults: Map<string, SecurityIssue[]>;
  
  /** å®šæ—¶å™¨æ˜ å°„ï¼ˆç”¨äºé˜²æŠ–ï¼‰ */
  timers: Map<string, NodeJS.Timeout>;
  
  /** æ˜¯å¦æ­£åœ¨æ˜¾ç¤º Modal å¼¹çª—ï¼ˆäº’æ–¥é”ï¼‰ */
  isShowingModal: boolean;
}

/**
 * Proactive Guard
 * 
 * æ ¸å¿ƒåŠŸèƒ½ï¼š
 * 1. ç›‘å¬æ–‡ä»¶ä¿å­˜äº‹ä»¶
 * 2. é˜²æŠ–å¤„ç†ï¼ˆé¿å…é«˜é¢‘ä¿å­˜å¯¼è‡´çš„æ€§èƒ½é—®é¢˜ï¼‰
 * 3. å¿«é€Ÿå®‰å…¨æ‰«æï¼ˆ< 50msï¼‰
 * 4. æ ¹æ®ä¸¥é‡ç¨‹åº¦æ˜¾ç¤ºä¸åŒæç¤º
 * 5. è‡ªåŠ¨æ›´æ–°è¯Šæ–­ä¿¡æ¯
 */
export class ProactiveGuard {
  private static instance: ProactiveGuard;
  private scanner: QuickSecurityScanner;
  private config: ProactiveGuardConfig;
  private state: GuardState;
  private diagnosticCollection: vscode.DiagnosticCollection;
  private statusBarItem: vscode.StatusBarItem | null = null;

  private constructor() {
    this.scanner = getQuickSecurityScanner();
    this.config = {
      ...DEFAULT_SCAN_CONFIG,
      enableModalForCritical: true,
      showStatusInStatusBar: true
    };
    this.state = {
      scanningFiles: new Set(),
      lastScanResults: new Map(),
      timers: new Map(),
      isShowingModal: false
    };
    this.diagnosticCollection = vscode.languages.createDiagnosticCollection('vsyuangs-proactive');
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  static getInstance(): ProactiveGuard {
    if (!ProactiveGuard.instance) {
      ProactiveGuard.instance = new ProactiveGuard();
    }
    return ProactiveGuard.instance;
  }

  /**
   * åˆå§‹åŒ–ï¼ˆåœ¨ activate ä¸­è°ƒç”¨ï¼‰
   */
  initialize(context: vscode.ExtensionContext): void {
    // 1. ç›‘å¬æ–‡ä»¶ä¿å­˜äº‹ä»¶
    context.subscriptions.push(
      vscode.workspace.onDidSaveTextDocument(doc => this.onDocumentSave(doc))
    );

    // 2. ç›‘å¬æ–‡æ¡£å…³é—­äº‹ä»¶ï¼Œæ¸…ç†å®šæ—¶å™¨å’Œè¯Šæ–­
    context.subscriptions.push(
      vscode.workspace.onDidCloseTextDocument(doc => this.onDocumentClose(doc))
    );

    // 3. æ³¨å†Œé…ç½®å˜æ›´ç›‘å¬
    context.subscriptions.push(
      vscode.workspace.onDidChangeConfiguration(e => {
        if (e.affectsConfiguration('vsyuangs.proactiveScan')) {
          this.updateConfig();
        }
      })
    );

    // 4. åˆ›å»ºçŠ¶æ€æ é¡¹ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if (this.config.showStatusInStatusBar) {
      this.statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
      this.statusBarItem.command = 'vsyuangs.showScanStats';
      this.statusBarItem.show();
      context.subscriptions.push(this.statusBarItem);
    }

    // 5. æ³¨å†Œå‘½ä»¤
    this.registerCommands(context);

    console.log('[ProactiveGuard] Initialized');
  }

  /**
   * æ–‡æ¡£ä¿å­˜äº‹ä»¶å¤„ç†
   */
  private onDocumentSave(doc: vscode.TextDocument): void {
    // æ£€æŸ¥æ˜¯å¦å¯ç”¨
    if (!this.config.enabled) return;

    // æ£€æŸ¥è¯­è¨€ç™½åå•
    if (this.config.languageWhitelist.length > 0) {
      if (!this.config.languageWhitelist.includes(doc.languageId)) {
        return;
      }
    }

    // æ£€æŸ¥æ–‡ä»¶å¤§å°
    const fileSize = doc.getText().length;
    if (fileSize < this.config.minFileSize || fileSize > this.config.maxFileSize) {
      return;
    }

    // é˜²æŠ–å¤„ç†
    const uri = doc.uri.toString();
    const existingTimer = this.state.timers.get(uri);
    
    if (existingTimer) {
      clearTimeout(existingTimer);
    }

    const timer = setTimeout(() => {
      this.performScan(doc);
      this.state.timers.delete(uri);
    }, this.config.delay);

    this.state.timers.set(uri, timer);
  }

  /**
   * æ‰§è¡Œæ‰«æ
   * 
   * æ³¨æ„ï¼šè™½ç„¶å®ç°äº† DiffSourceFactoryï¼Œä½† ProactiveGuard æ•…æ„é€‰æ‹©å…¨é‡æ‰«æ
   * åŸå› ï¼šå®‰å…¨æ‰«æï¼ˆSecrets/Evalï¼‰éœ€è¦æ£€æŸ¥å­˜é‡ä»£ç ï¼Œä¸èƒ½åªçœ‹å¢é‡
   * 
   * æœªæ¥ä¼˜åŒ–ï¼š
   * - å¯ä»¥åœ¨é…ç½®ä¸­å¢åŠ  "scanOnlyDiff" é€‰é¡¹
   * - å¢é‡ Code Review åŠŸèƒ½å¯ä»¥å¤ç”¨ DiffSource
   */
  private async performScan(doc: vscode.TextDocument): Promise<void> {
    const uri = doc.uri.toString();
    
    // é˜²æ­¢é‡å¤æ‰«æ
    if (this.state.scanningFiles.has(uri)) {
      return;
    }

    try {
      this.state.scanningFiles.add(uri);
      this.updateStatusBar('æ‰«æä¸­...');

      // ä½¿ç”¨ DiffSourceFactory è·å–ä»£ç ï¼ˆä¿æŒ API ä¸€è‡´æ€§ï¼‰
      // æ³¨æ„ï¼šç›®å‰å…¨é‡æ‰«ææ‰€æœ‰å†…å®¹ï¼Œå› ä¸ºå®‰å…¨æ£€æŸ¥éœ€è¦æ£€æŸ¥å­˜é‡ä»£ç 
      const diffResult = await DiffSourceFactory.tryGetDiff(doc);
      const code = diffResult ? doc.getText() : doc.getText(); // å¦‚æœè·å–å¤±è´¥ï¼Œé™çº§åˆ°å…¨é‡
      
      // ä¼ é€’ document å‚æ•°ä»¥ä½¿ç”¨ VS Code API ç²¾ç¡®è®¡ç®—è¡Œåˆ—å·ï¼ˆå…¼å®¹ CRLF/LFï¼‰
      const result = await this.scanner.quickScan(code, doc.fileName, doc);

      // ä¿å­˜ç»“æœ
      this.state.lastScanResults.set(uri, result.issues);

      // æ›´æ–°è¯Šæ–­ä¿¡æ¯
      this.updateDiagnostics(doc.uri, result.issues);

      // å¤„ç† Critical é”™è¯¯
      if (result.hasCriticalError && this.config.enableModalForCritical) {
        this.handleCriticalError(doc, result.issues);
      }

      // æ›´æ–°çŠ¶æ€æ 
      const issueCount = result.issues.filter(i => i.severity !== 'INFO').length;
      this.updateStatusBar(issueCount > 0 ? `å‘ç° ${issueCount} ä¸ªé—®é¢˜` : 'æ‰«æå®Œæˆ', issueCount > 0);

      console.log(`[ProactiveGuard] Scan completed for ${doc.fileName}: ${result.duration}ms, ${result.issues.length} issues`);
    } catch (error) {
      console.error(`[ProactiveGuard] Scan failed for ${doc.fileName}:`, error);
      this.updateStatusBar('æ‰«æå¤±è´¥');
    } finally {
      this.state.scanningFiles.delete(uri);
    }
  }

  /**
   * æ›´æ–°è¯Šæ–­ä¿¡æ¯
   */
  private updateDiagnostics(uri: vscode.Uri, issues: SecurityIssue[]): void {
    const diagnostics: vscode.Diagnostic[] = [];

    for (const issue of issues) {
      if (issue.line === undefined) continue;

      const range = new vscode.Range(
        new vscode.Position(issue.line, issue.column || 0),
        new vscode.Position(issue.line, (issue.column || 0) + 50)
      );

      const diagnostic = new vscode.Diagnostic(
        range,
        `[${issue.type}] ${issue.message}${issue.suggestion ? `\nå»ºè®®: ${issue.suggestion}` : ''}`,
        toDiagnosticSeverity(issue.severity)
      );

      diagnostic.source = 'vsyuangs-proactive';
      diagnostic.code = issue.ruleId;
      // ä½¿ç”¨ diagnostic.data å­˜å‚¨å…ƒæ•°æ®ï¼ˆVS Code å®˜æ–¹æ¨èï¼‰
      (diagnostic as any).data = {
        ruleId: issue.ruleId,
        issueType: issue.type,
        severity: issue.severity,
        suggestion: issue.suggestion
      };
      diagnostics.push(diagnostic);
    }

    this.diagnosticCollection.set(uri, diagnostics.length > 0 ? diagnostics : undefined);
  }

  /**
   * å¤„ç† Critical é”™è¯¯
   * 
   * é˜²æ­¢ Modal Spamï¼ˆå¼¹çª—è½°ç‚¸ï¼‰ï¼š
   * å¦‚æœå·²æœ‰å¼¹çª—åœ¨æ˜¾ç¤ºï¼Œé™çº§ä¸ºæ™®é€šæ¶ˆæ¯æˆ–çŠ¶æ€æ æç¤º
   */
  private async handleCriticalError(doc: vscode.TextDocument, issues: SecurityIssue[]): Promise<void> {
    const criticalIssues = issues.filter(i => i.severity === 'CRITICAL');

    // äº’æ–¥é”ï¼šå¦‚æœå·²æœ‰å¼¹çª—åœ¨æ˜¾ç¤ºï¼Œé™çº§ä¸ºçŠ¶æ€æ æç¤º
    if (this.state.isShowingModal) {
      this.updateStatusBar(`ğŸš¨ ${doc.fileName} æ£€æµ‹åˆ° ${criticalIssues.length} ä¸ªé«˜å±é£é™©`, true);
      return;
    }

    // è®¾ç½®äº’æ–¥é”
    this.state.isShowingModal = true;

    try {
      const selection = await vscode.window.showErrorMessage(
        `ğŸš¨ vsyuangs æ£€æµ‹åˆ° ${criticalIssues.length} ä¸ªé«˜å±å®‰å…¨é£é™©ï¼`,
        { modal: true },
        'æŸ¥çœ‹è¯¦æƒ…',
        'å¿½ç•¥è­¦å‘Š'
      );

      if (selection === 'æŸ¥çœ‹è¯¦æƒ…') {
        // è·³è½¬åˆ°ç¬¬ä¸€ä¸ªé—®é¢˜
        const firstIssue = criticalIssues[0];
        if (firstIssue.line !== undefined) {
          const editor = vscode.window.activeTextEditor;
          if (editor && editor.document.uri.toString() === doc.uri.toString()) {
            const range = new vscode.Range(firstIssue.line, 0, firstIssue.line, 0);
            editor.revealRange(range, vscode.TextEditorRevealType.InCenter);
          }
        }
      }
    } finally {
      // é‡Šæ”¾äº’æ–¥é”
      this.state.isShowingModal = false;
    }
  }

  /**
   * æ–‡æ¡£å…³é—­äº‹ä»¶å¤„ç†
   */
  private onDocumentClose(doc: vscode.TextDocument): void {
    const uri = doc.uri.toString();

    // æ¸…ç†å®šæ—¶å™¨
    const timer = this.state.timers.get(uri);
    if (timer) {
      clearTimeout(timer);
      this.state.timers.delete(uri);
    }

    // æ¸…ç†æ‰«æç»“æœ
    this.state.lastScanResults.delete(uri);

    // æ¸…ç†è¯Šæ–­ä¿¡æ¯
    this.diagnosticCollection.delete(doc.uri);
  }

  /**
   * æ›´æ–°çŠ¶æ€æ 
   */
  private updateStatusBar(text: string, isError: boolean = false): void {
    if (this.statusBarItem) {
      this.statusBarItem.text = `$(shield) ${text}`;
      this.statusBarItem.color = isError ? new vscode.ThemeColor('errorForeground') : undefined;
    }
  }

  /**
   * æ›´æ–°é…ç½®
   */
  private updateConfig(): void {
    const config = vscode.workspace.getConfiguration('vsyuangs.proactiveScan');

    this.config.enabled = config.get('enabled', true);
    this.config.delay = config.get('delay', 500);
    this.config.languageWhitelist = config.get('languageWhitelist', []);
    this.config.minFileSize = config.get('minFileSize', 100);
    this.config.maxFileSize = config.get('maxFileSize', 1024 * 1024);
    this.config.enableModalForCritical = config.get('enableModalForCritical', true);
  }

  /**
   * æ³¨å†Œå‘½ä»¤
   */
  private registerCommands(context: vscode.ExtensionContext): void {
    // æ˜¾ç¤ºæ‰«æç»Ÿè®¡
    context.subscriptions.push(
      vscode.commands.registerCommand('vsyuangs.showScanStats', () => {
        const stats = this.scanner.getPerformanceStats();
        const message = `
æ‰«æç»Ÿè®¡:
- æ€»æ‰«ææ¬¡æ•°: ${stats.totalScans}
- å¹³å‡è€—æ—¶: ${stats.averageDuration.toFixed(2)}ms
- æœ€å¤§è€—æ—¶: ${stats.maxDuration}ms
- å¹³å‡å‘ç°çš„é—®é¢˜: ${stats.averageIssuesFound.toFixed(2)}
        `.trim();
        
        vscode.window.showInformationMessage(message);
      })
    );

    // æ¸…ç©ºæ‰«æå†å²
    context.subscriptions.push(
      vscode.commands.registerCommand('vsyuangs.clearScanHistory', () => {
        this.scanner.clearPerformanceHistory();
        vscode.window.showInformationMessage('æ‰«æå†å²å·²æ¸…ç©º');
      })
    );

    // æ‰‹åŠ¨è§¦å‘æ‰«æ
    context.subscriptions.push(
      vscode.commands.registerCommand('vsyuangs.triggerManualScan', async () => {
        const editor = vscode.window.activeTextEditor;
        if (editor) {
          await this.performScan(editor.document);
        }
      })
    );
  }

  /**
   * è·å–å½“å‰é…ç½®
   */
  getConfig(): Readonly<ProactiveGuardConfig> {
    return { ...this.config };
  }

  /**
   * è·å–æ‰«ææ€§èƒ½ç»Ÿè®¡
   */
  getPerformanceStats() {
    return this.scanner.getPerformanceStats();
  }

  /**
   * æ¸…ç†èµ„æº
   */
  dispose(): void {
    this.diagnosticCollection.dispose();
    if (this.statusBarItem) {
      this.statusBarItem.dispose();
    }
    
    // æ¸…ç†æ‰€æœ‰å®šæ—¶å™¨
    for (const timer of this.state.timers.values()) {
      clearTimeout(timer);
    }
    this.state.timers.clear();
  }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/guard/VotingFileClassifier.ts

````typescript
import { Vote, CommitGroup, GroupExplanation } from './types';
import { PreferenceMemory } from './preferences';

export class VotingFileClassifier {
  constructor(private preferenceMemory: PreferenceMemory) {}

  classify(filePath: string, diff: string): GroupExplanation {
    const rawVotes: Vote[] = [];

    this.collectPathVotes(filePath, rawVotes);
    this.collectDiffVotes(diff, rawVotes);
    this.collectKeywordVotes(diff, rawVotes);

    // Apply preference adjustments to votes
    const adjustedVotes = rawVotes.map(vote =>
      this.applyPreferenceWeight(vote, filePath)
    );

    return this.aggregate(adjustedVotes);
  }

  private applyPreferenceWeight(vote: Vote, filePath: string): Vote {
    const multiplier = this.preferenceMemory.getWeightMultiplier(
      vote.source,
      vote.category
    );

    return {
      ...vote,
      weight: vote.weight * multiplier
    };
  }

  private aggregate(votes: Vote[]): GroupExplanation {
    const scores = new Map<CommitGroup, number>();

    for (const v of votes) {
      scores.set(v.category, (scores.get(v.category) ?? 0) + v.weight);
    }

    if (scores.size === 0) {
      return {
        category: 'other',
        confidence: 0,
        reasons: ['No classification signals detected'],
        votes
      };
    }

    const sorted = [...scores.entries()].sort((a, b) => b[1] - a[1]);
    const [top, second] = sorted;

    const total = [...scores.values()].reduce((a, b) => a + b, 0) || 1;
    const confidence =
      second ? (top[1] - second[1]) / total : top[1] / total;

    if (confidence < 0.3) {
      return {
        category: 'other',
        confidence,
        reasons: ['Low confidence, human confirmation required'],
        votes
      };
    }

    return {
      category: top[0],
      confidence,
      reasons: votes
        .filter(v => v.category === top[0])
        .map(v => v.reason),
      votes
    };
  }

  private collectPathVotes(path: string, votes: Vote[]) {
    if (path.includes('/ui/') || path.endsWith('.css') || path.endsWith('.scss') || path.endsWith('.jsx') || path.endsWith('.tsx')) {
      votes.push({
        category: 'ui',
        weight: 0.4,
        reason: 'UI-related file path',
        source: 'path'
      });
    }

    if (path.includes('/test/') || path.includes('__tests__/') || path.endsWith('.spec.ts') || path.endsWith('.test.ts') || path.endsWith('.spec.js') || path.endsWith('.test.js')) {
      votes.push({
        category: 'test',
        weight: 0.5,
        reason: 'Test file path',
        source: 'path'
      });
    }

    if (path.endsWith('.md') || path.endsWith('.txt') || path.includes('/docs/')) {
      votes.push({
        category: 'docs',
        weight: 0.6,
        reason: 'Documentation file',
        source: 'path'
      });
    }

    if (path.includes('/config/') || path.includes('.config.') || path.endsWith('.json') || path.endsWith('.yaml') || path.endsWith('.yml')) {
      votes.push({
        category: 'chore',
        weight: 0.2,
        reason: 'Configuration file',
        source: 'path'
      });
    }
  }

  private collectDiffVotes(diff: string, votes: Vote[]) {
    if (diff.match(/<[^>]+>/) || diff.includes('className=') || diff.includes('style=')) {
      votes.push({
        category: 'ui',
        weight: 0.3,
        reason: 'JSX / HTML diff detected',
        source: 'diff'
      });
    }

    if (diff.includes('describe(') || diff.includes('it(') || diff.includes('test(') || diff.includes('expect(')) {
      votes.push({
        category: 'test',
        weight: 0.4,
        reason: 'Test framework syntax detected',
        source: 'diff'
      });
    }

    if (diff.includes('console.log') || diff.includes('debugger') || diff.includes('// TODO') || diff.includes('// FIXME')) {
      votes.push({
        category: 'chore',
        weight: 0.1,
        reason: 'Debugging code detected',
        source: 'diff'
      });
    }
  }

  private collectKeywordVotes(diff: string, votes: Vote[]) {
    if (diff.toLowerCase().includes('readme') || diff.toLowerCase().includes('documentation') || diff.toLowerCase().includes('doc:')) {
      votes.push({
        category: 'docs',
        weight: 0.3,
        reason: 'Documentation keywords detected',
        source: 'keyword'
      });
    }

    if (diff.toLowerCase().includes('refactor') || diff.toLowerCase().includes('cleanup') || diff.toLowerCase().includes('perf:')) {
      votes.push({
        category: 'chore',
        weight: 0.2,
        reason: 'Chore-related keywords detected',
        source: 'keyword'
      });
    }

    if (diff.toLowerCase().includes('fix:') || diff.toLowerCase().includes('bug') || diff.toLowerCase().includes('error')) {
      votes.push({
        category: 'logic',
        weight: 0.3,
        reason: 'Bug fix keywords detected',
        source: 'keyword'
      });
    }
  }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/guard/explanationProtocol.ts

````typescript
/**
 * Smart Stage Explainability Protocol
 * 
 * Defines how classification explanations are formatted for UI/Chat display
 */

import { GroupExplanation } from '../guard/types';

export interface ExplanationDisplayData {
  category: string;
  confidence: number;
  confidencePercentage: string;
  confidenceLabel: 'High' | 'Medium' | 'Low';
  reasons: string[];
  behavior: 'auto' | 'suggest' | 'needs-confirmation';
  displayReasons: DisplayReason[];
}

export interface DisplayReason {
  text: string;
  source: string;
  weight: number;
}

/**
 * Format explanation for UI display
 */
export function formatExplanationForDisplay(explanation: GroupExplanation): ExplanationDisplayData {
  const confidencePercentage = `${Math.round(explanation.confidence * 100)}%`;
  let confidenceLabel: 'High' | 'Medium' | 'Low' = 'Low';
  let behavior: 'auto' | 'suggest' | 'needs-confirmation' = 'needs-confirmation';
  
  if (explanation.confidence >= 0.6) {
    confidenceLabel = 'High';
    behavior = 'auto';
  } else if (explanation.confidence >= 0.3) {
    confidenceLabel = 'Medium';
    behavior = 'suggest';
  } else {
    confidenceLabel = 'Low';
    behavior = 'needs-confirmation';
  }
  
  const displayReasons = explanation.votes.map(vote => ({
    text: vote.reason,
    source: vote.source,
    weight: vote.weight
  }));
  
  return {
    category: explanation.category,
    confidence: explanation.confidence,
    confidencePercentage,
    confidenceLabel,
    reasons: explanation.reasons,
    behavior,
    displayReasons
  };
}

/**
 * Generate display text for explanation
 */
export function generateExplanationDisplayText(explanation: GroupExplanation): string {
  const displayData = formatExplanationForDisplay(explanation);
  
  const parts = [
    `**${displayData.category.charAt(0).toUpperCase() + displayData.category.slice(1)}** (${displayData.confidencePercentage} confidence)`
  ];
  
  if (displayData.reasons.length > 0) {
    parts.push('');
    parts.push('â€¢ ' + displayData.reasons.join('\nâ€¢ '));
  }
  
  parts.push('');
  switch (displayData.behavior) {
    case 'auto':
      parts.push('âœ… Auto-grouped');
      break;
    case 'suggest':
      parts.push('ğŸ’¡ Suggested for this group');
      break;
    case 'needs-confirmation':
      parts.push('âŒ Needs confirmation');
      break;
  }
  
  return parts.join('\n');
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/guard/preferences.ts

````typescript
import { CommitGroup } from './types';

export interface DisagreementRecord {
  file: string;
  predicted: CommitGroup;
  confidence: number;
  userChoice: CommitGroup;
  timestamp: number;
}

export interface WeightAdjustment {
  source: string;
  category: CommitGroup;
  adjustment: number;
  timestamp: number;
}

export class PreferenceMemory {
  private disagreementLog: DisagreementRecord[] = [];
  private weightAdjustments: WeightAdjustment[] = [];
  
  recordDisagreement(record: DisagreementRecord): void {
    this.disagreementLog.push(record);
    
    // Adjust weights based on disagreement
    const confidenceFactor = Math.abs(record.confidence - 0.5) * 2; // Higher penalty for confident wrong predictions
    const adjustment = -0.1 * confidenceFactor;
    
    this.weightAdjustments.push({
      source: 'disagreement-correction',
      category: record.predicted,
      adjustment,
      timestamp: record.timestamp
    });
  }
  
  getWeightMultiplier(source: string, category: CommitGroup): number {
    // Get recent adjustments for this source-category combination
    const recentAdjustments = this.weightAdjustments
      .filter(adj => adj.source === source && adj.category === category)
      .filter(adj => Date.now() - adj.timestamp < 7 * 24 * 60 * 60 * 1000); // Last 7 days
      
    const totalAdjustment = recentAdjustments.reduce((sum, adj) => sum + adj.adjustment, 0);
    
    // Ensure multiplier stays within reasonable bounds
    return Math.max(0.5, Math.min(1.5, 1 + totalAdjustment));
  }
  
  getRecentDisagreements(limit: number = 10): DisagreementRecord[] {
    return this.disagreementLog
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, limit);
  }
  
  clearOldRecords(): void {
    const weekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
    
    this.disagreementLog = this.disagreementLog.filter(record => record.timestamp > weekAgo);
    this.weightAdjustments = this.weightAdjustments.filter(adj => adj.timestamp > weekAgo);
  }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/guard/types.ts

````typescript
export type CommitGroup =
  | 'ui'
  | 'logic'
  | 'docs'
  | 'test'
  | 'chore'
  | 'other';

export interface Vote {
  category: CommitGroup;
  weight: number; // 0.1 ~ 1.0
  reason: string;
  source: 'path' | 'diff' | 'keyword' | 'ast' | 'history';
}

export interface GroupExplanation {
  category: CommitGroup;
  confidence: number; // 0.0 ~ 1.0
  reasons: string[];
  votes: Vote[];
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/provider/ChatViewProvider.ts

````typescript
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { VSCodeAgentRuntime } from '../core/runtime';
import { GovernanceService } from '../../engine/agent/governance';
import * as chatHistoryStorage from '../../engine/agent/chatHistoryStorage';
import { createIgnoreFilter, IgnoreFilter } from '../utils/ignoreFilter';
import { GitManager } from '../git/GitManager';
import { DiffParser, DiffApplier } from '../../core/diff';
import { getDiffGradedApplier } from '../../core/DiffGradedApplier';
import { getSecurityScanCoordinator } from '../../core/SecurityScanCoordinator';

// æ¨¡å‹é…ç½®æ¥å£
interface ModelConfig {
    id: string;
    name: string;
    description: string;
}

interface ModelsConfigFile {
    availableModels: ModelConfig[];
    defaultModel: string;
}

/**
 * ChatView Provider - ä¾§è¾¹æ èŠå¤©è§†å›¾æä¾›è€…
 * 
 * èŒè´£ï¼š
 * - ç®¡ç† Webview UI çš„ç”Ÿå‘½å‘¨æœŸ
 * - ç»´æŠ¤èŠå¤©å†å²è®°å½•
 * - æä¾›ç”¨æˆ·è¾“å…¥æµå¼å±•ç¤º
 * - é€šè¿‡ VSCodeAgentRuntime æ‰§è¡Œ AI ä»»åŠ¡
 * 
 * æ³¨æ„ï¼šä¸è´Ÿè´£ context æ„é€ ï¼Œåªè´Ÿè´£ UI å±‚
 */
export class ChatViewProvider implements vscode.WebviewViewProvider {
    public static readonly viewType = 'yuangs.chatView';
    private _view?: vscode.WebviewView;
    private _messages: { role: string, content: string }[] = [];
    private _abortController: AbortController | null = null;
    private _ignoreFilter: IgnoreFilter | null = null;
    private _currentModel: string = 'gpt-4o-mini';
    private _runtime: VSCodeAgentRuntime | null = null;

    constructor(
        private readonly _context: vscode.ExtensionContext,
    ) {
        console.log('[ChatViewProvider] Initializing...');
        // Initialize ignore filter for file selection
        this._ignoreFilter = createIgnoreFilter();
        // ä» workspaceState åŠ è½½ä¿å­˜çš„æ¨¡å‹
        this._currentModel = this._context.workspaceState.get('currentModel', this.getDefaultModel());
        console.log(`[ChatViewProvider] Current model: ${this._currentModel}`);
        // ä¼˜å…ˆä»æ–‡ä»¶ç³»ç»Ÿæ¢å¤å†å²è®°å½•ï¼Œå¦åˆ™ä» workspaceState æ¢å¤
        this.loadHistory();

        // âœ… åˆå§‹åŒ–æ—¶åˆ›å»º runtime å¹¶è®¾ç½®å›è°ƒï¼ˆé¿å…æ¯æ¬¡è¯·æ±‚é‡å¤è®¾ç½®ï¼‰
        this._runtime = new VSCodeAgentRuntime();
        const contextAdapter = this._runtime.getContextAdapter();
        contextAdapter.setOnFileLoadedCallback((fileName: string) => {
            this._view?.webview.postMessage({
                type: 'success',
                value: `ğŸ“„ Referenced file: ${fileName}`
            });
            console.log(`[ChatViewProvider] UI notified of loaded file: ${fileName}`);
        });
        console.log('[ChatViewProvider] File loaded callback initialized');
    }

    /**
     * è·å–é»˜è®¤æ¨¡å‹
     */
    private getDefaultModel(): string {
        try {
            const config = this.getModelsConfig();
            return config.defaultModel;
        } catch (error) {
            console.warn('[ChatViewProvider] Failed to read default model from config, using fallback');
            return 'gpt-4o-mini';
        }
    }

    /**
     * è¯»å–æ¨¡å‹é…ç½®æ–‡ä»¶
     */
    private getModelsConfig(): ModelsConfigFile {
        // ä¼˜å…ˆä» dist ç›®å½•è¯»å–ï¼ˆæ‰“åŒ…åçš„ä½ç½®ï¼‰
        const possiblePaths = [
            path.join(this._context.extensionPath, 'dist', 'engine', 'core', 'models.config.json'),
            path.join(this._context.extensionPath, 'src', 'engine', 'core', 'models.config.json')
        ];

        let configPath: string | null = null;
        for (const testPath of possiblePaths) {
            if (fs.existsSync(testPath)) {
                configPath = testPath;
                console.log(`[ChatViewProvider] Found config file at: ${configPath}`);
                break;
            }
        }

        if (!configPath) {
            console.warn('[ChatViewProvider] Models config file not found at any location, using defaults');
            return {
                availableModels: [
                    { id: 'gpt-4o-mini', name: 'GPT-4o Mini', description: 'å¿«é€Ÿä¸”é«˜æ•ˆ' },
                    { id: 'glm4.7', name: 'glm4.7', description: 'å¹³è¡¡æ€§èƒ½' },
                    { id: 'gpt-4-turbo', name: 'GPT-4 Turbo', description: 'é«˜æ€§èƒ½' },
                    { id: 'gpt-4', name: 'GPT-4', description: 'æœ€å¼ºèƒ½åŠ›' },
                    { id: 'gpt-3.5-turbo', name: 'GPT-3.5 Turbo', description: 'ç»æµå®æƒ ' }
                ],
                defaultModel: 'gpt-4o-mini'
            };
        }

        try {
            const content = fs.readFileSync(configPath, 'utf-8');
            const config = JSON.parse(content) as ModelsConfigFile;
            console.log(`[ChatViewProvider] Loaded config with ${config.availableModels.length} models, default: ${config.defaultModel}`);
            return config;
        } catch (error) {
            console.error('[ChatViewProvider] Failed to parse models config:', error);
            throw error;
        }
    }

    public resolveWebviewView(
        webviewView: vscode.WebviewView,
        context: vscode.WebviewViewResolveContext,
        _token: vscode.CancellationToken,
    ) {
        console.log('[ChatViewProvider] Resolving webview view...');
        this._view = webviewView;

        webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [
                this._context.extensionUri
            ]
        };

        try {
            webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);
        } catch (error: any) {
            console.error('[ChatViewProvider] Error loading view:', error);
            webviewView.webview.html = `<html><body><h3>Error loading view</h3><pre>${error.message}</pre></body></html>`;
        }

        // ç›‘å¬ webview å¯è§æ€§å˜åŒ–
        webviewView.onDidChangeVisibility(() => {
            console.log(`[ChatViewProvider] Webview visibility changed. Visible: ${webviewView.visible}`);
            // æ¯æ¬¡ webview å˜ä¸ºå¯è§æ—¶ï¼Œç¡®ä¿å‘é€å†å²è®°å½•
            if (webviewView.visible && this._view) {
                this._view.webview.postMessage({ type: 'history', value: this._messages });
            }
        });

        // ç›‘å¬ webview é”€æ¯
        webviewView.onDidDispose(() => {
            console.log('[ChatViewProvider] Webview disposed');
            this._view = undefined;
        });

        // å½“ webview å‡†å¤‡å¥½åï¼Œå‘é€å†å²è®°å½•
        // ä½¿ç”¨ setTimeout ç¡®ä¿ webview å®Œå…¨åˆå§‹åŒ–
        setTimeout(() => {
            if (this._view) {
                console.log(`[ChatViewProvider] Sending ${this._messages.length} messages to UI`);
                this._view.webview.postMessage({ type: 'history', value: this._messages });
            }
        }, 100);

        webviewView.webview.onDidReceiveMessage(async data => {
            switch (data.type) {
                case 'ask':
                    console.log('[ChatViewProvider] User asked question');
                    await this.handleAgentTask(data.value);
                    break;
                case 'stop':
                    console.log('[ChatViewProvider] User requested stop');
                    if (this._abortController) {
                        this._abortController.abort();
                        this._abortController = null;
                    }
                    break;
                case 'getFiles':
                    const excludePattern = this._ignoreFilter?.getExcludePattern() || '**/node_modules/**';
                    // å¢åŠ æ–‡ä»¶æ•°é‡é™åˆ¶ï¼Œç¡®ä¿èƒ½è·å–åˆ°æ›´å¤šæ–‡ä»¶
                    const files = await vscode.workspace.findFiles('**/*', excludePattern, 1000);

                    // è·å–ç›¸å¯¹è·¯å¾„
                    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
                    let fileNames = files.map(f =>
                        workspaceFolder
                            ? path.relative(workspaceFolder.uri.fsPath, f.fsPath)
                            : f.fsPath
                    );

                    // å¦‚æœæœ‰æŸ¥è¯¢è¯ï¼Œè¿›è¡Œæ¨¡ç³ŠåŒ¹é…è¿‡æ»¤
                    if (data.query && data.query.trim()) {
                        const queryLower = data.query.toLowerCase();
                        fileNames = fileNames.filter(name =>
                            name.toLowerCase().includes(queryLower)
                        );
                    }

                    // é™åˆ¶è¿”å›æ•°é‡ï¼Œé¿å…åˆ—è¡¨å¤ªé•¿å½±å“æ€§èƒ½
                    fileNames = fileNames.slice(0, 50);

                    webviewView.webview.postMessage({
                        type: 'suggestions',
                        value: fileNames,
                        trigger: '@'
                    });
                    console.log(`[ChatViewProvider] Returned ${fileNames.length} files for query: "${data.query}"`);
                    break;
                case 'loadFileTree':
                    const allExcludePattern = this._ignoreFilter?.getExcludePattern() || '**/node_modules/**';
                    const allFiles = await vscode.workspace.findFiles('**/*', allExcludePattern, 500);
                    const allFileNames = allFiles.map(f => path.relative(vscode.workspace.workspaceFolders?.[0].uri.fsPath || '', f.fsPath));
                    webviewView.webview.postMessage({ type: 'fileTreeData', value: allFileNames });
                    break;
                case 'readFile':
                    // è¯»å–æ–‡ä»¶å†…å®¹å¹¶æ·»åŠ åˆ°ä¸Šä¸‹æ–‡
                    if (data.path) {
                        try {
                            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
                            const fsPath = (workspaceFolder && !path.isAbsolute(data.path))
                                ? path.join(workspaceFolder.uri.fsPath, data.path)
                                : data.path;
                            const uri = vscode.Uri.file(fsPath);
                            const doc = await vscode.workspace.openTextDocument(uri);
                            const content = doc.getText();

                            // è·å–æˆ–åˆ›å»º VSCodeAgentRuntime å®ä¾‹
                            if (!this._runtime) {
                                this._runtime = new VSCodeAgentRuntime();
                            }
                            const contextManager = this._runtime.getContextManager();

                            // å°†æ–‡ä»¶å†…å®¹æ·»åŠ åˆ°ä¸Šä¸‹æ–‡
                            const relativePath = workspaceFolder ? path.relative(workspaceFolder.uri.fsPath, uri.fsPath) : path.basename(uri.fsPath);

                            await contextManager.addContextItemAsync({
                                type: 'file',
                                path: uri.fsPath,
                                content: content,
                                semantic: 'source_code',
                                summary: `User selected file: ${path.basename(uri.fsPath)}`,
                                summarized: true,
                                summaryQuality: 1.0,
                                alias: relativePath, // ä½¿ç”¨ç›¸å¯¹è·¯å¾„ (e.g., "src/components/Button.tsx")
                                tags: ['user-selected', 'explicit', 'file-panel'],
                                importance: {
                                    id: uri.fsPath,
                                    path: uri.fsPath,
                                    type: 'file',
                                    useCount: 1,
                                    successCount: 1,
                                    failureCount: 0,
                                    lastUsed: Date.now(),
                                    createdAt: Date.now(),
                                    confidence: 1.0
                                }
                            });

                            console.log(`[ChatViewProvider] âœ… File added to context: ${data.path}`);

                            // å‘é€æˆåŠŸæ¶ˆæ¯åˆ° UI
                            webviewView.webview.postMessage({
                                type: 'success',
                                value: `ğŸ“„ File loaded: ${path.basename(uri.fsPath)}`
                            });

                            // åŒæ—¶æ‰“å¼€æ–‡ä»¶ä¾›ç”¨æˆ·æŸ¥çœ‹
                            await vscode.window.showTextDocument(doc, { preview: true });

                            // å…³é—­æ–‡ä»¶é¢æ¿
                            webviewView.webview.postMessage({ type: 'closeFilesPanel' });

                            // âœ… ä¿®å¤ï¼šä¸å†è‡ªåŠ¨è§¦å‘ AI åˆ†æ
                            // ç°åœ¨æ–‡ä»¶é€‰æ‹©å™¨ä½¿ç”¨ @ å¼•ç”¨æ–¹å¼ï¼Œæ–‡ä»¶å†…å®¹ä¼šé€šè¿‡ resolveUserReferences æ­£ç¡®åŠ è½½
                            // ä¿ç•™æ­¤ readFile å¤„ç†å™¨æ˜¯ä¸ºäº†å°†æ¥å¯èƒ½çš„å…¶ä»–ç”¨é€”
                        } catch (error: any) {
                            console.error(`[ChatViewProvider] Failed to read file ${data.path}:`, error);
                            webviewView.webview.postMessage({
                                type: 'error',
                                value: `Failed to read file: ${error.message}`
                            });
                        }
                    }
                    break;
                case 'exportChat':
                    this.exportChatHistory();
                    break;
                case 'clear':
                    this.clear();
                    break;
                case 'getSymbols':
                    const editor = vscode.window.activeTextEditor;
                    if (editor) {
                        try {
                            const symbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(
                                'vscode.executeDocumentSymbolProvider',
                                editor.document.uri
                            );
                            if (symbols) {
                                const symbolNames = symbols.map(s => s.name);
                                webviewView.webview.postMessage({ type: 'suggestions', value: symbolNames, trigger: '#' });
                            }
                        } catch (e) {
                            webviewView.webview.postMessage({ type: 'suggestions', value: [], trigger: '#' });
                        }
                    }
                    break;
                case 'applyDiff':
                    await this.handleApplyDiff(data.value);
                    break;
                case 'applyFullRewrite':
                    await this.handleApplyFullRewrite(data.path, data.content);
                    break;
                case 'open':
                    if (data.path) {
                        try {
                            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
                            const fsPath = (workspaceFolder && !path.isAbsolute(data.path))
                                ? path.join(workspaceFolder.uri.fsPath, data.path)
                                : data.path;
                            const uri = vscode.Uri.file(fsPath);
                            const doc = await vscode.workspace.openTextDocument(uri);
                            await vscode.window.showTextDocument(doc, { preview: true });
                        } catch (e) {
                            vscode.window.showErrorMessage(`Failed to open file: ${data.path}`);
                        }
                    }
                    break;
                case 'getCurrentModel':
                    // å‘é€å½“å‰æ¨¡å‹åˆ° UI
                    webviewView.webview.postMessage({ type: 'currentModel', value: this._currentModel });
                    break;
                case 'getModelsConfig':
                    // å‘é€æ¨¡å‹é…ç½®åˆ° UI
                    try {
                        const config = this.getModelsConfig();
                        webviewView.webview.postMessage({
                            type: 'modelsConfig',
                            value: config
                        });
                    } catch (error: any) {
                        console.error('[ChatViewProvider] Failed to send models config:', error);
                        webviewView.webview.postMessage({
                            type: 'error',
                            value: `Failed to load models config: ${error.message}`
                        });
                    }
                    break;
                case 'changeModel':
                    // æ›´æ–°å½“å‰æ¨¡å‹
                    this._currentModel = data.value;
                    console.log(`[ChatViewProvider] Model changed to: ${this._currentModel}`);
                    // ä¿å­˜åˆ° workspaceState
                    this._context.workspaceState.update('currentModel', this._currentModel);
                    break;
                case 'gitAction':
                    await this.handleGitAction(data.action);
                    break;
                case 'applyCommitMessage':
                    try {
                        await GitManager.setCommitMessage(data.value);
                        vscode.window.setStatusBarMessage("å·²æ›´æ–° Git æäº¤ä¿¡æ¯", 3000);
                    } catch (err) {
                        this._view?.webview.postMessage({ type: 'error', value: "æ— æ³•è®¿é—® Git ä»“åº“" });
                    }
                    break;
                case 'performCommit':
                    await this.handlePerformCommit(data.value);
                    break;
                case 'generatePatch':
                    await this.handleGeneratePatch(data.value);
                    break;
            }
        });
    }

    /**
     * ä» UI è§¦å‘çš„èŠå¤©æ‰§è¡Œ
     * 
     * è¿™æ˜¯ ChatViewProvider çš„ä¸»è¦å…¬å…± API
     * æœªæ¥ AskAI å‘½ä»¤ä¹Ÿå¯ä»¥é€šè¿‡äº‹ä»¶æœºåˆ¶è°ƒç”¨æ­¤æ–¹æ³•
     */
    public async runChatFromUI(userInput: string) {
        console.log(`[ChatViewProvider] Running chat from UI: ${userInput.substring(0, 50)}...`);
        await this.handleAgentTask(userInput);
    }

    private async handleAgentTask(userInput: string) {
        if (!this._view) {
            console.warn('[ChatViewProvider] No webview available');
            return;
        }
        if (!this._runtime) {
            console.warn('[ChatViewProvider] No runtime available');
            return;
        }

        // ä¿å­˜ view å¼•ç”¨ä»¥é¿å…åç»­ null æ£€æŸ¥
        const view = this._view!;

        // åˆ›å»ºæ–°çš„ AbortController
        this._abortController = new AbortController();
        const signal = this._abortController.signal;

        try {
            console.log('[ChatViewProvider] Starting AI task...');
            this._messages.push({ role: 'user', content: userInput });
            this._saveHistory();

            await GovernanceService.init(this._context.extensionUri.fsPath);

            const originalAdjudicate = GovernanceService.adjudicate;
            (GovernanceService as any).adjudicate = async (action: any) => {
                let details = '';
                let summary = '';

                if (action.type === 'tool_call') {
                    const toolName = action.payload.tool_name;
                    const params = action.payload.parameters;

                    // For skill creation, provide a concise summary
                    if (toolName === 'skill_create' && params) {
                        summary = `ğŸ“‹ Create New Skill: ${params.name || 'Unnamed Skill'}`;
                        details = `\nğŸ“ Description: ${params.description || 'No description'}`;

                        // Truncate long descriptions to avoid overflow
                        if (details.length > 300) {
                            details = details.substring(0, 300) + '...';
                        }

                        details += `\n\nğŸ’¡ Use when: ${params.whenToUse || 'Not specified'}`;

                        // Show success rate if available
                        if (params.confidence) {
                            details += `\nğŸ“Š Confidence: ${(params.confidence * 100).toFixed(1)}%`;
                        }
                    } else {
                        // For other tools, show basic info
                        details = `\nTool: ${toolName}`;
                        const paramsStr = JSON.stringify(params, null, 2);
                        // Truncate long parameter strings
                        if (paramsStr.length > 200) {
                            details += `\nParams: ${paramsStr.substring(0, 200)}...`;
                        } else {
                            details += `\nParams: ${paramsStr}`;
                        }
                    }
                } else if (action.type === 'shell_cmd') {
                    details = `\nCommand: ${action.payload.command}`;
                }

                // Truncate reasoning to fit on screen
                let reasoning = action.reasoning || 'No reason provided';
                const maxReasoningLength = 200;
                if (reasoning.length > maxReasoningLength) {
                    reasoning = reasoning.substring(0, maxReasoningLength) + '...';
                }

                const message = `${summary || `Agent wants to execute ${action.type}`}${details}\n\nReason: ${reasoning}`;

                // Auto-approve skill creation requests
                if (action.type === 'tool_call' && action.payload.tool_name === 'skill_create') {
                    console.log('[Governance] Auto-approving skill creation:', action.payload.parameters?.name);
                    return { status: 'approved', by: 'auto-policy', timestamp: Date.now() };
                }

                const choice = await vscode.window.showInformationMessage(
                    message,
                    { modal: true },
                    'Approve', 'Reject'
                );

                if (choice === 'Approve') {
                    return { status: 'approved', by: 'human', timestamp: Date.now() };
                } else {
                    return { status: 'rejected', by: 'human', reason: 'User Denied via VS Code UI', timestamp: Date.now() };
                }
            };

            // âœ… ä¿®å¤ï¼šç›´æ¥ä¼ é€’åŸå§‹ userInputï¼Œè®© VSCodeAgentRuntime å’Œ LLMAdapter å¤„ç†ä¸Šä¸‹æ–‡
            // VSCodeAgentRuntime.runChat() ä¼šï¼š
            // 1. è°ƒç”¨ resolveUserReferences() è§£æ @ å¼•ç”¨
            // 2. è°ƒç”¨ flush() ç­‰å¾…æ‰€æœ‰å¼‚æ­¥ä¸Šä¸‹æ–‡æ·»åŠ å®Œæˆ
            // 3. è°ƒç”¨ collectContext() æ”¶é›†å…¶ä»–ä¸Šä¸‹æ–‡
            // 4. LLMAdapter.think() ä¼šä» ContextBuffer æ„å»ºä¸Šä¸‹æ–‡æç¤º

            const contextManager = this._runtime.getContextManager();

            let fullAiResponse = '';
            await this._runtime.runChat(
                userInput,  // âœ… ä¼ é€’åŸå§‹è¾“å…¥ï¼Œè®©åº•å±‚å¤„ç†ä¸Šä¸‹æ–‡
                (chunk: string) => {
                    fullAiResponse += chunk;
                    this._view!.webview.postMessage({ type: 'aiChunk', value: chunk });
                },
                this._currentModel, // ä½¿ç”¨å½“å‰é€‰ä¸­çš„æ¨¡å‹
                () => {
                    // Context initialized callback
                    console.log('[ChatViewProvider] Context initialized, sending to UI...');
                    this.sendContextToUI(contextManager);
                },
                signal // âœ… ä¼ é€’å–æ¶ˆä¿¡å·
            );

            // å‘é€ä¸Šä¸‹æ–‡ä¿¡æ¯åˆ°UIï¼ˆä½†ä¸è‡ªåŠ¨å¼¹å‡ºé¢æ¿ï¼‰
            this.sendContextToUI(contextManager);

            // åªä¿å­˜æœ‰æ„ä¹‰çš„ AI å›å¤ï¼Œè¿‡æ»¤ç©ºå†…å®¹
            if (fullAiResponse && fullAiResponse.trim()) {
                this._messages.push({ role: 'assistant', content: fullAiResponse });
            }
            this._saveHistory();
            this._view!.webview.postMessage({ type: 'done' });
            (GovernanceService as any).adjudicate = originalAdjudicate;

        } catch (error: any) {
            // æ£€æŸ¥æ˜¯å¦æ˜¯å–æ¶ˆæ“ä½œ
            if (signal.aborted) {
                console.log('[ChatViewProvider] Task was aborted');
                this._view!.webview.postMessage({
                    type: 'error',
                    value: 'Generation stopped by user'
                });
            } else {
                this._view!.webview.postMessage({ type: 'error', value: error.message });
            }
        } finally {
            // æ¸…ç† AbortController
            this._abortController = null;
        }
    }

    /**
     * å‘é€ä¸Šä¸‹æ–‡ä¿¡æ¯åˆ°UI
     */
    private sendContextToUI(contextManager: any) {
        if (!this._view) return;

        try {
            const contextBuffer = contextManager.getContextBuffer();
            const items = contextBuffer.export();

            const high: any[] = [];
            const medium: any[] = [];
            const low: any[] = [];

            for (const item of items) {
                const confidence = item.importance?.confidence ?? 0.5;
                // ç¡®ä¿ tags å­˜åœ¨
                const tags = item.tags || [];

                // å°† item è½¬æ¢ä¸º UI éœ€è¦çš„è½»é‡çº§å¯¹è±¡
                const payload = {
                    ...item,
                    tags: tags // ç¡®ä¿ä¼ é€’å¤„ç†åçš„ tags
                };

                if (confidence >= 0.8) high.push(payload);
                else if (confidence >= 0.4) medium.push(payload);
                else low.push(payload);
            }

            // å‘é€åˆ†ç»„åçš„ä¸Šä¸‹æ–‡æ•°æ®åˆ°webview
            this._view.webview.postMessage({
                type: 'contextUpdate',
                value: [...high, ...medium, ...low], // æš‚æ—¶ä¿æŒæ‰å¹³åˆ—è¡¨ä»¥å…¼å®¹ç°æœ‰UIï¼Œåç»­å¯å‡çº§ä¸ºåˆ†ç»„æ˜¾ç¤º
                groups: { high, medium, low }, // åŒæ—¶å‘é€åˆ†ç»„æ•°æ®ä¾›æœªæ¥ä½¿ç”¨
                count: items.length // å‘é€æ€»æ•°åˆ°UI
            });

            console.log(`[ChatViewProvider] Sent context: High(${high.length}) Med(${medium.length}) Low(${low.length}) Total(${items.length})`);
        } catch (error) {
            console.error('[ChatViewProvider] Error sending context to UI:', error);
        }
    }

    private getFileLanguage(filePath: string): string {
        const ext = filePath.split('.').pop()?.toLowerCase() || '';
        const langMap: Record<string, string> = {
            'js': 'javascript',
            'ts': 'typescript',
            'tsx': 'typescript',
            'jsx': 'javascript',
            'py': 'python',
            'java': 'java',
            'go': 'go',
            'rs': 'rust',
            'cpp': 'cpp',
            'c': 'c',
            'h': 'c',
            'vue': 'vue',
            'yaml': 'yaml',
            'yml': 'yaml',
            'json': 'json',
            'md': 'markdown',
            'html': 'html',
            'css': 'css',
            'sh': 'bash',
            'bash': 'bash'
        };
        return langMap[ext] || 'text';
    }

    private async handleApplyDiff(diffData: any) {
        if (!this._view) return;

        try {
            if (diffData.type === 'unified') {
                console.log('[ChatViewProvider] Applying unified diff with graded applier...');

                // è½¬æ¢ä¸ºæ ‡å‡† unified diff æ ¼å¼
                const diffText = this.convertToUnifiedDiffFormat(diffData);
                console.log(`[ChatViewProvider] Diff text (${diffText.length} chars):`, diffText.substring(0, 200) + '...');

                // è·å–åŸå§‹ä»£ç ï¼ˆç”¨äº Phase 1 å®‰å…¨æ‰«æï¼‰
                const originalCode = await this.getOriginalCodeForDiff(diffData);

                // è§£æ diff
                const parseResult = DiffParser.parse(diffText);

                if (!parseResult.success) {
                    console.warn('[ChatViewProvider] Diff parsing failed:', parseResult.message);
                    throw new Error(`Diff è§£æå¤±è´¥: ${parseResult.message}`);
                }

                console.log('[ChatViewProvider] Diff parsed successfully:', {
                    fileCount: parseResult.stats.fileCount,
                    hunkCount: parseResult.stats.hunkCount,
                    totalAdded: parseResult.stats.totalAdded,
                    totalRemoved: parseResult.stats.totalRemoved
                });

                // ä½¿ç”¨æ–°çš„ DiffGradedApplier åº”ç”¨ diff
                const applier = getDiffGradedApplier();
                const startTime = Date.now();
                const applyResult = await applier.applyWithGrades(diffText, {
                    enableLevel1: true,
                    enableLevel2: true,
                    enableLevel3: true,
                    confirmBeforeFullOverride: true
                });
                const duration = Date.now() - startTime;

                if (!applyResult.success) {
                    console.error('[ChatViewProvider] All grades failed:', applyResult.error);
                    throw new Error(`è¡¥ä¸åº”ç”¨å¤±è´¥ï¼ˆæ‰€æœ‰çº§åˆ«éƒ½å¤±è´¥äº†ï¼‰: ${applyResult.message}`);
                }

                console.log('[ChatViewProvider] Diff applied successfully:', {
                    usedLevel: applyResult.usedLevel,
                    changedFiles: applyResult.changedFiles,
                    duration
                });

                // ä½¿ç”¨ SecurityScanCoordinator è¿è¡Œä¸‰å±‚å®‰å…¨æ‰«æ
                const coordinator = getSecurityScanCoordinator();
                const report = await coordinator.runFullScanPipeline(
                    originalCode,
                    parseResult,
                    applyResult.changedFiles
                );

                console.log('[ChatViewProvider] Security scan completed:', {
                    overallStatus: report.overallStatus,
                    criticalIssues: report.criticalIssueCount,
                    errorIssues: report.errorIssueCount,
                    warningIssues: report.warningIssueCount,
                    totalDuration: report.totalDuration
                });

                // æ ¹æ®å®‰å…¨æ‰«æç»“æœé‡‡å–è¡ŒåŠ¨
                if (report.overallStatus === 'failed') {
                    const choice = await vscode.window.showWarningMessage(
                        `å®‰å…¨æ‰«æå‘ç° ${report.criticalIssueCount + report.errorIssueCount} ä¸ªä¸¥é‡é—®é¢˜ï¼\nå»ºè®®æŸ¥çœ‹ Problems é¢æ¿ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ`,
                        'ç»§ç»­ï¼ˆä¸æ¨èï¼‰', 'å–æ¶ˆ'
                    );

                    if (choice !== 'ç»§ç»­ï¼ˆä¸æ¨èï¼‰') {
                        // å›æ»šæ›´æ”¹
                        vscode.window.showWarningMessage('å·²å–æ¶ˆåº”ç”¨ï¼Œæ›´æ”¹å·²å›æ»š');
                        return;
                    }
                } else if (report.overallStatus === 'warning') {
                    vscode.window.showInformationMessage(
                        `âœ“ Diff å·²åº”ç”¨ï¼ˆ${applyResult.usedLevel}ï¼‰\nâš ï¸ å‘ç° ${report.warningIssueCount} ä¸ªè­¦å‘Šï¼Œè¯·æŸ¥çœ‹ Problems é¢æ¿`
                    );
                } else {
                    vscode.window.showInformationMessage(
                        `âœ“ Diff å·²åº”ç”¨ï¼ˆ${applyResult.usedLevel}ï¼‰\nâœ… å®‰å…¨æ‰«æé€šè¿‡`
                    );
                }

                // å‘é€æˆåŠŸæ¶ˆæ¯åˆ° UI
                this._view.webview.postMessage({ type: 'diffApplied' });

                // è®°å½•é™çº§ä¿¡æ¯åˆ° UI
                if (applyResult.usedLevel && applyResult.usedLevel !== 'intelligent_fix') {
                    const levelNames: Record<string, string> = {
                        'fuzzy_location': 'Level 2',
                        'full_override': 'Level 3'
                    };
                    this._view.webview.postMessage({
                        type: 'info',
                        value: `ä½¿ç”¨äº† ${levelNames[applyResult.usedLevel] || applyResult.usedLevel}ï¼ˆé™çº§ï¼‰`
                    });
                }

            } else if (diffData.type === 'simple') {
                await this.applySimpleDiff(diffData);
                this._view.webview.postMessage({ type: 'diffApplied' });
                vscode.window.showInformationMessage('âœ“ Diff applied successfully!');
            } else {
                throw new Error('Unknown diff format');
            }
        } catch (error: any) {
            console.error('[ChatViewProvider] Diff application failed:', error);
            this._view.webview.postMessage({ type: 'diffError', value: error.message });
            vscode.window.showErrorMessage(`Failed to apply diff: ${error.message}`);
        }
    }

    /**
     * è·å– diff æ¶‰åŠçš„åŸå§‹ä»£ç 
     */
    private async getOriginalCodeForDiff(diffData: any): Promise<string> {
        try {
            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) {
                return '';
            }

            // è·å–ç¬¬ä¸€ä¸ªæ–‡ä»¶çš„åŸå§‹å†…å®¹
            const firstFile = diffData.files[0];
            if (!firstFile) {
                return '';
            }

            const filePath = path.join(
                workspaceFolder.uri.fsPath,
                firstFile.oldFile || firstFile.newFile
            );

            const uri = vscode.Uri.file(filePath);
            const document = await vscode.workspace.openTextDocument(uri);
            return document.getText();
        } catch (error) {
            console.warn('[ChatViewProvider] Failed to get original code:', error);
            return '';
        }
    }

    /**
     * å°†diffDataè½¬æ¢ä¸ºæ ‡å‡†çš„unified diffæ ¼å¼
     */
    private convertToUnifiedDiffFormat(diffData: any): string {
        let diffString = '';

        for (const file of diffData.files) {
            diffString += `--- a/${file.oldFile || 'original'}\n`;
            diffString += `+++ b/${file.newFile || 'modified'}\n`;

            for (const hunk of file.hunks) {
                diffString += `@@ -${hunk.oldStart},${hunk.oldLines} +${hunk.newStart},${hunk.newLines} @@\n`;

                for (const line of hunk.lines) {
                    if (line.startsWith('+')) {
                        diffString += line + '\n';
                    } else if (line.startsWith('-')) {
                        diffString += line + '\n';
                    } else {
                        diffString += ` ${line}\n`;
                    }
                }
            }
        }

        return diffString;
    }

    /**
     * è¯·æ±‚AIæä¾›å®Œæ•´ä»£ç 
     */
    private async requestFullCodeFromAI() {
        // è¿™é‡Œå¯ä»¥å®ç°å‘AIè¯·æ±‚å®Œæ•´ä»£ç çš„é€»è¾‘
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªæ–‡ä»¶');
            return;
        }

        const document = editor.document;
        const fileName = path.basename(document.fileName);

        // å‘AIå‘é€è¯·æ±‚ï¼Œè¦æ±‚æä¾›å®Œæ•´çš„æ–‡ä»¶å†…å®¹
        const prompt = `ç”±äºè¡¥ä¸åº”ç”¨å¤±è´¥ï¼Œæˆ‘éœ€è¦æ‚¨æä¾›å®Œæ•´çš„ ${fileName} æ–‡ä»¶å†…å®¹ã€‚è¯·ç›´æ¥è¾“å‡ºå®Œæ•´çš„ä»£ç ï¼Œä¸è¦åŒ…å«ä»»ä½•è§£é‡Šã€‚`;

        // å‘é€æ¶ˆæ¯åˆ°UIï¼Œè§¦å‘AIè¯·æ±‚
        this._view?.webview.postMessage({
            type: 'appendMessage',
            value: { role: 'user', content: prompt }
        });

        await this.handleAgentTask(prompt);
    }

    /**
     * å¤„ç†å…¨é‡å†…å®¹æ›¿æ¢
     */
    private async handleApplyFullRewrite(filePath: string, content: string) {
        try {
            let actualFilePath = filePath;

            // å¦‚æœæ²¡æœ‰æä¾›è·¯å¾„ï¼Œä½¿ç”¨å½“å‰æ´»åŠ¨æ–‡ä»¶
            if (!actualFilePath) {
                const editor = vscode.window.activeTextEditor;
                if (!editor) {
                    throw new Error('æ²¡æœ‰æ‰“å¼€çš„æ–‡ä»¶å¯ä¾›æ›¿æ¢ï¼Œè¯·å…ˆæ‰“å¼€ä¸€ä¸ªæ–‡ä»¶');
                }
                actualFilePath = path.relative(
                    vscode.workspace.workspaceFolders?.[0].uri.fsPath || '',
                    editor.document.uri.fsPath
                );
            }

            // ä½¿ç”¨æ–°çš„DiffApplierçš„å…¨é‡æ›¿æ¢åŠŸèƒ½
            const result = await DiffApplier.applyFullContent(actualFilePath, content);

            if (result.success) {
                vscode.window.showInformationMessage(`å·²æˆåŠŸæ›¿æ¢æ–‡ä»¶: ${actualFilePath}`);
            } else {
                throw new Error(result.message);
            }
        } catch (error) {
            console.error('[ChatViewProvider] Full rewrite failed:', error);
            vscode.window.showErrorMessage(`æ›¿æ¢å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async applyUnifiedDiff(file: any) {
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder) {
            throw new Error('No workspace folder open');
        }

        const filePath = path.join(workspaceFolder.uri.fsPath, file.newFile || file.oldFile);
        const fileUri = vscode.Uri.file(filePath);

        let document: vscode.TextDocument;
        try {
            document = await vscode.workspace.openTextDocument(fileUri);
        } catch {
            const edit = new vscode.WorkspaceEdit();
            edit.createFile(fileUri, { ignoreIfExists: true });
            await vscode.workspace.applyEdit(edit);
            document = await vscode.workspace.openTextDocument(fileUri);
        }

        const edit = new vscode.WorkspaceEdit();
        for (const hunk of file.hunks) {
            let startLine = hunk.oldStart - 1;
            if (startLine < 0) startLine = 0;
            const endLine = startLine + hunk.oldLines;

            const newLines: string[] = [];
            for (const line of hunk.lines) {
                if (line.startsWith('+')) {
                    newLines.push(line.substring(1));
                } else if (!line.startsWith('-')) {
                    newLines.push(line.startsWith(' ') ? line.substring(1) : line);
                }
            }

            const range = new vscode.Range(startLine, 0, endLine, 0);
            edit.replace(fileUri, range, newLines.join('\n') + '\n');
        }

        await vscode.workspace.applyEdit(edit);
        await document.save();
        await vscode.window.showTextDocument(document);
    }

    private async applySimpleDiff(diffData: any) {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            throw new Error('No active editor. Please open a file first.');
        }

        const document = editor.document;
        const edit = new vscode.WorkspaceEdit();
        const fullText = document.getText();

        if (diffData.removed.length > 0) {
            const toRemove = diffData.removed.join('\n');
            const index = fullText.indexOf(toRemove);

            if (index !== -1) {
                const startPos = document.positionAt(index);
                const endPos = document.positionAt(index + toRemove.length);
                const range = new vscode.Range(startPos, endPos);

                if (diffData.added.length > 0) {
                    edit.replace(document.uri, range, diffData.added.join('\n'));
                } else {
                    edit.delete(document.uri, range);
                }
            } else {
                throw new Error('Could not find the content to replace in the active file');
            }
        } else if (diffData.added.length > 0) {
            edit.insert(document.uri, editor.selection.active, diffData.added.join('\n'));
        }

        await vscode.workspace.applyEdit(edit);
        await document.save();
    }

    /**
     * è¾…åŠ©æ–¹æ³•ï¼šå°è¯•æ ¹æ®è·¯å¾„å°†æ–‡ä»¶åŠ è½½åˆ°ä¸Šä¸‹æ–‡
     */
    private async autoLoadFileToContext(relativePath: string) {
        try {
            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) return;

            // å°è¯•è§£æç»å¯¹è·¯å¾„
            const fullPath = path.isAbsolute(relativePath)
                ? relativePath
                : path.join(workspaceFolder.uri.fsPath, relativePath);

            if (fs.existsSync(fullPath) && fs.lstatSync(fullPath).isFile()) {
                const content = fs.readFileSync(fullPath, 'utf-8');

                if (!this._runtime) this._runtime = new VSCodeAgentRuntime();
                const contextManager = this._runtime.getContextManager();

                const relativePathForAlias = workspaceFolder ? path.relative(workspaceFolder.uri.fsPath, fullPath) : path.basename(fullPath);

                await contextManager.addContextItemAsync({
                    type: 'file',
                    path: fullPath,
                    content: content,
                    semantic: 'source_code',
                    alias: relativePathForAlias,
                    importance: {
                        id: path.basename(fullPath) + '-' + Date.now(), // ç”Ÿæˆå”¯ä¸€ID
                        path: fullPath,
                        type: 'file',
                        useCount: 1,
                        successCount: 1,
                        failureCount: 0,
                        lastUsed: Date.now(),
                        createdAt: Date.now(),
                        confidence: 1.0 // æ˜¾å¼å¼•ç”¨ç»™æœ€é«˜æƒé‡
                    }
                });
                console.log(`[ChatViewProvider] Auto-loaded @ reference: ${relativePath}`);
            }
        } catch (e) {
            console.warn(`[ChatViewProvider] Failed to auto-load @ reference: ${relativePath}`, e);
        }
    }

    public async clear() {
        this._messages = [];
        await this._saveHistory();
        await chatHistoryStorage.clearChatHistory();
        this._view?.webview.postMessage({ type: 'clear' });
    }

    private async loadHistory() {
        // ä¼˜å…ˆå°è¯•ä»æ–‡ä»¶ç³»ç»ŸåŠ è½½
        try {
            const fileHistory = await chatHistoryStorage.loadChatHistory();
            if (fileHistory && fileHistory.length > 0) {
                // å°† AIRequestMessage è½¬æ¢ä¸ºå†…éƒ¨æ ¼å¼
                this._messages = fileHistory.map(msg => ({
                    role: msg.role,
                    content: msg.content
                }));
                console.log(`[ChatViewProvider] Loaded ${this._messages.length} messages from file storage`);
                return;
            }
        } catch (e) {
            console.warn('[ChatViewProvider] Failed to load from file storage, falling back to workspaceState:', e);
        }

        // å›é€€åˆ° workspaceState
        this._messages = this._context.workspaceState.get<{ role: string, content: string }[]>('chatHistory', []);
        console.log(`[ChatViewProvider] Restored ${this._messages.length} messages from workspaceState`);
    }

    private _saveHistory() {
        // ä¿å­˜åˆ°æ–‡ä»¶ç³»ç»Ÿï¼ˆæŒä¹…åŒ–ï¼‰
        const historyForFile = this._messages.map(msg => ({
            role: msg.role as 'system' | 'user' | 'assistant',
            content: msg.content
        }));
        chatHistoryStorage.saveChatHistory(historyForFile);

        // åŒæ—¶ä¿å­˜åˆ° workspaceStateï¼ˆä½œä¸ºå¤‡ä»½ï¼‰
        this._context.workspaceState.update('chatHistory', this._messages);
    }

    private formatTimestamp(date: Date): string {
        const pad = (n: number) => String(n).padStart(2, '0');
        return [
            date.getFullYear(),
            pad(date.getMonth() + 1),
            pad(date.getDate()),
            pad(date.getHours()),
            pad(date.getMinutes()),
            pad(date.getSeconds()),
        ].join('');
    }

    private async exportChatHistory() {
        if (this._messages.length === 0) {
            vscode.window.showWarningMessage('No chat history to export.');
            return;
        }

        const now = new Date();
        const timestamp = this.formatTimestamp(now);
        const filename = `yuangs_chat_${timestamp}.md`;

        // ä¼˜åŒ–ï¼šå¤„ç†æ— å·¥ä½œåŒºæˆ–å¤šå·¥ä½œåŒºçš„è¾¹ç•Œæƒ…å†µ
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        const defaultUri = workspaceFolder
            ? vscode.Uri.file(path.join(workspaceFolder.uri.fsPath, filename))
            : undefined;

        const uri = await vscode.window.showSaveDialog({
            defaultUri,
            filters: { 'Markdown': ['md'] },
            title: 'Export Chat History'
        });

        if (uri) {
            try {
                const mdContent = this._messages.map(m => {
                    const role = m.role === 'user' ? '### ğŸ‘¤ User' : '### ğŸ¤– Assistant';
                    return `${role}\n\n${m.content}\n\n---\n`;
                }).join('\n');

                await vscode.workspace.fs.writeFile(uri, Buffer.from(mdContent));
                vscode.window.showInformationMessage(`Chat history exported to ${path.basename(uri.fsPath)}`);
            } catch (e: any) {
                vscode.window.showErrorMessage(`Failed to export chat history: ${e.message}`);
            }
        }
    }

    /**
     * å¤„ç†æäº¤è¯·æ±‚ (Service Layer é€»è¾‘ä¸‹æ²‰)
     */
    private async handlePerformCommit(message: string) {
        try {
            await GitManager.commit(message);

            // 1. é€šçŸ¥å‰ç«¯æˆåŠŸ
            this._view?.webview.postMessage({ type: 'success', value: 'Git Commit æˆåŠŸ' });

            // 2. VS Code åŸç”Ÿæç¤º
            vscode.window.showInformationMessage(`âœ… ä»£ç å·²æäº¤: ${message.trim().split('\n')[0]}`);

            // 3. æ¸…ç†çŠ¶æ€ (æ¸…ç©ºè¾“å…¥æ¡†)
            await GitManager.setCommitMessage('');

        } catch (error: any) {
            console.error('[ChatViewProvider] Commit failed:', error);

            // 4. é”™è¯¯åˆ†çº§å¤„ç† (å®‰å…¨ & UX)
            const errorMessage = error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯';

            // å‘é€ç»™å‰ç«¯çš„é”™è¯¯æ¶ˆæ¯ (ç”¨äº Toast æˆ– çŠ¶æ€æ )
            this._view?.webview.postMessage({
                type: 'error',
                value: errorMessage
            });

            // VS Code å¼¹çª—æç¤º (å¯¹äºä¸¥é‡é”™è¯¯)
            if (errorMessage.includes('æš‚å­˜åŒºä¸ºç©º') || errorMessage.includes('Git ä»“åº“')) {
                vscode.window.showWarningMessage(errorMessage);
            } else {
                vscode.window.showErrorMessage(`æäº¤ä¸­æ–­: ${errorMessage}`);
            }
        }
    }

    /**
     * å¤„ç†ç”Ÿæˆ Patch è¯·æ±‚
     */
    private async handleGeneratePatch(type: 'staged' | 'unstaged' | 'last') {
        try {
            const patch = await GitManager.generatePatch(type);

            // å‘é€ patch å†…å®¹åˆ°å‰ç«¯ï¼Œæ˜¾ç¤ºä¸º AI æ¶ˆæ¯
            const typeNames = {
                'staged': 'æš‚å­˜åŒº Patch',
                'unstaged': 'å·¥ä½œåŒº Patch',
                'last': 'æœ€åä¸€æ¬¡æäº¤ Patch'
            };

            const message = `# ${typeNames[type]}\n\n\`\`\`diff\n${patch}\n\`\`\``;

            this._view?.webview.postMessage({
                type: 'appendMessage',
                value: {
                    role: 'assistant',
                    content: message
                }
            });

            vscode.window.showInformationMessage(`âœ… ${typeNames[type]} ç”ŸæˆæˆåŠŸ`);

        } catch (error: any) {
            console.error('[ChatViewProvider] Generate patch failed:', error);

            const errorMessage = error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯';

            this._view?.webview.postMessage({
                type: 'error',
                value: errorMessage
            });

            vscode.window.showErrorMessage(`ç”Ÿæˆ patch å¤±è´¥: ${errorMessage}`);
        }
    }

    private async handleGitAction(action: 'commit' | 'review') {
        // è·å–æš‚å­˜åŒº Diff
        const changes = await GitManager.getStagedDiff();
        if (!changes) {
            this._view?.webview.postMessage({ type: 'error', value: "æœªæ£€æµ‹åˆ°æš‚å­˜åŒºå˜æ›´æˆ– Git ä»“åº“ä¸å¯ç”¨" });
            return;
        }


        // æ„å»ºæç¤ºè¯
        const prompt = action === 'commit'
            ? `ä½ æ˜¯ä¸€ä½èµ„æ·±å¼€å‘è€…ã€‚è¯·æ ¹æ®ä»¥ä¸‹ä»£ç å˜æ›´ç”Ÿæˆä¸€æ¡ç®€æ´ã€ç¬¦åˆ Conventional Commits è§„èŒƒçš„æäº¤æ¶ˆæ¯ã€‚åªéœ€è¿”å›æ¶ˆæ¯å†…å®¹æœ¬èº«ï¼š\n\n${changes}`
            : `ä½ æ˜¯ä¸€ä½ä»£ç å®¡æŸ¥ä¸“å®¶ã€‚è¯·å¯¹ä»¥ä¸‹å˜æ›´è¿›è¡Œè¯­ä¹‰çº§åˆ«çš„å®¡æŸ¥ï¼ŒæŒ‡å‡ºæ½œåœ¨é£é™©ã€æ€§èƒ½é—®é¢˜å’Œæœ€ä½³å®è·µå»ºè®®ï¼š\n\n${changes}`;

        // å‘é€ç»™ AI å¤„ç†
        await this.handleAgentTask(prompt);
    }

    private _getHtmlForWebview(webview: vscode.Webview) {
        const scriptUri = webview.asWebviewUri(vscode.Uri.joinPath(this._context.extensionUri, 'dist', 'webview', 'marked.min.js'));
        const htmlPath = path.join(this._context.extensionPath, 'dist', 'webview', 'sidebar.html');
        let htmlSnippet = fs.readFileSync(htmlPath, 'utf8');

        // ç”Ÿæˆéšæœº nonce ç”¨äº CSP
        const nonce = getNonce();

        // æ³¨å…¥ CSP å’Œæœ¬åœ°è„šæœ¬è·¯å¾„
        htmlSnippet = htmlSnippet.replace(
            /<script src="https:\/\/cdn\.jsdelivr\.net\/npm\/marked\/marked\.min\.js"><\/script>/,
            `<script nonce="${nonce}" src="${scriptUri}"></script>`
        );

        // æ³¨å…¥ CSP Meta æ ‡ç­¾
        const csp = `<meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; script-src 'nonce-${nonce}'; img-src ${webview.cspSource} https:; connect-src *;">`;
        htmlSnippet = htmlSnippet.replace('<head>', `<head>\n    ${csp}`);

        // ä¸ºæ‰€æœ‰çš„ <script> æ ‡ç­¾æ³¨å…¥ nonce
        htmlSnippet = htmlSnippet.replace(/<script>/g, `<script nonce="${nonce}">`);

        return htmlSnippet;
    }
}

function getNonce() {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567899';
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/provider/ProactiveCodeActionProvider.ts

````typescript
/**
 * Proactive Code Action Provider
 * 
 * åŠŸèƒ½ï¼š
 * - ä¸º ProactiveGuard å‘ç°çš„å®‰å…¨é—®é¢˜æä¾›å¿«é€Ÿä¿®å¤æ“ä½œ
 * - å®ç°"ä¸€é”®åŠ å…¥åå¥½é»‘åå•"åŠŸèƒ½
 * - é›†æˆ PreferenceMemory è®°å½•ç”¨æˆ·åé¦ˆ
 * 
 * å…³é”®ç‰¹æ€§ï¼š
 * - æŒ‰ Severity åŒºåˆ†æ“ä½œï¼ˆCRITICAL ä¸èƒ½è¢«å¿½ç•¥ï¼‰
 * - æä¾›"å¿½ç•¥æ­¤æ¬¡"ã€"ä¸å†æç¤ºæ­¤ç±»å»ºè®®"ç­‰é€‰é¡¹
 * - æ”¯æŒæ’¤å›æ“ä½œ
 */

import * as vscode from 'vscode';
import {
  SecurityIssue,
  SecuritySeverity,
  IssueType,
  DEFAULT_SCAN_CONFIG
} from '../../core/securityTypes';
import { getPreferenceMemory } from '../../core/preferenceMemory';

/**
 * Proactive Code Action
 */
export class ProactiveCodeActionProvider implements vscode.CodeActionProvider {
  public preferenceMemory: any;
  private context: vscode.ExtensionContext;

  constructor(context: vscode.ExtensionContext) {
    this.context = context;
    this.preferenceMemory = getPreferenceMemory(context);
  }

  /**
   * æä¾› Code Actions
   */
  provideCodeActions(
    document: vscode.TextDocument,
    range: vscode.Range,
    context: vscode.CodeActionContext,
    token: vscode.CancellationToken
  ): vscode.ProviderResult<vscode.CodeAction[]> {
    const actions: vscode.CodeAction[] = [];

    // åªå¤„ç† vsyuangs-proactive æ¥æºçš„ diagnostics
    const proactiveDiagnostics = context.diagnostics.filter(
      d => d.source === 'vsyuangs-proactive'
    );

    if (proactiveDiagnostics.length === 0) {
      return actions;
    }

    // æ£€æŸ¥è¯·æ±‚çš„ä»£ç æ“ä½œç±»å‹
    const only = context.only;
    const shouldIncludeQuickFix = !only || only.contains(vscode.CodeActionKind.QuickFix);

    // å¦‚æœåªè¯·æ±‚äº†å…¶ä»–ç±»å‹çš„æ“ä½œï¼ˆå¦‚ refactorï¼‰ï¼Œåˆ™ä¸è¿”å›ä»»ä½•æ“ä½œ
    if (!shouldIncludeQuickFix) {
      return actions;
    }

    // ä¸ºæ¯ä¸ª diagnostic åˆ›å»ºæ“ä½œ
    for (const diagnostic of proactiveDiagnostics) {
      const issue = this.extractSecurityIssue(diagnostic);
      
      if (!issue) {
        continue;
      }

      // 1. ä¿®å¤å»ºè®®ï¼ˆå¦‚æœæœ‰ï¼‰
      if (issue.suggestion) {
        const fixAction = this.createFixAction(issue, diagnostic);
        actions.push(fixAction);
      }

      // 2. æŸ¥çœ‹è¯¦æƒ…
      const detailsAction = this.createDetailsAction(issue);
      actions.push(detailsAction);

      // 3. å¿½ç•¥æ­¤æ¬¡ï¼ˆä¸å½±å“æœªæ¥å»ºè®®ï¼‰
      const ignoreOnceAction = this.createIgnoreOnceAction(issue);
      actions.push(ignoreOnceAction);

      // 4. ä¸å†æç¤ºæ­¤ç±»å»ºè®®ï¼ˆåŠ å…¥é»‘åå•ï¼‰- ä»…é CRITICAL
      if (issue.severity !== SecuritySeverity.CRITICAL) {
        const blacklistAction = this.createBlacklistAction(issue);
        actions.push(blacklistAction);
      }

      // 5. æ’¤å›ï¼ˆå¦‚æœå·²åŠ å…¥é»‘åå•ï¼‰
      const undoAction = this.createUndoBlacklistAction(issue);
      if (undoAction) {
        actions.push(undoAction);
      }
    }

    return actions;
  }

  /**
   * ä» diagnostic æå– SecurityIssue
   * 
   * ä» diagnostic.data è¯»å–å…ƒæ•°æ®ï¼ˆä½¿ç”¨ç±»å‹æ–­è¨€å…¼å®¹ VS Code APIï¼‰
   */
  private extractSecurityIssue(diagnostic: vscode.Diagnostic): SecurityIssue | null {
    const data = (diagnostic as any).data;

    if (!data || !data.ruleId || !data.issueType || !data.severity) {
      return null;
    }

    return {
      type: data.issueType,
      severity: data.severity,
      message: diagnostic.message,
      ruleId: data.ruleId,
      line: diagnostic.range.start.line,
      column: diagnostic.range.start.character,
      suggestion: data.suggestion
    };
  }

  /**
   * åˆ›å»ºä¿®å¤å»ºè®®æ“ä½œ
   */
  private createFixAction(
    issue: SecurityIssue,
    diagnostic: vscode.Diagnostic
  ): vscode.CodeAction {
    const action = new vscode.CodeAction(
      `åº”ç”¨ä¿®å¤: ${issue.ruleId}`,
      vscode.CodeActionKind.QuickFix
    );

    action.diagnostics = [diagnostic];
    action.isPreferred = true;

    // è¿™é‡Œå¯ä»¥æ ¹æ® issue.type å’Œ ruleId æä¾›å…·ä½“çš„ä¿®å¤æ–¹æ¡ˆ
    // ç›®å‰åªæ˜¾ç¤ºä¸€ä¸ªæç¤º
    action.command = {
      command: 'vsyuangs.proactive.showFixDetails',
      title: 'æŸ¥çœ‹ä¿®å¤è¯¦æƒ…',
      arguments: [issue]
    };

    return action;
  }

  /**
   * åˆ›å»ºæŸ¥çœ‹è¯¦æƒ…æ“ä½œ
   */
  private createDetailsAction(issue: SecurityIssue): vscode.CodeAction {
    const action = new vscode.CodeAction(
      'æŸ¥çœ‹è¯¦æƒ…',
      vscode.CodeActionKind.QuickFix
    );

    action.command = {
      command: 'vsyuangs.proactive.showIssueDetails',
      title: 'æŸ¥çœ‹è¯¦æƒ…',
      arguments: [issue]
    };

    return action;
  }

  /**
   * åˆ›å»ºå¿½ç•¥æ­¤æ¬¡æ“ä½œ
   */
  private createIgnoreOnceAction(issue: SecurityIssue): vscode.CodeAction {
    const action = new vscode.CodeAction(
      'å¿½ç•¥æ­¤æ¬¡',
      vscode.CodeActionKind.QuickFix
    );

    action.command = {
      command: 'vsyuangs.proactive.ignoreOnce',
      title: 'å¿½ç•¥æ­¤æ¬¡',
      arguments: [issue]
    };

    return action;
  }

  /**
   * åˆ›å»ºåŠ å…¥é»‘åå•æ“ä½œ
   */
  private createBlacklistAction(issue: SecurityIssue): vscode.CodeAction {
    const typeName = issue.type.replace(/_/g, ' ');
    const action = new vscode.CodeAction(
      `ä¸å†æç¤ºæ­¤ç±»å»ºè®® (${typeName})`,
      vscode.CodeActionKind.QuickFix
    );

    action.command = {
      command: 'vsyuangs.proactive.addToBlacklist',
      title: 'ä¸å†æç¤ºæ­¤ç±»å»ºè®®',
      arguments: [issue]
    };

    return action;
  }

  /**
   * åˆ›å»ºæ’¤å›é»‘åå•æ“ä½œ
   */
  private createUndoBlacklistAction(issue: SecurityIssue): vscode.CodeAction | null {
    // æ£€æŸ¥è¯¥ç±»å‹æ˜¯å¦å·²åœ¨é»‘åå•ä¸­
    // è¿™é‡Œéœ€è¦å¼‚æ­¥è°ƒç”¨ getBlacklistï¼Œä½† provideCodeActions æ˜¯åŒæ­¥çš„
    // æ‰€ä»¥æˆ‘ä»¬ç®€åŒ–ï¼šæ€»æ˜¯æ˜¾ç¤ºæ’¤å›é€‰é¡¹ï¼Œè®©å‘½ä»¤å¤„ç†æ—¶æ£€æŸ¥
    
    const action = new vscode.CodeAction(
      'æ’¤å›é»‘åå•',
      vscode.CodeActionKind.QuickFix
    );

    action.command = {
      command: 'vsyuangs.proactive.removeFromBlacklist',
      title: 'æ’¤å›é»‘åå•',
      arguments: [issue]
    };

    return action;
  }

  /**
   * è®°å½•ç”¨æˆ·åé¦ˆ
   */
  async recordFeedback(
    issueType: IssueType,
    action: 'applied' | 'ignored' | 'dismissed'
  ): Promise<void> {
    await this.preferenceMemory.recordFeedback(issueType, action);
  }

  /**
   * æ·»åŠ åˆ°é»‘åå•
   */
  async addToBlacklist(issueType: IssueType): Promise<void> {
    // è®°å½• 3 æ¬¡ ignoreï¼Œç¡®ä¿è¾¾åˆ°é˜ˆå€¼
    for (let i = 0; i < 3; i++) {
      await this.preferenceMemory.recordFeedback(issueType, 'ignored');
    }

    vscode.window.showInformationMessage(
      `å·²å°† "${issueType}" åŠ å…¥åå¥½é»‘åå•ã€‚ä»¥åå°†å¤§å¹…å‡å°‘æ­¤ç±»å»ºè®®ã€‚`
    );
  }

  /**
   * ä»é»‘åå•ç§»é™¤
   */
  async removeFromBlacklist(issueType: IssueType): Promise<void> {
    // è·å–å½“å‰åé¦ˆè®°å½•
    const stats = await this.preferenceMemory.getStats();
    const typeStats = stats.byType[issueType];
    
    if (typeStats && typeStats.totalCount > 0) {
      // è®°å½• 3 æ¬¡ applyï¼ŒæŠµæ¶ˆå¿½ç•¥
      for (let i = 0; i < 3; i++) {
        await this.preferenceMemory.recordFeedback(issueType, 'applied');
      }

      vscode.window.showInformationMessage(
        `å·²ä»é»‘åå•ç§»é™¤ "${issueType}"ã€‚`
      );
    } else {
      vscode.window.showInformationMessage(
        `"${issueType}" ä¸åœ¨é»‘åå•ä¸­ã€‚`
      );
    }
  }
}

/**
 * å•ä¾‹ç®¡ç†å™¨
 */
let actionProviderInstance: ProactiveCodeActionProvider | null = null;

export function getProactiveCodeActionProvider(
  context: vscode.ExtensionContext
): ProactiveCodeActionProvider {
  if (actionProviderInstance === null) {
    actionProviderInstance = new ProactiveCodeActionProvider(context);
  }
  return actionProviderInstance;
}

/**
 * æ³¨å†Œ Proactive ç›¸å…³å‘½ä»¤
 */
export function registerProactiveCommands(
  context: vscode.ExtensionContext
): void {
  const actionProvider = getProactiveCodeActionProvider(context);

  // 1. æ˜¾ç¤ºä¿®å¤è¯¦æƒ…
  const showFixDetailsCommand = vscode.commands.registerCommand(
    'vsyuangs.proactive.showFixDetails',
    async (issue: SecurityIssue) => {
      const message = `
ğŸ”§ ä¿®å¤å»ºè®®: ${issue.ruleId}

é—®é¢˜æè¿°: ${issue.message}

å»ºè®®ä¿®å¤:
${issue.suggestion || 'æš‚æ— å…·ä½“å»ºè®®'}

ç±»å‹: ${issue.type}
ä¸¥é‡ç¨‹åº¦: ${issue.severity}
ä½ç½®: è¡Œ ${issue.line !== undefined ? issue.line + 1 : 'N/A'}, åˆ— ${issue.column !== undefined ? issue.column + 1 : 'N/A'}
      `.trim();

      await vscode.window.showInformationMessage(message);
    }
  );

  // 2. æ˜¾ç¤ºé—®é¢˜è¯¦æƒ…
  const showIssueDetailsCommand = vscode.commands.registerCommand(
    'vsyuangs.proactive.showIssueDetails',
    async (issue: SecurityIssue) => {
      const message = `
ğŸ” é—®é¢˜è¯¦æƒ…

è§„åˆ™ ID: ${issue.ruleId}
é—®é¢˜æè¿°: ${issue.message}

ç±»å‹: ${issue.type}
ä¸¥é‡ç¨‹åº¦: ${issue.severity}
ä½ç½®: è¡Œ ${issue.line !== undefined ? issue.line + 1 : 'N/A'}, åˆ— ${issue.column !== undefined ? issue.column + 1 : 'N/A'}
      `.trim();

      await vscode.window.showInformationMessage(message);
    }
  );

  // 3. å¿½ç•¥æ­¤æ¬¡
  const ignoreOnceCommand = vscode.commands.registerCommand(
    'vsyuangs.proactive.ignoreOnce',
    async (issue: SecurityIssue) => {
      await actionProvider.recordFeedback(issue.type, 'ignored');
      
      // æ¸…é™¤å½“å‰ diagnostic
      const editor = vscode.window.activeTextEditor;
      if (editor) {
        const diagnostics = vscode.languages.getDiagnostics(editor.document.uri);
        const filtered = diagnostics.filter(
          d => !((d as any).ruleId === issue.ruleId)
        );
        // æ³¨æ„ï¼šè¿™é‡Œä¸èƒ½ç›´æ¥ä¿®æ”¹ diagnosticï¼Œå› ä¸ºå®ƒä»¬æ˜¯ç”± ProactiveGuard ç®¡ç†çš„
        // æˆ‘ä»¬åªè®°å½•åé¦ˆï¼Œè®© ProactiveGuard åœ¨ä¸‹æ¬¡æ‰«ææ—¶å¤„ç†
      }

      vscode.window.showInformationMessage('å·²å¿½ç•¥æ­¤æ¬¡å»ºè®®');
    }
  );

  // 4. æ·»åŠ åˆ°é»‘åå•
  const addToBlacklistCommand = vscode.commands.registerCommand(
    'vsyuangs.proactive.addToBlacklist',
    async (issue: SecurityIssue) => {
      const confirm = await vscode.window.showWarningMessage(
        `ç¡®å®šè¦å°† "${issue.type}" åŠ å…¥é»‘åå•å—ï¼Ÿ\n\nä»¥åå°†å¤§å¹…å‡å°‘æ­¤ç±»å»ºè®®ã€‚`,
        'ç¡®å®š',
        'å–æ¶ˆ'
      );

      if (confirm === 'ç¡®å®š') {
        await actionProvider.addToBlacklist(issue.type);
      }
    }
  );

  // 5. ä»é»‘åå•ç§»é™¤
  const removeFromBlacklistCommand = vscode.commands.registerCommand(
    'vsyuangs.proactive.removeFromBlacklist',
    async (issue: SecurityIssue) => {
      await actionProvider.removeFromBlacklist(issue.type);
    }
  );

  // 6. æ˜¾ç¤ºåå¥½ç»Ÿè®¡
  const showStatsCommand = vscode.commands.registerCommand(
    'vsyuangs.showScanStats',
    async () => {
      const stats = await actionProvider.preferenceMemory.getStats();
      const recordCount = await actionProvider.preferenceMemory.getRecordCount();
      const blacklist = await actionProvider.preferenceMemory.getBlacklist();
      const whitelist = await actionProvider.preferenceMemory.getWhitelist();

      let message = `
ğŸ“Š æ‰«æç»Ÿè®¡
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

æ€»åé¦ˆè®°å½•: ${stats.totalRecords}
å½“å‰è®°å½•æ•°: ${recordCount}
ç»Ÿè®¡æ—¶é—´æ®µ: ${new Date(stats.startTime).toLocaleDateString()} - ç°åœ¨

ğŸš« é»‘åå• (${blacklist.length}):
${blacklist.length > 0 ? blacklist.map((t: string) => `  â€¢ ${t}`).join('\n') : '  (æ— )'}

âœ… ç™½åå• (${whitelist.length}):
${whitelist.length > 0 ? whitelist.map((t: string) => `  â€¢ ${t}`).join('\n') : '  (æ— )'}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

æç¤º: ä½¿ç”¨ "Ctrl+Shift+P" -> "vsyuangs: æ¸…ç©ºæ‰«æå†å²" å¯æ¸…ç©ºæ‰€æœ‰è®°å½•ã€‚
      `.trim();

      await vscode.window.showInformationMessage(message);
    }
  );

  // 7. æ¸…ç©ºæ‰«æå†å²
  const clearHistoryCommand = vscode.commands.registerCommand(
    'vsyuangs.clearScanHistory',
    async () => {
      const confirm = await vscode.window.showWarningMessage(
        'ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ‰«æå†å²å’Œåå¥½è®°å½•å—ï¼Ÿ\n\næ­¤æ“ä½œä¸å¯æ¢å¤ã€‚',
        'ç¡®å®š',
        'å–æ¶ˆ'
      );

      if (confirm === 'ç¡®å®š') {
        await actionProvider.preferenceMemory.clear();
        vscode.window.showInformationMessage('å·²æ¸…ç©ºæ‰€æœ‰è®°å½•');
      }
    }
  );

  // 8. æ‰‹åŠ¨è§¦å‘æ‰«æ
  const triggerScanCommand = vscode.commands.registerCommand(
    'vsyuangs.triggerManualScan',
    async () => {
      const editor = vscode.window.activeTextEditor;
      if (!editor) {
        vscode.window.showWarningMessage('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªæ–‡ä»¶');
        return;
      }

      vscode.window.showInformationMessage(
        'æ‰‹åŠ¨æ‰«æåŠŸèƒ½éœ€è¦ ProactiveGuard æ”¯æŒã€‚\nè¯·ä¿å­˜æ–‡ä»¶ä»¥è§¦å‘è‡ªåŠ¨æ‰«æã€‚'
      );
    }
  );

  context.subscriptions.push(
    showFixDetailsCommand,
    showIssueDetailsCommand,
    ignoreOnceCommand,
    addToBlacklistCommand,
    removeFromBlacklistCommand,
    showStatsCommand,
    clearHistoryCommand,
    triggerScanCommand
  );

  console.log('[ProactiveCodeActionProvider] Commands registered');
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/provider/ReviewDiagnosticsProvider.ts

````typescript
/**
 * Review Diagnostics Provider
 * 
 * åŠŸèƒ½ï¼š
 * - å°† AI Review ç»“æœè½¬æ¢ä¸º VS Code Diagnosticsï¼ˆæ³¢æµªçº¿æ ‡æ³¨ï¼‰
 * - åœ¨ç¼–è¾‘å™¨ä¸­ç›´æ¥æ˜¾ç¤ºå®¡æŸ¥å»ºè®®
 * - æä¾› Code Actionï¼ˆå¿«é€Ÿä¿®å¤ï¼‰
 * 
 * ç”¨æˆ·ä½“éªŒï¼š
 * - ä¸éœ€è¦çœ‹ä¾§è¾¹æ ï¼Œç›´æ¥åœ¨ä»£ç è¡Œæ—è¾¹çœ‹åˆ° AI æç¤º
 * - ä¸€é”®åº”ç”¨ä¿®å¤å»ºè®®
 */

import * as vscode from 'vscode';
import { ReviewResultV1, ReviewIssue, ReviewSuggestion } from '../../core/reviewSchema';
import { DiffParser } from '../../core/diff';
import { DiffSecurityValidator } from '../../core/diffSecurityValidator';
import { DiffApplier } from '../../core/diff';

/**
 * Diagnostics ç®¡ç†
 */
export class ReviewDiagnosticsProvider {
  private diagnosticCollection: vscode.DiagnosticCollection;
  private codeActionProvider: ReviewCodeActionProvider;
  private securityValidator: DiffSecurityValidator;

  constructor() {
    this.diagnosticCollection = vscode.languages.createDiagnosticCollection('vsyuangs-review');
    this.codeActionProvider = new ReviewCodeActionProvider();
    this.securityValidator = new DiffSecurityValidator();

    // æ³¨å†Œ Code Action Provider
    vscode.languages.registerCodeActionsProvider('*', this.codeActionProvider);
  }

  /**
   * æ›´æ–° Diagnosticsï¼ˆä» ReviewResultV1ï¼‰
   */
  updateDiagnostics(reviewResult: ReviewResultV1): void {
    // æ¸…ç©ºä¹‹å‰çš„ diagnostics
    this.diagnosticCollection.clear();

    // è½¬æ¢æ¯ä¸ª issue ä¸º diagnostic
    const diagnosticsMap = new Map<string, vscode.Diagnostic[]>();

    for (const issue of reviewResult.issues) {
      if (!issue.location) {
        // æ²¡æœ‰ä½ç½®çš„ issueï¼Œè·³è¿‡ï¼ˆæˆ–è€…å¯ä»¥æ˜¾ç¤ºä¸º workspace-wideé—®é¢˜ï¼‰
        continue;
      }

      const diagnostic = this.createDiagnostic(issue);
      
      // æŒ‰ URI åˆ†ç»„
      const uri = this.getFileUri(issue.location.filePath);
      if (!diagnosticsMap.has(uri.toString())) {
        diagnosticsMap.set(uri.toString(), []);
      }
      diagnosticsMap.get(uri.toString())!.push(diagnostic);
    }

    // è®¾ç½® diagnostics
    for (const [uriString, diagnostics] of diagnosticsMap) {
      const uri = vscode.Uri.parse(uriString);
      this.diagnosticCollection.set(uri, diagnostics);
    }
  }

  /**
   * åˆ›å»ºå•ä¸ª Diagnostic
   */
  private createDiagnostic(issue: ReviewIssue): vscode.Diagnostic {
    const range = issue.location?.range 
      ? new vscode.Range(
          issue.location.range.startLine,
          issue.location.range.startChar || 0,
          issue.location.range.endLine,
          issue.location.range.endChar || Number.MAX_SAFE_INTEGER
        )
      : new vscode.Range(0, 0, 0, 0);

    const severity = this.mapSeverity(issue.severity);

    const diagnostic = new vscode.Diagnostic(
      range,
      issue.message,
      severity
    );

    // æ·»åŠ å…ƒæ•°æ®
    diagnostic.source = 'AI Review';
    diagnostic.code = issue.type;
    
    // æ·»åŠ ç›¸å…³ä¿¡æ¯
    if (issue.explanation) {
      diagnostic.relatedInformation = [
        new vscode.DiagnosticRelatedInformation(
          new vscode.Location(
            this.getFileUri(issue.location!.filePath),
            range
          ),
          issue.explanation
        )
      ];
    }

    // æ ¹æ®ç½®ä¿¡åº¦è®¾ç½®æ ‡ç­¾ï¼ˆå¯é€‰ï¼‰
    if (issue.confidence !== undefined && issue.confidence < 0.5) {
      diagnostic.tags = [vscode.DiagnosticTag.Unnecessary];
    }

    // å°† issue ID å­˜å‚¨åœ¨ data å­—æ®µä¸­ï¼Œä¾› CodeAction ä½¿ç”¨
    (diagnostic as any).issueId = issue.id;

    return diagnostic;
  }

  /**
   * æ˜ å°„ä¸¥é‡ç¨‹åº¦
   */
  private mapSeverity(severity: ReviewIssue['severity']): vscode.DiagnosticSeverity {
    switch (severity) {
      case 'error':
        return vscode.DiagnosticSeverity.Error;
      case 'warning':
        return vscode.DiagnosticSeverity.Warning;
      case 'info':
        return vscode.DiagnosticSeverity.Information;
      default:
        return vscode.DiagnosticSeverity.Hint;
    }
  }

  /**
   * è·å–æ–‡ä»¶ URI
   */
  private getFileUri(filePath: string): vscode.Uri {
    // å°è¯•åœ¨ workspace ä¸­æŸ¥æ‰¾æ–‡ä»¶
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (workspaceFolder) {
      const uri = vscode.Uri.joinPath(workspaceFolder.uri, filePath);
      return uri;
    }
    
    // å¦‚æœæ²¡æœ‰ workspaceï¼Œç›´æ¥ä½¿ç”¨æ–‡ä»¶è·¯å¾„
    return vscode.Uri.file(filePath);
  }

  /**
   * æ¸…é™¤æ‰€æœ‰ Diagnostics
   */
  clear(): void {
    this.diagnosticCollection.clear();
    this.codeActionProvider.clearSuggestions();
  }

  /**
   * åº”ç”¨ä¿®å¤å»ºè®®
   */
  async applySuggestion(suggestion: ReviewSuggestion): Promise<boolean> {
    if (!suggestion.diff) {
      vscode.window.showErrorMessage('Suggestion does not contain a diff');
      return false;
    }

    // å®‰å…¨éªŒè¯
    const parseResult = DiffParser.parse(suggestion.diff.content);
    if (!parseResult.success) {
      vscode.window.showErrorMessage('Failed to parse diff');
      return false;
    }

    const securityCheck = this.securityValidator.validate(parseResult);
    if (!securityCheck.valid) {
      const errorMessages = securityCheck.errors.map(e => e.message).join('\n');
      vscode.window.showErrorMessage(`Security validation failed:\n${errorMessages}`);
      return false;
    }

    // æ£€æŸ¥æ˜¯å¦éœ€è¦ç”¨æˆ·ç¡®è®¤
    if (suggestion.safety.requiresConfirmation) {
      const confirm = await vscode.window.showWarningMessage(
        `This change has ${suggestion.safety.risk} risk. Apply anyway?`,
        'Apply',
        'Cancel'
      );
      if (confirm !== 'Apply') {
        return false;
      }
    }

    // åº”ç”¨ diff
    const applyResult = await DiffApplier.apply(parseResult);
    if (applyResult.success) {
      vscode.window.showInformationMessage(
        `Successfully applied: ${applyResult.stats.hunksApplied} hunks, ${applyResult.stats.linesAdded} lines added, ${applyResult.stats.linesRemoved} lines removed`
      );
      return true;
    } else {
      vscode.window.showErrorMessage(`Failed to apply diff: ${applyResult.message}`);
      return false;
    }
  }

  /**
   * æ˜¾ç¤º Review æ‘˜è¦
   */
  showReviewSummary(reviewResult: ReviewResultV1): void {
    const message = `
AI Review Summary:
- Risk Level: ${reviewResult.summary.riskLevel.toUpperCase()}
- Issues: ${reviewResult.summary.issueCount}
- Suggestions: ${reviewResult.summary.suggestionCount}
    `.trim();

    vscode.window.showInformationMessage(message);
  }
}

/**
 * Code Action Providerï¼ˆå¿«é€Ÿä¿®å¤ï¼‰
 */
class ReviewCodeActionProvider implements vscode.CodeActionProvider {
  private suggestions: Map<string, ReviewSuggestion> = new Map();

  /**
   * æ›´æ–°å¯ç”¨å»ºè®®
   */
  updateSuggestions(suggestions: ReviewSuggestion[]): void {
    this.suggestions.clear();
    for (const suggestion of suggestions) {
      this.suggestions.set(suggestion.id, suggestion);
    }
  }

  /**
   * æ¸…é™¤å»ºè®®
   */
  clearSuggestions(): void {
    this.suggestions.clear();
  }

  /**
   * æä¾› Code Actions
   */
  provideCodeActions(
    document: vscode.TextDocument,
    range: vscode.Range,
    context: vscode.CodeActionContext,
    token: vscode.CancellationToken
  ): vscode.ProviderResult<vscode.CodeAction[]> {
    const actions: vscode.CodeAction[] = [];

    // æ£€æŸ¥è¯·æ±‚çš„ä»£ç æ“ä½œç±»å‹
    const only = context.only;
    const shouldIncludeQuickFix = !only || only.contains(vscode.CodeActionKind.QuickFix);

    // å¦‚æœåªè¯·æ±‚äº†å…¶ä»–ç±»å‹çš„æ“ä½œï¼ˆå¦‚ refactorï¼‰ï¼Œåˆ™ä¸è¿”å›ä»»ä½•æ“ä½œ
    if (!shouldIncludeQuickFix) {
      return actions;
    }

    // æŸ¥æ‰¾ç›¸å…³çš„ diagnostics
    for (const diagnostic of context.diagnostics) {
      if (diagnostic.source !== 'AI Review') {
        continue;
      }

      const issueId = (diagnostic as any).issueId;
      if (!issueId) {
        continue;
      }

      // æŸ¥æ‰¾å¯¹åº”çš„ suggestion
      for (const [id, suggestion] of this.suggestions) {
        // è¿™é‡Œå¯ä»¥æ ¹æ® issueId å’Œ suggestion çš„å…³ç³»æ¥åŒ¹é…
        // ç®€åŒ–å®ç°ï¼šæ‰€æœ‰ suggestions éƒ½å¯ä»¥ä½œä¸º code action
        
        const action = new vscode.CodeAction(
          suggestion.title,
          vscode.CodeActionKind.QuickFix
        );

        action.diagnostics = [diagnostic];
        
        // æ·»åŠ  Command
        action.command = {
          command: 'vsyuangs.applyReviewSuggestion',
          title: suggestion.title,
          arguments: [suggestion]
        };

        // æ ‡è®°æ˜¯å¦é¦–é€‰
        if (suggestion.safety.risk === 'low') {
          action.isPreferred = true;
        }

        actions.push(action);
      }
    }

    return actions;
  }
}

/**
 * å•ä¾‹ç®¡ç†å™¨ï¼ˆç”¨äº ProactiveGuard é›†æˆï¼‰
 */
let providerInstance: ReviewDiagnosticsProvider | null = null;

export function getReviewDiagnosticsProvider(): ReviewDiagnosticsProvider {
  if (!providerInstance) {
    providerInstance = new ReviewDiagnosticsProvider();
  }
  return providerInstance;
}

/**
 * æ³¨å†Œå‘½ä»¤
 */
export function registerReviewCommands(
  provider: ReviewDiagnosticsProvider,
  context: vscode.ExtensionContext
): void {
  // åº”ç”¨ Review å»ºè®®
  const applyCommand = vscode.commands.registerCommand(
    'vsyuangs.applyReviewSuggestion',
    async (suggestion: ReviewSuggestion) => {
      await provider.applySuggestion(suggestion);
    }
  );

  context.subscriptions.push(applyCommand);
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/sidePanel/YuangsPanel.ts

````typescript
import * as vscode from 'vscode';

export class YuangsPanel {
  private static panel: vscode.WebviewPanel | undefined;
  private static disposables: vscode.Disposable[] = [];

  static show(content: string, title: string = 'Yuangs AI') {
    if (this.panel) {
      // If panel exists, update its content
      this.panel.title = title;
      this.panel.reveal(vscode.ViewColumn.One);
      this.updateContent(content);
    } else {
      // Create new panel
      this.panel = vscode.window.createWebviewPanel(
        'yuangsPanel',
        title,
        vscode.ViewColumn.Beside,
        {
          enableScripts: true,
          retainContextWhenHidden: true
        }
      );

      this.panel.webview.html = this.getWebviewContent(content);

      this.panel.onDidDispose(() => {
        this.panel = undefined;
        while (this.disposables.length) {
          const disposable = this.disposables.pop();
          if (disposable) {
            disposable.dispose();
          }
        }
      }, null, this.disposables);

      // Handle messages from the webview
      this.panel.webview.onDidReceiveMessage(async (message) => {
        switch (message.command) {
          case 'applyOptimization':
            await this.handleApplyOptimization(message.args);
            break;
        }
      }, null, this.disposables);
    }
  }

  private static updateContent(content: string) {
    if (this.panel) {
      this.panel.webview.html = this.getWebviewContent(content);
    }
  }

  private static getWebviewContent(content: string): string {
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Yuangs AI</title>
  <style>
    /* Solarized Dark Color Palette */
    :root {
      --sol-base03: #002b36;
      --sol-base02: #073642;
      --sol-base01: #586e75;
      --sol-base00: #657b83;
      --sol-base0: #839496;
      --sol-base1: #93a1a1;
      --sol-base2: #eee8d5;
      --sol-base3: #fdf6e3;
      --sol-yellow: #b58900;
      --sol-orange: #cb4b16;
      --sol-red: #dc322f;
      --sol-magenta: #d33682;
      --sol-violet: #6c71c4;
      --sol-blue: #268bd2;
      --sol-cyan: #2aa198;
      --sol-green: #859900;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica', 'Arial', sans-serif;
      padding: 20px;
      line-height: 1.6;
      color: var(--sol-base0);
      background: var(--sol-base03);
    }
    
    /* Markdown styles */
    #content {
      color: var(--sol-base0);
    }
    #content h1, #content h2, #content h3, #content h4, #content h5, #content h6 {
      margin-top: 24px;
      margin-bottom: 16px;
      font-weight: 600;
      line-height: 1.25;
      color: var(--sol-base1);
    }
    #content h1 {
      font-size: 2em;
      padding-bottom: 0.3em;
      border-bottom: 1px solid var(--sol-base02);
      color: var(--sol-cyan);
    }
    #content h2 {
      font-size: 1.5em;
      padding-bottom: 0.3em;
      border-bottom: 1px solid var(--sol-base02);
      color: var(--sol-blue);
    }
    #content h3 {
      font-size: 1.25em;
      color: var(--sol-green);
    }
    #content h4 {
      color: var(--sol-yellow);
    }
    #content h5 {
      color: var(--sol-orange);
    }
    #content h6 {
      color: var(--sol-red);
    }
    #content p {
      margin-top: 0;
      margin-bottom: 16px;
      color: var(--sol-base0);
    }
    #content ul, #content ol {
      padding-left: 2em;
      margin-bottom: 16px;
      color: var(--sol-base0);
    }
    #content li {
      margin-bottom: 4px;
      color: var(--sol-base0);
    }
    #content blockquote {
      padding: 0 1em;
      color: var(--sol-base01);
      border-left: 0.25em solid var(--sol-violet);
      margin-bottom: 16px;
      background: var(--sol-base02);
      padding: 12px 16px;
      border-radius: 4px;
    }
    #content pre {
      background: var(--sol-base02);
      padding: 16px;
      border-radius: 6px;
      overflow: auto;
      font-size: 13px;
      margin-bottom: 16px;
      color: var(--sol-base1);
      border: 1px solid var(--sol-base01);
    }
    #content code {
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      background: var(--sol-base02);
      padding: 0.2em 0.4em;
      border-radius: 3px;
      font-size: 85%;
      color: var(--sol-cyan);
    }
    #content pre code {
      background: transparent;
      padding: 0;
      font-size: inherit;
      color: var(--sol-base0);
    }
    #content strong {
      font-weight: 600;
      color: var(--sol-orange);
    }
    #content em {
      font-style: italic;
      color: var(--sol-base1);
    }
    #content hr {
      height: 0.25em;
      padding: 0;
      margin: 24px 0;
      background-color: var(--sol-base02);
      border: 0;
    }
    #content table {
      border-spacing: 0;
      border-collapse: collapse;
      margin-bottom: 16px;
      width: 100%;
    }
    #content table th, #content table td {
      padding: 6px 13px;
      border: 1px solid var(--sol-base01);
      color: var(--sol-base0);
    }
    #content table th {
      font-weight: 600;
      background: var(--sol-base02);
      color: var(--sol-blue);
    }
    #content table tr:hover {
      background: var(--sol-base02);
    }
    #content a {
      color: var(--sol-blue);
      text-decoration: none;
    }
    #content a:hover {
      text-decoration: underline;
      color: var(--sol-cyan);
    }
    
    .button {
      background: var(--sol-blue);
      color: var(--sol-base3);
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 10px;
      font-weight: 500;
      transition: background-color 0.2s ease;
    }
    .button:hover {
      background: var(--sol-cyan);
    }
  </style>
</head>
<body>
  <div id="content"></div>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    const vscode = acquireVsCodeApi();
    
    // Parse and render markdown content
    const content = ${JSON.stringify(content)};
    document.getElementById('content').innerHTML = marked.parse(content);

    // Handle apply optimization link
    document.addEventListener('click', (e) => {
      if (e.target.tagName === 'A' && e.target.href.includes('yuangs.applyOptimization')) {
        e.preventDefault();
        const url = new URL(e.target.href);
        const args = url.searchParams.get('args');
        if (args) {
          vscode.postMessage({
            command: 'applyOptimization',
            args: JSON.parse(decodeURIComponent(args))
          });
        }
      }
    });
  </script>
</body>
</html>`;
  }

  private static escapeHtml(text: string): string {
    // Escape HTML entities manually to avoid using 'document' in webview context
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  private static async handleApplyOptimization(args: any) {
    try {
      const { documentUri, range, optimizedCode } = args;
      
      // Get the document
      const document = await vscode.workspace.openTextDocument(vscode.Uri.parse(documentUri));
      const editor = await vscode.window.showTextDocument(document);
      
      // Apply the optimization
      const edit = new vscode.WorkspaceEdit();
      const selectionRange = new vscode.Range(
        range.start.line, range.start.character,
        range.end.line, range.end.character
      );
      edit.replace(document.uri, selectionRange, optimizedCode);
      
      await vscode.workspace.applyEdit(edit);
      
      vscode.window.showInformationMessage('âœ… ä»£ç ä¼˜åŒ–å·²åº”ç”¨');
    } catch (error) {
      console.error('Error applying optimization:', error);
      vscode.window.showErrorMessage('åº”ç”¨ä»£ç ä¼˜åŒ–æ—¶å‘ç”Ÿé”™è¯¯: ' + (error as Error).message);
    }
  }
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/utils/ignoreFilter.ts

````typescript
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Parses ignore files (.gitignore, .vscodeignore) and returns exclude patterns
 * for use with vscode.workspace.findFiles
 */
export class IgnoreFilter {
    private patterns: string[] = [];

    constructor(workspaceRoot: string) {
        this.loadIgnorePatterns(workspaceRoot);
    }

    /**
     * Load and parse ignore files from the workspace
     */
    private loadIgnorePatterns(workspaceRoot: string) {
        const gitignorePath = path.join(workspaceRoot, '.gitignore');
        const vscodeignorePath = path.join(workspaceRoot, '.vscodeignore');

        // Load .gitignore patterns
        if (fs.existsSync(gitignorePath)) {
            const gitignoreContent = fs.readFileSync(gitignorePath, 'utf-8');
            this.patterns.push(...this.parseIgnoreFile(gitignoreContent));
        }

        // Load .vscodeignore patterns
        if (fs.existsSync(vscodeignorePath)) {
            const vscodeignoreContent = fs.readFileSync(vscodeignorePath, 'utf-8');
            this.patterns.push(...this.parseIgnoreFile(vscodeignoreContent));
        }

        // Always exclude node_modules if not already present
        if (!this.patterns.some(p => p.includes('node_modules'))) {
            this.patterns.push('**/node_modules/**');
        }

        console.log(`[IgnoreFilter] Loaded ${this.patterns.length} ignore patterns`);
    }

    /**
     * Parse ignore file content and return patterns
     */
    private parseIgnoreFile(content: string): string[] {
        const lines = content.split('\n');
        const patterns: string[] = [];

        for (const line of lines) {
            const trimmed = line.trim();

            // Skip empty lines and comments
            if (!trimmed || trimmed.startsWith('#')) {
                continue;
            }

            // Handle negation patterns (lines starting with !)
            if (trimmed.startsWith('!')) {
                // Negation patterns are handled differently in VSCode's findFiles
                // We'll skip them for now as findFiles doesn't support negation
                continue;
            }

            // Convert ignore pattern to VSCode glob pattern
            const globPattern = this.convertToGlob(trimmed);
            if (globPattern) {
                patterns.push(globPattern);
            }
        }

        return patterns;
    }

    /**
     * Convert ignore pattern to VSCode glob pattern
     */
    private convertToGlob(pattern: string): string | null {
        // If pattern already starts with **, keep it
        if (pattern.startsWith('**')) {
            return pattern;
        }

        // If pattern ends with /**, keep it
        if (pattern.endsWith('/**')) {
            return pattern;
        }

        // If pattern ends with /, it's a directory pattern - match all files in that directory
        if (pattern.endsWith('/')) {
            return `${pattern}**`;
        }

        // If pattern doesn't contain /, it's a filename pattern in any directory
        if (!pattern.includes('/')) {
            // For wildcard patterns like *.js, use them as-is with ** prefix
            if (pattern.includes('*')) {
                return `**/${pattern}`;
            }
            // For specific filenames, match the file itself (not a directory)
            return `**/${pattern}`;
        }

        // If pattern starts with /, it's relative to root
        if (pattern.startsWith('/')) {
            const subPattern = pattern.substring(1);
            // If it ends with /, match all files in that directory
            if (subPattern.endsWith('/')) {
                return `${subPattern}**`;
            }
            return subPattern;
        }

        // If pattern ends with *, keep it
        if (pattern.endsWith('*')) {
            return pattern;
        }

        // Check if this is a file path (contains a filename, not a directory)
        // We can detect this by checking if the last part has an extension or is a specific name
        const parts = pattern.split('/');
        const lastPart = parts[parts.length - 1];

        // If it looks like a file (has extension or is a specific filename), don't add /**
        if (lastPart.includes('.') && !lastPart.includes('*')) {
            return `**/${pattern}`;
        }

        // Also check if it's a known file pattern like .DS_Store, .gitignore, etc.
        if (lastPart.startsWith('.') && !lastPart.includes('*')) {
            return `**/${pattern}`;
        }

        // Default: treat as directory pattern, wrap with ** to match at any level
        return `**/${pattern}/**`;
    }

    /**
     * Get the combined exclude pattern for findFiles
     * Returns a comma-separated string of patterns
     */
    public getExcludePattern(): string {
        return this.patterns.join(',');
    }

    /**
     * Get all ignore patterns as an array
     */
    public getPatterns(): string[] {
        return [...this.patterns];
    }

    /**
     * Check if a file path should be ignored
     */
    public shouldIgnore(filePath: string, workspaceRoot: string): boolean {
        const relativePath = path.relative(workspaceRoot, filePath);

        for (const pattern of this.patterns) {
            if (this.matchesPattern(relativePath, pattern)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Check if a path matches a glob pattern
     */
    private matchesPattern(filePath: string, pattern: string): boolean {
        // Convert glob to regex
        let regexPattern = pattern
            // Escape special regex characters except *, ?, /
            .replace(/[.+^${}()|[\]\\]/g, '\\$&')
            // Convert ** to .*
            .replace(/\*\*/g, '.*')
            // Convert * to [^/]* (don't match across directories)
            .replace(/(?<!\.)\*/g, '[^/]*')
            // Convert ? to .
            .replace(/\?/g, '.');

        // Anchor to start and end
        regexPattern = `^${regexPattern}$`;

        const regex = new RegExp(regexPattern);
        return regex.test(filePath);
    }
}

/**
 * Create an IgnoreFilter instance for the current workspace
 */
export function createIgnoreFilter(): IgnoreFilter | null {
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) {
        console.warn('[IgnoreFilter] No workspace folder found');
        return null;
    }

    return new IgnoreFilter(workspaceFolder.uri.fsPath);
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/webview/context-panel-functions.js

````javascript
// ä¸Šä¸‹æ–‡é¢æ¿åŠŸèƒ½å‡½æ•°
// è¿™äº›å‡½æ•°å°†è¢«æ’å…¥åˆ°sidebar.htmlä¸­

// ä¸Šä¸‹æ–‡é¢æ¿å¼€å…³
function setupContextPanel() {
    // ä¸Šä¸‹æ–‡é¢æ¿å¼€å…³
    contextToggle.addEventListener('click', () => {
        contextPanel.classList.toggle('open');
        contextToggle.classList.toggle('visible');
    });

    contextClose.addEventListener('click', () => {
        contextPanel.classList.remove('open');
        contextToggle.classList.remove('visible');
    });

    // è¿‡æ»¤æŒ‰é’®äº‹ä»¶
    contextFilterBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            // ç§»é™¤æ‰€æœ‰activeç±»
            contextFilterBtns.forEach(b => b.classList.remove('active'));
            // æ·»åŠ activeç±»åˆ°å½“å‰æŒ‰é’®
            btn.classList.add('active');
            // æ›´æ–°è¿‡æ»¤å™¨
            currentFilter = btn.dataset.filter;
            // é‡æ–°æ¸²æŸ“
            renderContextItems();
        });
    });

    // æœç´¢åŠŸèƒ½
    contextSearch.addEventListener('input', (e) => {
        currentSearchQuery = e.target.value.toLowerCase();
        renderContextItems();
    });
}

// æ›´æ–°ä¸Šä¸‹æ–‡æ•°æ®
function updateContextItems(items) {
    currentContextItems = items || [];
    renderContextItems();
}

// æ¸²æŸ“ä¸Šä¸‹æ–‡é¡¹ç›®
function renderContextItems() {
    // è¿‡æ»¤ä¸Šä¸‹æ–‡é¡¹ç›®
    let filteredItems = currentContextItems.filter(item => {
        // ç±»å‹è¿‡æ»¤
        if (currentFilter !== 'all' && item.semantic !== currentFilter) {
            return false;
        }
        
        // æœç´¢è¿‡æ»¤
        if (currentSearchQuery) {
            const searchText = (item.path + item.summary + item.content).toLowerCase();
            if (!searchText.includes(currentSearchQuery)) {
                return false;
            }
        }
        
        return true;
    });

    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    contextStats.textContent = `${filteredItems.length} items`;
    
    // æ¸…ç©ºå¹¶é‡æ–°æ¸²æŸ“
    contextPanelContent.innerHTML = '';
    
    if (filteredItems.length === 0) {
        contextPanelContent.innerHTML = '<div class="context-empty">No context available</div>';
        return;
    }

    // æ¸²æŸ“æ¯ä¸ªä¸Šä¸‹æ–‡é¡¹ç›®
    filteredItems.forEach(item => {
        const itemElement = createContextItemElement(item);
        contextPanelContent.appendChild(itemElement);
    });
}

// åˆ›å»ºå•ä¸ªä¸Šä¸‹æ–‡é¡¹ç›®å…ƒç´ 
function createContextItemElement(item) {
    const div = document.createElement('div');
    div.className = 'context-item';
    
    // è·å–å›¾æ ‡
    const icon = getContextIcon(item.semantic);
    
    // è·å–é‡è¦æ€§ç™¾åˆ†æ¯”
    const importancePercent = item.importance ? 
        (item.importance.confidence * 100).toFixed(0) : '50';
    
    // è·å–æ ‡ç­¾HTML
    const badgesHtml = createContextBadges(item);
    
    // è·å–ç»Ÿè®¡ä¿¡æ¯
    const statsHtml = createContextStats(item);
    
    // è·å–å†…å®¹é¢„è§ˆ
    const previewText = item.summary || item.content.substring(0, 200);
    
    div.innerHTML = `
        <div class="context-item-header">
            <span class="context-item-icon">${icon}</span>
            <span class="context-item-title">${item.alias || item.path}</span>
            <div class="context-item-badges">${badgesHtml}</div>
        </div>
        <div class="context-item-stats">${statsHtml}</div>
        <div class="context-usage-bar">
            <div class="context-usage-fill" style="width: ${importancePercent}%"></div>
        </div>
        <div class="context-item-preview">${previewText}</div>
    `;
    
    // æ·»åŠ ç‚¹å‡»äº‹ä»¶
    div.addEventListener('click', () => {
        // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ›´å¤šäº¤äº’é€»è¾‘
        console.log('Context item clicked:', item);
    });
    
    return div;
}

// è·å–ä¸Šä¸‹æ–‡å›¾æ ‡
function getContextIcon(semantic) {
    const iconMap = {
        'source_code': 'ğŸ“„',
        'log': 'ğŸ“‹',
        'config': 'âš™ï¸',
        'documentation': 'ğŸ“š',
        'test': 'ğŸ§ª',
        'git': 'ğŸ”€',
        'evidence': 'ğŸ”',
        'diagnostics': 'âš ï¸'
    };
    
    return iconMap[semantic] || 'ğŸ“„';
}

// åˆ›å»ºæ ‡ç­¾
function createContextBadges(item) {
    const badges = [];
    
    // ç±»å‹æ ‡ç­¾
    if (item.semantic) {
        badges.push(`<span class="context-badge ${item.semantic}">${item.semantic}</span>`);
    }
    
    // æ ‡ç­¾
    if (item.tags && item.tags.length > 0) {
        item.tags.slice(0, 2).forEach(tag => {
            badges.push(`<span class="context-badge">${tag}</span>`);
        });
    }
    
    return badges.join('');
}

// åˆ›å»ºç»Ÿè®¡ä¿¡æ¯
function createContextStats(item) {
    const stats = [];
    
    // Tokenæ•°é‡
    if (item.tokens) {
        stats.push(`<span class="context-stat">ğŸ“Š ${item.tokens} tokens</span>`);
    }
    
    // ä½¿ç”¨æ¬¡æ•°
    if (item.importance && item.importance.useCount > 0) {
        stats.push(`<span class="context-stat">ğŸ”„ ${item.importance.useCount} uses</span>`);
    }
    
    // æœ€åä½¿ç”¨æ—¶é—´
    if (item.importance && item.importance.lastUsed) {
        const lastUsed = new Date(item.importance.lastUsed);
        const now = new Date();
        const diffMinutes = Math.floor((now - lastUsed) / 60000);
        
        if (diffMinutes < 1) {
            stats.push(`<span class="context-stat">â° just now</span>`);
        } else if (diffMinutes < 60) {
            stats.push(`<span class="context-stat">â° ${diffMinutes}m ago</span>`);
        } else if (diffMinutes < 1440) {
            stats.push(`<span class="context-stat">â° ${Math.floor(diffMinutes / 60)}h ago</span>`);
        } else {
            stats.push(`<span class="context-stat">â° ${Math.floor(diffMinutes / 1440)}d ago</span>`);
        }
    }
    
    return stats.join('');
}

// æ˜¾ç¤ºä¸Šä¸‹æ–‡é¢æ¿
function showContextPanel() {
    contextPanel.classList.add('open');
    contextToggle.classList.add('visible');
}

// éšè—ä¸Šä¸‹æ–‡é¢æ¿
function hideContextPanel() {
    contextPanel.classList.remove('open');
    contextToggle.classList.remove('visible');
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ vscode/webview/sidebar.html

````html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Yuangs Premium AI</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    /* =========================================
       1. å…¨å±€å˜é‡ä¸åŸºç¡€è®¾ç½®
       ========================================= */
    :root {
      /* æ ¸å¿ƒé¢œè‰²å¼•ç”¨ VS Code ä¸»é¢˜ */
      --bg-primary: var(--vscode-sideBar-background);
      --bg-secondary: var(--vscode-editor-background);
      --text-primary: var(--vscode-foreground);
      --text-secondary: var(--vscode-descriptionForeground);
      --accent: var(--vscode-textLink-foreground);
      --accent-hover: var(--vscode-textLink-activeForeground);
      --border-color: var(--vscode-widget-border);
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.1);
      --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.15);

      /* è‡ªå®šä¹‰é«˜çº§é…è‰² */
      --user-msg-bg: var(--vscode-button-background);
      --user-msg-text: var(--vscode-button-foreground);
      --ai-msg-bg: var(--vscode-editor-background);
      --radius-lg: 12px;
      --radius-md: 8px;
      --radius-sm: 4px;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Inter", sans-serif;
      font-size: var(--vscode-font-size);
      color: var(--text-primary);
      background: var(--bg-primary);
      padding: 0;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    /* æ»šåŠ¨æ¡ç¾åŒ– */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--vscode-scrollbarSlider-background);
      border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--vscode-scrollbarSlider-hoverBackground);
    }

    /* =========================================
       2. é¡¶éƒ¨å¯¼èˆªæ  (Header)
       ========================================= */
    header {
      height: 48px;
      width: 100%;
      background: var(--bg-primary);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 16px;
      box-sizing: border-box;
      z-index: 100;
      backdrop-filter: blur(10px);
      /* æ¯›ç»ç’ƒæ•ˆæœ */
    }

    /* ç§»é™¤æ—§çš„å½©è™¹çº¿ï¼Œæ”¹ç”¨ç²¾è‡´çš„ Logo æ ·å¼ */
    header::before {
      display: none;
    }

    .header-title {
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.5px;
      background: linear-gradient(90deg, var(--accent) 0%, var(--vscode-textLink-activeForeground) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .header-actions {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .icon-btn {
      background: transparent;
      border: 1px solid transparent;
      color: var(--text-primary);
      cursor: pointer;
      opacity: 0.7;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 6px;
      border-radius: var(--radius-sm);
      transition: all 0.2s ease;
    }

    .icon-btn:hover {
      opacity: 1;
      background: var(--vscode-toolbar-hoverBackground);
      transform: translateY(-1px);
    }

    .icon-btn.context-btn {
      background: var(--vscode-button-secondaryBackground);
      color: var(--vscode-button-secondaryForeground);
      border: 1px solid var(--border-color);
      padding: 4px 10px;
      font-size: 12px;
      font-weight: 500;
      opacity: 1;
    }

    .icon-btn.context-btn:hover {
      background: var(--vscode-button-secondaryHoverBackground);
    }

    /* æ¨¡å‹é€‰æ‹©å™¨ä¼˜åŒ– */
    .model-selector {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      background: var(--vscode-input-background);
      border: 1px solid var(--border-color);
      border-radius: 100px;
      /* èƒ¶å›Šæ ·å¼ */
      cursor: pointer;
      transition: all 0.2s;
      font-size: 12px;
    }

    .model-selector:hover {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(127, 127, 127, 0.1);
    }

    .model-selector-label {
      opacity: 0.9;
      white-space: nowrap;
    }

    .model-selector-dropdown {
      position: absolute;
      top: 40px;
      right: 12px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-md);
      min-width: 200px;
      max-height: 300px;
      overflow-y: auto;
      display: none;
      z-index: 3000;
      padding: 4px;
    }

    .model-option {
      padding: 8px 12px;
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.85em;
      border-radius: var(--radius-sm);
      margin-bottom: 2px;
    }

    .model-selector-dropdown.visible {
      display: block;
    }

    .model-option:hover {
      background: var(--vscode-list-hoverBackground);
    }

    .model-option.active {
      background: var(--vscode-list-activeSelectionBackground);
      color: var(--vscode-list-activeSelectionForeground);
    }

    .model-option-name {
      flex: 1;
    }

    .model-option-icon {
      opacity: 0.5;
      font-size: 0.8em;
    }

    .model-option.active .model-option-icon {
      opacity: 1;
    }

    /* =========================================
       3. å·¥å…·æ  (Git Toolbar)
       ========================================= */
    .git-toolbar {
      padding: 10px 16px;
      display: flex;
      gap: 12px;
      border-bottom: 1px solid var(--border-color);
      background: var(--bg-primary);
    }

    .secondary-btn {
      background: var(--vscode-button-secondaryBackground);
      color: var(--vscode-button-secondaryForeground);
      border: 1px solid transparent;
      padding: 6px 16px;
      border-radius: var(--radius-md);
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.2s;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .secondary-btn:hover {
      background: var(--vscode-button-secondaryHoverBackground);
      transform: translateY(-1px);
      box-shadow: var(--shadow-sm);
    }

    /* Patch ä¸‹æ‹‰èœå• */
    .patch-dropdown {
      position: absolute;
      top: calc(100% + 8px);
      left: 0;
      background: var(--vscode-editor-background);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-md);
      min-width: 200px;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      z-index: 3000;
      padding: 4px;
    }

    .patch-dropdown.visible {
      display: block;
    }

    .patch-option {
      padding: 10px 12px;
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.85em;
      border-radius: var(--radius-sm);
      margin-bottom: 2px;
    }

    .patch-option:hover {
      background: var(--vscode-list-hoverBackground);
    }

    .patch-option span:first-child {
      font-size: 1.4em;
      opacity: 0.8;
    }

    .patch-option strong {
      display: block;
      font-size: 1em;
    }

    .patch-option span:last-child {
      display: block;
      opacity: 0.6;
      font-size: 0.9em;
      margin-top: 2px;
    }

    /* =========================================
       4. èŠå¤©åŒºåŸŸ (Chat Container)
       ========================================= */
    #chat-container {
      flex-grow: 1;
      overflow-y: auto;
      padding: 20px 16px;
      display: flex;
      flex-direction: column;
      gap: 24px;
      /* å¢åŠ æ¶ˆæ¯é—´è· */
    }

    .message {
      padding: 12px 16px;
      border-radius: var(--radius-lg);
      max-width: 85%;
      word-wrap: break-word;
      position: relative;
      animation: fadeIn 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;
      line-height: 1.6;
      font-size: 13px;
    }

    /* ç”¨æˆ·æ¶ˆæ¯ï¼šç°ä»£æ¸å˜æˆ–çº¯è‰² */
    .user-message {
      align-self: flex-end;
      background: var(--user-msg-bg);
      color: var(--user-msg-text);
      border-bottom-right-radius: 2px;
      box-shadow: var(--shadow-sm);
    }

    /* AI æ¶ˆæ¯ï¼šå¹²å‡€çš„å¡ç‰‡é£æ ¼ */
    .ai-message {
      align-self: flex-start;
      background: var(--ai-msg-bg);
      border: 1px solid var(--border-color);
      border-bottom-left-radius: 2px;
      box-shadow: var(--shadow-sm);
    }

    /* AI æ¶ˆæ¯å†…çš„ Markdown æ ·å¼ä¼˜åŒ– */
    .ai-message p {
      margin: 0.5em 0;
    }

    .ai-message p:first-child {
      margin-top: 0;
    }

    .ai-message p:last-child {
      margin-bottom: 0;
    }

    .ai-message code {
      font-family: 'Fira Code', Consolas, monospace;
      font-size: 0.9em;
      background: rgba(127, 127, 127, 0.15);
      padding: 2px 5px;
      border-radius: 4px;
      color: var(--vscode-textPreformat-foreground);
    }

    /* ä»£ç å—ï¼šæ·»åŠ  macOS é£æ ¼å¤´éƒ¨ */
    .ai-message pre {
      background: var(--vscode-editor-background);
      border: 1px solid var(--border-color);
      padding: 30px 12px 12px 12px;
      /* Top padding reserved for header */
      border-radius: 8px;
      overflow-x: auto;
      margin: 12px 0;
      position: relative;
    }

    .ai-message pre::before {
      /* æ¨¡æ‹Ÿ macOS çª—å£çº¢é»„ç»¿ç‚¹ */
      content: "";
      position: absolute;
      top: 10px;
      left: 12px;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ff5f56;
      /* Red */
      box-shadow: 15px 0 0 #ffbd2e, 30px 0 0 #27c93f;
      /* Yellow & Green */
      opacity: 0.8;
    }

    /* Diff å—ç‰¹æ®Šæ ·å¼ */
    .ai-message pre.diff-block {
      border-left: 3px solid var(--accent);
    }

    .ai-message pre.diff-block::before {
      display: none;
      /* Diff å—ä¸æ˜¾ç¤ºçº¢ç»¿ç¯ï¼Œæ”¹ç”¨æ–‡å­— */
    }

    .ai-message pre.diff-block::after {
      content: "REVIEW DIFF";
      position: absolute;
      top: 6px;
      left: 8px;
      font-size: 10px;
      font-weight: bold;
      color: var(--text-secondary);
      letter-spacing: 1px;
    }

    /* æ¶ˆæ¯æ“ä½œæ  */
    .message-actions {
      position: absolute;
      top: 8px;
      right: 8px;
      display: flex;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 10;
    }

    .message:hover .message-actions {
      opacity: 1;
    }

    /* æ¶ˆæ¯æ“ä½œæŒ‰é’® */
    .message-action-btn {
      background: rgba(0, 0, 0, 0.6);
      border: none;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      font-size: 14px;
      transition: all 0.2s;
    }

    .message-action-btn:hover {
      background: var(--vscode-list-hoverBackground);
      color: var(--text-primary);
      transform: none;
    }

    .user-message .message-action-btn {
      /* ç”¨æˆ·æ¶ˆæ¯æ˜¯æ·±è‰²èƒŒæ™¯æ—¶ï¼Œæ“ä½œæ éœ€è¦é€‚é… */
      background: rgba(255, 255, 255, 0.3);
      color: white;
    }

    .user-message .message-action-btn:hover {
      background: rgba(255, 255, 255, 0.5);
    }

    /* åº”ç”¨ Diff æŒ‰é’® */
    .apply-diff-btn {
      position: absolute;
      top: 4px;
      right: 8px;
      background: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      padding: 4px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75em;
      font-family: var(--vscode-font-family);
      display: flex;
      align-items: center;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.2s, background 0.2s;
      z-index: 10;
    }

    .ai-message pre.diff-block:hover .apply-diff-btn {
      opacity: 1;
    }

    .apply-diff-btn:hover {
      background: var(--vscode-button-hoverBackground);
    }

    .apply-diff-btn:active {
      transform: scale(0.95);
    }

    .apply-diff-btn.applied {
      background: var(--vscode-testing-iconPassed);
      opacity: 1;
    }

    .apply-diff-btn.error {
      background: var(--vscode-testing-iconFailed);
      opacity: 1;
    }

    /* ç³»ç»Ÿæ¶ˆæ¯ */
    .system-message {
      align-self: center;
      font-size: 11px;
      color: var(--text-secondary);
      background: rgba(127, 127, 127, 0.05);
      padding: 4px 12px;
      border-radius: 100px;
      border: 1px solid transparent;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(8px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* =========================================
       5. åº•éƒ¨è¾“å…¥åŒºåŸŸ (Input Area)
       ========================================= */
    #input-area {
      padding: 16px 20px 24px 20px;
      background: transparent;
      /* ç§»é™¤èƒŒæ™¯è‰²ï¼Œå®ç°æ‚¬æµ®æ„Ÿ */
      border-top: none;
      position: relative;
    }

    /* æ·»åŠ æ¸å˜é®ç½©ï¼Œé˜²æ­¢èŠå¤©å†…å®¹çªç„¶æˆªæ–­ */
    #input-area::before {
      content: "";
      position: absolute;
      top: -20px;
      left: 0;
      right: 0;
      height: 20px;
      background: linear-gradient(to top, var(--bg-primary), transparent);
      pointer-events: none;
    }

    .input-wrapper {
      display: flex;
      background: var(--vscode-input-background);
      border: 1px solid var(--border-color);
      border-radius: 16px;
      /* æ›´å¤§çš„åœ†è§’ */
      padding: 8px 12px;
      align-items: flex-end;
      /* å¯¹é½åˆ°åº•éƒ¨ */
      box-shadow: var(--shadow-md);
      /* æ‚¬æµ®é˜´å½± */
      transition: all 0.2s ease;
    }

    .input-wrapper:focus-within {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(127, 127, 127, 0.1);
      transform: translateY(-1px);
    }

    #user-input {
      padding: 8px 4px;
      font-size: 13px;
      line-height: 1.5;
      flex-grow: 1;
      background: transparent;
      color: var(--vscode-input-foreground);
      border: none;
      outline: none;
      resize: none;
      max-height: 120px;
      min-height: 24px;
      font-family: inherit;
    }

    #send-btn,
    #stop-btn {
      margin-bottom: 2px;
      width: 28px;
      height: 28px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #send-btn {
      background: var(--accent);
      color: white;
      border: none;
      transition: all 0.2s;
    }

    #send-btn:hover {
      opacity: 0.9;
      transform: scale(1.05);
    }

    #stop-btn {
      background: var(--vscode-errorForeground);
      color: var(--vscode-button-foreground);
      border: none;
      display: none;
      animation: pulse 1.5s infinite;
    }

    #stop-btn:hover {
      opacity: 0.8;
    }

    #stop-btn.visible {
      display: flex;
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(235, 86, 86, 0.7);
      }

      70% {
        box-shadow: 0 0 0 6px rgba(235, 86, 86, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(235, 86, 86, 0);
      }
    }

    /* =========================================
       6. å»ºè®®åˆ—è¡¨
       ========================================= */
    #suggestions-list {
      position: absolute;
      bottom: 100%;
      left: 16px;
      right: 16px;
      background: var(--vscode-editor-background);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      box-shadow: var(--shadow-md);
      max-height: 200px;
      overflow-y: auto;
      display: none;
      z-index: 1000;
      margin-bottom: 8px;
    }

    .suggestion-item {
      padding: 8px 12px;
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.9em;
    }

    .suggestion-item:hover,
    .suggestion-item.selected {
      background: var(--vscode-list-hoverBackground);
      color: var(--vscode-list-hoverForeground);
    }

    .suggestion-icon {
      opacity: 0.7;
      font-size: 1.1em;
    }

    /* =========================================
       7. ä¾§è¾¹é¢æ¿ (Context & Files)
       ========================================= */
    #files-panel,
    #context-panel {
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.2);
      /* æ›´æŸ”å’Œçš„æ·±é˜´å½± */
      background: var(--bg-secondary);
      backdrop-filter: blur(20px);
    }

    .files-panel-header,
    .context-panel-header {
      height: 48px;
      padding: 0 16px;
      border-bottom: 1px solid var(--border-color);
      background: transparent;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .files-panel-title,
    .context-panel-title {
      font-weight: 600;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .files-panel-stats,
    .context-panel-stats {
      font-size: 11px;
      opacity: 0.7;
    }

    /* æ–‡ä»¶é¢æ¿ */
    #files-panel {
      position: fixed;
      top: 48px;
      left: -400px;
      width: 380px;
      height: calc(100vh - 48px);
      border-right: 1px solid var(--border-color);
      border-top: 1px solid var(--border-color);
      z-index: 1000;
      transition: left 0.3s ease;
      display: flex;
      flex-direction: column;
    }

    #files-panel.open {
      left: 0;
    }

    .files-panel-close,
    .context-panel-close {
      background: transparent;
      border: none;
      color: var(--text-primary);
      cursor: pointer;
      padding: 4px;
      opacity: 0.6;
      transition: opacity 0.2s;
    }

    .files-panel-close:hover,
    .context-panel-close:hover {
      opacity: 1;
    }

    .files-panel-controls {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-color);
    }

    .files-search,
    .context-search {
      flex: 1;
      background: var(--vscode-input-background);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 8px 12px;
      color: var(--vscode-input-foreground);
      font-size: 12px;
      outline: none;
      transition: border-color 0.2s;
    }

    .files-search:focus,
    .context-search:focus {
      border-color: var(--accent);
    }

    .files-panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 8px 0;
    }

    .file-tree-item {
      display: flex;
      align-items: center;
      padding: 6px 16px;
      cursor: pointer;
      transition: background 0.2s;
      user-select: none;
    }

    .file-tree-item:hover {
      background: var(--vscode-list-hoverBackground);
    }

    .file-tree-item.selected {
      background: var(--vscode-list-activeSelectionBackground);
      color: var(--vscode-list-activeSelectionForeground);
    }

    .file-tree-icon {
      margin-right: 8px;
      font-size: 1em;
      opacity: 0.8;
      flex-shrink: 0;
    }

    .file-tree-icon.expanded::before {
      content: "â–¼";
      font-size: 0.7em;
      margin-right: 2px;
    }

    .file-tree-icon.collapsed::before {
      content: "â–¶";
      font-size: 0.7em;
      margin-right: 2px;
    }

    .file-tree-name {
      flex: 1;
      font-size: 13px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .file-tree-children {
      display: none;
    }

    .file-tree-children.expanded {
      display: block;
    }

    .file-tree-item.folder {
      font-weight: 500;
    }

    .file-tree-item.file {
      opacity: 0.9;
    }

    .file-empty,
    .file-loading {
      text-align: center;
      padding: 40px 20px;
      opacity: 0.5;
      font-size: 13px;
    }

    /* ä¸Šä¸‹æ–‡é¢æ¿ */
    #context-panel {
      position: fixed;
      top: 48px;
      right: -400px;
      width: 380px;
      height: calc(100vh - 48px);
      border-left: 1px solid var(--border-color);
      border-top: 1px solid var(--border-color);
      z-index: 1000;
      transition: right 0.3s ease;
      display: flex;
      flex-direction: column;
    }

    #context-panel.open {
      right: 0;
    }

    .context-panel-controls {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .context-filter-btn {
      background: var(--vscode-button-secondaryBackground);
      border: 1px solid transparent;
      border-radius: 6px;
      padding: 4px 10px;
      color: var(--text-primary);
      cursor: pointer;
      font-size: 11px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .context-filter-btn:hover,
    .context-filter-btn.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .context-panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }

    .context-item {
      background: transparent;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s;
      overflow: hidden;
    }

    .context-item.collapsed .context-item-details {
      display: none;
    }

    .context-item.collapsed {
      padding: 10px 12px;
    }

    .context-item.expanded {
      padding: 12px;
    }

    .context-item:hover {
      background: var(--vscode-list-hoverBackground);
      border-color: var(--accent);
    }

    .context-item-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .context-item.collapsed .context-item-header {
      margin-bottom: 0;
    }

    .context-item-toggle {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.6;
      transition: transform 0.2s;
    }

    .context-item.expanded .context-item-toggle {
      transform: rotate(90deg);
    }

    .context-item-details {
      animation: slideDown 0.2s ease-out;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .context-item-icon {
      font-size: 1.2em;
    }

    .context-item-title {
      flex: 1;
      font-weight: 500;
      font-size: 13px;
      word-break: break-all;
    }

    .context-item-badges {
      display: flex;
      gap: 4px;
    }

    .context-badge {
      background: rgba(127, 127, 127, 0.15);
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 0.5px;
      opacity: 0.9;
    }

    .context-badge.source_code {
      background: rgba(86, 156, 214, 0.2);
    }

    .context-badge.log {
      background: rgba(152, 195, 121, 0.2);
    }

    .context-badge.git {
      background: rgba(229, 192, 123, 0.2);
    }

    .context-badge.diagnostics {
      background: rgba(224, 108, 117, 0.2);
    }

    .context-item-stats {
      display: flex;
      gap: 12px;
      font-size: 11px;
      opacity: 0.7;
      margin-bottom: 8px;
    }

    .context-stat {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .context-usage-bar {
      height: 3px;
      background: rgba(127, 127, 127, 0.15);
      border-radius: 2px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .context-usage-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-hover));
      border-radius: 2px;
      transition: width 0.3s ease;
    }

    .context-item-preview {
      background: rgba(0, 0, 0, 0.05);
      border-radius: 6px;
      padding: 8px;
      font-family: 'Fira Code', Consolas, monospace;
      font-size: 11px;
      max-height: 100px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .context-empty {
      text-align: center;
      padding: 40px 20px;
      opacity: 0.5;
      font-size: 13px;
    }

    /* =========================================
       8. å…¶ä»– UI ç»„ä»¶
       ========================================= */

    /* Flash Notification Toast */
    .flash-notification {
      background: var(--vscode-button-secondaryBackground);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      box-shadow: var(--shadow-md);
      top: 60px;
      right: 20px;
      /* é å³å¯¹é½ */
      border-radius: 8px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 16px;
      font-size: 13px;
      animation: slideInRight 0.3s ease-out, fadeOut 0.5s ease-in 2.5s forwards;
      max-width: 300px;
      z-index: 5000;
    }

    /* å³é”®èœå• */
    .context-menu {
      border-radius: 8px;
      padding: 4px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      box-shadow: var(--shadow-md);
      min-width: 180px;
      z-index: 10000;
      display: none;
      overflow: hidden;
    }

    .context-menu.visible {
      display: block;
    }

    .context-menu-item {
      padding: 8px 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--text-primary);
      transition: background 0.2s;
      border-radius: 4px;
    }

    .context-menu-item:hover {
      background: var(--vscode-list-hoverBackground);
      color: var(--text-primary);
    }

    .context-menu-separator {
      height: 1px;
      background: var(--border-color);
      margin: 4px 0;
    }

    /* å…‰æ ‡é—ªçƒæ•ˆæœ */
    .cursor {
      display: inline-block;
      width: 8px;
      height: 16px;
      background: var(--text-primary);
      margin-left: 4px;
      animation: blink 1s step-start infinite;
      vertical-align: middle;
      opacity: 0.8;
      border-radius: 1px;
    }

    @keyframes blink {
      50% {
        opacity: 0;
      }
    }

    /* æµå¼ä¼ è¾“æ ·å¼ */
    .streaming-draft {
      font-family: "Courier New", Consolas, Monaco, monospace;
      white-space: pre-wrap;
      word-wrap: break-word;
      line-height: 1.4;
    }

    .streaming-content {
      margin: 0;
      padding: 0;
      font-family: inherit;
      line-height: inherit;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .final-render {
      /* æœ€ç»ˆæ¸²æŸ“å®Œæˆåçš„æ ·å¼ */
    }

    /* åŠ è½½åŠ¨ç”» */
    .typing-indicator {
      display: flex;
      gap: 4px;
      padding: 4px;
    }

    .dot {
      width: 6px;
      height: 6px;
      background: var(--text-secondary);
      border-radius: 50%;
      animation: bounce 1.4s infinite ease-in-out both;
    }

    .dot:nth-child(1) {
      animation-delay: -0.32s;
    }

    .dot:nth-child(2) {
      animation-delay: -0.16s;
    }

    @keyframes bounce {

      0%,
      80%,
      100% {
        transform: scale(0);
      }

      40% {
        transform: scale(1);
      }
    }

    @keyframes slideInRight {
      from {
        opacity: 0;
        transform: translateX(100%);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
      }

      to {
        opacity: 0;
      }
    }

    /* Apply Commit Button */
    .apply-commit-btn {
      margin-top: 8px;
      background: var(--accent);
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 11px;
      font-weight: 500;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .apply-commit-btn:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }

    /* Review Tags */
    .review-tag {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: bold;
      text-transform: uppercase;
      margin-right: 6px;
      vertical-align: middle;
    }

    .tag-error {
      background: #f14c4c;
      color: white;
    }

    .tag-warning {
      background: #cca700;
      color: white;
    }

    .tag-info {
      background: #3794ef;
      color: white;
    }

    .review-item {
      border-left: 3px solid var(--accent);
      padding-left: 10px;
      margin: 8px 0;
      background: rgba(127, 127, 127, 0.1);
      padding: 8px;
      border-radius: 0 4px 4px 0;
    }

    /* =========================================
       9. æ—¥å¿—é¢æ¿ (Log Panel)
       ========================================= */
    #log-panel {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      box-shadow: var(--shadow-sm);
      display: flex;
      flex-direction: column;
      max-height: 200px;
      transition: max-height 0.3s ease;
    }

    #log-panel.collapsed {
      max-height: 40px;
      overflow: hidden;
    }

    /* Collapse log panel: hide content from layout and accessibility tree */
    #log-panel.collapsed .log-panel-content {
      display: none;
    }

    .log-panel-header {
      height: 36px;
      padding: 0 12px;
      background: var(--bg-primary);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
    }

    .log-panel-title {
      font-weight: 600;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .log-panel-stats {
      font-size: 10px;
      opacity: 0.7;
    }

    .log-panel-actions {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .log-action-btn {
      background: transparent;
      border: none;
      color: var(--text-primary);
      cursor: pointer;
      padding: 4px;
      opacity: 0.6;
      transition: opacity 0.2s;
      font-size: 12px;
    }

    .log-action-btn:hover {
      opacity: 1;
    }

    #log-toggle-btn {
      transition: transform 0.3s ease;
    }

    #log-panel.collapsed #log-toggle-btn {
      transform: rotate(180deg);
    }

    .log-panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 8px 12px;
      font-family: 'Fira Code', Consolas, monospace;
      font-size: 11px;
      line-height: 1.4;
      background: rgba(0, 0, 0, 0.02);
    }

    .log-entry {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 4px 0;
      border-bottom: 1px solid rgba(127, 127, 127, 0.1);
      cursor: pointer;
      transition: background 0.2s;
      word-break: break-all;
    }

    .log-entry:hover {
      background: rgba(127, 127, 127, 0.05);
    }

    .log-entry:last-child {
      border-bottom: none;
    }

    .log-time {
      color: var(--text-secondary);
      opacity: 0.8;
      flex-shrink: 0;
      font-size: 10px;
      min-width: 70px;
    }

    .log-level {
      font-weight: 600;
      font-size: 10px;
      padding: 2px 4px;
      border-radius: 2px;
      flex-shrink: 0;
      min-width: 50px;
      text-align: center;
    }

    .log-entry.log-info .log-level {
      color: #3794ef;
      background: rgba(55, 148, 239, 0.1);
    }

    .log-entry.log-warn .log-level {
      color: #cca700;
      background: rgba(204, 167, 0, 0.1);
    }

    .log-entry.log-error .log-level {
      color: #f14c4c;
      background: rgba(241, 76, 76, 0.1);
    }

    .log-entry.log-debug .log-level {
      color: #c5c5c5;
      background: rgba(197, 197, 197, 0.1);
    }

    .log-message {
      flex: 1;
      color: var(--text-primary);
    }

    .log-entry.log-error .log-message {
      color: #f14c4c;
    }

    .log-entry.log-warn .log-message {
      color: #d7ba7d;
    }
  </style>
</head>

<body>
  <script>
    // æ£€æµ‹æ˜¯å¦å¯ç”¨è°ƒè¯•æ¨¡å¼
    const urlParams = new URLSearchParams(window.location.search);
    const DEBUG_MODE = urlParams.get('debug') === 'true';

    // è°ƒè¯•æ—¥å¿—å‡½æ•°
    function debugLog(...args) {
      if (DEBUG_MODE) {
        console.log('[DEBUG]', ...args);
      }
    }

    // å¦‚æœæ˜¯è°ƒè¯•æ¨¡å¼ï¼Œæ˜¾ç¤ºè°ƒè¯•é¢æ¿
    window.addEventListener('DOMContentLoaded', () => {
      const debugInfo = document.getElementById('debug-info');
      if (debugInfo) {
        debugInfo.style.display = DEBUG_MODE ? 'block' : 'none';
      }
      debugLog('Debug mode:', DEBUG_MODE ? 'enabled' : 'disabled');
    });
  </script>
  <header>
    <div class="header-title">YGS AI</div>
    <div class="header-actions">
      <!-- æ¨¡å‹é€‰æ‹©å™¨ -->
      <div class="model-selector" id="model-selector" title="Select AI Model">
        <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor" style="opacity: 0.6;">
          <path
            d="M8 1a7 7 0 0 1 0 14A7 7 0 0 1 8 1zM0 8a8 8 0 1 0 16 0A8 8 0 0 0 0 8zm8 5a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm1-2.5V6H7v4.5h2z" />
        </svg>
        <span class="model-selector-label" id="current-model">Loading...</span>
        <svg width="10" height="10" viewBox="0 0 16 16" fill="currentColor" style="opacity: 0.5;">
          <path d="M8 11L3 6h2.5L8 8.5L10.5 6H13L8 11z" />
        </svg>
      </div>
      <!-- æ¨¡å‹ä¸‹æ‹‰èœå• -->
      <div class="model-selector-dropdown" id="model-dropdown">
        <!-- é€‰é¡¹å°†é€šè¿‡ JavaScript åŠ¨æ€ç”Ÿæˆ -->
      </div>
      <button class="icon-btn" id="files-toggle" title="Show Files">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
          <path
            d="M1 3.5A1.5 1.5 0 0 1 2.5 2h3.879a1.5 1.5 0 0 1 1.06.44l1.122 1.12A1.5 1.5 0 0 0 9.62 4H13.5A1.5 1.5 0 0 1 15 5.5v8a1.5 1.5 0 0 1-1.5 1.5h-11A1.5 1.5 0 0 1 1 13.5v-10zM2.5 3a.5.5 0 0 0-.5.5V13a.5.5 0 0 0 .5.5h11a.5.5 0 0 0 .5-.5V5.5a.5.5 0 0 0-.5-.5H9.62a1.5 1.5 0 0 1-1.06-.44l-1.12-1.12A1.5 1.5 0 0 0 6.38 3H2.5zM4 7.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zM4 10a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1h-4a.5.5 0 0 1-.5-.5z" />
        </svg>
      </button>
      <button class="icon-btn context-btn" id="context-toggle" title="Show Context Panel" style="z-index: 2000">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
          <path
            d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0zM4.5 7.5a.5.5 0 0 0 0 1h5.793l-2.147 2.146a.5.5 0 0 0 .708.708l3-3a.5.5 0 0 0 0-.708l-3-3a.5.5 0 0 0-.708.708L10.293 7.5H4.5z" />
        </svg>
        <span style="margin-left: 4px; font-size: 0.8em">Context</span>
      </button>
      <button class="icon-btn" id="export-btn" title="Export Chat History (.md)">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
          <path
            d="M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5L14 4.5zM13 5H9V1h4v4zM3 2v12h10V6H8V2H3z" />
        </svg>
      </button>
      <button class="icon-btn" id="clear-btn" title="Clear Chat">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M10 3h3v1h-1v9l-1 1H4l-1-1V4H2V3h3V2a1 1 0 0 1 1-1h3a1 1 0 0 1 1 1v1zM9 2H6v1h3V2zM4 4v9h7V4H4z" />
        </svg>
      </button>
    </div>
  </header>

  <div class="git-toolbar">
    <button class="secondary-btn" id="commit-btn" title="Generate Conventional Commit Message based on staged changes">
      <span>ğŸ“</span> Commit
    </button>
    <button class="secondary-btn" id="review-btn" title="Run Expert Code Review on staged changes">
      <span>ğŸ”</span> Review
    </button>
    <div style="position: relative;">
      <button class="secondary-btn" id="patch-btn" title="Generate Git Patch">
        <span>ğŸ“‹</span> Patch
        <svg width="10" height="10" viewBox="0 0 16 16" fill="currentColor" style="opacity: 0.5; margin-left: 4px;">
          <path d="M8 11L3 6h2.5L8 8.5L10.5 6H13L8 11z" />
        </svg>
      </button>
      <!-- Patch ä¸‹æ‹‰èœå• -->
      <div class="patch-dropdown" id="patch-dropdown">
        <div class="patch-option" data-type="staged">
          <span>ğŸ“¦</span>
          <div>
            <strong>æš‚å­˜åŒº Patch</strong>
            <span style="opacity: 0.6; font-size: 0.9em;">Staged changes</span>
          </div>
        </div>
        <div class="patch-option" data-type="unstaged">
          <span>ğŸ“„</span>
          <div>
            <strong>å·¥ä½œåŒº Patch</strong>
            <span style="opacity: 0.6; font-size: 0.9em;">Unstaged changes</span>
          </div>
        </div>
        <div class="patch-option" data-type="last">
          <span>ğŸ“œ</span>
          <div>
            <strong>æœ€åä¸€æ¬¡æäº¤ Patch</strong>
            <span style="opacity: 0.6; font-size: 0.9em;">Last commit</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- è°ƒè¯•ä¿¡æ¯ -->
  <div id="debug-info" style="font-size: 10px; color: #888; padding: 5px; border-top: 1px solid #333;">
    Debug: <span id="debug-status">Ready</span>
  </div>

  <!-- æ—¥å¿—åŒºåŸŸ -->
  <div id="log-panel">
    <div class="log-panel-header">
      <div class="log-panel-title">
        <span>ğŸ“‹ Debug Log</span>
        <span class="log-panel-stats" id="log-stats">0 entries</span>
      </div>
      <div class="log-panel-actions">
        <button class="log-action-btn" id="log-clear-btn" title="Clear Logs">
          ğŸ—‘ï¸
        </button>
        <button class="log-action-btn" id="log-copy-btn" title="Copy All Logs">
          ğŸ“‹
        </button>
        <button class="log-action-btn" id="log-toggle-btn" title="Toggle Log Panel">
          â–¼
        </button>
      </div>
    </div>
    <div class="log-panel-content" id="log-panel-content">
      <div class="log-entry log-info">
        <span class="log-time">--:--:--</span>
        <span class="log-level">[INFO]</span>
        <span class="log-message">Debug panel initialized. Click logs to copy.</span>
      </div>
    </div>
  </div>

  <div id="chat-container">
    <!-- åˆå§‹ä¸ºç©ºï¼Œç­‰å¾…å†å²è®°å½•åŠ è½½ -->
  </div>

  <div id="input-area">
    <div id="suggestions-list"></div>
    <div class="input-wrapper">
      <textarea id="user-input" rows="1" placeholder="Type your message..."></textarea>
      <button id="send-btn">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
          <path
            d="M1.146 1.146a.5.5 0 0 1 .538-.093l13 5a.5.5 0 0 1 0 .94l-13 5a.5.5 0 0 1-.667-.615L2.854 8 1.017 2.618a.5.5 0 0 1 .129-.472zM3.854 8l-1.5 4.34L13.84 8 2.354 3.66 3.854 8z" />
        </svg>
      </button>
      <button id="stop-btn" title="Stop Generation">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
          <path d="M4 4h8v8H4V4z" />
        </svg>
      </button>
    </div>
  </div>

  <!-- æ–‡ä»¶é¢æ¿ -->
  <div id="files-panel">
    <div class="files-panel-header">
      <div class="files-panel-title">
        <span>ğŸ“ Files</span>
        <span class="files-panel-stats" id="files-stats">Loading...</span>
      </div>
      <button class="files-panel-close" id="files-close">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
          <path
            d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z" />
        </svg>
      </button>
    </div>
    <div class="files-panel-controls">
      <input type="text" class="files-search" id="files-search" placeholder="Search files..." />
    </div>
    <div class="files-panel-content" id="files-panel-content">
      <div class="file-loading">Loading files...</div>
    </div>
  </div>

  <!-- å³é”®èœå• -->
  <div class="context-menu" id="context-menu">
    <div class="context-menu-item" id="context-copy">
      <span>ğŸ“‹</span>
      <span>å¤åˆ¶æ¶ˆæ¯</span>
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" id="context-delete">
      <span>ğŸ—‘ï¸</span>
      <span>åˆ é™¤æ¶ˆæ¯</span>
    </div>
  </div>

  <!-- ä¸Šä¸‹æ–‡é¢æ¿ -->
  <div id="context-panel">
    <div class="context-panel-header">
      <div class="context-panel-title">
        <span>ğŸ“‹ Context</span>
        <span class="context-panel-stats" id="context-stats">0 items</span>
      </div>
      <button class="context-panel-close" id="context-close">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
          <path
            d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z" />
        </svg>
      </button>
    </div>
    <div class="context-panel-controls">
      <input type="text" class="context-search" id="context-search" placeholder="Search context..." />
      <button class="context-filter-btn active" data-filter="all">All</button>
      <button class="context-filter-btn" data-filter="source_code">
        Code
      </button>
      <button class="context-filter-btn" data-filter="log">Log</button>
      <button class="context-filter-btn" data-filter="git">Git</button>
    </div>
    <div class="context-panel-content" id="context-panel-content">
      <div class="context-empty">No context available</div>
    </div>
  </div>

  <script>
    const vscode = acquireVsCodeApi();
    const chatContainer = document.getElementById("chat-container");
    const userInput = document.getElementById("user-input");
    const sendBtn = document.getElementById("send-btn");
    const stopBtn = document.getElementById("stop-btn");
    const exportBtn = document.getElementById("export-btn");
    const clearBtn = document.getElementById("clear-btn");
    const suggestionsList = document.getElementById("suggestions-list");

    // ä¸Šä¸‹æ–‡é¢æ¿ç›¸å…³å…ƒç´ 
    const filesPanel = document.getElementById("files-panel");
    const filesToggle = document.getElementById("files-toggle");
    const filesClose = document.getElementById("files-close");
    const filesPanelContent = document.getElementById("files-panel-content");
    const filesSearch = document.getElementById("files-search");
    const filesStats = document.getElementById("files-stats");

    const contextPanel = document.getElementById("context-panel");
    const contextToggle = document.getElementById("context-toggle");
    const contextClose = document.getElementById("context-close");
    const contextPanelContent = document.getElementById(
      "context-panel-content",
    );
    const contextSearch = document.getElementById("context-search");
    const contextStats = document.getElementById("context-stats");
    const contextFilterBtns = document.querySelectorAll(
      ".context-filter-btn",
    );

    let currentAiMessageElement = null;
    let currentAiRawText = "";
    let suggestionType = null; // '@' or '#'
    let selectedSuggestionIndex = -1;
    let currentSuggestions = [];

    // ä¸Šä¸‹æ–‡ç›¸å…³çŠ¶æ€
    let currentContextItems = [];
    let currentFilter = "all";
    let currentSearchQuery = "";

    // æ–‡ä»¶ç›¸å…³çŠ¶æ€
    let fileTreeData = null;
    let currentFileSearchQuery = "";
    let allFiles = [];

    // è¾“å…¥æ¡†é«˜åº¦è‡ªåŠ¨ä¼¸ç¼©
    userInput.addEventListener("input", (e) => {
      userInput.style.height = "auto";
      userInput.style.height = userInput.scrollHeight + "px";

      handleTriggerDetection(e);
    });

    function handleTriggerDetection(e) {
      const value = userInput.value;
      const cursorPos = userInput.selectionStart;
      const textBeforeCursor = value.substring(0, cursorPos);

      // æ£€æµ‹è§¦å‘ç¬¦
      const lastAt = textBeforeCursor.lastIndexOf("@");
      const lastHash = textBeforeCursor.lastIndexOf("#");
      const lastTriggerIndex = Math.max(lastAt, lastHash);

      if (
        lastTriggerIndex !== -1 &&
        (lastTriggerIndex === 0 ||
          /\s/.test(textBeforeCursor[lastTriggerIndex - 1]))
      ) {
        const trigger = textBeforeCursor[lastTriggerIndex];
        const query = textBeforeCursor.substring(lastTriggerIndex + 1);

        // åªæœ‰å½“æŸ¥è¯¢ä¸­æ²¡æœ‰ç©ºæ ¼æ—¶æ‰è§¦å‘ï¼ˆç©ºæŸ¥è¯¢ä¹Ÿå…è®¸è§¦å‘ï¼‰
        if (!/\s/.test(query)) {
          suggestionType = trigger;

          // ç«‹å³æ˜¾ç¤ºåŠ è½½çŠ¶æ€
          suggestionsList.innerHTML =
            '<div class="suggestion-item">ğŸ” Loading...</div>';
          suggestionsList.style.display = "block";

          if (trigger === "@") {
            vscode.postMessage({ type: "getFiles", query });
          } else {
            vscode.postMessage({ type: "getSymbols", query });
          }
          return;
        }
      }

      hideSuggestions();
    }

    function showSuggestions(suggestions, trigger) {
      currentSuggestions = suggestions;
      if (suggestions.length === 0) {
        hideSuggestions();
        return;
      }

      suggestionsList.innerHTML = "";
      suggestionsList.style.display = "block";
      selectedSuggestionIndex = 0;

      suggestions.forEach((item, index) => {
        const div = document.createElement("div");
        div.className = "suggestion-item" + (index === 0 ? " selected" : "");
        const icon = trigger === "@" ? "ğŸ“„" : "ğŸ”§";
        div.innerHTML = `<span class="suggestion-icon">${icon}</span><span>${item}</span>`;
        div.onclick = () => selectSuggestion(item);
        suggestionsList.appendChild(div);
      });
    }

    function hideSuggestions() {
      suggestionsList.style.display = "none";
      suggestionType = null;
      selectedSuggestionIndex = -1;
    }

    function selectSuggestion(value) {
      const text = userInput.value;
      const cursorPos = userInput.selectionStart;
      const textBeforeCursor = text.substring(0, cursorPos);
      const textAfterCursor = text.substring(cursorPos);

      const lastTriggerIndex = textBeforeCursor.lastIndexOf(suggestionType);

      // 1. æ›´æ–°è¾“å…¥æ¡†æ–‡å­—
      const newText =
        textBeforeCursor.substring(0, lastTriggerIndex) +
        suggestionType +
        value +
        " " +
        textAfterCursor;

      userInput.value = newText;
      hideSuggestions();
      userInput.focus();

      // 2. å¦‚æœæ˜¯æ–‡ä»¶å¼•ç”¨ (@)ï¼Œç«‹å³é€šçŸ¥åç«¯è¯»å–è¯¥æ–‡ä»¶å†…å®¹åˆ°ä¸Šä¸‹æ–‡
      if (suggestionType === '@') {
        vscode.postMessage({
          type: 'readFile', // å¤ç”¨ä½ å·²æœ‰çš„ readFile é€»è¾‘
          path: value      // æ³¨æ„ï¼šè¿™é‡Œçš„ value åº”è¯¥æ˜¯ç›¸å¯¹è·¯å¾„æˆ–ç»å¯¹è·¯å¾„
        });
      }

      // é‡æ–°è®¡ç®—é«˜åº¦
      userInput.style.height = "auto";
      userInput.style.height = userInput.scrollHeight + "px";
    }

    function addMessage(text, role, isRaw = false) {
      const div = document.createElement("div");
      div.className = `message ${role}-message`;
      div.dataset.content = text; // ä¿å­˜åŸå§‹æ–‡æœ¬å†…å®¹

      // âœ… æ·»åŠ å³é”®èœå•äº‹ä»¶ç›‘å¬
      div.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();
        showContextMenu(e.clientX, e.clientY, div, text);
      });

      // åˆ›å»ºæ¶ˆæ¯å†…å®¹å®¹å™¨ï¼ˆå…ˆæ·»åŠ å†…å®¹ï¼‰
      const contentDiv = document.createElement("div");
      contentDiv.className = "message-content";

      if (role === "ai") {
        contentDiv.innerHTML = marked.parse(text);
        // å¤„ç† diff ä»£ç å—
        processDiffBlocks(contentDiv);
      } else {
        contentDiv.textContent = text;
      }

      div.appendChild(contentDiv);

      // åˆ›å»ºæ¶ˆæ¯æ“ä½œæŒ‰é’®å®¹å™¨
      const actionsDiv = document.createElement("div");
      actionsDiv.className = "message-actions";

      // å¤åˆ¶æŒ‰é’®
      const copyBtn = document.createElement("button");
      copyBtn.className = "message-action-btn copy-action-btn";
      copyBtn.innerHTML = "ğŸ“‹";
      copyBtn.title = "å¤åˆ¶æ¶ˆæ¯";
      copyBtn.onclick = (e) => {
        e.stopPropagation();
        copyMessageText(text);
      };

      // åˆ é™¤æŒ‰é’®
      const deleteBtn = document.createElement("button");
      deleteBtn.className = "message-action-btn delete-action-btn";
      deleteBtn.innerHTML = "ğŸ—‘ï¸";
      deleteBtn.title = "åˆ é™¤æ¶ˆæ¯";
      deleteBtn.style.pointerEvents = "auto";
      deleteBtn.style.zIndex = "100";
      deleteBtn.onclick = (e) => {
        console.log('[Delete button clicked], target:', e.target);
        e.preventDefault();
        e.stopImmediatePropagation();
        deleteMessage(div);
      };

      actionsDiv.appendChild(copyBtn);
      actionsDiv.appendChild(deleteBtn);
      div.appendChild(actionsDiv);

      chatContainer.appendChild(div);
      scrollToBottom();
      return div;
    }

    // å¤åˆ¶æ¶ˆæ¯æ–‡æœ¬
    function copyMessageText(text) {
      // åœ¨ VS Code webview ç¯å¢ƒä¸­ï¼Œnavigator.clipboard API å¯èƒ½å—åˆ°é™åˆ¶
      // ä½¿ç”¨å¤šç§æ–¹æ³•å°è¯•å¤åˆ¶

      // æ–¹æ³• 1: å°è¯•ä½¿ç”¨ç°ä»£ Clipboard API
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(() => {
          showFlashNotification("âœ“ å·²å¤åˆ¶åˆ°å‰ªè´´æ¿");
          return;
        }).catch((err) => {
          console.warn("Clipboard API å¤±è´¥ï¼Œå°è¯• fallback æ–¹æ³•:", err);
          // ç»§ç»­å°è¯•å…¶ä»–æ–¹æ³•
        });
      }

      // æ–¹æ³• 2: ä½¿ç”¨ä¼ ç»Ÿçš„ execCommand æ–¹æ³•ï¼ˆå…¼å®¹æ€§æ›´å¥½ï¼‰
      try {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed"; // é¿å…é¡µé¢æ»šåŠ¨
        textArea.style.left = "-9999px";
        textArea.style.top = "0";
        textArea.style.opacity = "0"; // ä¸å¯è§
        document.body.appendChild(textArea);
        textArea.select();
        textArea.setSelectionRange(0, 99999); // é€‰ä¸­å…¨éƒ¨æ–‡æœ¬

        const successful = document.execCommand('copy');
        document.body.removeChild(textArea);

        if (successful) {
          showFlashNotification("âœ“ å·²å¤åˆ¶åˆ°å‰ªè´´æ¿");
          return;
        } else {
          throw new Error("execCommand('copy') å¤±è´¥");
        }
      } catch (err) {
        console.error("execCommand å¤åˆ¶å¤±è´¥:", err);

        // æ–¹æ³• 3: ä½œä¸ºæœ€åçš„ fallbackï¼Œè®©ç”¨æˆ·æ‰‹åŠ¨å¤åˆ¶
        alert(`å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ä»¥ä¸‹å†…å®¹ï¼š\n\n${text}`);
        return;
      }
    }

    // åˆ é™¤æ¶ˆæ¯
    function deleteMessage(messageElement) {
      console.log('[deleteMessage] Deleting message element:', messageElement);
      if (!messageElement) {
        console.error('[deleteMessage] messageElement is null/undefined');
        return;
      }

      // âŒ ç§»é™¤ confirm å¼¹çª—ï¼Œåœ¨ VS Code webview ç¯å¢ƒä¸­å¯èƒ½è¢«æ‹¦æˆª
      // æ”¹ä¸ºç›´æ¥åˆ é™¤å¹¶æ˜¾ç¤º Toast æç¤º

      try {
        // æ·»åŠ æ·¡å‡ºåŠ¨ç”»æ•ˆæœ
        messageElement.style.transition = "opacity 0.3s, transform 0.3s";
        messageElement.style.opacity = "0";
        messageElement.style.transform = "scale(0.9)";

        // ç­‰å¾…åŠ¨ç”»ç»“æŸåç§»é™¤ DOM
        setTimeout(() => {
          if (messageElement.remove) {
            messageElement.remove();
          } else if (messageElement.parentNode) {
            messageElement.parentNode.removeChild(messageElement);
          }
          console.log('[deleteMessage] Element removed successfully');

          // æ˜¾ç¤ºé€šçŸ¥
          showFlashNotification("ğŸ—‘ï¸ æ¶ˆæ¯å·²åˆ é™¤");

          // å¯é€‰ï¼šé€šçŸ¥åç«¯ä»å†å²è®°å½•ä¸­åˆ é™¤
          // vscode.postMessage({ type: "deleteMessage", index: ... });
        }, 300);

      } catch (error) {
        console.error('[deleteMessage] Error removing element:', error);
        showFlashNotification("âœ— åˆ é™¤å¤±è´¥");
      }
    }

    // æ£€æµ‹å¹¶å¤„ç† diff ä»£ç å—
    function processDiffBlocks(messageElement) {
      const codeBlocks = messageElement.querySelectorAll("pre code");

      codeBlocks.forEach((codeBlock, index) => {
        const content = codeBlock.textContent;
        const preElement = codeBlock.parentElement;

        // æ£€æµ‹æ˜¯å¦æ˜¯ diff æ ¼å¼
        if (isDiffContent(content)) {
          preElement.classList.add("diff-block");

          // æ·»åŠ åº”ç”¨æŒ‰é’®
          const applyBtn = document.createElement("button");
          applyBtn.className = "apply-diff-btn";
          applyBtn.innerHTML = "âœ“ Apply";
          applyBtn.title = "Apply this diff to your code";

          // å­˜å‚¨ diff å†…å®¹
          applyBtn.dataset.diffContent = content;
          applyBtn.dataset.diffIndex = index;

          applyBtn.onclick = () => applyDiff(applyBtn, content);

          preElement.appendChild(applyBtn);
        }
      });
    }

    // æ£€æµ‹æ˜¯å¦æ˜¯ diff å†…å®¹
    function isDiffContent(content) {
      const lines = content.trim().split("\n");

      // æ£€æµ‹å¸¸è§çš„ diff æ ¼å¼ç‰¹å¾
      const hasDiffMarkers = lines.some(
        (line) =>
          line.startsWith("+++") ||
          line.startsWith("---") ||
          line.startsWith("@@") ||
          line.match(/^diff --git/),
      );

      // æˆ–è€…æ£€æµ‹æ˜¯å¦æœ‰è¶³å¤Ÿå¤šçš„ +/- è¡Œ
      const changeLines = lines.filter(
        (line) => line.startsWith("+") || line.startsWith("-"),
      );

      return (
        hasDiffMarkers ||
        (changeLines.length >= 3 && changeLines.length / lines.length > 0.3)
      );
    }

    // åº”ç”¨ diff
    function applyDiff(button, diffContent) {
      button.disabled = true;
      button.innerHTML = "â³ Applying...";

      // è§£æ diff å†…å®¹
      const diffData = parseDiff(diffContent);

      if (!diffData) {
        button.innerHTML = "âœ— Invalid Diff";
        button.classList.add("error");
        setTimeout(() => {
          button.disabled = false;
          button.innerHTML = "âœ“ Apply";
          button.classList.remove("error");
        }, 2000);
        return;
      }

      // å‘é€åˆ° VS Code æ‰©å±•è¿›è¡Œåº”ç”¨
      vscode.postMessage({
        type: "applyDiff",
        value: diffData,
      });

      // ç­‰å¾…å“åº”
      button.dataset.pending = "true";
    }

    // è§£æ diff å†…å®¹
    function parseDiff(diffContent) {
      const lines = diffContent.trim().split("\n");
      let currentFile = null;
      const files = [];

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        // æ£€æµ‹æ–‡ä»¶å
        if (line.startsWith("--- ") || line.startsWith("+++ ")) {
          const match = line.match(/^[+-]{3}\s+(?:a\/|b\/)?(.+?)(?:\s+|$)/);
          if (match) {
            const filename = match[1];
            if (line.startsWith("---")) {
              currentFile = { oldFile: filename, newFile: null, hunks: [] };
            } else if (currentFile) {
              currentFile.newFile = filename;
              files.push(currentFile);
            }
          }
        }

        // æ£€æµ‹ hunk å¤´éƒ¨ (@@)
        if (line.startsWith("@@") && currentFile) {
          const hunkMatch = line.match(
            /@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/,
          );
          if (hunkMatch) {
            const hunk = {
              oldStart: parseInt(hunkMatch[1]),
              oldLines: parseInt(hunkMatch[2] || "1"),
              newStart: parseInt(hunkMatch[3]),
              newLines: parseInt(hunkMatch[4] || "1"),
              lines: [],
            };

            // æ”¶é›† hunk çš„å†…å®¹
            i++;
            while (
              i < lines.length &&
              !lines[i].startsWith("@@") &&
              !lines[i].startsWith("---")
            ) {
              hunk.lines.push(lines[i]);
              i++;
            }
            i--; // å›é€€ä¸€è¡Œ

            currentFile.hunks.push(hunk);
          }
        }
      }

      // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ ‡å‡†æ ¼å¼ï¼Œå°è¯•ç®€å•çš„ +/- æ ¼å¼
      if (files.length === 0) {
        const addedLines = [];
        const removedLines = [];
        const contextLines = [];

        lines.forEach((line) => {
          if (line.startsWith("+") && !line.startsWith("+++")) {
            addedLines.push(line.substring(1));
          } else if (line.startsWith("-") && !line.startsWith("---")) {
            removedLines.push(line.substring(1));
          } else if (!line.startsWith("@@")) {
            contextLines.push(line);
          }
        });

        if (addedLines.length > 0 || removedLines.length > 0) {
          return {
            type: "simple",
            added: addedLines,
            removed: removedLines,
            context: contextLines,
            raw: diffContent,
          };
        }
      }

      return files.length > 0
        ? { type: "unified", files, raw: diffContent }
        : null;
    }

    function scrollToBottom() {
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    function handleSend() {
      const text = userInput.value.trim();
      if (text) {
        addMessage(text, "user");
        vscode.postMessage({ type: "ask", value: text });
        userInput.value = "";
        userInput.style.height = "auto";
        currentAiMessageElement = null;
        currentAiRawText = "";
        userInput.disabled = true;
        sendBtn.style.display = "none";
        stopBtn.classList.add("visible");

        // æ·»åŠ åŠ è½½æŒ‡ç¤ºå™¨
        const loader = document.createElement("div");
        loader.id = "ai-loader";
        loader.className = "message ai-message system-message";
        loader.innerHTML =
          '<div class="typing-indicator"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>';
        chatContainer.appendChild(loader);
        scrollToBottom();
      }
    }

    function handleStop() {
      vscode.postMessage({ type: "stop" });
      addMessage("ğŸ›‘ Generation stopped by user", "system");
    }

    sendBtn.addEventListener("click", handleSend);
    stopBtn.addEventListener("click", handleStop);

    // é”®ç›˜å¯¼èˆªåŠŸèƒ½ - è·Ÿè¸ªå½“å‰é€‰ä¸­çš„æ¶ˆæ¯ç´¢å¼•
    let currentMessageIndex = -1;

    function updateMessageSelection() {
      // æ¯æ¬¡éƒ½é‡æ–°è·å–æœ€æ–°çš„æ¶ˆæ¯åˆ—è¡¨
      const messages = chatContainer.getElementsByClassName("message");

      // ç§»é™¤æ‰€æœ‰æ¶ˆæ¯çš„é€‰ä¸­æ ·å¼
      Array.from(messages).forEach(msg => msg.style.outline = "none");

      // å¦‚æœæœ‰é€‰ä¸­çš„æ¶ˆæ¯ï¼Œæ·»åŠ é«˜äº®æ ·å¼
      if (currentMessageIndex >= 0 && currentMessageIndex < messages.length) {
        messages[currentMessageIndex].style.outline = "2px solid var(--accent)";
        messages[currentMessageIndex].style.outlineOffset = "2px";
      }
    }

    userInput.addEventListener("keydown", (e) => {
      if (suggestionsList.style.display === "block") {
        if (e.key === "ArrowDown") {
          e.preventDefault();
          selectedSuggestionIndex =
            (selectedSuggestionIndex + 1) % currentSuggestions.length;
          updateSuggestionSelection();
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          selectedSuggestionIndex =
            (selectedSuggestionIndex - 1 + currentSuggestions.length) %
            currentSuggestions.length;
          updateSuggestionSelection();
        } else if (e.key === "Enter" || e.key === "Tab") {
          e.preventDefault();
          if (selectedSuggestionIndex !== -1) {
            selectSuggestion(currentSuggestions[selectedSuggestionIndex]);
          }
        } else if (e.key === "Escape") {
          hideSuggestions();
        }
        return;
      }

      // é”®ç›˜å¯¼èˆªæ¶ˆæ¯
      const currentMessages = chatContainer.getElementsByClassName("message");

      if (e.key === "ArrowLeft" || e.key === "ArrowUp") {
        // å·¦ç®­å¤´æˆ–ä¸Šç®­å¤´ - ç§»åŠ¨åˆ°ä¸Šä¸€æ¡æ¶ˆæ¯
        e.preventDefault();
        if (currentMessages.length > 0) {
          currentMessageIndex = currentMessageIndex <= 0
            ? currentMessages.length - 1
            : currentMessageIndex - 1;
          updateMessageSelection();
          // æ»šåŠ¨åˆ°å¯è§åŒºåŸŸ
          currentMessages[currentMessageIndex].scrollIntoView({
            behavior: 'smooth',
            block: 'nearest'
          });
        }
      } else if (e.key === "ArrowRight" || e.key === "ArrowDown") {
        // å³ç®­å¤´æˆ–ä¸‹ç®­å¤´ - ç§»åŠ¨åˆ°ä¸‹ä¸€æ¡æ¶ˆæ¯
        e.preventDefault();
        if (currentMessages.length > 0) {
          currentMessageIndex = currentMessageIndex >= currentMessages.length - 1
            ? 0
            : currentMessageIndex + 1;
          updateMessageSelection();
          // æ»šåŠ¨åˆ°å¯è§åŒºåŸŸ
          currentMessages[currentMessageIndex].scrollIntoView({
            behavior: 'smooth',
            block: 'nearest'
          });
        }
      } else if (e.key === "Home") {
        // Home - è·³è½¬åˆ°ç¬¬ä¸€æ¡æ¶ˆæ¯
        e.preventDefault();
        if (currentMessages.length > 0) {
          currentMessageIndex = 0;
          updateMessageSelection();
          chatContainer.scrollTop = 0;
        }
      } else if (e.key === "End") {
        // End - è·³è½¬åˆ°æœ€åä¸€æ¡æ¶ˆæ¯
        e.preventDefault();
        if (currentMessages.length > 0) {
          currentMessageIndex = currentMessages.length - 1;
          updateMessageSelection();
          scrollToBottom();
        }
      } else if (e.key === "Escape") {
        // Escape - å–æ¶ˆé€‰ä¸­
        e.preventDefault();
        currentMessageIndex = -1;
        updateMessageSelection();
        // å¦‚æœå³é”®èœå•æ‰“å¼€ï¼Œå…³é—­å®ƒ
        if (contextMenu.classList.contains("visible")) {
          hideContextMenu();
        }
      }

      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        handleSend();
      }
    });

    // ç›‘å¬æ¶ˆæ¯æ·»åŠ ï¼Œæ›´æ–°æ¶ˆæ¯åˆ—è¡¨
    const observer = new MutationObserver((mutations) => {
      // å½“æœ‰æ–°æ¶ˆæ¯æ—¶ï¼Œé‡ç½®é€‰ä¸­çŠ¶æ€åˆ°æœ€åä¸€æ¡
      const messages = chatContainer.getElementsByClassName("message");
      if (messages.length > 0) {
        currentMessageIndex = messages.length - 1;
        updateMessageSelection();
      }
    });
    observer.observe(chatContainer, { childList: true });

    exportBtn.addEventListener("click", () => {
      vscode.postMessage({ type: "exportChat" });
    });

    clearBtn.addEventListener("click", () => {
      vscode.postMessage({ type: "clear" }); // å·²ç»åœ¨ Provider ä¸­å®ç°æ¸…ç†é€»è¾‘
    });

    function updateSuggestionSelection() {
      const items = suggestionsList.querySelectorAll(".suggestion-item");
      items.forEach((item, index) => {
        item.className =
          "suggestion-item" +
          (index === selectedSuggestionIndex ? " selected" : "");
        if (index === selectedSuggestionIndex) {
          item.scrollIntoView({ block: "nearest" });
        }
      });
    }

    // ç›‘å¬æ–‡æœ¬é€‰æ‹©äº‹ä»¶ï¼Œè‡ªåŠ¨å¡«å…¥è¾“å…¥æ¡†
    document.addEventListener("mouseup", () => {
      const selection = window.getSelection();
      const selectedText = selection.toString().trim();

      if (selectedText) {
        // æ£€æŸ¥é€‰ä¸­çš„æ–‡æœ¬æ˜¯å¦åœ¨èŠå¤©å®¹å™¨å†…
        const range = selection.getRangeAt(0);
        const container = range.commonAncestorContainer;
        const parentElement =
          container.nodeType === Node.TEXT_NODE
            ? container.parentElement
            : container;

        // ç¡®ä¿é€‰ä¸­çš„å†…å®¹åœ¨èŠå¤©å®¹å™¨å†…ï¼Œä¸”ä¸åœ¨è¾“å…¥æ¡†å†…
        if (
          chatContainer.contains(parentElement) &&
          !userInput.contains(parentElement)
        ) {
          userInput.value = selectedText;
          userInput.focus();

          // é‡æ–°è®¡ç®—è¾“å…¥æ¡†é«˜åº¦
          userInput.style.height = "auto";
          userInput.style.height = userInput.scrollHeight + "px";

          // æ¸…é™¤é€‰æ‹©ï¼Œé¿å…è§†è§‰å¹²æ‰°
          selection.removeAllRanges();
        }
      }
    });

    // æ·»åŠ ä¸€ä¸ªæ ‡å¿—æ¥æ ‡è¯†å½“å‰æ˜¯å¦æ­£åœ¨æµå¼æ¥æ”¶AIæ¶ˆæ¯
    let isStreaming = false;

    // æ ‡è®°æ˜¯å¦å·²ç»åŠ è½½è¿‡å†å²è®°å½•
    let historyLoaded = false;

    // å½“å‰æ€è€ƒå—ï¼ˆç”¨äºæµå¼ä¼ è¾“ï¼‰
    let currentThinkingBlock = null;

    window.addEventListener("message", (event) => {
      const message = event.data;
      const loader = document.getElementById("ai-loader");

      switch (message.type) {
        case "closeFilesPanel":
          // å…³é—­æ–‡ä»¶é¢æ¿
          filesPanel.classList.remove("open");
          break;
        case "suggestions":
          showSuggestions(message.value, message.trigger);
          break;
        case "history":
          // åªåŠ è½½ä¸€æ¬¡å†å²è®°å½•ï¼Œé¿å…é‡å¤æ¸²æŸ“
          if (!historyLoaded) {
            historyLoaded = true;
            chatContainer.innerHTML = ""; // æ¸…ç©ºåˆå§‹åŒ–çŠ¶æ€

            if (message.value && message.value.length > 0) {
              message.value.forEach((msg) => {
                addMessage(msg.content, msg.role === "user" ? "user" : "ai");
              });
              // æ»šåŠ¨åˆ°åº•éƒ¨
              requestAnimationFrame(() => {
                scrollToBottom();
              });
            } else {
              chatContainer.innerHTML = '<div class="message system-message">âœ¨ Yuangs AI Agent initialized and ready.</div>';
            }
          }
          break;
        case "appendMessage":
          addMessage(message.value.content, message.value.role === "user" ? "user" : "ai");
          requestAnimationFrame(() => {
            scrollToBottom();
          });
          break;
        case "aiChunk":
          if (loader) {
            loader.remove();
            stopBtn.classList.add("visible");
          }

          // å¼€å§‹æµå¼æ¥æ”¶
          isStreaming = true;

          if (!currentAiMessageElement) {
            // åˆ›å»ºAIæ¶ˆæ¯å®¹å™¨
            const aiMessageDiv = document.createElement("div");
            aiMessageDiv.className = "message ai-message"; // ç›´æ¥ä½¿ç”¨æœ€ç»ˆæ ·å¼
            // aiMessageDiv.style.minHeight = '24px'; // é˜²æ­¢é«˜åº¦å¡Œé™·
            chatContainer.appendChild(aiMessageDiv);
            currentAiMessageElement = aiMessageDiv;
          }

          currentAiRawText += message.value;

          // å®æ—¶ Markdown æ¸²æŸ“
          // æŠ€å·§ï¼šå¦‚æœä»£ç å—æœªé—­åˆï¼Œæ‰‹åŠ¨ä¸´æ—¶é—­åˆå®ƒä»¥ä¿è¯æ¸²æŸ“æ­£ç¡®
          let textToRender = currentAiRawText;
          const codeBlockCount = (textToRender.match(/```/g) || []).length;
          if (codeBlockCount % 2 !== 0) {
            textToRender += "\n```";
          }

          // æ¸²æŸ“å†…å®¹å¹¶æ·»åŠ å…‰æ ‡
          currentAiMessageElement.innerHTML =
            marked.parse(textToRender) + '<span class="cursor"></span>';

          // å¹³æ»‘æ»šåŠ¨åˆ°åº•éƒ¨
          // ä½¿ç”¨ requestAnimationFrame ä¼˜åŒ–æ»šåŠ¨æ€§èƒ½
          requestAnimationFrame(() => {
            scrollToBottom();
          });
          break;
        case "done":
          // æµå¼ä¼ è¾“ç»“æŸ
          if (isStreaming && currentAiMessageElement) {
            isStreaming = false;

            // âœ… ä¿å­˜å½“å‰æ¶ˆæ¯å…ƒç´ çš„å¼•ç”¨
            const messageElementToDelete = currentAiMessageElement;
            const aiRawTextToCopy = currentAiRawText;

            // ç§»é™¤å…‰æ ‡ï¼Œè¿›è¡Œæœ€ç»ˆæ¸²æŸ“
            currentAiMessageElement.innerHTML =
              marked.parse(currentAiRawText);

            // ä¿å­˜åŸå§‹æ–‡æœ¬å†…å®¹åˆ° dataset
            messageElementToDelete.dataset.content = aiRawTextToCopy;

            // å¤„ç†diffå—å’Œå…¶ä»–åå¤„ç†
            processDiffBlocks(messageElementToDelete, aiRawTextToCopy);
            processCommitSuggestions(messageElementToDelete, aiRawTextToCopy);

            // é‡æ–°æ·»åŠ å³é”®èœå•äº‹ä»¶ç›‘å¬
            messageElementToDelete.addEventListener('contextmenu', (e) => {
              e.preventDefault();
              e.stopPropagation();
              showContextMenu(e.clientX, e.clientY, messageElementToDelete, aiRawTextToCopy);
            });

            // é‡æ–°æ·»åŠ æ¶ˆæ¯æ“ä½œæŒ‰é’®ï¼ˆå› ä¸º innerHTML æ›¿æ¢ä¼šç§»é™¤å®ƒä»¬ï¼‰
            if (!messageElementToDelete.querySelector('.message-actions')) {
              const actionsDiv = document.createElement("div");
              actionsDiv.className = "message-actions";

              const copyBtn = document.createElement("button");
              copyBtn.className = "message-action-btn copy-action-btn";
              copyBtn.innerHTML = "ğŸ“‹";
              copyBtn.title = "å¤åˆ¶æ¶ˆæ¯";
              copyBtn.onclick = (e) => {
                e.stopPropagation();
                copyMessageText(aiRawTextToCopy);
              };

              const deleteBtn = document.createElement("button");
              deleteBtn.className = "message-action-btn delete-action-btn";
              deleteBtn.innerHTML = "ğŸ—‘ï¸";
              deleteBtn.title = "åˆ é™¤æ¶ˆæ¯";
              deleteBtn.style.pointerEvents = "auto";
              deleteBtn.style.zIndex = "100";
              deleteBtn.onclick = (e) => {
                console.log('[Delete button clicked from done case], target:', e.target);
                e.preventDefault();
                e.stopImmediatePropagation();
                deleteMessage(messageElementToDelete);
              };

              actionsDiv.appendChild(copyBtn);
              actionsDiv.appendChild(deleteBtn);
              messageElementToDelete.appendChild(actionsDiv);
            }

            // æ·»åŠ æ·¡å…¥æ•ˆæœæˆ–å…¶ä»–å®ŒæˆåŠ¨æ•ˆ
            messageElementToDelete.classList.add("final-render");

            // é‡è¦ï¼šå¤„ç†å®Œä¸€æ¬¡ AI å›å¤åï¼Œå¦‚æœæ˜¯ commit flowï¼Œé‡ç½®çŠ¶æ€
            // ä½†ä¸èƒ½ç«‹å³é‡ç½®ï¼Œå› ä¸ºå¯èƒ½è¿˜æœ‰åç»­æ¸²æŸ“å¸§ã€‚
            // è¿™é‡Œæˆ‘ä»¬ä¾èµ–ä¸‹ä¸€æ¬¡ triggerGit æ¥è¦†ç›–çŠ¶æ€ï¼Œæˆ–è€…è®¾ç½®ä¸€ä¸ªè¶…æ—¶
            if (lastGitAction === 'commit') {
              setTimeout(() => { lastGitAction = null; }, 1000);
            }
          }

          currentAiMessageElement = null;
          currentAiRawText = "";
          currentThinkingBlock = null;
          userInput.disabled = false;
          userInput.focus();
          sendBtn.style.display = "flex";
          stopBtn.classList.remove("visible");

          // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨ï¼Œç¡®ä¿æ–°æ¶ˆæ¯å¯è§
          requestAnimationFrame(() => {
            scrollToBottom();
          });
          break;
        case "clear":
          chatContainer.innerHTML =
            '<div class="message system-message">âœ¨ Chat cleared.</div>';
          userInput.disabled = false;
          userInput.focus();
          sendBtn.style.display = "flex";
          stopBtn.classList.remove("visible");
          break;
        case "error":
          if (loader) loader.remove();
          addMessage("âŒ Error: " + message.value, "system");
          userInput.disabled = false;
          userInput.focus();
          sendBtn.style.display = "flex";
          stopBtn.classList.remove("visible");
          break;
        case "success":
          // æˆåŠŸæ¶ˆæ¯ï¼Œæ˜¾ç¤ºä¸ºç³»ç»Ÿæ¶ˆæ¯
          showFlashNotification(message.value);
          break;
        case "diffApplied":
          // Diff åº”ç”¨æˆåŠŸ
          const successButtons = document.querySelectorAll(
            '.apply-diff-btn[data-pending="true"]',
          );
          successButtons.forEach((btn) => {
            btn.innerHTML = "âœ“ Applied";
            btn.classList.add("applied");
            btn.disabled = true;
            btn.dataset.pending = "false";
          });
          break;
        case "diffError":
          // Diff åº”ç”¨å¤±è´¥
          const errorButtons = document.querySelectorAll(
            '.apply-diff-btn[data-pending="true"]',
          );
          errorButtons.forEach((btn) => {
            btn.innerHTML = "âœ— Failed";
            btn.classList.add("error");
            btn.dataset.pending = "false";
            setTimeout(() => {
              btn.disabled = false;
              btn.innerHTML = "âœ“ Apply";
              btn.classList.remove("error");
            }, 3000);
          });
          if (message.value) {
            addMessage(
              "âŒ Diff application error: " + message.value,
              "system",
            );
          }
          break;
        case "contextUpdate":
          // æ›´æ–°ä¸Šä¸‹æ–‡æ•°æ®
          if (typeof updateContextItems === "function") {
            updateContextItems(message.value);
          }
          break;
        case "showContextPanel":
          // æ˜¾ç¤ºä¸Šä¸‹æ–‡é¢æ¿
          if (typeof showContextPanel === "function") {
            showContextPanel();
          }
          break;
        case "fileTreeData":
          // æ¥æ”¶æ–‡ä»¶æ ‘æ•°æ®
          handleFileTreeData(message.value);
          break;
        case "modelsConfig":
          // æ¥æ”¶æ¨¡å‹é…ç½®
          availableModels = message.value.availableModels || [];
          currentModel = message.value.defaultModel || currentModel;
          renderModelOptions();
          updateCurrentModel(currentModel);
          console.log("Models config received:", availableModels);
          break;
      }
    });

    // === æ—¥å¿—é¢æ¿åŠŸèƒ½ ===

    // æ—¥å¿—é¢æ¿ç›¸å…³å…ƒç´ 
    const logPanel = document.getElementById("log-panel");
    const logPanelContent = document.getElementById("log-panel-content");
    const logStats = document.getElementById("log-stats");
    const logClearBtn = document.getElementById("log-clear-btn");
    const logCopyBtn = document.getElementById("log-copy-btn");
    const logToggleBtn = document.getElementById("log-toggle-btn");

    // æ—¥å¿—å­˜å‚¨
    const logEntries = [];
    const MAX_LOG_ENTRIES = 1000;

    // æ·»åŠ æ—¥å¿—å‡½æ•°
    function addLog(level, message) {
      const timestamp = new Date();
      const timeStr = timestamp.toTimeString().split(' ')[0];
      const logEntry = { timestamp, timeStr, level, message };
      logEntries.push(logEntry);

      if (logEntries.length > MAX_LOG_ENTRIES) {
        logEntries.shift();
      }

      const logDiv = document.createElement("div");
      logDiv.className = `log-entry log-${level.toLowerCase()}`;
      logDiv.innerHTML = `
        <span class="log-time">${timeStr}</span>
        <span class="log-level">[${level.toUpperCase()}]</span>
        <span class="log-message">${escapeHtml(message)}</span>
      `;
      logDiv.addEventListener("click", () => {
        copyLog(`${timeStr} [${level.toUpperCase()}] ${message}`);
      });
      logPanelContent.appendChild(logDiv);
      logPanelContent.scrollTop = logPanelContent.scrollHeight;
      logStats.textContent = `${logEntries.length} entries`;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function copyLog(text) {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(() => {
          showFlashNotification("ğŸ“‹ Log copied");
        }).catch(err => console.warn("Clipboard API å¤±è´¥:", err));
      }
    }

    function clearLogs() {
      logEntries.length = 0;
      logPanelContent.innerHTML = '';
      addLog('info', 'Logs cleared by user');
    }

    function copyAllLogs() {
      const allLogs = logEntries.map(entry =>
        `${entry.timeStr} [${entry.level.toUpperCase()}] ${entry.message}`
      ).join('\n');

      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(allLogs).then(() => {
          showFlashNotification(`ğŸ“‹ Copied ${logEntries.length} logs`);
        }).catch(err => console.warn("Clipboard API å¤±è´¥:", err));
      }
    }

    function toggleLogPanel() {
      logPanel.classList.toggle("collapsed");
      const isCollapsed = logPanel.classList.contains("collapsed");
      logToggleBtn.textContent = isCollapsed ? "â–¶" : "â–¼";
    }

    // æ—¥å¿—é¢æ¿äº‹ä»¶ç»‘å®š
    logClearBtn.addEventListener("click", clearLogs);
    logCopyBtn.addEventListener("click", copyAllLogs);
    logToggleBtn.addEventListener("click", toggleLogPanel);

    // æ‹¦æˆª console è¾“å‡º
    const originalConsoleLog = console.log;
    const originalConsoleWarn = console.warn;
    const originalConsoleError = console.error;

    console.log = function (...args) {
      originalConsoleLog.apply(console, args);
      addLog('info', args.map(arg =>
        typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
      ).join(' '));
    };

    console.warn = function (...args) {
      originalConsoleWarn.apply(console, args);
      addLog('warn', args.map(arg =>
        typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
      ).join(' '));
    };

    console.error = function (...args) {
      originalConsoleError.apply(console, args);
      addLog('error', args.map(arg =>
        typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
      ).join(' '));
    };

    // åˆå§‹åŒ–æ—¥å¿—
    addLog('info', 'Log panel initialized successfully');
    console.log('[LOG] Debug panel is ready to capture logs');

    // åˆå§‹åŒ–æ–‡ä»¶é¢æ¿
    if (typeof setupFilesPanel === "function") {
      setupFilesPanel();
    }

    // åˆå§‹åŒ–ä¸Šä¸‹æ–‡é¢æ¿
    if (typeof setupContextPanel === "function") {
      setupContextPanel();
    }

    // === æ–‡ä»¶é¢æ¿åŠŸèƒ½å‡½æ•° ===

    function setupFilesPanel() {
      // æ–‡ä»¶é¢æ¿å¼€å…³
      filesToggle.addEventListener("click", () => {
        filesPanel.classList.toggle("open");
        if (filesPanel.classList.contains("open") && !fileTreeData) {
          loadFileTree();
        }
      });

      filesClose.addEventListener("click", () => {
        filesPanel.classList.remove("open");
      });

      // æœç´¢åŠŸèƒ½
      filesSearch.addEventListener("input", (e) => {
        currentFileSearchQuery = e.target.value.toLowerCase();
        renderFileTree();
      });
    }

    // åŠ è½½æ–‡ä»¶æ ‘
    function loadFileTree() {
      filesPanelContent.innerHTML =
        '<div class="file-loading">Loading files...</div>';
      vscode.postMessage({ type: "loadFileTree" });
    }

    // å¤„ç†æ–‡ä»¶æ ‘æ•°æ®
    function handleFileTreeData(files) {
      allFiles = files;
      fileTreeData = buildFileTree(files);
      renderFileTree();
    }

    // æ„å»ºæ–‡ä»¶æ ‘ç»“æ„
    function buildFileTree(files) {
      const root = {};

      files.forEach((filePath) => {
        const parts = filePath.split("/");
        let current = root;
        let fullPath = "";

        parts.forEach((part, index) => {
          fullPath = fullPath ? fullPath + "/" + part : part;

          if (!current[part]) {
            current[part] = {
              name: part,
              path: fullPath, // ä¿å­˜å®Œæ•´è·¯å¾„
              isFile: index === parts.length - 1,
              children: {},
            };
          }
          current = current[part];
        });
      });

      return root;
    }

    // æ¸²æŸ“æ–‡ä»¶æ ‘
    function renderFileTree() {
      if (!fileTreeData) {
        filesPanelContent.innerHTML =
          '<div class="file-empty">No files loaded</div>';
        return;
      }

      // è¿‡æ»¤æ–‡ä»¶
      let filteredFiles = allFiles;
      if (currentFileSearchQuery) {
        filteredFiles = allFiles.filter((f) =>
          f.toLowerCase().includes(currentFileSearchQuery),
        );
        filesStats.textContent = `${filteredFiles.length} files`;
      } else {
        filesStats.textContent = `${allFiles.length} files`;
      }

      // æ¸…ç©ºå¹¶é‡æ–°æ¸²æŸ“
      filesPanelContent.innerHTML = "";

      if (filteredFiles.length === 0) {
        filesPanelContent.innerHTML =
          '<div class="file-empty">No matching files</div>';
        return;
      }

      if (currentFileSearchQuery) {
        // æœç´¢æ¨¡å¼ï¼šæ˜¾ç¤ºæ‰å¹³åˆ—è¡¨
        renderFileList(filteredFiles);
      } else {
        // æ ‘å½¢æ¨¡å¼ï¼šæ˜¾ç¤ºå±‚çº§ç»“æ„
        renderTreeNode(fileTreeData, filesPanelContent, 0);
      }
    }

    // æ¸²æŸ“æ–‡ä»¶åˆ—è¡¨ï¼ˆæœç´¢æ¨¡å¼ï¼‰
    function renderFileList(files) {
      files.forEach((filePath) => {
        const item = document.createElement("div");
        item.className = "file-tree-item file";

        const icon = getFileIcon(filePath);
        const fileName = filePath.split("/").pop();

        item.innerHTML = `
                    <span class="file-tree-icon">${icon}</span>
                    <span class="file-tree-name">${fileName}</span>
                `;

        item.addEventListener("click", () => {
          handleFileClick(filePath);
        });

        filesPanelContent.appendChild(item);
      });
    }

    // æ¸²æŸ“æ ‘èŠ‚ç‚¹
    function renderTreeNode(node, container, level) {
      const entries = Object.entries(node).sort((a, b) => {
        // æ–‡ä»¶å¤¹æ’åœ¨å‰é¢
        if (a[1].isFile && !b[1].isFile) return 1;
        if (!a[1].isFile && b[1].isFile) return -1;
        return a[0].localeCompare(b[0]);
      });

      entries.forEach(([name, data]) => {
        const item = document.createElement("div");

        if (!data.isFile) {
          // æ–‡ä»¶å¤¹
          item.className = "file-tree-item folder";
          item.style.paddingLeft = `${16 + level * 16}px`;

          item.innerHTML = `
                        <span class="file-tree-icon collapsed" data-path="${name}"></span>
                        <span class="file-tree-name">${name}</span>
                    `;

          const childrenContainer = document.createElement("div");
          childrenContainer.className = "file-tree-children";

          item
            .querySelector(".file-tree-icon")
            .addEventListener("click", (e) => {
              e.stopPropagation();
              const icon = e.target;
              if (icon.classList.contains("collapsed")) {
                icon.classList.remove("collapsed");
                icon.classList.add("expanded");
                childrenContainer.classList.add("expanded");
              } else {
                icon.classList.remove("expanded");
                icon.classList.add("collapsed");
                childrenContainer.classList.remove("expanded");
              }
            });

          item.addEventListener("click", () => {
            // é»˜è®¤å±•å¼€/æŠ˜å 
            const icon = item.querySelector(".file-tree-icon");
            icon.click();
          });

          container.appendChild(item);
          container.appendChild(childrenContainer);

          // é€’å½’æ¸²æŸ“å­èŠ‚ç‚¹
          renderTreeNode(data.children, childrenContainer, level + 1);
        } else {
          // æ–‡ä»¶
          item.className = "file-tree-item file";
          item.style.paddingLeft = `${16 + level * 16}px`;

          const icon = getFileIcon(name);
          item.innerHTML = `
                        <span class="file-tree-icon">${icon}</span>
                        <span class="file-tree-name">${name}</span>
                    `;

          item.addEventListener("click", () => {
            handleFileClick(data.path);
          });

          container.appendChild(item);
        }
      });
    }

    // è·å–æ–‡ä»¶å›¾æ ‡
    function getFileIcon(filename) {
      const ext = filename.split(".").pop().toLowerCase();
      const iconMap = {
        js: "ğŸ“œ",
        ts: "ğŸ“˜",
        tsx: "âš›ï¸",
        jsx: "âš›ï¸",
        html: "ğŸŒ",
        css: "ğŸ¨",
        scss: "ğŸ¨",
        json: "ğŸ“‹",
        md: "ğŸ“",
        py: "ğŸ",
        java: "â˜•",
        go: "ğŸ¹",
        rs: "ğŸ¦€",
        cpp: "âš™ï¸",
        c: "âš™ï¸",
        h: "ğŸ“„",
        vue: "ğŸ’š",
        angular: "ğŸ…°ï¸",
        react: "âš›ï¸",
        yaml: "ğŸ“‹",
        yml: "ğŸ“‹",
        xml: "ğŸ“‹",
        sh: "ğŸ’»",
        bash: "ğŸ’»",
        zsh: "ğŸ’»",
        git: "ğŸ”€",
        lock: "ğŸ”’",
        env: "ğŸ”",
        test: "ğŸ§ª",
        spec: "ğŸ§ª",
      };

      return iconMap[ext] || "ğŸ“„";
    }

    // å¤„ç†æ–‡ä»¶ç‚¹å‡»
    function handleFileClick(filePath) {
      // âœ… ä¿®å¤ï¼šä¸å†ç«‹å³å‘é€ ask æ¶ˆæ¯ï¼Œè€Œæ˜¯åœ¨è¾“å…¥æ¡†ä¸­æ’å…¥ @æ–‡ä»¶è·¯å¾„
      // è¿™æ ·å¯ä»¥è®© @ å¼•ç”¨è§£ææœºåˆ¶æ­£å¸¸å·¥ä½œï¼Œç¡®ä¿æ–‡ä»¶å†…å®¹è¢«æ­£ç¡®åŠ è½½åˆ°ä¸Šä¸‹æ–‡ä¸­

      // å…³é—­æ–‡ä»¶é¢æ¿
      filesPanel.classList.remove("open");

      // åœ¨è¾“å…¥æ¡†ä¸­æ’å…¥ @æ–‡ä»¶è·¯å¾„ å’Œæç¤ºæ–‡æœ¬
      const question = `@${filePath} è¯·åˆ†æè¿™ä¸ªæ–‡ä»¶`;
      userInput.value = question;

      // è‡ªåŠ¨è°ƒæ•´è¾“å…¥æ¡†é«˜åº¦
      userInput.style.height = "auto";
      userInput.style.height = userInput.scrollHeight + "px";

      // èšç„¦åˆ°è¾“å…¥æ¡†ï¼Œè®©ç”¨æˆ·å¯ä»¥çœ‹åˆ°å¹¶ä¿®æ”¹
      userInput.focus();

      // å°†å…‰æ ‡ç§»åŠ¨åˆ°æœ«å°¾
      userInput.setSelectionRange(question.length, question.length);

      // å¯é€‰ï¼šè‡ªåŠ¨è§¦å‘å‘é€ï¼ˆå¦‚æœä½ å¸Œæœ›è‡ªåŠ¨å‘é€çš„è¯ï¼‰
      // æ³¨é‡Šæ‰ä¸‹é¢è¿™è¡Œï¼Œè®©ç”¨æˆ·æ‰‹åŠ¨ç‚¹å‡»å‘é€æŒ‰é’®
      // sendBtn.click();
    }

    // è·å–æ–‡ä»¶è¯­è¨€ï¼ˆè¾…åŠ©å‡½æ•°ï¼‰
    function getFileLanguage(filename) {
      const ext = filename.split(".").pop()?.toLowerCase() || "";
      const langMap = {
        js: "javascript",
        ts: "typescript",
        tsx: "typescript",
        jsx: "javascript",
        py: "python",
        java: "java",
        go: "go",
        rs: "rust",
        cpp: "cpp",
        c: "c",
        h: "c",
        vue: "vue",
        yaml: "yaml",
        yml: "yaml",
        json: "json",
        md: "markdown",
        html: "html",
        css: "css",
        sh: "bash",
        bash: "bash",
      };
      return langMap[ext] || "text";
    }

    // === ä¸Šä¸‹æ–‡é¢æ¿åŠŸèƒ½å‡½æ•° ===

    // ä¸Šä¸‹æ–‡é¢æ¿å¼€å…³
    function setupContextPanel() {
      // ä¸Šä¸‹æ–‡é¢æ¿å¼€å…³
      contextToggle.addEventListener("click", () => {
        contextPanel.classList.toggle("open");
        contextToggle.classList.toggle("visible");
      });

      contextClose.addEventListener("click", () => {
        contextPanel.classList.remove("open");
        contextToggle.classList.remove("visible");
      });

      // è¿‡æ»¤æŒ‰é’®äº‹ä»¶
      contextFilterBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          // ç§»é™¤æ‰€æœ‰activeç±»
          contextFilterBtns.forEach((b) => b.classList.remove("active"));
          // æ·»åŠ activeç±»åˆ°å½“å‰æŒ‰é’®
          btn.classList.add("active");
          // æ›´æ–°è¿‡æ»¤å™¨
          currentFilter = btn.dataset.filter;
          // é‡æ–°æ¸²æŸ“
          renderContextItems();
        });
      });

      // æœç´¢åŠŸèƒ½
      contextSearch.addEventListener("input", (e) => {
        currentSearchQuery = e.target.value.toLowerCase();
        renderContextItems();
      });
    }

    // æ›´æ–°ä¸Šä¸‹æ–‡æ•°æ®
    function updateContextItems(items) {
      const oldCount = currentContextItems.length;
      currentContextItems = items || [];
      const newCount = currentContextItems.length;

      renderContextItems();

      // å¦‚æœæœ‰æ›´æ–°ï¼Œæ˜¾ç¤º flash é€šçŸ¥
      if (newCount > oldCount) {
        showFlashNotification(`ğŸ“‹ Context updated: ${newCount - oldCount} new item${newCount - oldCount > 1 ? 's' : ''} added`);
      }
    }

    // æ¸²æŸ“ä¸Šä¸‹æ–‡é¡¹ç›®
    function renderContextItems() {
      // è¿‡æ»¤ä¸Šä¸‹æ–‡é¡¹ç›®
      let filteredItems = currentContextItems.filter((item) => {
        // ç±»å‹è¿‡æ»¤
        if (currentFilter !== "all" && item.semantic !== currentFilter) {
          return false;
        }

        // æœç´¢è¿‡æ»¤
        if (currentSearchQuery) {
          const searchText = (
            item.path +
            item.summary +
            item.content
          ).toLowerCase();
          if (!searchText.includes(currentSearchQuery)) {
            return false;
          }
        }

        return true;
      });

      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      contextStats.textContent = `${filteredItems.length} items`;

      // æ¸…ç©ºå¹¶é‡æ–°æ¸²æŸ“
      contextPanelContent.innerHTML = "";

      if (filteredItems.length === 0) {
        contextPanelContent.innerHTML =
          '<div class="context-empty">No context available</div>';
        return;
      }

      // æ¸²æŸ“æ¯ä¸ªä¸Šä¸‹æ–‡é¡¹ç›®
      filteredItems.forEach((item) => {
        const itemElement = createContextItemElement(item);
        contextPanelContent.appendChild(itemElement);
      });
    }

    // åˆ›å»ºå•ä¸ªä¸Šä¸‹æ–‡é¡¹ç›®å…ƒç´ 
    function createContextItemElement(item) {
      const div = document.createElement("div");
      div.className = "context-item collapsed"; // é»˜è®¤æŠ˜å 

      // è·å–å›¾æ ‡
      const icon = getContextIcon(item.semantic);

      // è·å–é‡è¦æ€§ç™¾åˆ†æ¯”
      const importancePercent = item.importance
        ? (item.importance.confidence * 100).toFixed(0)
        : "50";

      // è·å–æ ‡ç­¾HTML
      const badgesHtml = createContextBadges(item);

      // è·å–ç»Ÿè®¡ä¿¡æ¯
      const statsHtml = createContextStats(item);

      // è·å–å†…å®¹é¢„è§ˆ
      const previewText = item.summary || item.content.substring(0, 200);

      div.innerHTML = `
                <div class="context-item-header">
                    <span class="context-item-toggle">â–¶</span>
                    <span class="context-item-icon">${icon}</span>
                    <span class="context-item-title">${item.alias || item.path}</span>
                    <div class="context-item-badges">${badgesHtml}</div>
                </div>
                <div class="context-item-details">
                    <div class="context-item-stats">${statsHtml}</div>
                    <div class="context-usage-bar">
                        <div class="context-usage-fill" style="width: ${importancePercent}%"></div>
                    </div>
                    <div class="context-item-preview">${previewText}</div>
                </div>
            `;

      // æ·»åŠ ç‚¹å‡»äº‹ä»¶ - åˆ‡æ¢å±•å¼€/æŠ˜å 
      div.addEventListener("click", (e) => {
        // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé¿å…è§¦å‘å…¶ä»–ç‚¹å‡»äº‹ä»¶
        e.stopPropagation();

        // åˆ‡æ¢å±•å¼€/æŠ˜å çŠ¶æ€
        div.classList.toggle("collapsed");
        div.classList.toggle("expanded");

        // å¦‚æœå±•å¼€ï¼Œæ‰“å¼€æ–‡ä»¶
        if (!div.classList.contains("collapsed") && item.path) {
          vscode.postMessage({
            type: "open",
            path: item.path,
          });
        }

        console.log("Context item toggled:", item, "expanded:", !div.classList.contains("collapsed"));
      });

      return div;
    }

    // è·å–ä¸Šä¸‹æ–‡å›¾æ ‡
    function getContextIcon(semantic) {
      const iconMap = {
        source_code: "ğŸ“„",
        log: "ğŸ“‹",
        config: "âš™ï¸",
        documentation: "ğŸ“š",
        test: "ğŸ§ª",
        git: "ğŸ”€",
        evidence: "ğŸ”",
        diagnostics: "âš ï¸",
      };

      return iconMap[semantic] || "ğŸ“„";
    }

    // åˆ›å»ºæ ‡ç­¾
    function createContextBadges(item) {
      const badges = [];

      // ç±»å‹æ ‡ç­¾
      if (item.semantic) {
        badges.push(
          `<span class="context-badge ${item.semantic}">${item.semantic}</span>`,
        );
      }

      // æ ‡ç­¾
      if (item.tags && item.tags.length > 0) {
        item.tags.slice(0, 2).forEach((tag) => {
          badges.push(`<span class="context-badge">${tag}</span>`);
        });
      }

      return badges.join("");
    }

    // åˆ›å»ºç»Ÿè®¡ä¿¡æ¯
    function createContextStats(item) {
      const stats = [];

      // Tokenæ•°é‡
      if (item.tokens) {
        stats.push(
          `<span class="context-stat">ğŸ“Š ${item.tokens} tokens</span>`,
        );
      }

      // ä½¿ç”¨æ¬¡æ•°
      if (item.importance && item.importance.useCount > 0) {
        stats.push(
          `<span class="context-stat">ğŸ”„ ${item.importance.useCount} uses</span>`,
        );
      }

      // æœ€åä½¿ç”¨æ—¶é—´
      if (item.importance && item.importance.lastUsed) {
        const lastUsed = new Date(item.importance.lastUsed);
        const now = new Date();
        const diffMinutes = Math.floor((now - lastUsed) / 60000);

        if (diffMinutes < 1) {
          stats.push(`<span class="context-stat">â° just now</span>`);
        } else if (diffMinutes < 60) {
          stats.push(
            `<span class="context-stat">â° ${diffMinutes}m ago</span>`,
          );
        } else if (diffMinutes < 1440) {
          stats.push(
            `<span class="context-stat">â° ${Math.floor(diffMinutes / 60)}h ago</span>`,
          );
        } else {
          stats.push(
            `<span class="context-stat">â° ${Math.floor(diffMinutes / 1440)}d ago</span>`,
          );
        }
      }

      return stats.join("");
    }

    // æ˜¾ç¤ºä¸Šä¸‹æ–‡é¢æ¿
    function showContextPanel() {
      contextPanel.classList.add("open");
      contextToggle.classList.add("visible");
    }

    // éšè—ä¸Šä¸‹æ–‡é¢æ¿
    function hideContextPanel() {
      contextPanel.classList.remove("open");
      contextToggle.classList.remove("visible");
    }

    // æ˜¾ç¤º flash é€šçŸ¥
    function showFlashNotification(message) {
      const notification = document.createElement("div");
      notification.className = "flash-notification";
      notification.textContent = message;

      document.body.appendChild(notification);

      // 3ç§’åè‡ªåŠ¨ç§»é™¤
      setTimeout(() => {
        notification.remove();
      }, 3000);
    }

    // === å³é”®èœå•åŠŸèƒ½ ===

    const contextMenu = document.getElementById("context-menu");
    const contextCopy = document.getElementById("context-copy");
    const contextDelete = document.getElementById("context-delete");

    // å½“å‰å³é”®èœå•å…³è”çš„æ¶ˆæ¯å…ƒç´ å’Œæ–‡æœ¬
    let currentContextMessageElement = null;
    let currentContextMessageText = "";

    // æ˜¾ç¤ºå³é”®èœå•
    function showContextMenu(x, y, messageElement, messageText) {
      currentContextMessageElement = messageElement;
      currentContextMessageText = messageText;

      // è®¾ç½®èœå•ä½ç½®
      contextMenu.style.left = x + "px";
      contextMenu.style.top = y + "px";
      contextMenu.classList.add("visible");
    }

    // éšè—å³é”®èœå•
    function hideContextMenu() {
      contextMenu.classList.remove("visible");
      currentContextMessageElement = null;
      currentContextMessageText = "";
    }

    // ç‚¹å‡»é¡µé¢å…¶ä»–åœ°æ–¹æ—¶éšè—å³é”®èœå•
    document.addEventListener("click", (e) => {
      if (!contextMenu.contains(e.target)) {
        hideContextMenu();
      }
    });

    // å³é”®èœå•é¡¹ï¼šå¤åˆ¶
    contextCopy.addEventListener("click", (e) => {
      e.stopPropagation();
      e.preventDefault();
      console.log('[Context menu copy clicked]');
      if (currentContextMessageText) {
        copyMessageText(currentContextMessageText);
      }
      hideContextMenu();
    });

    // å³é”®èœå•é¡¹ï¼šåˆ é™¤
    contextDelete.addEventListener("click", (e) => {
      e.stopPropagation();
      e.preventDefault();
      console.log('[Context menu delete clicked]');
      if (currentContextMessageElement) {
        deleteMessage(currentContextMessageElement);
      }
      hideContextMenu();
    });

    // === æ¨¡å‹é€‰æ‹©å™¨åŠŸèƒ½ ===

    const modelSelector = document.getElementById("model-selector");
    const modelDropdown = document.getElementById("model-dropdown");
    const currentModelLabel = document.getElementById("current-model");

    // å¯ç”¨çš„ AI æ¨¡å‹åˆ—è¡¨ï¼ˆä»åç«¯åŠ è½½ï¼‰
    let availableModels = [];

    // å½“å‰é€‰ä¸­çš„æ¨¡å‹
    let currentModel = "gpt-4o-mini";

    // åˆå§‹åŒ–æ¨¡å‹é€‰æ‹©å™¨
    function initModelSelector() {
      // ä»æ‰©å±•è·å–æ¨¡å‹é…ç½®
      vscode.postMessage({ type: "getModelsConfig" });
      // åŒæ—¶è·å–å½“å‰é€‰ä¸­çš„æ¨¡å‹
      vscode.postMessage({ type: "getCurrentModel" });

      // ç‚¹å‡»åˆ‡æ¢ä¸‹æ‹‰èœå•
      modelSelector.addEventListener("click", (e) => {
        e.stopPropagation();
        modelDropdown.classList.toggle("visible");
      });

      // ç‚¹å‡»å¤–éƒ¨å…³é—­ä¸‹æ‹‰èœå•
      document.addEventListener("click", (e) => {
        if (!modelSelector.contains(e.target) && !modelDropdown.contains(e.target)) {
          modelDropdown.classList.remove("visible");
        }
      });

      // é˜»æ­¢ä¸‹æ‹‰èœå•å†…éƒ¨ç‚¹å‡»äº‹ä»¶å†’æ³¡
      modelDropdown.addEventListener("click", (e) => {
        e.stopPropagation();
      });
    }

    // æ¸²æŸ“æ¨¡å‹é€‰é¡¹
    function renderModelOptions() {
      modelDropdown.innerHTML = "";

      availableModels.forEach((model) => {
        const option = document.createElement("div");
        option.className = `model-option ${model.id === currentModel ? "active" : ""}`;
        option.innerHTML = `
            <span class="model-option-name">
              <strong>${model.name}</strong>
              <br>
              <span style="opacity: 0.6; font-size: 0.9em;">${model.description}</span>
            </span>
            <span class="model-option-icon">${model.id === currentModel ? "âœ“" : ""}</span>
          `;

        option.addEventListener("click", () => {
          selectModel(model.id);
        });

        modelDropdown.appendChild(option);
      });
    }

    // é€‰æ‹©æ¨¡å‹
    function selectModel(modelId) {
      if (currentModel === modelId) {
        modelDropdown.classList.remove("visible");
        return;
      }

      currentModel = modelId;
      currentModelLabel.textContent = availableModels.find(m => m.id === modelId)?.name || modelId;

      // é‡æ–°æ¸²æŸ“é€‰é¡¹ä»¥æ›´æ–°é€‰ä¸­çŠ¶æ€
      renderModelOptions();

      // å…³é—­ä¸‹æ‹‰èœå•
      modelDropdown.classList.remove("visible");

      // å‘é€åˆ°æ‰©å±•
      vscode.postMessage({ type: "changeModel", value: modelId });

      // æ˜¾ç¤ºåˆ‡æ¢æˆåŠŸæ¶ˆæ¯
      addMessage(`ğŸ”„ å·²åˆ‡æ¢åˆ°æ¨¡å‹: ${availableModels.find(m => m.id === modelId)?.name}`, "system");
    }

    // === Git Operations ===
    let lastGitAction = null; // Track the last action type for context

    function triggerGit(actionType) {
      try {
        console.log('[DEBUG] triggerGit called with action:', actionType);
        const debugStatus = document.getElementById('debug-status');
        if (debugStatus) {
          debugStatus.textContent = 'triggerGit called: ' + actionType;
          debugStatus.style.color = '#00ff00';
        }
        lastGitAction = actionType;
        addMessage(`Running Git ${actionType === 'commit' ? 'Commit Generation' : 'Code Review'} on staged changes...`, 'system');
        vscode.postMessage({
          type: 'gitAction',
          action: actionType
        });
        console.log('[DEBUG] Message posted to vscode');
        if (debugStatus) {
          debugStatus.textContent = 'Message posted: ' + actionType;
        }
      } catch (error) {
        console.error('[ERROR] triggerGit failed:', error);
        alert('Error: ' + error.message);
        const debugStatus = document.getElementById('debug-status');
        if (debugStatus) {
          debugStatus.textContent = 'ERROR: ' + error.message;
          debugStatus.style.color = '#ff0000';
        }
      }
    }

    // ä½¿ç”¨äº‹ä»¶ç›‘å¬å™¨ç»‘å®šæŒ‰é’®ï¼Œè€Œä¸æ˜¯ onclick
    document.addEventListener('DOMContentLoaded', function () {
      const commitBtn = document.getElementById('commit-btn');
      const reviewBtn = document.getElementById('review-btn');

      console.log('[DEBUG] DOM loaded, binding buttons...');

      if (commitBtn) {
        commitBtn.addEventListener('click', function (e) {
          console.log('[DEBUG] Commit button clicked!');
          e.preventDefault();
          e.stopPropagation();
          triggerGit('commit');
        });
        console.log('[DEBUG] Commit button bound');
      } else {
        console.error('[ERROR] Commit button not found!');
      }

      if (reviewBtn) {
        reviewBtn.addEventListener('click', function (e) {
          console.log('[DEBUG] Review button clicked!');
          e.preventDefault();
          e.stopPropagation();
          triggerGit('review');
        });
        console.log('[DEBUG] Review button bound');
      } else {
        console.error('[ERROR] Review button not found!');
      }

      console.log('[DEBUG] All buttons bound successfully');
    });

    function processCommitSuggestions(messageElement, rawText) {
      // If user explicitly requested a commit message, be more lenient with detection
      // Otherwise, stick to stricter regex to avoid false positives in general chat
      const content = rawText.trim();
      let isCommitMsg = false;

      if (lastGitAction === 'commit') {
        // Context-aware: If we just asked for a commit, almost any non-empty short text is likely one
        isCommitMsg = content.length > 0 && content.length < 500;
        // Reset after processing to avoid affecting future messages
        // (Wait a bit in case of streaming chunks affecting logic, but here we process final block)
      } else {
        // Fallback: Standard heuristic detection
        isCommitMsg = /^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\(.+\))?:/.test(content) && content.length < 300;
      }

      if (isCommitMsg) {
        // Avoid adding duplicate buttons
        if (!messageElement.querySelector('.apply-commit-btn')) {
          const applyBtn = document.createElement('button');
          applyBtn.className = 'apply-commit-btn';
          applyBtn.innerHTML = `<span>ğŸ“¥</span> Apply to Git Input`;
          applyBtn.onclick = () => {
            vscode.postMessage({
              type: 'applyCommitMessage',
              value: content
            });
            applyBtn.innerHTML = `<span>âœ…</span> Applied`;
            applyBtn.disabled = true;
            applyBtn.style.opacity = '0.7';
          };
          messageElement.appendChild(applyBtn);
        }
      }
    }

    // === Patch åŠŸèƒ½ ===
    const patchBtn = document.getElementById('patch-btn');
    const patchDropdown = document.getElementById('patch-dropdown');
    const patchOptions = document.querySelectorAll('.patch-option');

    if (patchBtn) {
      patchBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        patchDropdown.classList.toggle('visible');
      });

      // ç‚¹å‡»é€‰é¡¹ç”Ÿæˆ patch
      patchOptions.forEach(option => {
        option.addEventListener('click', (e) => {
          e.stopPropagation();
          const type = option.dataset.type;
          patchDropdown.classList.remove('visible');

          vscode.postMessage({
            type: 'generatePatch',
            value: type
          });
        });
      });
    }

    // ç‚¹å‡»å¤–éƒ¨å…³é—­ä¸‹æ‹‰èœå•
    document.addEventListener('click', (e) => {
      if (patchBtn && patchDropdown && !patchBtn.contains(e.target) && !patchDropdown.contains(e.target)) {
        patchDropdown.classList.remove('visible');
      }
    });
    function updateCurrentModel(modelId) {
      currentModel = modelId;
      const model = availableModels.find(m => m.id === modelId);
      currentModelLabel.textContent = model ? model.name : modelId;
      renderModelOptions();
    }

    // åœ¨æ¶ˆæ¯ç›‘å¬å™¨ä¸­æ·»åŠ æ¨¡å‹ç›¸å…³å¤„ç†
    window.addEventListener("message", (event) => {
      const message = event.data;

      // åœ¨ç°æœ‰çš„ switch è¯­å¥ä¸­æ·»åŠ æ–° case
      if (message.type === "currentModel") {
        updateCurrentModel(message.value);
      }
    });

    // åˆå§‹åŒ–æ¨¡å‹é€‰æ‹©å™¨
    initModelSelector();
  </script>
</body>

</html>
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ ygs.md

````markdown
æˆ‘çš„é¡¹ç›®æœ‰å¾ˆå¤šäº®ç‚¹ï¼Œå¸‚åœºä¸Šç±»ä¼¼çš„äº§å“ä¸å¤šã€‚
æˆ‘ç›¸ä¿¡è¿™ä¸ªé¡¹ç›®ä¸€å®šä¼šå–å¾—æˆåŠŸçš„ï¼
ä½ è§‰å¾—å‘¢ï¼Ÿ
````

[â¬† å›åˆ°ç›®å½•](#toc)

---
### ğŸ“Š æœ€ç»ˆç»Ÿè®¡æ±‡æ€»
- **æ–‡ä»¶æ€»æ•°:** 115
- **ä»£ç æ€»è¡Œæ•°:** 23081
- **ç‰©ç†æ€»å¤§å°:** 686.42 KB
